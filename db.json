{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/aniqueue-result.jpg","path":"images/aniqueue-result.jpg","modified":1,"renderable":0},{"_id":"source/images/douglas-crockford.jpg","path":"images/douglas-crockford.jpg","modified":1,"renderable":0},{"_id":"source/images/logo.png","path":"images/logo.png","modified":1,"renderable":0},{"_id":"source/images/nicholas-zakas.jpg","path":"images/nicholas-zakas.jpg","modified":1,"renderable":0},{"_id":"source/images/practice-1-result.png","path":"images/practice-1-result.png","modified":1,"renderable":0},{"_id":"source/images/profile-1.png","path":"images/profile-1.png","modified":1,"renderable":0},{"_id":"themes/cactus/source/css/rtl.styl","path":"css/rtl.styl","modified":1,"renderable":1},{"_id":"themes/cactus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/cactus/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/cactus/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/cactus/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/cactus/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":1,"renderable":1},{"_id":"themes/cactus/source/images/logo.png","path":"images/logo.png","modified":1,"renderable":1},{"_id":"themes/cactus/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/cactus/source/images/thumb.jpeg","path":"images/thumb.jpeg","modified":1,"renderable":1},{"_id":"source/images/clean-code/code-quality-wtf.jpg","path":"images/clean-code/code-quality-wtf.jpg","modified":1,"renderable":0},{"_id":"source/images/clean-code/code-review-0.png","path":"images/clean-code/code-review-0.png","modified":1,"renderable":0},{"_id":"source/images/clean-code/code-review-4.png","path":"images/clean-code/code-review-4.png","modified":1,"renderable":0},{"_id":"source/images/thumbs/go-thumb.jpeg","path":"images/thumbs/go-thumb.jpeg","modified":1,"renderable":0},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff2","path":"lib/vazir-font/Vazir-Black.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff","path":"lib/vazir-font/Vazir-Black.woff","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff","path":"lib/vazir-font/Vazir-Bold.woff","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff2","path":"lib/vazir-font/Vazir-Bold.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff","path":"lib/vazir-font/Vazir-Light.woff","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff2","path":"lib/vazir-font/Vazir-Light.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff","path":"lib/vazir-font/Vazir-Medium.woff","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff2","path":"lib/vazir-font/Vazir-Medium.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff","path":"lib/vazir-font/Vazir-Thin.woff","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff2","path":"lib/vazir-font/Vazir-Thin.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir.woff","path":"lib/vazir-font/Vazir.woff","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/font-face.css","path":"lib/vazir-font/font-face.css","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir.woff2","path":"lib/vazir-font/Vazir.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.eot","path":"lib/vazir-font/Vazir-Black.eot","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.ttf","path":"lib/vazir-font/Vazir-Black.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.eot","path":"lib/vazir-font/Vazir-Bold.eot","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.ttf","path":"lib/vazir-font/Vazir-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.eot","path":"lib/vazir-font/Vazir-Light.eot","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.ttf","path":"lib/vazir-font/Vazir-Light.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.eot","path":"lib/vazir-font/Vazir-Medium.eot","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.ttf","path":"lib/vazir-font/Vazir-Medium.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.ttf","path":"lib/vazir-font/Vazir-Thin.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.eot","path":"lib/vazir-font/Vazir-Thin.eot","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir.eot","path":"lib/vazir-font/Vazir.eot","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir.ttf","path":"lib/vazir-font/Vazir.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"source/images/clean-code/code-review-3.png","path":"images/clean-code/code-review-3.png","modified":1,"renderable":0},{"_id":"themes/cactus/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.eot","path":"lib/font-awesome/webfonts/fa-regular-400.eot","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.ttf","path":"lib/font-awesome/webfonts/fa-regular-400.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff","path":"lib/font-awesome/webfonts/fa-regular-400.woff","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/justified-gallery/css/justifiedGallery.min.css","path":"lib/justified-gallery/css/justifiedGallery.min.css","modified":1,"renderable":1},{"_id":"source/images/clean-code/code-review-1.png","path":"images/clean-code/code-review-1.png","modified":1,"renderable":0},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff","path":"lib/font-awesome/webfonts/fa-brands-400.woff","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff","path":"lib/font-awesome/webfonts/fa-solid-900.woff","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/js/jquery.justifiedGallery.min.js","modified":1,"renderable":1},{"_id":"source/images/clean-code/code-review-2.png","path":"images/clean-code/code-review-2.png","modified":1,"renderable":0},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.ttf","path":"lib/font-awesome/webfonts/fa-brands-400.ttf","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.eot","path":"lib/font-awesome/webfonts/fa-brands-400.eot","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.svg","path":"lib/font-awesome/webfonts/fa-regular-400.svg","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.eot","path":"lib/font-awesome/webfonts/fa-solid-900.eot","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.ttf","path":"lib/font-awesome/webfonts/fa-solid-900.ttf","modified":1,"renderable":1},{"_id":"source/images/typewriter.jpg","path":"images/typewriter.jpg","modified":1,"renderable":0},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.svg","path":"lib/font-awesome/webfonts/fa-solid-900.svg","modified":1,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.svg","path":"lib/font-awesome/webfonts/fa-brands-400.svg","modified":1,"renderable":1},{"_id":"source/images/header_image.gif","path":"images/header_image.gif","modified":1,"renderable":0}],"Cache":[{"_id":"themes/cactus/.stylintrc","hash":"eb5f48e83657928cb0cbee031373b2cd36ca0083","modified":1575558329507},{"_id":"themes/cactus/.jshintrc","hash":"2548bd6ce44422edc7e6f9f68061ab47f26c4f57","modified":1575558329507},{"_id":"themes/cactus/LICENSE","hash":"346ece39a983b0e7858c11f785cd846cef9eb875","modified":1575558329508},{"_id":"themes/cactus/README.md","hash":"6b0c6ea10c3a68c3788f2c81065bad37699dc6a7","modified":1575558329508},{"_id":"themes/cactus/_config.yml","hash":"ba26e7fe028a2c198185774882d9ce6e465c3310","modified":1581349037997},{"_id":"themes/cactus/gulpfile.js","hash":"1fa30783f9bbf96e77b4279572b7c159936d225b","modified":1576582949295},{"_id":"themes/cactus/package.json","hash":"5bbdbc429e9d46acf97baf7ac5654edde0781064","modified":1575558329513},{"_id":"source/.DS_Store","hash":"1ee1e036a851e01844d87f6f56e8061edf72fb2c","modified":1579326874300},{"_id":"themes/cactus/languages/en.yml","hash":"4b7c4fe7dd266e4f0612b5aea25d324f3b009b90","modified":1579331104168},{"_id":"themes/cactus/languages/default.yml","hash":"4b7c4fe7dd266e4f0612b5aea25d324f3b009b90","modified":1579331104168},{"_id":"themes/cactus/layout/archive.ejs","hash":"b5e70bd2780d044b94e22ce8af0afb114c2a6eae","modified":1575558329512},{"_id":"themes/cactus/layout/layout.ejs","hash":"ad0f48fca26b3670c9fbcb3e61bfbaa62dc33ab2","modified":1575558329513},{"_id":"themes/cactus/layout/page.ejs","hash":"c5465d5315a7544aa466b01fd8cfb62917a8bb1d","modified":1575558329513},{"_id":"themes/cactus/layout/index.ejs","hash":"c1f2600d7738f27e17c6bb95a34eddaa0a7743c4","modified":1575559175290},{"_id":"themes/cactus/scripts/merge-configs.js","hash":"2048c3415d96b17b9d84aa44bc0c25f1210525f8","modified":1575558329513},{"_id":"themes/cactus/scripts/meta.js","hash":"fa6055a39851c9953d033e70c1614547b94dce60","modified":1575558329513},{"_id":"themes/cactus/scripts/page_title.js","hash":"fa662dbdb82779af1b95e35ed7ccdf4866a53dee","modified":1575558329514},{"_id":"themes/cactus/layout/post.ejs","hash":"a070916c6da75d06998fa92eabde7945619dc3bf","modified":1579527657793},{"_id":"themes/cactus/scripts/thumbnail.js","hash":"df8829fd8c3119650037eba5ec11bdce06acff9d","modified":1575558329514},{"_id":"source/about/index.md","hash":"23db7fc58a72ccdb8150d5a051cfa1745d1a508b","modified":1581258001168},{"_id":"source/_drafts/block-chain-js-5.md","hash":"3b38b728a9f80d82f8087ef5cbf08d2178cd41c7","modified":1581258001157},{"_id":"themes/cactus/source/.DS_Store","hash":"88729ce2f536778c35628ac1344dd29dd76ec252","modified":1581431243293},{"_id":"source/_drafts/javascript-daily-function-22.md","hash":"ab4f1445031645cc752a350c0cad47a4dc3fb0fa","modified":1575558329480},{"_id":"source/_drafts/functaional-js-study-3.md","hash":"d7a138fa819daff3ec1d51314f093efeedf09ca9","modified":1575558329480},{"_id":"source/_drafts/landsurfing.md","hash":"b1f4431b89ad9a18ec5ef3e6eae34fdf521d66d9","modified":1575558329481},{"_id":"source/_drafts/like-me-3.md","hash":"c9647a1a0e878a9539aae2fed311f4fa8fd76b3b","modified":1575558329481},{"_id":"source/_posts/1-year-anniversary.md","hash":"1712ba9a52564e9cae9f46c5c2d707a58c113d35","modified":1581258001159},{"_id":"source/_posts/block-chain-js-1.md","hash":"930ce2fae27256299987c58e39478cb9ba55c4fb","modified":1563192454502},{"_id":"source/_posts/block-chain-js-2.md","hash":"1add74aa52da6b739a9f8a841fc07f205e28a126","modified":1563192453382},{"_id":"source/_posts/block-chain-js-3.md","hash":"91bdf81810892b479441ed762493b6d2045f0613","modified":1563192452205},{"_id":"source/_posts/block-chain-js-4.md","hash":"7865afcbf7f85c91de921cbc6cf484d81c122a49","modified":1563192450410},{"_id":"source/_posts/challenge-portfolio-page.md","hash":"2af86cc7602d57b24dd7115eddb56e4c97b9f1eb","modified":1575558329482},{"_id":"source/_posts/block-chain-js-0.md","hash":"23d0a9620915cbdd6cde9298d04d4bb919fe5bb7","modified":1575558368869},{"_id":"source/_posts/clean-code-2.md","hash":"b861881e41c666f1eee7be0a326970765e14c6fc","modified":1581258001162},{"_id":"source/_posts/clean-code-0.md","hash":"27ae5e8ee96c5e8080322e723169edb9e59389dd","modified":1581419936530},{"_id":"source/_posts/clean-code-1.md","hash":"dc45039ff1199d59d472abb9c5d27afdbb6a8aa2","modified":1581258001161},{"_id":"source/_posts/clean-code-3.md","hash":"706f1cb51cddd2972c3a565991ee80d08753f538","modified":1581258001164},{"_id":"source/_posts/css-color-hex-code-and-rgb.md","hash":"cda27b7d4f91d5426c2d45320041d501fc86334d","modified":1575558329482},{"_id":"source/_posts/css-style-override.md","hash":"f0f59a2725f463f2bbf253f48410b759ea91b174","modified":1575558329482},{"_id":"source/_posts/coin.md","hash":"82f4b00679c3628505b98efaa1c3445b1386d133","modified":1575558329482},{"_id":"source/_posts/daily-commit-today-i-learned.md","hash":"7b1a1c497ed132bf01ea14825373e202a8e0eba4","modified":1575558329482},{"_id":"source/_posts/daily-fp-1.md","hash":"48e630c4654a8cd2e371d10fec66c91cbad27ff6","modified":1581258001165},{"_id":"source/_posts/daily-fp-0.md","hash":"b62d120b194b0f0045da018ba42b6e428e2c16ec","modified":1575558368869},{"_id":"source/_posts/daily-fp-10.md","hash":"031c9392137b80424438db48b25dcc7e67143365","modified":1575558368868},{"_id":"source/_posts/daily-fp-11.md","hash":"3e2ab0c169ac3144326d40cbd954f246112ecfb1","modified":1575558368867},{"_id":"source/_posts/daily-fp-12.md","hash":"1d4bc24627b175e8a87f231cf30b163ac95ce16c","modified":1575558368866},{"_id":"source/_posts/daily-fp-15.md","hash":"b46969f8464236cc85c09ab2de41a6b6dbd49ee6","modified":1575558368865},{"_id":"source/_posts/daily-fp-14.md","hash":"bbd057b4277c2af532961d0acbed812db3767300","modified":1575558368865},{"_id":"source/_posts/daily-fp-17.md","hash":"e114b16406752864ae697d72fecdc4b2c5bb53ef","modified":1575558368864},{"_id":"source/_posts/daily-fp-16.md","hash":"a2b3e6579d56858c1b24a8420d7e8ca37122b335","modified":1575558368864},{"_id":"source/_posts/daily-fp-13.md","hash":"5160b4cd273dd53eaaed9335577dbdd778976ec9","modified":1575558368866},{"_id":"source/_posts/daily-fp-2.md","hash":"61fde49c5f088dbba8f71e8e916e0686d3865ac2","modified":1575558368862},{"_id":"source/_posts/daily-fp-18.md","hash":"a3d2fa09faaf03e293ba882f919761fbe6201ff5","modified":1575558368863},{"_id":"source/_posts/daily-fp-19.md","hash":"a30cccef64550a5483286d8d44f942553b29f8b0","modified":1575558368863},{"_id":"source/_posts/daily-fp-20.md","hash":"6e604259a30a83605b5cdfc28d9c619e2ff60d38","modified":1575558368861},{"_id":"source/_posts/daily-fp-21.md","hash":"ab8623f5423d216940a489bb57626e09b666d22f","modified":1575558368861},{"_id":"source/_posts/daily-fp-4.md","hash":"d3db82c35d5a2c90f90081520ab33845321128bb","modified":1575558368859},{"_id":"source/_posts/daily-fp-22.md","hash":"c4c2a46bcac193d968f32b9983d032c4167aa698","modified":1575558368860},{"_id":"source/_posts/daily-fp-3.md","hash":"339dc4f8c42908ca27131c31eb5548516c12045d","modified":1575558368860},{"_id":"source/_posts/daily-fp-5.md","hash":"a8fd820263095886ddd23202067a18989bbba330","modified":1575558368858},{"_id":"source/_posts/daily-fp-6.md","hash":"682c552975bd5203d53f1db707aad6c768fa34ec","modified":1575558368858},{"_id":"source/_posts/daily-fp-7.md","hash":"d797a908cfd438a6d0127ea6cca4ce444f51617a","modified":1575558368857},{"_id":"source/_posts/daily-fp-8.md","hash":"e2a5024819c83dbf8d5a8119fa586603b4311357","modified":1575558368857},{"_id":"source/_posts/daily-fp-9.md","hash":"ea085027256110035f37d1d6a214c420d8d3833d","modified":1575558368856},{"_id":"source/_posts/fork-execlp-wait.md","hash":"ea2c76391c28a8f713d9fbaf562bb3e52ff0e94d","modified":1575558329482},{"_id":"source/_posts/functional-js-study-1.md","hash":"3e56b6af23a1867a71dec3cf7a7c3c10b1477835","modified":1575558329483},{"_id":"source/_posts/functional-js-study-0.md","hash":"88e8d92fcc4cc324d35790f80760b71bdc89ba3a","modified":1575558368856},{"_id":"source/_posts/introduction-to-blog.md","hash":"e712cab5451fccac775eac7aa639733f92a6af47","modified":1575558329483},{"_id":"source/_posts/functional-js-study-2.md","hash":"897567cf0c70989c3a2f86914ec45439e7d3020a","modified":1575558329483},{"_id":"source/_posts/javascript-intro-1.md","hash":"446ecc294d62f5465aaa2d4f22f395c88b60de76","modified":1575558329490},{"_id":"source/_posts/javascript-intro-2.md","hash":"88e2f052a967190366d976ba2b835d21a936d93d","modified":1578922846651},{"_id":"source/_posts/javascript-keywords.md","hash":"c1632b3c68a275b844b2d7842512e3545197623f","modified":1575558329490},{"_id":"source/_posts/learn-about-mean-stack.md","hash":"1aa2b69e99b6541e801ec120cdd5826dfe4c4a05","modified":1575558329490},{"_id":"source/_posts/javascript-prototype.md","hash":"e4e49d09fb0e32eaf3fd25e1e766bbb81f080c52","modified":1575558329490},{"_id":"source/_posts/like-me-1.md","hash":"a16c18ae7241bbf1fa97bf5f6bbeffaa064ab4b6","modified":1563192076458},{"_id":"source/_posts/make-bingo-game-1.md","hash":"55e7f331306d788c6bd51107d2650191e8e9fc71","modified":1575558329491},{"_id":"source/_posts/make-bingo-game-0.md","hash":"1d6d4d183c151236cd8074b01533fee0d8aa4ae8","modified":1576583199386},{"_id":"source/_posts/like-me-2.md","hash":"4b1e017da55cb8d82b02e38b3725f0ddf68d2ae6","modified":1563192194729},{"_id":"source/_posts/practice-animal-shelter.md","hash":"10c9a14e0e685ba33e241682e921fe49f534a31f","modified":1575558329491},{"_id":"source/_posts/practice-min-stack.md","hash":"60b3fb1e20be9eef60d7e69164428c630b5e78d5","modified":1575558329492},{"_id":"source/_posts/prato-2.md","hash":"03e0b14908812947e651ef8f530f0a313ed313a6","modified":1575558329492},{"_id":"source/_posts/prato-1.md","hash":"d9917159014a4eb24cb74bbd0548b395f36c9229","modified":1575558329492},{"_id":"source/_posts/project-tribute-page.md","hash":"a9802654bef7454a4447b0a311b6c2de6b72025a","modified":1575558329492},{"_id":"source/_posts/retrospection-2018.md","hash":"02e747776f4931d8d84b4f466c48c74b34873a91","modified":1581258001167},{"_id":"source/_posts/my-bro-fp-1.md","hash":"eb3c4e2ec846c264af519d1d20c387339072dfbe","modified":1578398476300},{"_id":"source/_posts/write-it-go-1.md","hash":"9e0db9db866bbb5507f004d19c72cf72b0d59353","modified":1581514237018},{"_id":"source/_posts/write-in-go-0.md","hash":"dd187ac3dd537c69705538c931839dbcb1770bbf","modified":1581512705879},{"_id":"source/images/aniqueue-result.jpg","hash":"badb9725b4fc9f26725ddba7e580fff8becbf391","modified":1575558329493},{"_id":"source/images/.DS_Store","hash":"2dac0e310274ed23f31e1ffa5e0b1806924566e2","modified":1579354783212},{"_id":"source/_posts/my-bro-fp-0.md","hash":"225d3afb0c433b5fb28d1b51efff4956a0db2eff","modified":1578396434979},{"_id":"source/images/douglas-crockford.jpg","hash":"535cb26bd4d3cf60c9599ff5e317f048b8a52f9d","modified":1575558329493},{"_id":"source/images/logo.png","hash":"2316f51b5a7dee1339c289b8d88caf90f18304b5","modified":1575558329500},{"_id":"source/images/nicholas-zakas.jpg","hash":"6664a2f5939ae1ccfc37c972c2d6c49a892b4c78","modified":1575558329501},{"_id":"source/images/practice-1-result.png","hash":"0ace303eec00b434839c03ade29760ce8b61b52d","modified":1575558329501},{"_id":"source/images/profile-1.png","hash":"75a65bf9f9de1791cd0fa74aa7befe8b0d16f70e","modified":1575558329501},{"_id":"source/search/index.md","hash":"fa6b80810d94e473464532fa50993e34ab99e35c","modified":1578491860735},{"_id":"themes/cactus/layout/_partial/comments.ejs","hash":"4cf8d0059e5f8bc8ae1dd1a426293583fd398052","modified":1575558329509},{"_id":"themes/cactus/layout/_partial/footer.ejs","hash":"c3a80e347cb11022baf5e65fb4d0209b8d205693","modified":1575558329509},{"_id":"themes/cactus/layout/_partial/header.ejs","hash":"9b2b7d6e9ab514107adf408c7ec8530fd612b3d5","modified":1575558329509},{"_id":"themes/cactus/layout/_partial/pagination.ejs","hash":"23bf862b3b8a3cd831850504d9b5a24d21b005e7","modified":1575558329510},{"_id":"themes/cactus/layout/_partial/head.ejs","hash":"1abeb1f88cce8b2b543dabaf887acb65a30065b2","modified":1576582848375},{"_id":"themes/cactus/layout/_partial/scripts.ejs","hash":"da21959cb16a6b0ba06825aa7ea65c0efcb6c440","modified":1575558329512},{"_id":"themes/cactus/layout/_partial/styles.ejs","hash":"be1b54388eb02176dd4722285dda19e3dce2e62e","modified":1575558329512},{"_id":"themes/cactus/layout/_partial/search.ejs","hash":"8b4bf9cf5db0ce762a31fc3baae0f2fc004bece4","modified":1575558329512},{"_id":"themes/cactus/source/css/_extend.styl","hash":"2ff73bd3dbdb58fa69cbadb2a1c0ed966812ce88","modified":1575558329515},{"_id":"themes/cactus/source/css/_fonts.styl","hash":"18850fecb03e2e2bed416c07ba6920ff5b433d55","modified":1576582839260},{"_id":"themes/cactus/source/css/_mixins.styl","hash":"1a9e309523df9685e8d088dcff0a809c58e2c392","modified":1575558329528},{"_id":"themes/cactus/source/css/_util.styl","hash":"2bfeb2e2605dd5235693b00c71a212646d2e0410","modified":1575558329530},{"_id":"themes/cactus/source/css/rtl.styl","hash":"98355abe9ef3a398a5b4cb40d3d33bf86ac8d1d4","modified":1575558329530},{"_id":"themes/cactus/source/css/style.styl","hash":"23b2b86a0ab2c193af74014033774bcfb36a5efe","modified":1575558329530},{"_id":"themes/cactus/source/css/_variables.styl","hash":"eedd084df8b8d5fda213ab34df3a8305fcc700f0","modified":1576582996512},{"_id":"themes/cactus/source/js/main.js","hash":"584c5a69ac81a483a1c4377a2e2cf326c2795e7b","modified":1575558329538},{"_id":"themes/cactus/source/js/search.js","hash":"a74d0c601f820160825a2e4ad13618074d714933","modified":1575558329538},{"_id":"themes/cactus/source/images/apple-touch-icon.png","hash":"f062959c6ac64da6cd97ebe5f304bb781a3adce9","modified":1581258001175},{"_id":"themes/cactus/source/images/favicon-192x192.png","hash":"f062959c6ac64da6cd97ebe5f304bb781a3adce9","modified":1581258001176},{"_id":"themes/cactus/source/images/logo.png","hash":"f062959c6ac64da6cd97ebe5f304bb781a3adce9","modified":1581258001179},{"_id":"themes/cactus/source/images/favicon.ico","hash":"b23f3c404e9ba9366e8300fd2bebd42b2f018651","modified":1581258001178},{"_id":"themes/cactus/source/images/thumb.jpeg","hash":"2fa4c04307dfd627db0ad58bd678a965d33f1aca","modified":1581433454567},{"_id":"source/images/clean-code/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1579336449970},{"_id":"source/images/clean-code/code-quality-wtf.jpg","hash":"9df0ed0995128d78c1c1d5ffd8a4d4425ba039ab","modified":1579321828181},{"_id":"source/images/clean-code/code-review-0.png","hash":"785c428d988351c80d76308b9bb0a360ff52db4f","modified":1579324201024},{"_id":"themes/cactus/layout/_partial/post/actions_mobile.ejs","hash":"c73f2feb4c1b0bc4d652b02e7e13122a777b5130","modified":1575558329510},{"_id":"themes/cactus/layout/_partial/post/actions_desktop.ejs","hash":"5728f8c2808465c6be801b8c8c4f5bb6b96dd64e","modified":1581258026621},{"_id":"source/images/clean-code/code-review-4.png","hash":"9050b30e036f666b59d74eda06fcbca47b4ff3cc","modified":1579327106570},{"_id":"themes/cactus/layout/_partial/post/category.ejs","hash":"b5bfa049f17868fb09d9d2a7e1d5279fa0381d37","modified":1575558329510},{"_id":"themes/cactus/layout/_partial/post/date.ejs","hash":"12a4a7ba6334e3e5c03d9a9601d7779a27c2e082","modified":1575558329510},{"_id":"themes/cactus/layout/_partial/post/gallery.ejs","hash":"9aecd8908e8a684f33dc20c02497c0f1774137c7","modified":1575558329510},{"_id":"themes/cactus/layout/_partial/post/tag.ejs","hash":"e08fae30da060f49c087f6c121868b08eb55c795","modified":1575558329511},{"_id":"themes/cactus/layout/_partial/post/title.ejs","hash":"a060f1c6e3718494a6b1d0e1981ea0bf4e549828","modified":1575558329511},{"_id":"themes/cactus/layout/_partial/post/share.ejs","hash":"1b21c90f25e8f1f8101c9f7e77e81b691b887c2f","modified":1575558368825},{"_id":"source/images/thumbs/go-thumb.jpeg","hash":"32fe5f7f796d8c2e72c7668b8f0c9360664cccf5","modified":1581433433295},{"_id":"themes/cactus/source/css/_colors/classic.styl","hash":"0f0ec41a4165814ce69688425d5ac4d701b7cc70","modified":1575558329514},{"_id":"themes/cactus/source/css/_colors/dark.styl","hash":"5c2794002b4f9428d267f73eb00498166b27e617","modified":1581258001172},{"_id":"themes/cactus/source/css/_colors/white.styl","hash":"2b25ad24573bded8b42f9d80112eab9fadbed1a5","modified":1575558329515},{"_id":"themes/cactus/source/css/_colors/light.styl","hash":"d09f781cb02394850737b3a9efc6693307d5bf09","modified":1581178280928},{"_id":"themes/cactus/source/css/_highlight/androidstudio.styl","hash":"2af0861725f97f0ee2ded67c3d2d4548c62b2d16","modified":1575558329515},{"_id":"themes/cactus/source/css/_highlight/agate.styl","hash":"53027913ed8d4f75ac3e49e76aad824f0df62da3","modified":1575558329515},{"_id":"themes/cactus/source/css/_highlight/arta.styl","hash":"b3e81e3e694ceb8deed178adb8b91013c5120e30","modified":1575558329516},{"_id":"themes/cactus/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1575558329516},{"_id":"themes/cactus/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1575558329517},{"_id":"themes/cactus/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1575558329516},{"_id":"themes/cactus/source/css/_highlight/atelier-cave-dark.styl","hash":"ce63dd8548688d88254405eedfa75b1d7c82449e","modified":1575558329517},{"_id":"themes/cactus/source/css/_highlight/atelier-dune-dark.styl","hash":"c196ff0ee064af0e507823694ae39020addfc280","modified":1575558329517},{"_id":"themes/cactus/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1575558329518},{"_id":"themes/cactus/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1575558329518},{"_id":"themes/cactus/source/css/_highlight/atelier-forest-dark.styl","hash":"effbc5d75fa87203c847039869c22031b40d5b7d","modified":1575558329518},{"_id":"themes/cactus/source/css/_highlight/atelier-estuary-dark.styl","hash":"0bb16a4eff93688f40787abc2f9e56e7d5cc93e7","modified":1575558329518},{"_id":"themes/cactus/source/css/_highlight/atelier-heath-dark.styl","hash":"9a2e9a1d0a01bbdf158560c3ed1c134e098b2c68","modified":1575558329518},{"_id":"themes/cactus/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1575558329518},{"_id":"themes/cactus/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1575558329518},{"_id":"themes/cactus/source/css/_highlight/atelier-lakeside-dark.styl","hash":"10ee3882fca7b97a37bd309d2d35fce9868647bb","modified":1575558329519},{"_id":"themes/cactus/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1575558329519},{"_id":"themes/cactus/source/css/_highlight/atelier-plateau-dark.styl","hash":"84c80e6f67f62fce958d25817c277d2360272617","modified":1575558329519},{"_id":"themes/cactus/source/css/_highlight/atelier-savanna-dark.styl","hash":"e32c1c70def8060fce5e790979a126da650ac642","modified":1575558329519},{"_id":"themes/cactus/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1575558329519},{"_id":"themes/cactus/source/css/_highlight/atelier-seaside-dark.styl","hash":"2edf385215bbe1985b1a10106525d362667d28c2","modified":1575558329519},{"_id":"themes/cactus/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"538a14321193cd8abf2ddc484306631e54149ffb","modified":1575558329520},{"_id":"themes/cactus/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1575558329519},{"_id":"themes/cactus/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1575558329520},{"_id":"themes/cactus/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1575558329520},{"_id":"themes/cactus/source/css/_highlight/codepen-embed.styl","hash":"8b7b34484f76a6c2c3b1a9e49abb9b382f439ae8","modified":1575558329520},{"_id":"themes/cactus/source/css/_highlight/brown-paper.styl","hash":"c2326ba20a5020a66ca7895258d18833327d4334","modified":1575558329520},{"_id":"themes/cactus/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1575558329520},{"_id":"themes/cactus/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1575558329521},{"_id":"themes/cactus/source/css/_highlight/dark.styl","hash":"f5e6e75958de59e87fc6be3a1668e870e20bc836","modified":1575558329521},{"_id":"themes/cactus/source/css/_highlight/darkula.styl","hash":"9717efa9194837ba3fb4d762997d33075dcf8bfa","modified":1575558329521},{"_id":"themes/cactus/source/css/_highlight/far.styl","hash":"aaac3028f5e33123cd123a583cddc9290c45ec8e","modified":1575558329521},{"_id":"themes/cactus/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1575558329521},{"_id":"themes/cactus/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1575558329521},{"_id":"themes/cactus/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1575558329521},{"_id":"themes/cactus/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1575558329522},{"_id":"themes/cactus/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1575558329522},{"_id":"themes/cactus/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1575558329522},{"_id":"themes/cactus/source/css/_highlight/hopscotch.styl","hash":"1378a6bc67a32c0cbff72ab771268b53f9aa586d","modified":1575558329522},{"_id":"themes/cactus/source/css/_highlight/highlightjs.styl","hash":"0e198b7a59191c7a39b641a4ddd22c948edb9358","modified":1575558329522},{"_id":"themes/cactus/source/css/_highlight/hybrid.styl","hash":"b8eb5c69d12f2ee5ebc50265ae271699d7f1a8d3","modified":1575558329522},{"_id":"themes/cactus/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1575558329523},{"_id":"themes/cactus/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1575558329523},{"_id":"themes/cactus/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1575558329523},{"_id":"themes/cactus/source/css/_highlight/ir-black.styl","hash":"53e5d74326a4527b92272bbd6946d4fec92720e8","modified":1575558329523},{"_id":"themes/cactus/source/css/_highlight/kimbie.styl","hash":"51b889ca7c6fe178cfbbe28d875a6ea427184441","modified":1575558329523},{"_id":"themes/cactus/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1575558329523},{"_id":"themes/cactus/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1575558329523},{"_id":"themes/cactus/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1575558329524},{"_id":"themes/cactus/source/css/_highlight/monokai-sublime.styl","hash":"c385b11345894be7e6ce3c5f08663e199933b8e4","modified":1575558329524},{"_id":"themes/cactus/source/css/_highlight/monokai.styl","hash":"f87be027848ea6bee623a08ad1e17b2f5b7937ee","modified":1575558329524},{"_id":"themes/cactus/source/css/_highlight/obsidian.styl","hash":"199e28326be8590883f0813ebbd54fcfaa4750fd","modified":1575558329524},{"_id":"themes/cactus/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1575558329524},{"_id":"themes/cactus/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1575558329524},{"_id":"themes/cactus/source/css/_highlight/paraiso.styl","hash":"75f181eece6b71d033ea0c8d6cf00ae7efb9e29b","modified":1575558329525},{"_id":"themes/cactus/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1575558329525},{"_id":"themes/cactus/source/css/_highlight/pojoaque.styl","hash":"4e7b6b046b8575ac749f6aec4e953a62ada27a36","modified":1575558329525},{"_id":"themes/cactus/source/css/_highlight/railscasts.styl","hash":"b6674db9210e0c4444e4835fff2d1361f3ebd64c","modified":1575558329526},{"_id":"themes/cactus/source/css/_highlight/rainbow.styl","hash":"c0cf97aae3e10fdcd10414547a711c9effbc39b8","modified":1575558329526},{"_id":"themes/cactus/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1575558329526},{"_id":"themes/cactus/source/css/_highlight/school-book.styl","hash":"d43560fe519a931ce6da7d57416d7aa148441b83","modified":1575558329526},{"_id":"themes/cactus/source/css/_highlight/solarized-dark.styl","hash":"90c9da5aa594383697e5b18892a7f95beb053f55","modified":1575558329526},{"_id":"themes/cactus/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1575558329527},{"_id":"themes/cactus/source/css/_highlight/sunburst.styl","hash":"af3eec0fd56151e55bbd49c31b151f36717611d8","modified":1575558329527},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-blue.styl","hash":"f24c17d0ab815dcfaab3438cb9fe2ab4839f5e0d","modified":1575558329527},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-bright.styl","hash":"7674fecb6d27350727dc0d2dc93bc018382ebbd0","modified":1575558329527},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-eighties.styl","hash":"28d751075ebabf7d0327a36f725076fe82fdf626","modified":1575558329527},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night.styl","hash":"16ba09b2db501e4e3e2e7d62595d9bf935bf27c4","modified":1575558329527},{"_id":"themes/cactus/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1575558329528},{"_id":"themes/cactus/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1575558329528},{"_id":"themes/cactus/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1575558329528},{"_id":"themes/cactus/source/css/_highlight/zenburn.styl","hash":"68ff9332ccc03f9389b15b713415cde016f8088f","modified":1575558329528},{"_id":"themes/cactus/source/css/_partial/archive.styl","hash":"ef8fc52337c4c7b010cad7c427cb78009b30f9d8","modified":1575558329528},{"_id":"themes/cactus/source/css/_partial/article.styl","hash":"6c2692943f0e69c52d0811f58ac38acaecd36a58","modified":1581258001174},{"_id":"themes/cactus/source/css/_partial/categories.styl","hash":"a43f00e61b3507f130b8a3f8108a4eeca147c2a0","modified":1575558329529},{"_id":"themes/cactus/source/css/_partial/comments.styl","hash":"1e90f1fb9d4c155df518cacb5a537e9de9c042c1","modified":1575558329529},{"_id":"themes/cactus/source/css/_partial/footer.styl","hash":"d9b13e402808175dc90761cc4fdfe3d4808034f8","modified":1575558329529},{"_id":"themes/cactus/source/css/_partial/header.styl","hash":"662667942cc9a2caf55caa84a0fc73617d0c3aa4","modified":1575558329529},{"_id":"themes/cactus/source/css/_partial/index.styl","hash":"59c99f4ea3a73bf47ce030df166c5e33d5de31fb","modified":1575558329529},{"_id":"themes/cactus/source/css/_partial/pagination.styl","hash":"950bf517bbe7adb9a9aa4eb5ddec74ffc7598787","modified":1575558329529},{"_id":"themes/cactus/source/css/_partial/search.styl","hash":"159be002780c62a77f46947cf854a7342fba24f4","modified":1575558329530},{"_id":"themes/cactus/source/css/_partial/tags.styl","hash":"d571d5c7c960300d29c5f0ec3fe1140322ecd6b3","modified":1575558329530},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff2","hash":"0a257c8b60e0f20802c1dc8daeed2d3cb0d44f17","modified":1575558329606},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff","hash":"37443d0040f0d7af381c955e4c15919a15d0349e","modified":1575558329605},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff","hash":"df15fd1e74b6f4a50bea57e2b44d9627f38495b5","modified":1575558329610},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff2","hash":"62447a951d48b21c4696ae72df4bc4adef636e26","modified":1575558329611},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff","hash":"32ae5c0d1d5943c8bb8e0f6ab07c3269c6f8b8a8","modified":1575558329615},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff2","hash":"ef07a250766fea840c1049e67c0405d9216ee0a8","modified":1575558329616},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff","hash":"f5653059b2a5929516e4aab02329a978600b9b67","modified":1575558329620},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff2","hash":"668400ae92700965f03f2371faaee0ab8c8347c3","modified":1575558329620},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff","hash":"ad4d46a99a1daf6353c86c79ac3a2b030213859c","modified":1575558329624},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff2","hash":"c3be79b553ec394db71268d604b1d29183b867dc","modified":1575558329625},{"_id":"themes/cactus/source/lib/vazir-font/Vazir.woff","hash":"bbee70033f0f5882e9869e417b69c6a38f56f187","modified":1575558329629},{"_id":"themes/cactus/source/lib/vazir-font/font-face.css","hash":"8f2bf6b59ae1f2ed4c2fead6cea4b8314fcf62e5","modified":1575558329630},{"_id":"themes/cactus/source/lib/vazir-font/Vazir.woff2","hash":"30ce165216db078951a690a6ad665b9b78f5dd81","modified":1575558329629},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.eot","hash":"13d026ff857c853cbd0dc519b6e58669db309441","modified":1575558329602},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.ttf","hash":"594dc3344ad14903c247615427d1009709f0f5a4","modified":1575558329604},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.eot","hash":"f76ec625e15522ff60d21f7a9a3b71c65bc27556","modified":1575558329608},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.ttf","hash":"2e6c9df9f775373fb1988ae8529aa8f05313dae6","modified":1575558329609},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.eot","hash":"3edffd7bb61eee8cd46b57225f9f9e5264e3362b","modified":1575558329613},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.ttf","hash":"9f1e2934098a6a4a7c5584c8f3fa24a707070da3","modified":1575558329614},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.eot","hash":"1f5a73db7947ef22c8a2bb19d6449b80496c03c4","modified":1575558329617},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.ttf","hash":"295f7e02c9b157e7ea63ad09613b00ceab85c5cd","modified":1575558329619},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.ttf","hash":"a6aa450ee6e0f85786474ca6b04827ef97e81af4","modified":1575558329623},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.eot","hash":"08e1503d1181188690fd9c81860d6c890c1465f6","modified":1575558329622},{"_id":"themes/cactus/source/lib/vazir-font/Vazir.eot","hash":"31a9219c25fe1991fb745ec8dbbcf45c6094a702","modified":1575558329627},{"_id":"themes/cactus/source/lib/vazir-font/Vazir.ttf","hash":"f22b219824026e490a581ddb3b36b07997dff0e3","modified":1575558329628},{"_id":"themes/cactus/source/lib/jquery/jquery.min.js","hash":"0dc32db4aa9c5f03f3b38c47d883dbd4fed13aae","modified":1575558329569},{"_id":"source/images/clean-code/code-review-3.png","hash":"0da46fbe73a36d8103f2148146f3d58e9b47b6c0","modified":1579324437406},{"_id":"themes/cactus/source/css/_partial/post/actions_desktop.styl","hash":"4ef72ea70f7c840b2843bf7717aaafae3b6fc241","modified":1575558329529},{"_id":"themes/cactus/source/css/_partial/post/actions_mobile.styl","hash":"fe6148be3bfd352c26ced95ba45ef9f83c9baccb","modified":1575558329530},{"_id":"themes/cactus/source/lib/font-awesome/css/all.min.css","hash":"cf1a3fd771900af34f2af22142beecfb47367548","modified":1575558329539},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"d902f8db3e021155f177f698a252fb98d6e61768","modified":1575558329551},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.eot","hash":"42ff503f20e97503cef8e5b2ec10ae07699d7c01","modified":1575558329552},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"c140085833a38abec6b7df99d4ccac93eb266031","modified":1575558329554},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff","hash":"7b3f44b4d3028f3c87ddf0f4bd62511c9bf4a87e","modified":1575558329555},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"9784edb76f8a2ed595ea4bf74d46cda4eff3b303","modified":1575558329555},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"92da6e3c7121e21cdfde25ef08797a3937a683e1","modified":1575558329568},{"_id":"themes/cactus/source/lib/justified-gallery/css/justifiedGallery.min.css","hash":"92bb6e468a1db7fbd99ccb960e15e28572254263","modified":1575558329570},{"_id":"source/images/clean-code/code-review-1.png","hash":"42b6b4c66c39d23587b67a06270d5f424acea783","modified":1579324310949},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff","hash":"f9d835a0f9248b1bb33d66968e87c4a50103ed8d","modified":1575558329550},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff","hash":"80d33a73cbb60e206ef6f5c898988641576c7dda","modified":1575558329567},{"_id":"themes/cactus/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"82ab395176c927ffbb2f7c95132ee0a06cd5d64a","modified":1575558329571},{"_id":"source/images/clean-code/code-review-2.png","hash":"b35ceb2209e8044e69f62629584888ed28a14aba","modified":1579324369005},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"19e302760e39e25a5f8d90d6cd0164ef6cd74f8c","modified":1575558329549},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.eot","hash":"644ece8263d2f96b087eebf7f6d4e309e5898eb5","modified":1575558329541},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.svg","hash":"33e86c0ad6fb9c5c0c8c2af4cb2d790c6b14a8aa","modified":1575558329553},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.eot","hash":"10740942ec6b3f4985529d343402d0bf32f9f847","modified":1575558329557},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"c445864a9646948e0d7ff44930ad732ee61427d8","modified":1575558329566},{"_id":"source/images/typewriter.jpg","hash":"d62db944644d1122f636e8d64ee570a154bf4166","modified":1575558329506},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.svg","hash":"ed6c1ed8f24df909f40fe5e5c652d7ff9570c821","modified":1575558329564},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.svg","hash":"b0bb9e6ac7709206b9510f1718516d89aead5b21","modified":1575558329547},{"_id":"source/images/header_image.gif","hash":"d44bf70508a9bac20de05cfd77d44fa7b35a2092","modified":1575558329500}],"Category":[{"name":"joeun.dev","_id":"ck6jcr9en0004dirvnn0b0c32"},{"name":"programming","_id":"ck6jcr9et0009dirvrovggga1"},{"name":"view of value","_id":"ck6jcr9f2000jdirv2o8o5it7"},{"name":"rabbylab","_id":"ck6jcr9fb000ydirv7nqou7ir"},{"name":"paradigm","_id":"ck6jcr9h2004qdirvvzfwz2t0"},{"name":"landsurfing","_id":"ck6jcr9ij0098dirvbscdih0s"}],"Data":[],"Page":[{"title":"About","date":"2019-12-31T15:00:00.000Z","_content":"### 소개\n\n안녕하세요. 하조은입니다. 헤븐 조선을 꿈꾸며 오늘도 세상을 바꿔가고 있습니다. 현재 [뱅크샐러드](https://rainist.com/)에서 개발자로 일하며 대한민국 금융을 바꿔나가고 있습니다. 커뮤니티 매니저로 <이름없는 독서모임>과 <한동 스타트업 모임>을 운영하고 있습니다. 개발과 관련된 글은 [이곳](https://joeun.dev)에 조금 더 일반적인 글은 [브런치](https://brunch.co.kr/@joeun)에 올리고 있습니다.\n\n### 경력\n\n|회사|역할|재직 기간|기술 스택|\n|---|---|---|---|\n| 뱅크샐러드 | Software Engineer | 18.12 ~ | React, TypeScript |\n| 마켓프레스 | Software Engineer | 16.07 ~ 18.11 | Node.js, [Partial.js](https://marpple.github.io/partial.js/) |\n\n### 발표 및 강의\n\n|날짜|주관|제목|\n|---|---|---|\n| 18.04.24 | 한동대학교 | 일상에 스며든 오픈소스 |\n| 18.07.20 | 성신여자대학교 | 어쩌다 개발자 |\n| 18.10.30 | 이화여자대학교 | 핵심 직무 이해 - IT |\n| 18.11.08 | 학산중학교 | 소프트웨어 개발자 이야기 |\n| 19.02.16 | GDG | [전지적 문과 시점: 개발자가 되는 방법](https://speakerdeck.com/joeun_ha/190216-gdg) |\n| 19.03.16 | 콘샐러드 | [담대한 협업과 클린코드](https://speakerdeck.com/joeun_ha/190316-con-salad) |\n| 19.07.06 | GDG x For.D | [It was my intern. Now your turn.](https://speakerdeck.com/joeun_ha/190706-gdg-x-for-dot-d) |\n| 20.01.07 | [SSAFY](https://www.ssafy.com/ksp/jsp/swp/swpMain.jsp) | [협업을 위한 클린코드](https://speakerdeck.com/joeun_ha/200107-ssafy) |\n","source":"about/index.md","raw":"---\ntitle: About\ndate: 2020-01-01 00:00:00\n---\n### 소개\n\n안녕하세요. 하조은입니다. 헤븐 조선을 꿈꾸며 오늘도 세상을 바꿔가고 있습니다. 현재 [뱅크샐러드](https://rainist.com/)에서 개발자로 일하며 대한민국 금융을 바꿔나가고 있습니다. 커뮤니티 매니저로 <이름없는 독서모임>과 <한동 스타트업 모임>을 운영하고 있습니다. 개발과 관련된 글은 [이곳](https://joeun.dev)에 조금 더 일반적인 글은 [브런치](https://brunch.co.kr/@joeun)에 올리고 있습니다.\n\n### 경력\n\n|회사|역할|재직 기간|기술 스택|\n|---|---|---|---|\n| 뱅크샐러드 | Software Engineer | 18.12 ~ | React, TypeScript |\n| 마켓프레스 | Software Engineer | 16.07 ~ 18.11 | Node.js, [Partial.js](https://marpple.github.io/partial.js/) |\n\n### 발표 및 강의\n\n|날짜|주관|제목|\n|---|---|---|\n| 18.04.24 | 한동대학교 | 일상에 스며든 오픈소스 |\n| 18.07.20 | 성신여자대학교 | 어쩌다 개발자 |\n| 18.10.30 | 이화여자대학교 | 핵심 직무 이해 - IT |\n| 18.11.08 | 학산중학교 | 소프트웨어 개발자 이야기 |\n| 19.02.16 | GDG | [전지적 문과 시점: 개발자가 되는 방법](https://speakerdeck.com/joeun_ha/190216-gdg) |\n| 19.03.16 | 콘샐러드 | [담대한 협업과 클린코드](https://speakerdeck.com/joeun_ha/190316-con-salad) |\n| 19.07.06 | GDG x For.D | [It was my intern. Now your turn.](https://speakerdeck.com/joeun_ha/190706-gdg-x-for-dot-d) |\n| 20.01.07 | [SSAFY](https://www.ssafy.com/ksp/jsp/swp/swpMain.jsp) | [협업을 위한 클린코드](https://speakerdeck.com/joeun_ha/200107-ssafy) |\n","updated":"2020-02-09T14:20:01.168Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck6jcr9ed0000dirvpnryew64","content":"<h3 id=\"소개\"><a href=\"#소개\" class=\"headerlink\" title=\"소개\"></a>소개</h3><p>안녕하세요. 하조은입니다. 헤븐 조선을 꿈꾸며 오늘도 세상을 바꿔가고 있습니다. 현재 <a href=\"https://rainist.com/\" target=\"_blank\" rel=\"noopener\">뱅크샐러드</a>에서 개발자로 일하며 대한민국 금융을 바꿔나가고 있습니다. 커뮤니티 매니저로 &lt;이름없는 독서모임&gt;과 &lt;한동 스타트업 모임&gt;을 운영하고 있습니다. 개발과 관련된 글은 <a href=\"https://joeun.dev\">이곳</a>에 조금 더 일반적인 글은 <a href=\"https://brunch.co.kr/@joeun\" target=\"_blank\" rel=\"noopener\">브런치</a>에 올리고 있습니다.</p>\n<h3 id=\"경력\"><a href=\"#경력\" class=\"headerlink\" title=\"경력\"></a>경력</h3><table>\n<thead>\n<tr>\n<th>회사</th>\n<th>역할</th>\n<th>재직 기간</th>\n<th>기술 스택</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>뱅크샐러드</td>\n<td>Software Engineer</td>\n<td>18.12 ~</td>\n<td>React, TypeScript</td>\n</tr>\n<tr>\n<td>마켓프레스</td>\n<td>Software Engineer</td>\n<td>16.07 ~ 18.11</td>\n<td>Node.js, <a href=\"https://marpple.github.io/partial.js/\" target=\"_blank\" rel=\"noopener\">Partial.js</a></td>\n</tr>\n</tbody></table>\n<h3 id=\"발표-및-강의\"><a href=\"#발표-및-강의\" class=\"headerlink\" title=\"발표 및 강의\"></a>발표 및 강의</h3><table>\n<thead>\n<tr>\n<th>날짜</th>\n<th>주관</th>\n<th>제목</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>18.04.24</td>\n<td>한동대학교</td>\n<td>일상에 스며든 오픈소스</td>\n</tr>\n<tr>\n<td>18.07.20</td>\n<td>성신여자대학교</td>\n<td>어쩌다 개발자</td>\n</tr>\n<tr>\n<td>18.10.30</td>\n<td>이화여자대학교</td>\n<td>핵심 직무 이해 - IT</td>\n</tr>\n<tr>\n<td>18.11.08</td>\n<td>학산중학교</td>\n<td>소프트웨어 개발자 이야기</td>\n</tr>\n<tr>\n<td>19.02.16</td>\n<td>GDG</td>\n<td><a href=\"https://speakerdeck.com/joeun_ha/190216-gdg\" target=\"_blank\" rel=\"noopener\">전지적 문과 시점: 개발자가 되는 방법</a></td>\n</tr>\n<tr>\n<td>19.03.16</td>\n<td>콘샐러드</td>\n<td><a href=\"https://speakerdeck.com/joeun_ha/190316-con-salad\" target=\"_blank\" rel=\"noopener\">담대한 협업과 클린코드</a></td>\n</tr>\n<tr>\n<td>19.07.06</td>\n<td>GDG x For.D</td>\n<td><a href=\"https://speakerdeck.com/joeun_ha/190706-gdg-x-for-dot-d\" target=\"_blank\" rel=\"noopener\">It was my intern. Now your turn.</a></td>\n</tr>\n<tr>\n<td>20.01.07</td>\n<td><a href=\"https://www.ssafy.com/ksp/jsp/swp/swpMain.jsp\" target=\"_blank\" rel=\"noopener\">SSAFY</a></td>\n<td><a href=\"https://speakerdeck.com/joeun_ha/200107-ssafy\" target=\"_blank\" rel=\"noopener\">협업을 위한 클린코드</a></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"소개\"><a href=\"#소개\" class=\"headerlink\" title=\"소개\"></a>소개</h3><p>안녕하세요. 하조은입니다. 헤븐 조선을 꿈꾸며 오늘도 세상을 바꿔가고 있습니다. 현재 <a href=\"https://rainist.com/\" target=\"_blank\" rel=\"noopener\">뱅크샐러드</a>에서 개발자로 일하며 대한민국 금융을 바꿔나가고 있습니다. 커뮤니티 매니저로 &lt;이름없는 독서모임&gt;과 &lt;한동 스타트업 모임&gt;을 운영하고 있습니다. 개발과 관련된 글은 <a href=\"https://joeun.dev\">이곳</a>에 조금 더 일반적인 글은 <a href=\"https://brunch.co.kr/@joeun\" target=\"_blank\" rel=\"noopener\">브런치</a>에 올리고 있습니다.</p>\n<h3 id=\"경력\"><a href=\"#경력\" class=\"headerlink\" title=\"경력\"></a>경력</h3><table>\n<thead>\n<tr>\n<th>회사</th>\n<th>역할</th>\n<th>재직 기간</th>\n<th>기술 스택</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>뱅크샐러드</td>\n<td>Software Engineer</td>\n<td>18.12 ~</td>\n<td>React, TypeScript</td>\n</tr>\n<tr>\n<td>마켓프레스</td>\n<td>Software Engineer</td>\n<td>16.07 ~ 18.11</td>\n<td>Node.js, <a href=\"https://marpple.github.io/partial.js/\" target=\"_blank\" rel=\"noopener\">Partial.js</a></td>\n</tr>\n</tbody></table>\n<h3 id=\"발표-및-강의\"><a href=\"#발표-및-강의\" class=\"headerlink\" title=\"발표 및 강의\"></a>발표 및 강의</h3><table>\n<thead>\n<tr>\n<th>날짜</th>\n<th>주관</th>\n<th>제목</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>18.04.24</td>\n<td>한동대학교</td>\n<td>일상에 스며든 오픈소스</td>\n</tr>\n<tr>\n<td>18.07.20</td>\n<td>성신여자대학교</td>\n<td>어쩌다 개발자</td>\n</tr>\n<tr>\n<td>18.10.30</td>\n<td>이화여자대학교</td>\n<td>핵심 직무 이해 - IT</td>\n</tr>\n<tr>\n<td>18.11.08</td>\n<td>학산중학교</td>\n<td>소프트웨어 개발자 이야기</td>\n</tr>\n<tr>\n<td>19.02.16</td>\n<td>GDG</td>\n<td><a href=\"https://speakerdeck.com/joeun_ha/190216-gdg\" target=\"_blank\" rel=\"noopener\">전지적 문과 시점: 개발자가 되는 방법</a></td>\n</tr>\n<tr>\n<td>19.03.16</td>\n<td>콘샐러드</td>\n<td><a href=\"https://speakerdeck.com/joeun_ha/190316-con-salad\" target=\"_blank\" rel=\"noopener\">담대한 협업과 클린코드</a></td>\n</tr>\n<tr>\n<td>19.07.06</td>\n<td>GDG x For.D</td>\n<td><a href=\"https://speakerdeck.com/joeun_ha/190706-gdg-x-for-dot-d\" target=\"_blank\" rel=\"noopener\">It was my intern. Now your turn.</a></td>\n</tr>\n<tr>\n<td>20.01.07</td>\n<td><a href=\"https://www.ssafy.com/ksp/jsp/swp/swpMain.jsp\" target=\"_blank\" rel=\"noopener\">SSAFY</a></td>\n<td><a href=\"https://speakerdeck.com/joeun_ha/200107-ssafy\" target=\"_blank\" rel=\"noopener\">협업을 위한 클린코드</a></td>\n</tr>\n</tbody></table>\n"},{"title":"Search","type":"search","search":true,"date":"2018-06-25T06:54:34.000Z","_content":"","source":"search/index.md","raw":"---\ntitle: Search\ntype: search\nsearch: true\ndate: 2018-06-25 15:54:34\n---\n","updated":"2020-01-08T13:57:40.735Z","path":"search/index.html","comments":1,"layout":"page","_id":"ck6jcr9ek0002dirvpygqbvi0","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"block-chain-js","date":"2018-07-02T12:03:35.000Z","_content":"\n\nhttps://steemkr.com/kr/@yahweh87/4-merkle-tree-merkle-root\n","source":"_drafts/block-chain-js-5.md","raw":"---\ntitle: block-chain-js\ncategories:\n  - joeun.dev\ndate: 2018-07-02 21:03:35\ntags:\n---\n\n\nhttps://steemkr.com/kr/@yahweh87/4-merkle-tree-merkle-root\n","slug":"block-chain-js-5","published":0,"updated":"2020-02-09T14:20:01.157Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9ef0001dirvvu91jkrq","content":"<p><a href=\"https://steemkr.com/kr/@yahweh87/4-merkle-tree-merkle-root\" target=\"_blank\" rel=\"noopener\">https://steemkr.com/kr/@yahweh87/4-merkle-tree-merkle-root</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://steemkr.com/kr/@yahweh87/4-merkle-tree-merkle-root\" target=\"_blank\" rel=\"noopener\">https://steemkr.com/kr/@yahweh87/4-merkle-tree-merkle-root</a></p>\n"},{"title":"오늘의 함수 - convert","date":"2019-01-02T11:00:00.000Z","description":"json 데이터를 csv 포맷 데이터로 치환하는 convert 함수를 만들어봤습니다.","_content":"","source":"_drafts/javascript-daily-function-22.md","raw":"---\ntitle: '오늘의 함수 - convert'\ndate: 2019-01-02 20:00:00\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: 'json 데이터를 csv 포맷 데이터로 치환하는 convert 함수를 만들어봤습니다.'\n---\n","slug":"javascript-daily-function-22","published":0,"updated":"2019-12-05T15:05:29.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9ek0003dirvslfjuslh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"[함수형 자바스크립트] Movie Box 1 - 필터링, 정렬","date":"2017-10-23T06:06:58.000Z","_content":"## Movie Box 만들기\n영화 데이터를 다루는 앱을 만들면서 함수형 프로그래밍의 실전 예제를 경험해보자. \n(모든 예제는 웹 브라우저의 '검사' 도구를 열어서 테스트할 수 있다.)\n\n\n\n---\n\n### 전체 스터디 일정\n  ##### 1주차 | [기본 함수 구현하고 사용하기](/programming/functional-js-study/)\n  ##### 2주차 | [고차 함수와 커링(currying)](/programming/functional-js-study-1/)\n  ##### 3주차 | [함수형 자바스크립트 라이브러리](/programming/functional-js-study-2/)\n  ##### 4주차 | Movie Box 1 - 필터링, 정렬\n  ##### _5주차 | Movie Box 2 - 필터링, 정렬 복습_\n  ##### _6주차 | Movie Box 3 - 지연평가 L, memoize_\n  ##### _7주차 | Movie Box 4 - 비동기 상황 다루기_\n\n[예제 코드](https://github.com/joeunha/functional-js-study/tree/master/04_week)","source":"_drafts/functaional-js-study-3.md","raw":"---\ntitle: '[함수형 자바스크립트] Movie Box 1 - 필터링, 정렬'\ncategories:\n  - programming\ntags:\n  - javascript\n  - 자바스크립트\n  - don.js\n  - partial.js\n  - 함수형 프로그래밍\n  - 함수형 자바스크립트\ndate: 2017-10-23 15:06:58\n---\n## Movie Box 만들기\n영화 데이터를 다루는 앱을 만들면서 함수형 프로그래밍의 실전 예제를 경험해보자. \n(모든 예제는 웹 브라우저의 '검사' 도구를 열어서 테스트할 수 있다.)\n\n\n\n---\n\n### 전체 스터디 일정\n  ##### 1주차 | [기본 함수 구현하고 사용하기](/programming/functional-js-study/)\n  ##### 2주차 | [고차 함수와 커링(currying)](/programming/functional-js-study-1/)\n  ##### 3주차 | [함수형 자바스크립트 라이브러리](/programming/functional-js-study-2/)\n  ##### 4주차 | Movie Box 1 - 필터링, 정렬\n  ##### _5주차 | Movie Box 2 - 필터링, 정렬 복습_\n  ##### _6주차 | Movie Box 3 - 지연평가 L, memoize_\n  ##### _7주차 | Movie Box 4 - 비동기 상황 다루기_\n\n[예제 코드](https://github.com/joeunha/functional-js-study/tree/master/04_week)","slug":"functaional-js-study-3","published":0,"updated":"2019-12-05T15:05:29.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9eo0005dirvsam3irzg","content":"<h2 id=\"Movie-Box-만들기\"><a href=\"#Movie-Box-만들기\" class=\"headerlink\" title=\"Movie Box 만들기\"></a>Movie Box 만들기</h2><p>영화 데이터를 다루는 앱을 만들면서 함수형 프로그래밍의 실전 예제를 경험해보자.<br>(모든 예제는 웹 브라우저의 ‘검사’ 도구를 열어서 테스트할 수 있다.)</p>\n<hr>\n<h3 id=\"전체-스터디-일정\"><a href=\"#전체-스터디-일정\" class=\"headerlink\" title=\"전체 스터디 일정\"></a>전체 스터디 일정</h3><h5 id=\"1주차-기본-함수-구현하고-사용하기\"><a href=\"#1주차-기본-함수-구현하고-사용하기\" class=\"headerlink\" title=\"1주차 | 기본 함수 구현하고 사용하기\"></a>1주차 | <a href=\"/programming/functional-js-study/\">기본 함수 구현하고 사용하기</a></h5><h5 id=\"2주차-고차-함수와-커링-currying\"><a href=\"#2주차-고차-함수와-커링-currying\" class=\"headerlink\" title=\"2주차 | 고차 함수와 커링(currying)\"></a>2주차 | <a href=\"/programming/functional-js-study-1/\">고차 함수와 커링(currying)</a></h5><h5 id=\"3주차-함수형-자바스크립트-라이브러리\"><a href=\"#3주차-함수형-자바스크립트-라이브러리\" class=\"headerlink\" title=\"3주차 | 함수형 자바스크립트 라이브러리\"></a>3주차 | <a href=\"/programming/functional-js-study-2/\">함수형 자바스크립트 라이브러리</a></h5><h5 id=\"4주차-Movie-Box-1-필터링-정렬\"><a href=\"#4주차-Movie-Box-1-필터링-정렬\" class=\"headerlink\" title=\"4주차 | Movie Box 1 - 필터링, 정렬\"></a>4주차 | Movie Box 1 - 필터링, 정렬</h5><h5 id=\"5주차-Movie-Box-2-필터링-정렬-복습\"><a href=\"#5주차-Movie-Box-2-필터링-정렬-복습\" class=\"headerlink\" title=\"5주차 | Movie Box 2 - 필터링, 정렬 복습\"></a><em>5주차 | Movie Box 2 - 필터링, 정렬 복습</em></h5><h5 id=\"6주차-Movie-Box-3-지연평가-L-memoize\"><a href=\"#6주차-Movie-Box-3-지연평가-L-memoize\" class=\"headerlink\" title=\"6주차 | Movie Box 3 - 지연평가 L, memoize\"></a><em>6주차 | Movie Box 3 - 지연평가 L, memoize</em></h5><h5 id=\"7주차-Movie-Box-4-비동기-상황-다루기\"><a href=\"#7주차-Movie-Box-4-비동기-상황-다루기\" class=\"headerlink\" title=\"7주차 | Movie Box 4 - 비동기 상황 다루기\"></a><em>7주차 | Movie Box 4 - 비동기 상황 다루기</em></h5><p><a href=\"https://github.com/joeunha/functional-js-study/tree/master/04_week\" target=\"_blank\" rel=\"noopener\">예제 코드</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Movie-Box-만들기\"><a href=\"#Movie-Box-만들기\" class=\"headerlink\" title=\"Movie Box 만들기\"></a>Movie Box 만들기</h2><p>영화 데이터를 다루는 앱을 만들면서 함수형 프로그래밍의 실전 예제를 경험해보자.<br>(모든 예제는 웹 브라우저의 ‘검사’ 도구를 열어서 테스트할 수 있다.)</p>\n<hr>\n<h3 id=\"전체-스터디-일정\"><a href=\"#전체-스터디-일정\" class=\"headerlink\" title=\"전체 스터디 일정\"></a>전체 스터디 일정</h3><h5 id=\"1주차-기본-함수-구현하고-사용하기\"><a href=\"#1주차-기본-함수-구현하고-사용하기\" class=\"headerlink\" title=\"1주차 | 기본 함수 구현하고 사용하기\"></a>1주차 | <a href=\"/programming/functional-js-study/\">기본 함수 구현하고 사용하기</a></h5><h5 id=\"2주차-고차-함수와-커링-currying\"><a href=\"#2주차-고차-함수와-커링-currying\" class=\"headerlink\" title=\"2주차 | 고차 함수와 커링(currying)\"></a>2주차 | <a href=\"/programming/functional-js-study-1/\">고차 함수와 커링(currying)</a></h5><h5 id=\"3주차-함수형-자바스크립트-라이브러리\"><a href=\"#3주차-함수형-자바스크립트-라이브러리\" class=\"headerlink\" title=\"3주차 | 함수형 자바스크립트 라이브러리\"></a>3주차 | <a href=\"/programming/functional-js-study-2/\">함수형 자바스크립트 라이브러리</a></h5><h5 id=\"4주차-Movie-Box-1-필터링-정렬\"><a href=\"#4주차-Movie-Box-1-필터링-정렬\" class=\"headerlink\" title=\"4주차 | Movie Box 1 - 필터링, 정렬\"></a>4주차 | Movie Box 1 - 필터링, 정렬</h5><h5 id=\"5주차-Movie-Box-2-필터링-정렬-복습\"><a href=\"#5주차-Movie-Box-2-필터링-정렬-복습\" class=\"headerlink\" title=\"5주차 | Movie Box 2 - 필터링, 정렬 복습\"></a><em>5주차 | Movie Box 2 - 필터링, 정렬 복습</em></h5><h5 id=\"6주차-Movie-Box-3-지연평가-L-memoize\"><a href=\"#6주차-Movie-Box-3-지연평가-L-memoize\" class=\"headerlink\" title=\"6주차 | Movie Box 3 - 지연평가 L, memoize\"></a><em>6주차 | Movie Box 3 - 지연평가 L, memoize</em></h5><h5 id=\"7주차-Movie-Box-4-비동기-상황-다루기\"><a href=\"#7주차-Movie-Box-4-비동기-상황-다루기\" class=\"headerlink\" title=\"7주차 | Movie Box 4 - 비동기 상황 다루기\"></a><em>7주차 | Movie Box 4 - 비동기 상황 다루기</em></h5><p><a href=\"https://github.com/joeunha/functional-js-study/tree/master/04_week\" target=\"_blank\" rel=\"noopener\">예제 코드</a></p>\n"},{"title":"나와 같다면 - 배워서 남주자","date":"2018-02-16T09:38:24.000Z","_content":"\n##### '나와 같다면' 시리즈 소개\n  _'그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼'_ 김연우씨가 불러서 더 유명한 노래 '나와 같다면'에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.\n\n* * *\n\n## 배워서 남주자\n1. 나는 왜 배우는가?\n- 성장하기 위해서 배운다\n- 왜 성장하려고 하는가?\n- 각기 다양한 이유가 있다. 직장, 돈, 더 나은 삶을 위해. 그 모든 것은 '행복'을 위함이다. 성장을 통해 행복해질 수 있다고 믿기 때문이다. 나 역시 마찬가지 성장은 행복을 가져다 준다고 믿는다. 여기서의 행복은 '자기 만족'이라는 방식으로 표현된다. 나는 자기 만족을 위해 배운다. 나는 배움으로 성장하고 성장함으로 자기 만족이라는 행복에 이를 수 있다.\n\n2. 나는 왜 남주는가?\n두가지 이유가 있다. 첫째로 남을 주는 행위를 통해 더 배울 수 있다. 다른 이들에게 내가 배운 내용을 전달하기 위해서 정리하는 작업이 필요한데 이 과정을 통해 내가 배운 것을 복습할 수 있다. 또 가르쳐주고 알려주는 과정을 통해 예상치 못한 방식으로 지식을 바라볼 수 있는 관점이 생긴다. 이건 다른 학문으로 확장하는데 아주 유용하다. \n두번째로는 행복을 위함이다. 기회가 되면 나의 행복론에 대해 적을 수 있겠지만 오늘은 배움과 나눔에 대한 것만 논하겠다. 나는 나눔을 통해 행복을 느낀다. 나의 성장이 남에게도 도움이 된다는 느낌. 내 존재가 다른 이에게 선한 영향을 끼친다는 느낌과 기분이야말로 내가 느낄 수 있는 최고의 행복이다. 결국 나는 행복하기 위해 배우고 나눈다. \n\n3. 배워서 나눔으로 함께 성장하자.\n엄청난 것을 나누는게 아니다. 그저 각자가 평소에 자주 하는 그 '일(Job)' 혹은 취미를 공유함으로 남을 도울 수 있다는 이야기를 하고 싶다. 나는 개발자로 일하고 있고 취미로 보드를 탄다. 나는 개발 지식이 필요한 이들에게 내가 가진 지식을 나눔으로 다른 이들을 돕고 있다. 취미는 아직 미약하여 누군가를 알려줄 수준이 아니지만 배우고자 하는 이들에게는 최선을 다해 알려준다. 단언컨대 나는 이 과정을 통해 성장하고 있다. 두번의 함수형 프로그래밍 스터디를 통해 확립되지 않았던 지식이 확립되고 정돈되었으며, Github 스터디를 통해서도 마찬가지 경험을 했다. ","source":"_drafts/like-me-3.md","raw":"---\ntitle: '나와 같다면 - 배워서 남주자'\ncategories:\n  - view of value\ntags:\n  - opinion\n  - 나와 같다면\ndate: 2018-02-16 18:38:24\n---\n\n##### '나와 같다면' 시리즈 소개\n  _'그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼'_ 김연우씨가 불러서 더 유명한 노래 '나와 같다면'에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.\n\n* * *\n\n## 배워서 남주자\n1. 나는 왜 배우는가?\n- 성장하기 위해서 배운다\n- 왜 성장하려고 하는가?\n- 각기 다양한 이유가 있다. 직장, 돈, 더 나은 삶을 위해. 그 모든 것은 '행복'을 위함이다. 성장을 통해 행복해질 수 있다고 믿기 때문이다. 나 역시 마찬가지 성장은 행복을 가져다 준다고 믿는다. 여기서의 행복은 '자기 만족'이라는 방식으로 표현된다. 나는 자기 만족을 위해 배운다. 나는 배움으로 성장하고 성장함으로 자기 만족이라는 행복에 이를 수 있다.\n\n2. 나는 왜 남주는가?\n두가지 이유가 있다. 첫째로 남을 주는 행위를 통해 더 배울 수 있다. 다른 이들에게 내가 배운 내용을 전달하기 위해서 정리하는 작업이 필요한데 이 과정을 통해 내가 배운 것을 복습할 수 있다. 또 가르쳐주고 알려주는 과정을 통해 예상치 못한 방식으로 지식을 바라볼 수 있는 관점이 생긴다. 이건 다른 학문으로 확장하는데 아주 유용하다. \n두번째로는 행복을 위함이다. 기회가 되면 나의 행복론에 대해 적을 수 있겠지만 오늘은 배움과 나눔에 대한 것만 논하겠다. 나는 나눔을 통해 행복을 느낀다. 나의 성장이 남에게도 도움이 된다는 느낌. 내 존재가 다른 이에게 선한 영향을 끼친다는 느낌과 기분이야말로 내가 느낄 수 있는 최고의 행복이다. 결국 나는 행복하기 위해 배우고 나눈다. \n\n3. 배워서 나눔으로 함께 성장하자.\n엄청난 것을 나누는게 아니다. 그저 각자가 평소에 자주 하는 그 '일(Job)' 혹은 취미를 공유함으로 남을 도울 수 있다는 이야기를 하고 싶다. 나는 개발자로 일하고 있고 취미로 보드를 탄다. 나는 개발 지식이 필요한 이들에게 내가 가진 지식을 나눔으로 다른 이들을 돕고 있다. 취미는 아직 미약하여 누군가를 알려줄 수준이 아니지만 배우고자 하는 이들에게는 최선을 다해 알려준다. 단언컨대 나는 이 과정을 통해 성장하고 있다. 두번의 함수형 프로그래밍 스터디를 통해 확립되지 않았던 지식이 확립되고 정돈되었으며, Github 스터디를 통해서도 마찬가지 경험을 했다. ","slug":"like-me-3","published":0,"updated":"2019-12-05T15:05:29.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9eq0007dirvsn43i040","content":"<h5 id=\"‘나와-같다면’-시리즈-소개\"><a href=\"#‘나와-같다면’-시리즈-소개\" class=\"headerlink\" title=\"‘나와 같다면’ 시리즈 소개\"></a>‘나와 같다면’ 시리즈 소개</h5><p>  <em>‘그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼’</em> 김연우씨가 불러서 더 유명한 노래 ‘나와 같다면’에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.</p>\n<hr>\n<h2 id=\"배워서-남주자\"><a href=\"#배워서-남주자\" class=\"headerlink\" title=\"배워서 남주자\"></a>배워서 남주자</h2><ol>\n<li>나는 왜 배우는가?</li>\n</ol>\n<ul>\n<li>성장하기 위해서 배운다</li>\n<li>왜 성장하려고 하는가?</li>\n<li>각기 다양한 이유가 있다. 직장, 돈, 더 나은 삶을 위해. 그 모든 것은 ‘행복’을 위함이다. 성장을 통해 행복해질 수 있다고 믿기 때문이다. 나 역시 마찬가지 성장은 행복을 가져다 준다고 믿는다. 여기서의 행복은 ‘자기 만족’이라는 방식으로 표현된다. 나는 자기 만족을 위해 배운다. 나는 배움으로 성장하고 성장함으로 자기 만족이라는 행복에 이를 수 있다.</li>\n</ul>\n<ol start=\"2\">\n<li><p>나는 왜 남주는가?<br>두가지 이유가 있다. 첫째로 남을 주는 행위를 통해 더 배울 수 있다. 다른 이들에게 내가 배운 내용을 전달하기 위해서 정리하는 작업이 필요한데 이 과정을 통해 내가 배운 것을 복습할 수 있다. 또 가르쳐주고 알려주는 과정을 통해 예상치 못한 방식으로 지식을 바라볼 수 있는 관점이 생긴다. 이건 다른 학문으로 확장하는데 아주 유용하다.<br>두번째로는 행복을 위함이다. 기회가 되면 나의 행복론에 대해 적을 수 있겠지만 오늘은 배움과 나눔에 대한 것만 논하겠다. 나는 나눔을 통해 행복을 느낀다. 나의 성장이 남에게도 도움이 된다는 느낌. 내 존재가 다른 이에게 선한 영향을 끼친다는 느낌과 기분이야말로 내가 느낄 수 있는 최고의 행복이다. 결국 나는 행복하기 위해 배우고 나눈다. </p>\n</li>\n<li><p>배워서 나눔으로 함께 성장하자.<br>엄청난 것을 나누는게 아니다. 그저 각자가 평소에 자주 하는 그 ‘일(Job)’ 혹은 취미를 공유함으로 남을 도울 수 있다는 이야기를 하고 싶다. 나는 개발자로 일하고 있고 취미로 보드를 탄다. 나는 개발 지식이 필요한 이들에게 내가 가진 지식을 나눔으로 다른 이들을 돕고 있다. 취미는 아직 미약하여 누군가를 알려줄 수준이 아니지만 배우고자 하는 이들에게는 최선을 다해 알려준다. 단언컨대 나는 이 과정을 통해 성장하고 있다. 두번의 함수형 프로그래밍 스터디를 통해 확립되지 않았던 지식이 확립되고 정돈되었으며, Github 스터디를 통해서도 마찬가지 경험을 했다. </p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"‘나와-같다면’-시리즈-소개\"><a href=\"#‘나와-같다면’-시리즈-소개\" class=\"headerlink\" title=\"‘나와 같다면’ 시리즈 소개\"></a>‘나와 같다면’ 시리즈 소개</h5><p>  <em>‘그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼’</em> 김연우씨가 불러서 더 유명한 노래 ‘나와 같다면’에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.</p>\n<hr>\n<h2 id=\"배워서-남주자\"><a href=\"#배워서-남주자\" class=\"headerlink\" title=\"배워서 남주자\"></a>배워서 남주자</h2><ol>\n<li>나는 왜 배우는가?</li>\n</ol>\n<ul>\n<li>성장하기 위해서 배운다</li>\n<li>왜 성장하려고 하는가?</li>\n<li>각기 다양한 이유가 있다. 직장, 돈, 더 나은 삶을 위해. 그 모든 것은 ‘행복’을 위함이다. 성장을 통해 행복해질 수 있다고 믿기 때문이다. 나 역시 마찬가지 성장은 행복을 가져다 준다고 믿는다. 여기서의 행복은 ‘자기 만족’이라는 방식으로 표현된다. 나는 자기 만족을 위해 배운다. 나는 배움으로 성장하고 성장함으로 자기 만족이라는 행복에 이를 수 있다.</li>\n</ul>\n<ol start=\"2\">\n<li><p>나는 왜 남주는가?<br>두가지 이유가 있다. 첫째로 남을 주는 행위를 통해 더 배울 수 있다. 다른 이들에게 내가 배운 내용을 전달하기 위해서 정리하는 작업이 필요한데 이 과정을 통해 내가 배운 것을 복습할 수 있다. 또 가르쳐주고 알려주는 과정을 통해 예상치 못한 방식으로 지식을 바라볼 수 있는 관점이 생긴다. 이건 다른 학문으로 확장하는데 아주 유용하다.<br>두번째로는 행복을 위함이다. 기회가 되면 나의 행복론에 대해 적을 수 있겠지만 오늘은 배움과 나눔에 대한 것만 논하겠다. 나는 나눔을 통해 행복을 느낀다. 나의 성장이 남에게도 도움이 된다는 느낌. 내 존재가 다른 이에게 선한 영향을 끼친다는 느낌과 기분이야말로 내가 느낄 수 있는 최고의 행복이다. 결국 나는 행복하기 위해 배우고 나눈다. </p>\n</li>\n<li><p>배워서 나눔으로 함께 성장하자.<br>엄청난 것을 나누는게 아니다. 그저 각자가 평소에 자주 하는 그 ‘일(Job)’ 혹은 취미를 공유함으로 남을 도울 수 있다는 이야기를 하고 싶다. 나는 개발자로 일하고 있고 취미로 보드를 탄다. 나는 개발 지식이 필요한 이들에게 내가 가진 지식을 나눔으로 다른 이들을 돕고 있다. 취미는 아직 미약하여 누군가를 알려줄 수준이 아니지만 배우고자 하는 이들에게는 최선을 다해 알려준다. 단언컨대 나는 이 과정을 통해 성장하고 있다. 두번의 함수형 프로그래밍 스터디를 통해 확립되지 않았던 지식이 확립되고 정돈되었으며, Github 스터디를 통해서도 마찬가지 경험을 했다. </p>\n</li>\n</ol>\n"},{"title":"자바스크립트로 블록체인 - mining","date":"2018-06-24T15:00:00.000Z","description":"자바스크립트로 블록체인을 구현해보자","_content":"_자바스크립트로 블록체인을 구현해보자_\n\n__\\*주의: 해당 글은 대략적인 구조를 설명함으로 실제 암호화폐의 구현과 다를 수 있습니다.__\n\n## 구현\n\n오늘은 [지난 시간](/programming/block-chain-js/)에 설명한 기본 개념과 데이터 구조를 골자로 블록을 채굴하는 함수를 구현해보겠습니다. 노드(Node.js) 환경에서 구현하고 ES6 문법을 사용합니다. 암호화 알고리즘으로 SHA256을 사용하고 해당 함수를 가져오기 위해 [crypto-js](https://www.npmjs.com/package/crypto-js)라는 패키지를 사용합니다. (설치 방법은 생략하겠습니다.) \n\n아래의 코드에 오늘 이야기할 모든 내용이 있습니다. 해쉬 값을 계산하는 `calculate_hash` 함수와 이를 사용하여 블록을 채굴하는 `mining` 함수입니다.   \n\n```javascript\nconst { SHA256 }  = require('crypto-js');\n\nfunction calculate_hash(block) {\n  let { previousHash, timestamp, transactions, nonce } = block;\n  return SHA256(previousHash + timestamp + JSON.stringify(transactions) + nonce).toString();\n}\n\nfunction mining(previousHash, timestamp, transactions, diff) {\n  let block = { previousHash, timestamp, transactions, nonce: 0 };\n  block.hash = calculate_hash(block);\n  \n  while (block.hash.substring(0, diff) !== Array(diff + 1).join('0')) {\n    block.nonce++;\n    block.hash = calculate_hash(block);\n  }\n\n  return block;\n}\n```\n\n#### SHA256\n찬찬히 살펴보죠. 우선 해시함수인 `SHA256`을 가져왔습니다. 이 함수에게 문자열을 전달하면 16진수로 표현된 해시값을 반환합니다. [웹 사이트](https://passwordsgenerator.net/sha256-hash-generator/)에서 테스트 해볼 수도 있습니다. 이렇게 만들어진 값은 유니크한 값으로 블록의 고유한(unique) 주소 값이 됩니다. 하지만 진짜 고유한 값이 되려면 전달하는 문자열이 고유해야합니다. 같은 문자열을 넣으면 같은 해시값을 반환하기 때문이죠.\n\n#### calulate_hash\n`calculate_hash` 함수를 살펴보면 어떻게 고유한 값을 만드는지 알 수 있습니다. 이전 블록의 해시값(`previousHash`)과 현재 블록이 생성되는 시간(`timestamp`), 거래내역(`transaction`) 그리고 난스(`nonce`)를 조합해서 고유한 값을 만들어냅니다. 거래내역은 배열의 형태이기 때문에 `JSON.stringify`를 이용해 문자열로 치환합니다. 해시함수가 반환하는 값도 문자열로 바꿔 반환하면 우리가 원하는 해시값이 됩니다.\n\n#### mining\n채굴을 위해 사용되는 `mining` 함수는 이전 블록의 해시값, 시간, 거래내역, 난이도(`diff`)를 인자로 받습니다. 그리고 해당 값과 난스, 해시값을 합쳐 블록(`block`)을 만들어둡니다. 블록은 반복적인 해시값 계산을 통해 난이도를 통과하면 최종적으로 반환됩니다.\n\nwhile 문의 조건을 살펴보면 해시값의 앞자리 수가 난이도 만큼의 0을 갖는지 확인합니다. 난이도가 2라면 해시값은 '00A123...'과 같은 형태가 되어야 한다는 뜻이죠. 속을 살펴보면 난스를 하나씩 증가시켜 반복적으로 해시값을 계산하는 것을 확인할 수 있습니다. 이렇게 반복 계산을 통해 원하는 값을 발견하면 while 문을 벗어납니다. 이렇게 난스를 증가시켜가며 난이도에 맞는 해시값을 발견하는게 바로 __'채굴'__입니다. 참 쉽죠?\n\n## 테스트\n\n실제로 함수를 돌려보면 아래와 같은 결과를 만듭니다. 159회의 시도(nonce)를 통해 해시값을 발견하고 블록을 만들어냈군요!  \n\n```javascript\nconsole.log(mining('', new Date(), [{ adam: -10, eve: 10 }], 2));\n \n//  { previousHash: '',\n//    timestamp: 2018-06-25T03:25:01.985Z,\n//    transactions: [ { adam: -10, eve: 10 } ],\n//    nonce: 159,\n//    hash: '006a918403e96e3545c8dfa58d360a6e6dd284e8ca74c2a81228243b2e45a1c0' }\n```\n\n오늘의 코드는 [Github](https://github.com/joeunha/block-js/blob/master/v01.js)에서 확인하실 수 있습니다. 다음 시간에는 체인에 추가하는 과정을 구현해겠습니다.","source":"_posts/block-chain-js-1.md","raw":"---\ntitle: '자바스크립트로 블록체인 - mining'\ncategories:\n  - programming\ntags:\n  - javascript\n  - 자바스크립트\n  - blockchain\n  - 블록체인\ndate: 2018-06-25 00:00:00\ndescription: 자바스크립트로 블록체인을 구현해보자\n---\n_자바스크립트로 블록체인을 구현해보자_\n\n__\\*주의: 해당 글은 대략적인 구조를 설명함으로 실제 암호화폐의 구현과 다를 수 있습니다.__\n\n## 구현\n\n오늘은 [지난 시간](/programming/block-chain-js/)에 설명한 기본 개념과 데이터 구조를 골자로 블록을 채굴하는 함수를 구현해보겠습니다. 노드(Node.js) 환경에서 구현하고 ES6 문법을 사용합니다. 암호화 알고리즘으로 SHA256을 사용하고 해당 함수를 가져오기 위해 [crypto-js](https://www.npmjs.com/package/crypto-js)라는 패키지를 사용합니다. (설치 방법은 생략하겠습니다.) \n\n아래의 코드에 오늘 이야기할 모든 내용이 있습니다. 해쉬 값을 계산하는 `calculate_hash` 함수와 이를 사용하여 블록을 채굴하는 `mining` 함수입니다.   \n\n```javascript\nconst { SHA256 }  = require('crypto-js');\n\nfunction calculate_hash(block) {\n  let { previousHash, timestamp, transactions, nonce } = block;\n  return SHA256(previousHash + timestamp + JSON.stringify(transactions) + nonce).toString();\n}\n\nfunction mining(previousHash, timestamp, transactions, diff) {\n  let block = { previousHash, timestamp, transactions, nonce: 0 };\n  block.hash = calculate_hash(block);\n  \n  while (block.hash.substring(0, diff) !== Array(diff + 1).join('0')) {\n    block.nonce++;\n    block.hash = calculate_hash(block);\n  }\n\n  return block;\n}\n```\n\n#### SHA256\n찬찬히 살펴보죠. 우선 해시함수인 `SHA256`을 가져왔습니다. 이 함수에게 문자열을 전달하면 16진수로 표현된 해시값을 반환합니다. [웹 사이트](https://passwordsgenerator.net/sha256-hash-generator/)에서 테스트 해볼 수도 있습니다. 이렇게 만들어진 값은 유니크한 값으로 블록의 고유한(unique) 주소 값이 됩니다. 하지만 진짜 고유한 값이 되려면 전달하는 문자열이 고유해야합니다. 같은 문자열을 넣으면 같은 해시값을 반환하기 때문이죠.\n\n#### calulate_hash\n`calculate_hash` 함수를 살펴보면 어떻게 고유한 값을 만드는지 알 수 있습니다. 이전 블록의 해시값(`previousHash`)과 현재 블록이 생성되는 시간(`timestamp`), 거래내역(`transaction`) 그리고 난스(`nonce`)를 조합해서 고유한 값을 만들어냅니다. 거래내역은 배열의 형태이기 때문에 `JSON.stringify`를 이용해 문자열로 치환합니다. 해시함수가 반환하는 값도 문자열로 바꿔 반환하면 우리가 원하는 해시값이 됩니다.\n\n#### mining\n채굴을 위해 사용되는 `mining` 함수는 이전 블록의 해시값, 시간, 거래내역, 난이도(`diff`)를 인자로 받습니다. 그리고 해당 값과 난스, 해시값을 합쳐 블록(`block`)을 만들어둡니다. 블록은 반복적인 해시값 계산을 통해 난이도를 통과하면 최종적으로 반환됩니다.\n\nwhile 문의 조건을 살펴보면 해시값의 앞자리 수가 난이도 만큼의 0을 갖는지 확인합니다. 난이도가 2라면 해시값은 '00A123...'과 같은 형태가 되어야 한다는 뜻이죠. 속을 살펴보면 난스를 하나씩 증가시켜 반복적으로 해시값을 계산하는 것을 확인할 수 있습니다. 이렇게 반복 계산을 통해 원하는 값을 발견하면 while 문을 벗어납니다. 이렇게 난스를 증가시켜가며 난이도에 맞는 해시값을 발견하는게 바로 __'채굴'__입니다. 참 쉽죠?\n\n## 테스트\n\n실제로 함수를 돌려보면 아래와 같은 결과를 만듭니다. 159회의 시도(nonce)를 통해 해시값을 발견하고 블록을 만들어냈군요!  \n\n```javascript\nconsole.log(mining('', new Date(), [{ adam: -10, eve: 10 }], 2));\n \n//  { previousHash: '',\n//    timestamp: 2018-06-25T03:25:01.985Z,\n//    transactions: [ { adam: -10, eve: 10 } ],\n//    nonce: 159,\n//    hash: '006a918403e96e3545c8dfa58d360a6e6dd284e8ca74c2a81228243b2e45a1c0' }\n```\n\n오늘의 코드는 [Github](https://github.com/joeunha/block-js/blob/master/v01.js)에서 확인하실 수 있습니다. 다음 시간에는 체인에 추가하는 과정을 구현해겠습니다.","slug":"block-chain-js-1","published":1,"updated":"2019-07-15T12:07:34.502Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9es0008dirv7k4y1zfp","content":"<p><em>자바스크립트로 블록체인을 구현해보자</em></p>\n<p><strong>*주의: 해당 글은 대략적인 구조를 설명함으로 실제 암호화폐의 구현과 다를 수 있습니다.</strong></p>\n<h2 id=\"구현\"><a href=\"#구현\" class=\"headerlink\" title=\"구현\"></a>구현</h2><p>오늘은 <a href=\"/programming/block-chain-js/\">지난 시간</a>에 설명한 기본 개념과 데이터 구조를 골자로 블록을 채굴하는 함수를 구현해보겠습니다. 노드(Node.js) 환경에서 구현하고 ES6 문법을 사용합니다. 암호화 알고리즘으로 SHA256을 사용하고 해당 함수를 가져오기 위해 <a href=\"https://www.npmjs.com/package/crypto-js\" target=\"_blank\" rel=\"noopener\">crypto-js</a>라는 패키지를 사용합니다. (설치 방법은 생략하겠습니다.) </p>\n<p>아래의 코드에 오늘 이야기할 모든 내용이 있습니다. 해쉬 값을 계산하는 <code>calculate_hash</code> 함수와 이를 사용하여 블록을 채굴하는 <code>mining</code> 함수입니다.   </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; SHA256 &#125;  = <span class=\"built_in\">require</span>(<span class=\"string\">'crypto-js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculate_hash</span>(<span class=\"params\">block</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123; previousHash, timestamp, transactions, nonce &#125; = block;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> SHA256(previousHash + timestamp + <span class=\"built_in\">JSON</span>.stringify(transactions) + nonce).toString();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mining</span>(<span class=\"params\">previousHash, timestamp, transactions, diff</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> block = &#123; previousHash, timestamp, transactions, <span class=\"attr\">nonce</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">  block.hash = calculate_hash(block);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">while</span> (block.hash.substring(<span class=\"number\">0</span>, diff) !== <span class=\"built_in\">Array</span>(diff + <span class=\"number\">1</span>).join(<span class=\"string\">'0'</span>)) &#123;</span><br><span class=\"line\">    block.nonce++;</span><br><span class=\"line\">    block.hash = calculate_hash(block);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"SHA256\"><a href=\"#SHA256\" class=\"headerlink\" title=\"SHA256\"></a>SHA256</h4><p>찬찬히 살펴보죠. 우선 해시함수인 <code>SHA256</code>을 가져왔습니다. 이 함수에게 문자열을 전달하면 16진수로 표현된 해시값을 반환합니다. <a href=\"https://passwordsgenerator.net/sha256-hash-generator/\" target=\"_blank\" rel=\"noopener\">웹 사이트</a>에서 테스트 해볼 수도 있습니다. 이렇게 만들어진 값은 유니크한 값으로 블록의 고유한(unique) 주소 값이 됩니다. 하지만 진짜 고유한 값이 되려면 전달하는 문자열이 고유해야합니다. 같은 문자열을 넣으면 같은 해시값을 반환하기 때문이죠.</p>\n<h4 id=\"calulate-hash\"><a href=\"#calulate-hash\" class=\"headerlink\" title=\"calulate_hash\"></a>calulate_hash</h4><p><code>calculate_hash</code> 함수를 살펴보면 어떻게 고유한 값을 만드는지 알 수 있습니다. 이전 블록의 해시값(<code>previousHash</code>)과 현재 블록이 생성되는 시간(<code>timestamp</code>), 거래내역(<code>transaction</code>) 그리고 난스(<code>nonce</code>)를 조합해서 고유한 값을 만들어냅니다. 거래내역은 배열의 형태이기 때문에 <code>JSON.stringify</code>를 이용해 문자열로 치환합니다. 해시함수가 반환하는 값도 문자열로 바꿔 반환하면 우리가 원하는 해시값이 됩니다.</p>\n<h4 id=\"mining\"><a href=\"#mining\" class=\"headerlink\" title=\"mining\"></a>mining</h4><p>채굴을 위해 사용되는 <code>mining</code> 함수는 이전 블록의 해시값, 시간, 거래내역, 난이도(<code>diff</code>)를 인자로 받습니다. 그리고 해당 값과 난스, 해시값을 합쳐 블록(<code>block</code>)을 만들어둡니다. 블록은 반복적인 해시값 계산을 통해 난이도를 통과하면 최종적으로 반환됩니다.</p>\n<p>while 문의 조건을 살펴보면 해시값의 앞자리 수가 난이도 만큼의 0을 갖는지 확인합니다. 난이도가 2라면 해시값은 ‘00A123…’과 같은 형태가 되어야 한다는 뜻이죠. 속을 살펴보면 난스를 하나씩 증가시켜 반복적으로 해시값을 계산하는 것을 확인할 수 있습니다. 이렇게 반복 계산을 통해 원하는 값을 발견하면 while 문을 벗어납니다. 이렇게 난스를 증가시켜가며 난이도에 맞는 해시값을 발견하는게 바로 <strong>‘채굴’</strong>입니다. 참 쉽죠?</p>\n<h2 id=\"테스트\"><a href=\"#테스트\" class=\"headerlink\" title=\"테스트\"></a>테스트</h2><p>실제로 함수를 돌려보면 아래와 같은 결과를 만듭니다. 159회의 시도(nonce)를 통해 해시값을 발견하고 블록을 만들어냈군요!  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(mining(<span class=\"string\">''</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(), [&#123; <span class=\"attr\">adam</span>: <span class=\"number\">-10</span>, <span class=\"attr\">eve</span>: <span class=\"number\">10</span> &#125;], <span class=\"number\">2</span>));</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//  &#123; previousHash: '',</span></span><br><span class=\"line\"><span class=\"comment\">//    timestamp: 2018-06-25T03:25:01.985Z,</span></span><br><span class=\"line\"><span class=\"comment\">//    transactions: [ &#123; adam: -10, eve: 10 &#125; ],</span></span><br><span class=\"line\"><span class=\"comment\">//    nonce: 159,</span></span><br><span class=\"line\"><span class=\"comment\">//    hash: '006a918403e96e3545c8dfa58d360a6e6dd284e8ca74c2a81228243b2e45a1c0' &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>오늘의 코드는 <a href=\"https://github.com/joeunha/block-js/blob/master/v01.js\" target=\"_blank\" rel=\"noopener\">Github</a>에서 확인하실 수 있습니다. 다음 시간에는 체인에 추가하는 과정을 구현해겠습니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>자바스크립트로 블록체인을 구현해보자</em></p>\n<p><strong>*주의: 해당 글은 대략적인 구조를 설명함으로 실제 암호화폐의 구현과 다를 수 있습니다.</strong></p>\n<h2 id=\"구현\"><a href=\"#구현\" class=\"headerlink\" title=\"구현\"></a>구현</h2><p>오늘은 <a href=\"/programming/block-chain-js/\">지난 시간</a>에 설명한 기본 개념과 데이터 구조를 골자로 블록을 채굴하는 함수를 구현해보겠습니다. 노드(Node.js) 환경에서 구현하고 ES6 문법을 사용합니다. 암호화 알고리즘으로 SHA256을 사용하고 해당 함수를 가져오기 위해 <a href=\"https://www.npmjs.com/package/crypto-js\" target=\"_blank\" rel=\"noopener\">crypto-js</a>라는 패키지를 사용합니다. (설치 방법은 생략하겠습니다.) </p>\n<p>아래의 코드에 오늘 이야기할 모든 내용이 있습니다. 해쉬 값을 계산하는 <code>calculate_hash</code> 함수와 이를 사용하여 블록을 채굴하는 <code>mining</code> 함수입니다.   </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; SHA256 &#125;  = <span class=\"built_in\">require</span>(<span class=\"string\">'crypto-js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">calculate_hash</span>(<span class=\"params\">block</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123; previousHash, timestamp, transactions, nonce &#125; = block;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> SHA256(previousHash + timestamp + <span class=\"built_in\">JSON</span>.stringify(transactions) + nonce).toString();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mining</span>(<span class=\"params\">previousHash, timestamp, transactions, diff</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> block = &#123; previousHash, timestamp, transactions, <span class=\"attr\">nonce</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">  block.hash = calculate_hash(block);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">while</span> (block.hash.substring(<span class=\"number\">0</span>, diff) !== <span class=\"built_in\">Array</span>(diff + <span class=\"number\">1</span>).join(<span class=\"string\">'0'</span>)) &#123;</span><br><span class=\"line\">    block.nonce++;</span><br><span class=\"line\">    block.hash = calculate_hash(block);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"SHA256\"><a href=\"#SHA256\" class=\"headerlink\" title=\"SHA256\"></a>SHA256</h4><p>찬찬히 살펴보죠. 우선 해시함수인 <code>SHA256</code>을 가져왔습니다. 이 함수에게 문자열을 전달하면 16진수로 표현된 해시값을 반환합니다. <a href=\"https://passwordsgenerator.net/sha256-hash-generator/\" target=\"_blank\" rel=\"noopener\">웹 사이트</a>에서 테스트 해볼 수도 있습니다. 이렇게 만들어진 값은 유니크한 값으로 블록의 고유한(unique) 주소 값이 됩니다. 하지만 진짜 고유한 값이 되려면 전달하는 문자열이 고유해야합니다. 같은 문자열을 넣으면 같은 해시값을 반환하기 때문이죠.</p>\n<h4 id=\"calulate-hash\"><a href=\"#calulate-hash\" class=\"headerlink\" title=\"calulate_hash\"></a>calulate_hash</h4><p><code>calculate_hash</code> 함수를 살펴보면 어떻게 고유한 값을 만드는지 알 수 있습니다. 이전 블록의 해시값(<code>previousHash</code>)과 현재 블록이 생성되는 시간(<code>timestamp</code>), 거래내역(<code>transaction</code>) 그리고 난스(<code>nonce</code>)를 조합해서 고유한 값을 만들어냅니다. 거래내역은 배열의 형태이기 때문에 <code>JSON.stringify</code>를 이용해 문자열로 치환합니다. 해시함수가 반환하는 값도 문자열로 바꿔 반환하면 우리가 원하는 해시값이 됩니다.</p>\n<h4 id=\"mining\"><a href=\"#mining\" class=\"headerlink\" title=\"mining\"></a>mining</h4><p>채굴을 위해 사용되는 <code>mining</code> 함수는 이전 블록의 해시값, 시간, 거래내역, 난이도(<code>diff</code>)를 인자로 받습니다. 그리고 해당 값과 난스, 해시값을 합쳐 블록(<code>block</code>)을 만들어둡니다. 블록은 반복적인 해시값 계산을 통해 난이도를 통과하면 최종적으로 반환됩니다.</p>\n<p>while 문의 조건을 살펴보면 해시값의 앞자리 수가 난이도 만큼의 0을 갖는지 확인합니다. 난이도가 2라면 해시값은 ‘00A123…’과 같은 형태가 되어야 한다는 뜻이죠. 속을 살펴보면 난스를 하나씩 증가시켜 반복적으로 해시값을 계산하는 것을 확인할 수 있습니다. 이렇게 반복 계산을 통해 원하는 값을 발견하면 while 문을 벗어납니다. 이렇게 난스를 증가시켜가며 난이도에 맞는 해시값을 발견하는게 바로 <strong>‘채굴’</strong>입니다. 참 쉽죠?</p>\n<h2 id=\"테스트\"><a href=\"#테스트\" class=\"headerlink\" title=\"테스트\"></a>테스트</h2><p>실제로 함수를 돌려보면 아래와 같은 결과를 만듭니다. 159회의 시도(nonce)를 통해 해시값을 발견하고 블록을 만들어냈군요!  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(mining(<span class=\"string\">''</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(), [&#123; <span class=\"attr\">adam</span>: <span class=\"number\">-10</span>, <span class=\"attr\">eve</span>: <span class=\"number\">10</span> &#125;], <span class=\"number\">2</span>));</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//  &#123; previousHash: '',</span></span><br><span class=\"line\"><span class=\"comment\">//    timestamp: 2018-06-25T03:25:01.985Z,</span></span><br><span class=\"line\"><span class=\"comment\">//    transactions: [ &#123; adam: -10, eve: 10 &#125; ],</span></span><br><span class=\"line\"><span class=\"comment\">//    nonce: 159,</span></span><br><span class=\"line\"><span class=\"comment\">//    hash: '006a918403e96e3545c8dfa58d360a6e6dd284e8ca74c2a81228243b2e45a1c0' &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>오늘의 코드는 <a href=\"https://github.com/joeunha/block-js/blob/master/v01.js\" target=\"_blank\" rel=\"noopener\">Github</a>에서 확인하실 수 있습니다. 다음 시간에는 체인에 추가하는 과정을 구현해겠습니다.</p>\n"},{"title":"자바스크립트로 블록체인 - add_block","date":"2018-06-25T15:00:00.000Z","description":"자바스크립트로 블록체인을 구현해보자","_content":"_자바스크립트로 블록체인을 구현해보자_\n\n__\\*주의: 해당 글은 대략적인 구조를 설명함으로 실제 암호화폐의 구현과 다를 수 있습니다.__\n\n## 선언\n\n[지난 시간](/programming/block-chain-js-1/)에 해시값을 구하는 함수와 블록을 채굴하는 함수를 구현했습니다. 오늘은 블록을 체인에 추가하는 함수 `add_block`를 구현해보겠습니다. 더불어 블록의 유효성을 검사하는 함수(`is_block_valid`)와 보상을 주는 함수(`reward_to`)도 만들어볼까 합니다.\n\n우선 블록체인 환경에서 공통으로 사용할 변수들을 선언합니다. 다양한 방법이 가능하지만 저는 노드(Node.js) 환경의 전역 변수인 `global`에 몇가지 변수들을 아래와 같이 선언하기로 했습니다.\n\n```javascript\nlet G = typeof window == 'object' ? window : global;\n\nG.CHAIN = {};\nG.DIFF = 2;\nG.HEAD = '';\nG.USERS = {\n  '0001': { name: 'A', balance: 70 },\n  '0002': { name: 'B', balance: 50 },\n  '0003': { name: 'C', balance: 110 }\n};\n```\n\n#### G\n굳이 전역 변수임을 명시하지 않고도 전역에 붙여서 사용할 수 있지만 혼란을 방지하기 위해 `G`라는 키워드를 사용하기로 했습니다. 그리고 여기에 붙는 값을 대문자로 표기합니다. `DIFF`는 난이도입니다. `HEAD`는 가장 최근에 만들어진 블록의 해시값입니다. `USERS`는 블록체인에 참여한 노드(user)들의 정보를 담고 있습니다. 키 값은 주소에 해당하는 값이고 각각의 노드는 이름(`name`)과 잔액(`balance`) 정보를 가지고 있습니다.   \n\n`CHAIN`이 블록을 담을 객체입니다. 배열로 선언하지 않은 이유는 블록 자체가 순서대로 정렬되지 않아도 찾을 수 있다는 걸 보다 쉽게 표현하기 위함입니다. 배열로 생성될 때마다 push 메서드로 넣어주면 편하지만 해시값으로 이전 블록을 추적하는 재미(?)가 덜합니다.\n\n__이때 `G`는 해당 블록체인을 만들어가는 모든 노드가 공유하고 있다고 생각해주세요.__\n\n\n## 구현\n\n앞서 선언한 전역 변수(`G`)를 사용해서 `add_block` 함수를 아래와 같이 구현할 수 있습니다. \n\n```javascript\nfunction is_block_valid(block) {\n  if (block.hash.substring(0, G.DIFF) !== Array(G.DIFF + 1).join('0')) return false;\n  return calculate_hash(block) === block.hash;\n}\n\nfunction add_block(block) {\n  if (!is_block_valid(block)) return false;\n  G.CHAIN[block.hash] = block;\n  G.HEAD = block.hash;\n  return true;\n}\n\nfunction reward_to(address) {\n  return function(is_success) {\n    if (is_success) {\n     G.USERS[address].balance += G.DIFF * 10;\n     G.DIFF++;\n    }\n  }\n}\n```\n\n#### is_block_valid\n생성된 블록이 유효한지 검사하기 위해서는 블록이 가진 해시값(hash)이 제대로 계산된 것인지 확인해야 합니다. 실제로 블록체인에서는 이 과정을 다른 노드들이 수행합니다. 채굴에 성공했다고 주장하는 A라는 노드가 실제로 채굴에 성공한 것이 맞는지 다른 노드(B,C,D...)가 확인하는 절차인 것이죠. \n\n이를 위해, \n1. 발견한 해시값이 난이도(`G.DIFF`)에 부합하는지\n2. 발견한 난스(nonce)가 제대로된 해시값을 만들어내는지 \n\n확인합니다.      \n\n#### add_block\n유효성 검사를 통과한다면 블록을 체인에 추가합니다. 이때 해당 블록의 해시값을 키로 줍니다. 그것만이 유니크한 값이기 때문이죠. 그리고 `G.HEAD`를 갱신합니다. 이제 가장 최신의 노드는 현재 생성된 노드입니다. 블록 추가 성공 여부(true/false)를 반환합니다.\n\n#### reward_to\n주소값을 인자로 받고 블록 추가 성공 여부(`is_success`)를 확인한 뒤 보상을 주고 난이도를 조정합니다. 이때 함수가 함수를 반환하는 것을 확인할 수 있는데, [처음](/programming/block-chain-js/)에 예고드린 것처럼 제 방식으로 풀어내기 위함입니다. [`go` 함수](/programming/functional-js-study/#5-go)를 사용해서 보상 받을 노드를 설정하는 방식을 써볼까 합니다.\n\n난이도를 조정하는 부분은 실제 블록체인에서는 훨씬 고상하고 어려운 방법을 취합니다. 비트코인의 경우 채굴에 성공하기까지의 시간을 계산해서 너무 빨랐으면 난이도를 올리고 너무 느렸으면 난이도를 낮춘다고 합니다. 우선 저는 단순하게 블록이 추가될 때마다 난이도를 올리겠습니다.\n\n\n## 테스트\n\n함수를 합성해서 즉시 실행하는 `go` 함수와 조합하여 아래와 같이 테스트할 수 있습니다. 성공적으로 체인에 블록을 추가하고 보상도 이루어졌죠.\n\n```javascript\nconst go = (seed, ...fns) => fns.reduce((res, f) => f(res), seed);\nconst MY_ADDRESS = '0001';\n\ngo(mining(G.HEAD, new Date(), [{ A: -10, B: 10 }], G.DIFF),\n  add_block,\n  reward_to(MY_ADDRESS),\n  () => console.log('Block Chain: ', G.CHAIN),\n  () => console.log(`${MY_ADDRESS}'s Balance:`, G.USERS[MY_ADDRESS].balance));\n\n// Block Chain:  { '0047ba9d3380fe143b0eeb8b1216c99ebd69f7350732b81167cfd06c8d2356a7': \n//    { previousHash: '',\n//      timestamp: 2018-06-26T10:08:35.977Z,\n//      transactions: [ [Object] ],\n//      nonce: 138,\n//      hash: '0047ba9d3380fe143b0eeb8b1216c99ebd69f7350732b81167cfd06c8d2356a7' } }\n// 0001's Balance: 90\n```\n\n오늘의 코드는 [Github](https://github.com/joeunha/block-js/blob/master/v02.js)에서 확인하실 수 있습니다. 다음 시간에는 보다 많은 블록을 생성해보고 거래(transaction)를 관리하는 함수를 만들어 보겠습니다.","source":"_posts/block-chain-js-2.md","raw":"---\ntitle: '자바스크립트로 블록체인 - add_block'\ncategories:\n  - programming\ntags:\n  - javascript\n  - 자바스크립트\n  - blockchain\n  - 블록체인\ndate: 2018-06-26 00:00:00\ndescription: 자바스크립트로 블록체인을 구현해보자\n---\n_자바스크립트로 블록체인을 구현해보자_\n\n__\\*주의: 해당 글은 대략적인 구조를 설명함으로 실제 암호화폐의 구현과 다를 수 있습니다.__\n\n## 선언\n\n[지난 시간](/programming/block-chain-js-1/)에 해시값을 구하는 함수와 블록을 채굴하는 함수를 구현했습니다. 오늘은 블록을 체인에 추가하는 함수 `add_block`를 구현해보겠습니다. 더불어 블록의 유효성을 검사하는 함수(`is_block_valid`)와 보상을 주는 함수(`reward_to`)도 만들어볼까 합니다.\n\n우선 블록체인 환경에서 공통으로 사용할 변수들을 선언합니다. 다양한 방법이 가능하지만 저는 노드(Node.js) 환경의 전역 변수인 `global`에 몇가지 변수들을 아래와 같이 선언하기로 했습니다.\n\n```javascript\nlet G = typeof window == 'object' ? window : global;\n\nG.CHAIN = {};\nG.DIFF = 2;\nG.HEAD = '';\nG.USERS = {\n  '0001': { name: 'A', balance: 70 },\n  '0002': { name: 'B', balance: 50 },\n  '0003': { name: 'C', balance: 110 }\n};\n```\n\n#### G\n굳이 전역 변수임을 명시하지 않고도 전역에 붙여서 사용할 수 있지만 혼란을 방지하기 위해 `G`라는 키워드를 사용하기로 했습니다. 그리고 여기에 붙는 값을 대문자로 표기합니다. `DIFF`는 난이도입니다. `HEAD`는 가장 최근에 만들어진 블록의 해시값입니다. `USERS`는 블록체인에 참여한 노드(user)들의 정보를 담고 있습니다. 키 값은 주소에 해당하는 값이고 각각의 노드는 이름(`name`)과 잔액(`balance`) 정보를 가지고 있습니다.   \n\n`CHAIN`이 블록을 담을 객체입니다. 배열로 선언하지 않은 이유는 블록 자체가 순서대로 정렬되지 않아도 찾을 수 있다는 걸 보다 쉽게 표현하기 위함입니다. 배열로 생성될 때마다 push 메서드로 넣어주면 편하지만 해시값으로 이전 블록을 추적하는 재미(?)가 덜합니다.\n\n__이때 `G`는 해당 블록체인을 만들어가는 모든 노드가 공유하고 있다고 생각해주세요.__\n\n\n## 구현\n\n앞서 선언한 전역 변수(`G`)를 사용해서 `add_block` 함수를 아래와 같이 구현할 수 있습니다. \n\n```javascript\nfunction is_block_valid(block) {\n  if (block.hash.substring(0, G.DIFF) !== Array(G.DIFF + 1).join('0')) return false;\n  return calculate_hash(block) === block.hash;\n}\n\nfunction add_block(block) {\n  if (!is_block_valid(block)) return false;\n  G.CHAIN[block.hash] = block;\n  G.HEAD = block.hash;\n  return true;\n}\n\nfunction reward_to(address) {\n  return function(is_success) {\n    if (is_success) {\n     G.USERS[address].balance += G.DIFF * 10;\n     G.DIFF++;\n    }\n  }\n}\n```\n\n#### is_block_valid\n생성된 블록이 유효한지 검사하기 위해서는 블록이 가진 해시값(hash)이 제대로 계산된 것인지 확인해야 합니다. 실제로 블록체인에서는 이 과정을 다른 노드들이 수행합니다. 채굴에 성공했다고 주장하는 A라는 노드가 실제로 채굴에 성공한 것이 맞는지 다른 노드(B,C,D...)가 확인하는 절차인 것이죠. \n\n이를 위해, \n1. 발견한 해시값이 난이도(`G.DIFF`)에 부합하는지\n2. 발견한 난스(nonce)가 제대로된 해시값을 만들어내는지 \n\n확인합니다.      \n\n#### add_block\n유효성 검사를 통과한다면 블록을 체인에 추가합니다. 이때 해당 블록의 해시값을 키로 줍니다. 그것만이 유니크한 값이기 때문이죠. 그리고 `G.HEAD`를 갱신합니다. 이제 가장 최신의 노드는 현재 생성된 노드입니다. 블록 추가 성공 여부(true/false)를 반환합니다.\n\n#### reward_to\n주소값을 인자로 받고 블록 추가 성공 여부(`is_success`)를 확인한 뒤 보상을 주고 난이도를 조정합니다. 이때 함수가 함수를 반환하는 것을 확인할 수 있는데, [처음](/programming/block-chain-js/)에 예고드린 것처럼 제 방식으로 풀어내기 위함입니다. [`go` 함수](/programming/functional-js-study/#5-go)를 사용해서 보상 받을 노드를 설정하는 방식을 써볼까 합니다.\n\n난이도를 조정하는 부분은 실제 블록체인에서는 훨씬 고상하고 어려운 방법을 취합니다. 비트코인의 경우 채굴에 성공하기까지의 시간을 계산해서 너무 빨랐으면 난이도를 올리고 너무 느렸으면 난이도를 낮춘다고 합니다. 우선 저는 단순하게 블록이 추가될 때마다 난이도를 올리겠습니다.\n\n\n## 테스트\n\n함수를 합성해서 즉시 실행하는 `go` 함수와 조합하여 아래와 같이 테스트할 수 있습니다. 성공적으로 체인에 블록을 추가하고 보상도 이루어졌죠.\n\n```javascript\nconst go = (seed, ...fns) => fns.reduce((res, f) => f(res), seed);\nconst MY_ADDRESS = '0001';\n\ngo(mining(G.HEAD, new Date(), [{ A: -10, B: 10 }], G.DIFF),\n  add_block,\n  reward_to(MY_ADDRESS),\n  () => console.log('Block Chain: ', G.CHAIN),\n  () => console.log(`${MY_ADDRESS}'s Balance:`, G.USERS[MY_ADDRESS].balance));\n\n// Block Chain:  { '0047ba9d3380fe143b0eeb8b1216c99ebd69f7350732b81167cfd06c8d2356a7': \n//    { previousHash: '',\n//      timestamp: 2018-06-26T10:08:35.977Z,\n//      transactions: [ [Object] ],\n//      nonce: 138,\n//      hash: '0047ba9d3380fe143b0eeb8b1216c99ebd69f7350732b81167cfd06c8d2356a7' } }\n// 0001's Balance: 90\n```\n\n오늘의 코드는 [Github](https://github.com/joeunha/block-js/blob/master/v02.js)에서 확인하실 수 있습니다. 다음 시간에는 보다 많은 블록을 생성해보고 거래(transaction)를 관리하는 함수를 만들어 보겠습니다.","slug":"block-chain-js-2","published":1,"updated":"2019-07-15T12:07:33.382Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9et000adirvq9qs988p","content":"<p><em>자바스크립트로 블록체인을 구현해보자</em></p>\n<p><strong>*주의: 해당 글은 대략적인 구조를 설명함으로 실제 암호화폐의 구현과 다를 수 있습니다.</strong></p>\n<h2 id=\"선언\"><a href=\"#선언\" class=\"headerlink\" title=\"선언\"></a>선언</h2><p><a href=\"/programming/block-chain-js-1/\">지난 시간</a>에 해시값을 구하는 함수와 블록을 채굴하는 함수를 구현했습니다. 오늘은 블록을 체인에 추가하는 함수 <code>add_block</code>를 구현해보겠습니다. 더불어 블록의 유효성을 검사하는 함수(<code>is_block_valid</code>)와 보상을 주는 함수(<code>reward_to</code>)도 만들어볼까 합니다.</p>\n<p>우선 블록체인 환경에서 공통으로 사용할 변수들을 선언합니다. 다양한 방법이 가능하지만 저는 노드(Node.js) 환경의 전역 변수인 <code>global</code>에 몇가지 변수들을 아래와 같이 선언하기로 했습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> G = <span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> == <span class=\"string\">'object'</span> ? <span class=\"built_in\">window</span> : global;</span><br><span class=\"line\"></span><br><span class=\"line\">G.CHAIN = &#123;&#125;;</span><br><span class=\"line\">G.DIFF = <span class=\"number\">2</span>;</span><br><span class=\"line\">G.HEAD = <span class=\"string\">''</span>;</span><br><span class=\"line\">G.USERS = &#123;</span><br><span class=\"line\">  <span class=\"string\">'0001'</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'A'</span>, <span class=\"attr\">balance</span>: <span class=\"number\">70</span> &#125;,</span><br><span class=\"line\">  <span class=\"string\">'0002'</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'B'</span>, <span class=\"attr\">balance</span>: <span class=\"number\">50</span> &#125;,</span><br><span class=\"line\">  <span class=\"string\">'0003'</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'C'</span>, <span class=\"attr\">balance</span>: <span class=\"number\">110</span> &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"G\"><a href=\"#G\" class=\"headerlink\" title=\"G\"></a>G</h4><p>굳이 전역 변수임을 명시하지 않고도 전역에 붙여서 사용할 수 있지만 혼란을 방지하기 위해 <code>G</code>라는 키워드를 사용하기로 했습니다. 그리고 여기에 붙는 값을 대문자로 표기합니다. <code>DIFF</code>는 난이도입니다. <code>HEAD</code>는 가장 최근에 만들어진 블록의 해시값입니다. <code>USERS</code>는 블록체인에 참여한 노드(user)들의 정보를 담고 있습니다. 키 값은 주소에 해당하는 값이고 각각의 노드는 이름(<code>name</code>)과 잔액(<code>balance</code>) 정보를 가지고 있습니다.   </p>\n<p><code>CHAIN</code>이 블록을 담을 객체입니다. 배열로 선언하지 않은 이유는 블록 자체가 순서대로 정렬되지 않아도 찾을 수 있다는 걸 보다 쉽게 표현하기 위함입니다. 배열로 생성될 때마다 push 메서드로 넣어주면 편하지만 해시값으로 이전 블록을 추적하는 재미(?)가 덜합니다.</p>\n<p><strong>이때 <code>G</code>는 해당 블록체인을 만들어가는 모든 노드가 공유하고 있다고 생각해주세요.</strong></p>\n<h2 id=\"구현\"><a href=\"#구현\" class=\"headerlink\" title=\"구현\"></a>구현</h2><p>앞서 선언한 전역 변수(<code>G</code>)를 사용해서 <code>add_block</code> 함수를 아래와 같이 구현할 수 있습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">is_block_valid</span>(<span class=\"params\">block</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (block.hash.substring(<span class=\"number\">0</span>, G.DIFF) !== <span class=\"built_in\">Array</span>(G.DIFF + <span class=\"number\">1</span>).join(<span class=\"string\">'0'</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> calculate_hash(block) === block.hash;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add_block</span>(<span class=\"params\">block</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!is_block_valid(block)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  G.CHAIN[block.hash] = block;</span><br><span class=\"line\">  G.HEAD = block.hash;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reward_to</span>(<span class=\"params\">address</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">is_success</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_success) &#123;</span><br><span class=\"line\">     G.USERS[address].balance += G.DIFF * <span class=\"number\">10</span>;</span><br><span class=\"line\">     G.DIFF++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"is-block-valid\"><a href=\"#is-block-valid\" class=\"headerlink\" title=\"is_block_valid\"></a>is_block_valid</h4><p>생성된 블록이 유효한지 검사하기 위해서는 블록이 가진 해시값(hash)이 제대로 계산된 것인지 확인해야 합니다. 실제로 블록체인에서는 이 과정을 다른 노드들이 수행합니다. 채굴에 성공했다고 주장하는 A라는 노드가 실제로 채굴에 성공한 것이 맞는지 다른 노드(B,C,D…)가 확인하는 절차인 것이죠. </p>\n<p>이를 위해, </p>\n<ol>\n<li>발견한 해시값이 난이도(<code>G.DIFF</code>)에 부합하는지</li>\n<li>발견한 난스(nonce)가 제대로된 해시값을 만들어내는지 </li>\n</ol>\n<p>확인합니다.      </p>\n<h4 id=\"add-block\"><a href=\"#add-block\" class=\"headerlink\" title=\"add_block\"></a>add_block</h4><p>유효성 검사를 통과한다면 블록을 체인에 추가합니다. 이때 해당 블록의 해시값을 키로 줍니다. 그것만이 유니크한 값이기 때문이죠. 그리고 <code>G.HEAD</code>를 갱신합니다. 이제 가장 최신의 노드는 현재 생성된 노드입니다. 블록 추가 성공 여부(true/false)를 반환합니다.</p>\n<h4 id=\"reward-to\"><a href=\"#reward-to\" class=\"headerlink\" title=\"reward_to\"></a>reward_to</h4><p>주소값을 인자로 받고 블록 추가 성공 여부(<code>is_success</code>)를 확인한 뒤 보상을 주고 난이도를 조정합니다. 이때 함수가 함수를 반환하는 것을 확인할 수 있는데, <a href=\"/programming/block-chain-js/\">처음</a>에 예고드린 것처럼 제 방식으로 풀어내기 위함입니다. <a href=\"/programming/functional-js-study/#5-go\"><code>go</code> 함수</a>를 사용해서 보상 받을 노드를 설정하는 방식을 써볼까 합니다.</p>\n<p>난이도를 조정하는 부분은 실제 블록체인에서는 훨씬 고상하고 어려운 방법을 취합니다. 비트코인의 경우 채굴에 성공하기까지의 시간을 계산해서 너무 빨랐으면 난이도를 올리고 너무 느렸으면 난이도를 낮춘다고 합니다. 우선 저는 단순하게 블록이 추가될 때마다 난이도를 올리겠습니다.</p>\n<h2 id=\"테스트\"><a href=\"#테스트\" class=\"headerlink\" title=\"테스트\"></a>테스트</h2><p>함수를 합성해서 즉시 실행하는 <code>go</code> 함수와 조합하여 아래와 같이 테스트할 수 있습니다. 성공적으로 체인에 블록을 추가하고 보상도 이루어졌죠.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> go = <span class=\"function\">(<span class=\"params\">seed, ...fns</span>) =&gt;</span> fns.reduce(<span class=\"function\">(<span class=\"params\">res, f</span>) =&gt;</span> f(res), seed);</span><br><span class=\"line\"><span class=\"keyword\">const</span> MY_ADDRESS = <span class=\"string\">'0001'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">go(mining(G.HEAD, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(), [&#123; <span class=\"attr\">A</span>: <span class=\"number\">-10</span>, <span class=\"attr\">B</span>: <span class=\"number\">10</span> &#125;], G.DIFF),</span><br><span class=\"line\">  add_block,</span><br><span class=\"line\">  reward_to(MY_ADDRESS),</span><br><span class=\"line\">  () =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'Block Chain: '</span>, G.CHAIN),</span><br><span class=\"line\">  () =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;MY_ADDRESS&#125;</span>'s Balance:`</span>, G.USERS[MY_ADDRESS].balance));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Block Chain:  &#123; '0047ba9d3380fe143b0eeb8b1216c99ebd69f7350732b81167cfd06c8d2356a7': </span></span><br><span class=\"line\"><span class=\"comment\">//    &#123; previousHash: '',</span></span><br><span class=\"line\"><span class=\"comment\">//      timestamp: 2018-06-26T10:08:35.977Z,</span></span><br><span class=\"line\"><span class=\"comment\">//      transactions: [ [Object] ],</span></span><br><span class=\"line\"><span class=\"comment\">//      nonce: 138,</span></span><br><span class=\"line\"><span class=\"comment\">//      hash: '0047ba9d3380fe143b0eeb8b1216c99ebd69f7350732b81167cfd06c8d2356a7' &#125; &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 0001's Balance: 90</span></span><br></pre></td></tr></table></figure>\n\n<p>오늘의 코드는 <a href=\"https://github.com/joeunha/block-js/blob/master/v02.js\" target=\"_blank\" rel=\"noopener\">Github</a>에서 확인하실 수 있습니다. 다음 시간에는 보다 많은 블록을 생성해보고 거래(transaction)를 관리하는 함수를 만들어 보겠습니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>자바스크립트로 블록체인을 구현해보자</em></p>\n<p><strong>*주의: 해당 글은 대략적인 구조를 설명함으로 실제 암호화폐의 구현과 다를 수 있습니다.</strong></p>\n<h2 id=\"선언\"><a href=\"#선언\" class=\"headerlink\" title=\"선언\"></a>선언</h2><p><a href=\"/programming/block-chain-js-1/\">지난 시간</a>에 해시값을 구하는 함수와 블록을 채굴하는 함수를 구현했습니다. 오늘은 블록을 체인에 추가하는 함수 <code>add_block</code>를 구현해보겠습니다. 더불어 블록의 유효성을 검사하는 함수(<code>is_block_valid</code>)와 보상을 주는 함수(<code>reward_to</code>)도 만들어볼까 합니다.</p>\n<p>우선 블록체인 환경에서 공통으로 사용할 변수들을 선언합니다. 다양한 방법이 가능하지만 저는 노드(Node.js) 환경의 전역 변수인 <code>global</code>에 몇가지 변수들을 아래와 같이 선언하기로 했습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> G = <span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> == <span class=\"string\">'object'</span> ? <span class=\"built_in\">window</span> : global;</span><br><span class=\"line\"></span><br><span class=\"line\">G.CHAIN = &#123;&#125;;</span><br><span class=\"line\">G.DIFF = <span class=\"number\">2</span>;</span><br><span class=\"line\">G.HEAD = <span class=\"string\">''</span>;</span><br><span class=\"line\">G.USERS = &#123;</span><br><span class=\"line\">  <span class=\"string\">'0001'</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'A'</span>, <span class=\"attr\">balance</span>: <span class=\"number\">70</span> &#125;,</span><br><span class=\"line\">  <span class=\"string\">'0002'</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'B'</span>, <span class=\"attr\">balance</span>: <span class=\"number\">50</span> &#125;,</span><br><span class=\"line\">  <span class=\"string\">'0003'</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'C'</span>, <span class=\"attr\">balance</span>: <span class=\"number\">110</span> &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"G\"><a href=\"#G\" class=\"headerlink\" title=\"G\"></a>G</h4><p>굳이 전역 변수임을 명시하지 않고도 전역에 붙여서 사용할 수 있지만 혼란을 방지하기 위해 <code>G</code>라는 키워드를 사용하기로 했습니다. 그리고 여기에 붙는 값을 대문자로 표기합니다. <code>DIFF</code>는 난이도입니다. <code>HEAD</code>는 가장 최근에 만들어진 블록의 해시값입니다. <code>USERS</code>는 블록체인에 참여한 노드(user)들의 정보를 담고 있습니다. 키 값은 주소에 해당하는 값이고 각각의 노드는 이름(<code>name</code>)과 잔액(<code>balance</code>) 정보를 가지고 있습니다.   </p>\n<p><code>CHAIN</code>이 블록을 담을 객체입니다. 배열로 선언하지 않은 이유는 블록 자체가 순서대로 정렬되지 않아도 찾을 수 있다는 걸 보다 쉽게 표현하기 위함입니다. 배열로 생성될 때마다 push 메서드로 넣어주면 편하지만 해시값으로 이전 블록을 추적하는 재미(?)가 덜합니다.</p>\n<p><strong>이때 <code>G</code>는 해당 블록체인을 만들어가는 모든 노드가 공유하고 있다고 생각해주세요.</strong></p>\n<h2 id=\"구현\"><a href=\"#구현\" class=\"headerlink\" title=\"구현\"></a>구현</h2><p>앞서 선언한 전역 변수(<code>G</code>)를 사용해서 <code>add_block</code> 함수를 아래와 같이 구현할 수 있습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">is_block_valid</span>(<span class=\"params\">block</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (block.hash.substring(<span class=\"number\">0</span>, G.DIFF) !== <span class=\"built_in\">Array</span>(G.DIFF + <span class=\"number\">1</span>).join(<span class=\"string\">'0'</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> calculate_hash(block) === block.hash;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add_block</span>(<span class=\"params\">block</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!is_block_valid(block)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  G.CHAIN[block.hash] = block;</span><br><span class=\"line\">  G.HEAD = block.hash;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reward_to</span>(<span class=\"params\">address</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">is_success</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_success) &#123;</span><br><span class=\"line\">     G.USERS[address].balance += G.DIFF * <span class=\"number\">10</span>;</span><br><span class=\"line\">     G.DIFF++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"is-block-valid\"><a href=\"#is-block-valid\" class=\"headerlink\" title=\"is_block_valid\"></a>is_block_valid</h4><p>생성된 블록이 유효한지 검사하기 위해서는 블록이 가진 해시값(hash)이 제대로 계산된 것인지 확인해야 합니다. 실제로 블록체인에서는 이 과정을 다른 노드들이 수행합니다. 채굴에 성공했다고 주장하는 A라는 노드가 실제로 채굴에 성공한 것이 맞는지 다른 노드(B,C,D…)가 확인하는 절차인 것이죠. </p>\n<p>이를 위해, </p>\n<ol>\n<li>발견한 해시값이 난이도(<code>G.DIFF</code>)에 부합하는지</li>\n<li>발견한 난스(nonce)가 제대로된 해시값을 만들어내는지 </li>\n</ol>\n<p>확인합니다.      </p>\n<h4 id=\"add-block\"><a href=\"#add-block\" class=\"headerlink\" title=\"add_block\"></a>add_block</h4><p>유효성 검사를 통과한다면 블록을 체인에 추가합니다. 이때 해당 블록의 해시값을 키로 줍니다. 그것만이 유니크한 값이기 때문이죠. 그리고 <code>G.HEAD</code>를 갱신합니다. 이제 가장 최신의 노드는 현재 생성된 노드입니다. 블록 추가 성공 여부(true/false)를 반환합니다.</p>\n<h4 id=\"reward-to\"><a href=\"#reward-to\" class=\"headerlink\" title=\"reward_to\"></a>reward_to</h4><p>주소값을 인자로 받고 블록 추가 성공 여부(<code>is_success</code>)를 확인한 뒤 보상을 주고 난이도를 조정합니다. 이때 함수가 함수를 반환하는 것을 확인할 수 있는데, <a href=\"/programming/block-chain-js/\">처음</a>에 예고드린 것처럼 제 방식으로 풀어내기 위함입니다. <a href=\"/programming/functional-js-study/#5-go\"><code>go</code> 함수</a>를 사용해서 보상 받을 노드를 설정하는 방식을 써볼까 합니다.</p>\n<p>난이도를 조정하는 부분은 실제 블록체인에서는 훨씬 고상하고 어려운 방법을 취합니다. 비트코인의 경우 채굴에 성공하기까지의 시간을 계산해서 너무 빨랐으면 난이도를 올리고 너무 느렸으면 난이도를 낮춘다고 합니다. 우선 저는 단순하게 블록이 추가될 때마다 난이도를 올리겠습니다.</p>\n<h2 id=\"테스트\"><a href=\"#테스트\" class=\"headerlink\" title=\"테스트\"></a>테스트</h2><p>함수를 합성해서 즉시 실행하는 <code>go</code> 함수와 조합하여 아래와 같이 테스트할 수 있습니다. 성공적으로 체인에 블록을 추가하고 보상도 이루어졌죠.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> go = <span class=\"function\">(<span class=\"params\">seed, ...fns</span>) =&gt;</span> fns.reduce(<span class=\"function\">(<span class=\"params\">res, f</span>) =&gt;</span> f(res), seed);</span><br><span class=\"line\"><span class=\"keyword\">const</span> MY_ADDRESS = <span class=\"string\">'0001'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">go(mining(G.HEAD, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(), [&#123; <span class=\"attr\">A</span>: <span class=\"number\">-10</span>, <span class=\"attr\">B</span>: <span class=\"number\">10</span> &#125;], G.DIFF),</span><br><span class=\"line\">  add_block,</span><br><span class=\"line\">  reward_to(MY_ADDRESS),</span><br><span class=\"line\">  () =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'Block Chain: '</span>, G.CHAIN),</span><br><span class=\"line\">  () =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;MY_ADDRESS&#125;</span>'s Balance:`</span>, G.USERS[MY_ADDRESS].balance));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Block Chain:  &#123; '0047ba9d3380fe143b0eeb8b1216c99ebd69f7350732b81167cfd06c8d2356a7': </span></span><br><span class=\"line\"><span class=\"comment\">//    &#123; previousHash: '',</span></span><br><span class=\"line\"><span class=\"comment\">//      timestamp: 2018-06-26T10:08:35.977Z,</span></span><br><span class=\"line\"><span class=\"comment\">//      transactions: [ [Object] ],</span></span><br><span class=\"line\"><span class=\"comment\">//      nonce: 138,</span></span><br><span class=\"line\"><span class=\"comment\">//      hash: '0047ba9d3380fe143b0eeb8b1216c99ebd69f7350732b81167cfd06c8d2356a7' &#125; &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 0001's Balance: 90</span></span><br></pre></td></tr></table></figure>\n\n<p>오늘의 코드는 <a href=\"https://github.com/joeunha/block-js/blob/master/v02.js\" target=\"_blank\" rel=\"noopener\">Github</a>에서 확인하실 수 있습니다. 다음 시간에는 보다 많은 블록을 생성해보고 거래(transaction)를 관리하는 함수를 만들어 보겠습니다.</p>\n"},{"title":"자바스크립트로 블록체인 - transaction","date":"2018-06-27T15:00:00.000Z","description":"자바스크립트로 블록체인을 구현해보자","_content":"_자바스크립트로 블록체인을 구현해보자_\n\n__\\*주의: 해당 글은 대략적인 구조를 설명함으로 실제 암호화폐의 구현과 다를 수 있습니다.__\n\n## 선언\n\n[지난 시간](/programming/block-chain-js-2/)에는 블록을 체인에 추가하고 채굴을 성공한 노드에게 보상을 주는 부분까지 구현했습니다. 오늘은 거래(transaction)를 관리하는 함수들을 구현해보겠습니다. 우선 지난번과 마찬가지로 블록체인 환경에서 공통으로 사용할 변수를 선언하겠습니다. `G`는 블록체인을 만들어가는 모든 노드가 공유하고 있는 변수입니다.\n\n```javascript\nG.TRX = [];\n```\n\n#### G.TRX\n\n거래 내역을 배열로 담고 있습니다. 거래 내역 하나는 객체로 생겼고 어떤 모양일지는 아래에서 살펴봅니다. 이 변수를 장부라고 이해하고 `G.LEDGER`라고 이름 지을까 고민했는데, 길이가 더 짧아서 지금처럼 가기로 했습니다. (`G.TRANSACTIONS`는 너무 길어서 축약했습니다.)\n\n## 구현\n\n이제 아래와 같이 거래를 생성하는 함수를 만들어볼 수 있습니다. \n\n```javascript\nfunction transaction(fromAddress, toAddress, amount) {\n  if (get_balance(fromAddress) >= amount)\n    G.TRX.push({ fromAddress, toAddress, amount });\n  return G.TRX;\n}\n\nfunction get_balance(address) {\n  if (address === '0000') return 1000;\n  return G.TRX.reduce((bal, trx) => {\n    if (trx.fromAddress === address) bal -= trx.amount;\n    if (trx.toAddress === address) bal += trx.amount;\n    return bal;\n  }, balance_from_chain(address));\n}\n\nfunction balance_from_chain(address) {\n  return Object.keys(G.CHAIN).reduce((sum, key) =>\n    G.CHAIN[key].transactions.reduce((bal, trx) => {\n      if (trx.fromAddress === address) bal -= trx.amount;\n      if (trx.toAddress === address) bal += trx.amount;\n      return bal;\n    }, sum), 0);\n}\n```\n\n#### transaction\n거래를 생성하는 이 함수는 거래 내역(`G.TRX`)에 새로운 거래를 추가하는 것을 목표로 합니다. 인자로 돈을 보내는 주소(`fromAddress`), 받는 주소(`toAddress`), 보내는 양(`amount`)를 받습니다. 받은 인자를 객체로 감싸 거래 내역에 넣어주면(push) 이 함수의 역할은 끝이 납니다. 다만 잔액이 보낼 양보다 많아야하겠죠. 이를 위해 `get_balance` 함수를 호출합니다.  \n\n#### get_balance\n이전에 생성된 거래 내역(`G.TRX`)을 주소값(`address`)으로 조회해서 잔액을 확인합니다. 보내는 입장이었다면 빼고 받는 입장이었다면 더합니다. 이 과정에 `reduce` 메서드를 사용했습니다. 해당 메서드는 첫번째 인자로 어떻게 값을 줄여나갈지 정하는 함수를 받고 두번째로는 어떤 값으로 시작할지 지정해주는 값을 받습니다. 이때 시작이 되는 값은 체인에서 조회한 잔액입니다. `balance_from_chain` 함수가 체인에서 잔액을 조회해주죠.\n\n(이 함수에서 첫번째 줄은 주소값이 '0000'일 때 무조건 1000을 반환합니다. 이는 주소값 '0000'은 보상을 주는 노드라고 가정했기 때문입니다.)\n\n#### balance_from_chain\n체인에 기록된 거래 내역은 블록 단위로 돌면서 내부의 거래 내역(`transactions`)을 돌면서 잔액을 구해야합니다. 위와 같이 `reduce` 메서드를 중첩해서 사용하면 원하는 값을 얻을 수 있습니다. 화살표 함수와 중첩해서 사용하니 조금 복잡한듯 보입니다만 그리 어려운 내용은 아닙니다.\n\n다만 아쉬운 점은 잔액을 조회하는 코드가 중복된다는 점입니다. 리팩토링할 필요가 있겠군요.\n\n\n## 리팩토링\n\n우선 중복되는 부분을 바깥으로 꺼내 함수로 만들려고 합니다. `sum_balance`라고 이름 지은 함수를 만들었습니다.\n\n```javascript\nfunction sum_balance(trx, init, address) {\n  return trx.reduce((b, t) => {\n    if (t.fromAddress === address) b -= t.amount;\n    if (t.toAddress === address) b += t.amount;\n    return b;\n  }, init);\n}\n```\n\n#### sum_balance\n코드 전체를 축약하는 김에 변수명도 조금 짧게 줄였습니다. 앞글자만 남겨버렸네요. 인자를 보시면 배열인 거래 내역(`trx`)과 초기값(`init`), 주소값(`address`)을 받았습니다. 이 녀석들이 있으면 잔액을 구할 수 있습니다.    \n \n덕분에 두 함수(`get_balance`, `balance_from_chain`)가 아래와 같이 간결해졌습니다.\n\n```javascript\nfunction get_balance(address) {\n  if (address === '0000') return 1000;\n  return sum_balance(G.TRX, balance_from_chain(address), address);\n}\n\nfunction balance_from_chain(address) {\n  return Object.keys(G.CHAIN).reduce((sum, key) => sum_balance(G.CHAIN[key].transactions, sum, address), 0);\n}\n```\n\n눈치채신 분들도 계시겠지만 잔액을 위와 같은 방법으로 조회하게되면 이전에 만들었던 `G.USERS` 변수가 필요 없습니다. 그러면 보상을 주는 함수([`reward_to`](/programming/block-chain-js-2/#reward-to))도 수정이 필요합니다.\n\n```javascript\nfunction reward_to(address) {\n  return function(is_success) {\n/* 변경 전 */\n//     if (is_success) {\n//       G.USERS[address].balance += G.DIFF * 10;\n//       G.DIFF++;\n//     }\n\n/* 변경 후 */\n    if (is_success) {\n      G.TRX = [];\n      transaction('0000', address, G.DIFF * 10);\n      G.DIFF++;\n    }\n  }\n}\n```\n\n#### reward_to\n이전과 마찬가지로 고차 함수인 `reward_to` 함수는 주소값(`address`)을 인자로 받고 함수를 반환합니다. 이후 채굴 성공 여부(`is_success`)를 인자로 전달 받는 것까지 완전히 동일하지만 보상을 주는 방식이 다릅니다. 우선 기존의 거래 내역(`G.TRX`)을 초기화합니다. 그리고 거래를 발생시켜 채굴자의 잔액을 늘려 보상을 줍니다. 이 거래가 다음 블록의 첫번째 거래가 되는 것이죠. 이후 이전과 마찬가지로 난이도를 증가시키고 함수를 끝냅니다.\n\n\n## 테스트\n\n이제 아래와 같이 테스트 해볼 수 있습니다. 몇차례의 거래(잔액이 부족한 거래는 무시하죠.)가 일어나고 블록을 채굴합니다. 또 다시 거래가 일어나고 채굴을 합니다. 거래 내역(`transactions`)를 잘 보세요.\n\n```javascript\nconst MY_ADDRESS = '0001';\n\ntransaction('0000', '0001', 100);\ntransaction(MY_ADDRESS, '0002', 20);\ntransaction(MY_ADDRESS, '0003', 30);\ntransaction(MY_ADDRESS, '0003', 300); // <-- 잔액 부족!\n\ngo(mining(G.HEAD, new Date(), G.TRX, G.DIFF),\n  add_block,\n  reward_to(MY_ADDRESS));\n\ntransaction('0003', MY_ADDRESS, 10);\n\ngo(mining(G.HEAD, new Date(), G.TRX, G.DIFF),\n  add_block,\n  reward_to(MY_ADDRESS),\n  () => console.log('Block Chain:', G.CHAIN),\n  () => console.log('My Balance:', get_balance(MY_ADDRESS)));\n\n// Block Chain: { '005d4d146a89f67c0daaba4dd414d5086f051c968b12d985e157f773ed617fb6': \n//    { previousHash: '',\n//      timestamp: 2018-06-28T05:27:49.102Z,\n//      transactions: [ [Object], [Object], [Object] ],\n//      nonce: 36,\n//      hash: '005d4d146a89f67c0daaba4dd414d5086f051c968b12d985e157f773ed617fb6' },\n//   '0004c4254f3ea25adb367c71244f7b0e4938d13245c8ea6603c1708020d88d14': \n//    { previousHash: '005d4d146a89f67c0daaba4dd414d5086f051c968b12d985e157f773ed617fb6',\n//      timestamp: 2018-06-28T05:27:49.115Z,\n//      transactions: [ [Object], [Object] ],\n//      nonce: 4267,\n//      hash: '0004c4254f3ea25adb367c71244f7b0e4938d13245c8ea6603c1708020d88d14' } }\n// My Balance: 110\n```\n\n오늘의 코드는 [Github](https://github.com/joeunha/block-js/blob/master/v03.js)에서 확인하실 수 있습니다. 다음 시간에는 체인 유효성 검사를 해보겠습니다.","source":"_posts/block-chain-js-3.md","raw":"---\ntitle: '자바스크립트로 블록체인 - transaction'\ncategories:\n  - programming\ntags:\n  - javascript\n  - 자바스크립트\n  - blockchain\n  - 블록체인\ndate: 2018-06-28 00:00:00\ndescription: 자바스크립트로 블록체인을 구현해보자\n---\n_자바스크립트로 블록체인을 구현해보자_\n\n__\\*주의: 해당 글은 대략적인 구조를 설명함으로 실제 암호화폐의 구현과 다를 수 있습니다.__\n\n## 선언\n\n[지난 시간](/programming/block-chain-js-2/)에는 블록을 체인에 추가하고 채굴을 성공한 노드에게 보상을 주는 부분까지 구현했습니다. 오늘은 거래(transaction)를 관리하는 함수들을 구현해보겠습니다. 우선 지난번과 마찬가지로 블록체인 환경에서 공통으로 사용할 변수를 선언하겠습니다. `G`는 블록체인을 만들어가는 모든 노드가 공유하고 있는 변수입니다.\n\n```javascript\nG.TRX = [];\n```\n\n#### G.TRX\n\n거래 내역을 배열로 담고 있습니다. 거래 내역 하나는 객체로 생겼고 어떤 모양일지는 아래에서 살펴봅니다. 이 변수를 장부라고 이해하고 `G.LEDGER`라고 이름 지을까 고민했는데, 길이가 더 짧아서 지금처럼 가기로 했습니다. (`G.TRANSACTIONS`는 너무 길어서 축약했습니다.)\n\n## 구현\n\n이제 아래와 같이 거래를 생성하는 함수를 만들어볼 수 있습니다. \n\n```javascript\nfunction transaction(fromAddress, toAddress, amount) {\n  if (get_balance(fromAddress) >= amount)\n    G.TRX.push({ fromAddress, toAddress, amount });\n  return G.TRX;\n}\n\nfunction get_balance(address) {\n  if (address === '0000') return 1000;\n  return G.TRX.reduce((bal, trx) => {\n    if (trx.fromAddress === address) bal -= trx.amount;\n    if (trx.toAddress === address) bal += trx.amount;\n    return bal;\n  }, balance_from_chain(address));\n}\n\nfunction balance_from_chain(address) {\n  return Object.keys(G.CHAIN).reduce((sum, key) =>\n    G.CHAIN[key].transactions.reduce((bal, trx) => {\n      if (trx.fromAddress === address) bal -= trx.amount;\n      if (trx.toAddress === address) bal += trx.amount;\n      return bal;\n    }, sum), 0);\n}\n```\n\n#### transaction\n거래를 생성하는 이 함수는 거래 내역(`G.TRX`)에 새로운 거래를 추가하는 것을 목표로 합니다. 인자로 돈을 보내는 주소(`fromAddress`), 받는 주소(`toAddress`), 보내는 양(`amount`)를 받습니다. 받은 인자를 객체로 감싸 거래 내역에 넣어주면(push) 이 함수의 역할은 끝이 납니다. 다만 잔액이 보낼 양보다 많아야하겠죠. 이를 위해 `get_balance` 함수를 호출합니다.  \n\n#### get_balance\n이전에 생성된 거래 내역(`G.TRX`)을 주소값(`address`)으로 조회해서 잔액을 확인합니다. 보내는 입장이었다면 빼고 받는 입장이었다면 더합니다. 이 과정에 `reduce` 메서드를 사용했습니다. 해당 메서드는 첫번째 인자로 어떻게 값을 줄여나갈지 정하는 함수를 받고 두번째로는 어떤 값으로 시작할지 지정해주는 값을 받습니다. 이때 시작이 되는 값은 체인에서 조회한 잔액입니다. `balance_from_chain` 함수가 체인에서 잔액을 조회해주죠.\n\n(이 함수에서 첫번째 줄은 주소값이 '0000'일 때 무조건 1000을 반환합니다. 이는 주소값 '0000'은 보상을 주는 노드라고 가정했기 때문입니다.)\n\n#### balance_from_chain\n체인에 기록된 거래 내역은 블록 단위로 돌면서 내부의 거래 내역(`transactions`)을 돌면서 잔액을 구해야합니다. 위와 같이 `reduce` 메서드를 중첩해서 사용하면 원하는 값을 얻을 수 있습니다. 화살표 함수와 중첩해서 사용하니 조금 복잡한듯 보입니다만 그리 어려운 내용은 아닙니다.\n\n다만 아쉬운 점은 잔액을 조회하는 코드가 중복된다는 점입니다. 리팩토링할 필요가 있겠군요.\n\n\n## 리팩토링\n\n우선 중복되는 부분을 바깥으로 꺼내 함수로 만들려고 합니다. `sum_balance`라고 이름 지은 함수를 만들었습니다.\n\n```javascript\nfunction sum_balance(trx, init, address) {\n  return trx.reduce((b, t) => {\n    if (t.fromAddress === address) b -= t.amount;\n    if (t.toAddress === address) b += t.amount;\n    return b;\n  }, init);\n}\n```\n\n#### sum_balance\n코드 전체를 축약하는 김에 변수명도 조금 짧게 줄였습니다. 앞글자만 남겨버렸네요. 인자를 보시면 배열인 거래 내역(`trx`)과 초기값(`init`), 주소값(`address`)을 받았습니다. 이 녀석들이 있으면 잔액을 구할 수 있습니다.    \n \n덕분에 두 함수(`get_balance`, `balance_from_chain`)가 아래와 같이 간결해졌습니다.\n\n```javascript\nfunction get_balance(address) {\n  if (address === '0000') return 1000;\n  return sum_balance(G.TRX, balance_from_chain(address), address);\n}\n\nfunction balance_from_chain(address) {\n  return Object.keys(G.CHAIN).reduce((sum, key) => sum_balance(G.CHAIN[key].transactions, sum, address), 0);\n}\n```\n\n눈치채신 분들도 계시겠지만 잔액을 위와 같은 방법으로 조회하게되면 이전에 만들었던 `G.USERS` 변수가 필요 없습니다. 그러면 보상을 주는 함수([`reward_to`](/programming/block-chain-js-2/#reward-to))도 수정이 필요합니다.\n\n```javascript\nfunction reward_to(address) {\n  return function(is_success) {\n/* 변경 전 */\n//     if (is_success) {\n//       G.USERS[address].balance += G.DIFF * 10;\n//       G.DIFF++;\n//     }\n\n/* 변경 후 */\n    if (is_success) {\n      G.TRX = [];\n      transaction('0000', address, G.DIFF * 10);\n      G.DIFF++;\n    }\n  }\n}\n```\n\n#### reward_to\n이전과 마찬가지로 고차 함수인 `reward_to` 함수는 주소값(`address`)을 인자로 받고 함수를 반환합니다. 이후 채굴 성공 여부(`is_success`)를 인자로 전달 받는 것까지 완전히 동일하지만 보상을 주는 방식이 다릅니다. 우선 기존의 거래 내역(`G.TRX`)을 초기화합니다. 그리고 거래를 발생시켜 채굴자의 잔액을 늘려 보상을 줍니다. 이 거래가 다음 블록의 첫번째 거래가 되는 것이죠. 이후 이전과 마찬가지로 난이도를 증가시키고 함수를 끝냅니다.\n\n\n## 테스트\n\n이제 아래와 같이 테스트 해볼 수 있습니다. 몇차례의 거래(잔액이 부족한 거래는 무시하죠.)가 일어나고 블록을 채굴합니다. 또 다시 거래가 일어나고 채굴을 합니다. 거래 내역(`transactions`)를 잘 보세요.\n\n```javascript\nconst MY_ADDRESS = '0001';\n\ntransaction('0000', '0001', 100);\ntransaction(MY_ADDRESS, '0002', 20);\ntransaction(MY_ADDRESS, '0003', 30);\ntransaction(MY_ADDRESS, '0003', 300); // <-- 잔액 부족!\n\ngo(mining(G.HEAD, new Date(), G.TRX, G.DIFF),\n  add_block,\n  reward_to(MY_ADDRESS));\n\ntransaction('0003', MY_ADDRESS, 10);\n\ngo(mining(G.HEAD, new Date(), G.TRX, G.DIFF),\n  add_block,\n  reward_to(MY_ADDRESS),\n  () => console.log('Block Chain:', G.CHAIN),\n  () => console.log('My Balance:', get_balance(MY_ADDRESS)));\n\n// Block Chain: { '005d4d146a89f67c0daaba4dd414d5086f051c968b12d985e157f773ed617fb6': \n//    { previousHash: '',\n//      timestamp: 2018-06-28T05:27:49.102Z,\n//      transactions: [ [Object], [Object], [Object] ],\n//      nonce: 36,\n//      hash: '005d4d146a89f67c0daaba4dd414d5086f051c968b12d985e157f773ed617fb6' },\n//   '0004c4254f3ea25adb367c71244f7b0e4938d13245c8ea6603c1708020d88d14': \n//    { previousHash: '005d4d146a89f67c0daaba4dd414d5086f051c968b12d985e157f773ed617fb6',\n//      timestamp: 2018-06-28T05:27:49.115Z,\n//      transactions: [ [Object], [Object] ],\n//      nonce: 4267,\n//      hash: '0004c4254f3ea25adb367c71244f7b0e4938d13245c8ea6603c1708020d88d14' } }\n// My Balance: 110\n```\n\n오늘의 코드는 [Github](https://github.com/joeunha/block-js/blob/master/v03.js)에서 확인하실 수 있습니다. 다음 시간에는 체인 유효성 검사를 해보겠습니다.","slug":"block-chain-js-3","published":1,"updated":"2019-07-15T12:07:32.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9ev000cdirvsmaaegnq","content":"<p><em>자바스크립트로 블록체인을 구현해보자</em></p>\n<p><strong>*주의: 해당 글은 대략적인 구조를 설명함으로 실제 암호화폐의 구현과 다를 수 있습니다.</strong></p>\n<h2 id=\"선언\"><a href=\"#선언\" class=\"headerlink\" title=\"선언\"></a>선언</h2><p><a href=\"/programming/block-chain-js-2/\">지난 시간</a>에는 블록을 체인에 추가하고 채굴을 성공한 노드에게 보상을 주는 부분까지 구현했습니다. 오늘은 거래(transaction)를 관리하는 함수들을 구현해보겠습니다. 우선 지난번과 마찬가지로 블록체인 환경에서 공통으로 사용할 변수를 선언하겠습니다. <code>G</code>는 블록체인을 만들어가는 모든 노드가 공유하고 있는 변수입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">G.TRX = [];</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"G-TRX\"><a href=\"#G-TRX\" class=\"headerlink\" title=\"G.TRX\"></a>G.TRX</h4><p>거래 내역을 배열로 담고 있습니다. 거래 내역 하나는 객체로 생겼고 어떤 모양일지는 아래에서 살펴봅니다. 이 변수를 장부라고 이해하고 <code>G.LEDGER</code>라고 이름 지을까 고민했는데, 길이가 더 짧아서 지금처럼 가기로 했습니다. (<code>G.TRANSACTIONS</code>는 너무 길어서 축약했습니다.)</p>\n<h2 id=\"구현\"><a href=\"#구현\" class=\"headerlink\" title=\"구현\"></a>구현</h2><p>이제 아래와 같이 거래를 생성하는 함수를 만들어볼 수 있습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">transaction</span>(<span class=\"params\">fromAddress, toAddress, amount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (get_balance(fromAddress) &gt;= amount)</span><br><span class=\"line\">    G.TRX.push(&#123; fromAddress, toAddress, amount &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> G.TRX;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get_balance</span>(<span class=\"params\">address</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (address === <span class=\"string\">'0000'</span>) <span class=\"keyword\">return</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> G.TRX.reduce(<span class=\"function\">(<span class=\"params\">bal, trx</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (trx.fromAddress === address) bal -= trx.amount;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (trx.toAddress === address) bal += trx.amount;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bal;</span><br><span class=\"line\">  &#125;, balance_from_chain(address));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">balance_from_chain</span>(<span class=\"params\">address</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(G.CHAIN).reduce(<span class=\"function\">(<span class=\"params\">sum, key</span>) =&gt;</span></span><br><span class=\"line\">    G.CHAIN[key].transactions.reduce(<span class=\"function\">(<span class=\"params\">bal, trx</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (trx.fromAddress === address) bal -= trx.amount;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (trx.toAddress === address) bal += trx.amount;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> bal;</span><br><span class=\"line\">    &#125;, sum), <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"transaction\"><a href=\"#transaction\" class=\"headerlink\" title=\"transaction\"></a>transaction</h4><p>거래를 생성하는 이 함수는 거래 내역(<code>G.TRX</code>)에 새로운 거래를 추가하는 것을 목표로 합니다. 인자로 돈을 보내는 주소(<code>fromAddress</code>), 받는 주소(<code>toAddress</code>), 보내는 양(<code>amount</code>)를 받습니다. 받은 인자를 객체로 감싸 거래 내역에 넣어주면(push) 이 함수의 역할은 끝이 납니다. 다만 잔액이 보낼 양보다 많아야하겠죠. 이를 위해 <code>get_balance</code> 함수를 호출합니다.  </p>\n<h4 id=\"get-balance\"><a href=\"#get-balance\" class=\"headerlink\" title=\"get_balance\"></a>get_balance</h4><p>이전에 생성된 거래 내역(<code>G.TRX</code>)을 주소값(<code>address</code>)으로 조회해서 잔액을 확인합니다. 보내는 입장이었다면 빼고 받는 입장이었다면 더합니다. 이 과정에 <code>reduce</code> 메서드를 사용했습니다. 해당 메서드는 첫번째 인자로 어떻게 값을 줄여나갈지 정하는 함수를 받고 두번째로는 어떤 값으로 시작할지 지정해주는 값을 받습니다. 이때 시작이 되는 값은 체인에서 조회한 잔액입니다. <code>balance_from_chain</code> 함수가 체인에서 잔액을 조회해주죠.</p>\n<p>(이 함수에서 첫번째 줄은 주소값이 ‘0000’일 때 무조건 1000을 반환합니다. 이는 주소값 ‘0000’은 보상을 주는 노드라고 가정했기 때문입니다.)</p>\n<h4 id=\"balance-from-chain\"><a href=\"#balance-from-chain\" class=\"headerlink\" title=\"balance_from_chain\"></a>balance_from_chain</h4><p>체인에 기록된 거래 내역은 블록 단위로 돌면서 내부의 거래 내역(<code>transactions</code>)을 돌면서 잔액을 구해야합니다. 위와 같이 <code>reduce</code> 메서드를 중첩해서 사용하면 원하는 값을 얻을 수 있습니다. 화살표 함수와 중첩해서 사용하니 조금 복잡한듯 보입니다만 그리 어려운 내용은 아닙니다.</p>\n<p>다만 아쉬운 점은 잔액을 조회하는 코드가 중복된다는 점입니다. 리팩토링할 필요가 있겠군요.</p>\n<h2 id=\"리팩토링\"><a href=\"#리팩토링\" class=\"headerlink\" title=\"리팩토링\"></a>리팩토링</h2><p>우선 중복되는 부분을 바깥으로 꺼내 함수로 만들려고 합니다. <code>sum_balance</code>라고 이름 지은 함수를 만들었습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum_balance</span>(<span class=\"params\">trx, init, address</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> trx.reduce(<span class=\"function\">(<span class=\"params\">b, t</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t.fromAddress === address) b -= t.amount;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t.toAddress === address) b += t.amount;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  &#125;, init);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sum-balance\"><a href=\"#sum-balance\" class=\"headerlink\" title=\"sum_balance\"></a>sum_balance</h4><p>코드 전체를 축약하는 김에 변수명도 조금 짧게 줄였습니다. 앞글자만 남겨버렸네요. 인자를 보시면 배열인 거래 내역(<code>trx</code>)과 초기값(<code>init</code>), 주소값(<code>address</code>)을 받았습니다. 이 녀석들이 있으면 잔액을 구할 수 있습니다.    </p>\n<p>덕분에 두 함수(<code>get_balance</code>, <code>balance_from_chain</code>)가 아래와 같이 간결해졌습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get_balance</span>(<span class=\"params\">address</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (address === <span class=\"string\">'0000'</span>) <span class=\"keyword\">return</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum_balance(G.TRX, balance_from_chain(address), address);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">balance_from_chain</span>(<span class=\"params\">address</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(G.CHAIN).reduce(<span class=\"function\">(<span class=\"params\">sum, key</span>) =&gt;</span> sum_balance(G.CHAIN[key].transactions, sum, address), <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>눈치채신 분들도 계시겠지만 잔액을 위와 같은 방법으로 조회하게되면 이전에 만들었던 <code>G.USERS</code> 변수가 필요 없습니다. 그러면 보상을 주는 함수(<a href=\"/programming/block-chain-js-2/#reward-to\"><code>reward_to</code></a>)도 수정이 필요합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reward_to</span>(<span class=\"params\">address</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">is_success</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/* 변경 전 */</span></span><br><span class=\"line\"><span class=\"comment\">//     if (is_success) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       G.USERS[address].balance += G.DIFF * 10;</span></span><br><span class=\"line\"><span class=\"comment\">//       G.DIFF++;</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 변경 후 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_success) &#123;</span><br><span class=\"line\">      G.TRX = [];</span><br><span class=\"line\">      transaction(<span class=\"string\">'0000'</span>, address, G.DIFF * <span class=\"number\">10</span>);</span><br><span class=\"line\">      G.DIFF++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"reward-to\"><a href=\"#reward-to\" class=\"headerlink\" title=\"reward_to\"></a>reward_to</h4><p>이전과 마찬가지로 고차 함수인 <code>reward_to</code> 함수는 주소값(<code>address</code>)을 인자로 받고 함수를 반환합니다. 이후 채굴 성공 여부(<code>is_success</code>)를 인자로 전달 받는 것까지 완전히 동일하지만 보상을 주는 방식이 다릅니다. 우선 기존의 거래 내역(<code>G.TRX</code>)을 초기화합니다. 그리고 거래를 발생시켜 채굴자의 잔액을 늘려 보상을 줍니다. 이 거래가 다음 블록의 첫번째 거래가 되는 것이죠. 이후 이전과 마찬가지로 난이도를 증가시키고 함수를 끝냅니다.</p>\n<h2 id=\"테스트\"><a href=\"#테스트\" class=\"headerlink\" title=\"테스트\"></a>테스트</h2><p>이제 아래와 같이 테스트 해볼 수 있습니다. 몇차례의 거래(잔액이 부족한 거래는 무시하죠.)가 일어나고 블록을 채굴합니다. 또 다시 거래가 일어나고 채굴을 합니다. 거래 내역(<code>transactions</code>)를 잘 보세요.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MY_ADDRESS = <span class=\"string\">'0001'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">transaction(<span class=\"string\">'0000'</span>, <span class=\"string\">'0001'</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">transaction(MY_ADDRESS, <span class=\"string\">'0002'</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">transaction(MY_ADDRESS, <span class=\"string\">'0003'</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">transaction(MY_ADDRESS, <span class=\"string\">'0003'</span>, <span class=\"number\">300</span>); <span class=\"comment\">// &lt;-- 잔액 부족!</span></span><br><span class=\"line\"></span><br><span class=\"line\">go(mining(G.HEAD, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(), G.TRX, G.DIFF),</span><br><span class=\"line\">  add_block,</span><br><span class=\"line\">  reward_to(MY_ADDRESS));</span><br><span class=\"line\"></span><br><span class=\"line\">transaction(<span class=\"string\">'0003'</span>, MY_ADDRESS, <span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">go(mining(G.HEAD, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(), G.TRX, G.DIFF),</span><br><span class=\"line\">  add_block,</span><br><span class=\"line\">  reward_to(MY_ADDRESS),</span><br><span class=\"line\">  () =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'Block Chain:'</span>, G.CHAIN),</span><br><span class=\"line\">  () =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'My Balance:'</span>, get_balance(MY_ADDRESS)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Block Chain: &#123; '005d4d146a89f67c0daaba4dd414d5086f051c968b12d985e157f773ed617fb6': </span></span><br><span class=\"line\"><span class=\"comment\">//    &#123; previousHash: '',</span></span><br><span class=\"line\"><span class=\"comment\">//      timestamp: 2018-06-28T05:27:49.102Z,</span></span><br><span class=\"line\"><span class=\"comment\">//      transactions: [ [Object], [Object], [Object] ],</span></span><br><span class=\"line\"><span class=\"comment\">//      nonce: 36,</span></span><br><span class=\"line\"><span class=\"comment\">//      hash: '005d4d146a89f67c0daaba4dd414d5086f051c968b12d985e157f773ed617fb6' &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//   '0004c4254f3ea25adb367c71244f7b0e4938d13245c8ea6603c1708020d88d14': </span></span><br><span class=\"line\"><span class=\"comment\">//    &#123; previousHash: '005d4d146a89f67c0daaba4dd414d5086f051c968b12d985e157f773ed617fb6',</span></span><br><span class=\"line\"><span class=\"comment\">//      timestamp: 2018-06-28T05:27:49.115Z,</span></span><br><span class=\"line\"><span class=\"comment\">//      transactions: [ [Object], [Object] ],</span></span><br><span class=\"line\"><span class=\"comment\">//      nonce: 4267,</span></span><br><span class=\"line\"><span class=\"comment\">//      hash: '0004c4254f3ea25adb367c71244f7b0e4938d13245c8ea6603c1708020d88d14' &#125; &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// My Balance: 110</span></span><br></pre></td></tr></table></figure>\n\n<p>오늘의 코드는 <a href=\"https://github.com/joeunha/block-js/blob/master/v03.js\" target=\"_blank\" rel=\"noopener\">Github</a>에서 확인하실 수 있습니다. 다음 시간에는 체인 유효성 검사를 해보겠습니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>자바스크립트로 블록체인을 구현해보자</em></p>\n<p><strong>*주의: 해당 글은 대략적인 구조를 설명함으로 실제 암호화폐의 구현과 다를 수 있습니다.</strong></p>\n<h2 id=\"선언\"><a href=\"#선언\" class=\"headerlink\" title=\"선언\"></a>선언</h2><p><a href=\"/programming/block-chain-js-2/\">지난 시간</a>에는 블록을 체인에 추가하고 채굴을 성공한 노드에게 보상을 주는 부분까지 구현했습니다. 오늘은 거래(transaction)를 관리하는 함수들을 구현해보겠습니다. 우선 지난번과 마찬가지로 블록체인 환경에서 공통으로 사용할 변수를 선언하겠습니다. <code>G</code>는 블록체인을 만들어가는 모든 노드가 공유하고 있는 변수입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">G.TRX = [];</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"G-TRX\"><a href=\"#G-TRX\" class=\"headerlink\" title=\"G.TRX\"></a>G.TRX</h4><p>거래 내역을 배열로 담고 있습니다. 거래 내역 하나는 객체로 생겼고 어떤 모양일지는 아래에서 살펴봅니다. 이 변수를 장부라고 이해하고 <code>G.LEDGER</code>라고 이름 지을까 고민했는데, 길이가 더 짧아서 지금처럼 가기로 했습니다. (<code>G.TRANSACTIONS</code>는 너무 길어서 축약했습니다.)</p>\n<h2 id=\"구현\"><a href=\"#구현\" class=\"headerlink\" title=\"구현\"></a>구현</h2><p>이제 아래와 같이 거래를 생성하는 함수를 만들어볼 수 있습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">transaction</span>(<span class=\"params\">fromAddress, toAddress, amount</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (get_balance(fromAddress) &gt;= amount)</span><br><span class=\"line\">    G.TRX.push(&#123; fromAddress, toAddress, amount &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> G.TRX;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get_balance</span>(<span class=\"params\">address</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (address === <span class=\"string\">'0000'</span>) <span class=\"keyword\">return</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> G.TRX.reduce(<span class=\"function\">(<span class=\"params\">bal, trx</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (trx.fromAddress === address) bal -= trx.amount;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (trx.toAddress === address) bal += trx.amount;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bal;</span><br><span class=\"line\">  &#125;, balance_from_chain(address));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">balance_from_chain</span>(<span class=\"params\">address</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(G.CHAIN).reduce(<span class=\"function\">(<span class=\"params\">sum, key</span>) =&gt;</span></span><br><span class=\"line\">    G.CHAIN[key].transactions.reduce(<span class=\"function\">(<span class=\"params\">bal, trx</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (trx.fromAddress === address) bal -= trx.amount;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (trx.toAddress === address) bal += trx.amount;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> bal;</span><br><span class=\"line\">    &#125;, sum), <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"transaction\"><a href=\"#transaction\" class=\"headerlink\" title=\"transaction\"></a>transaction</h4><p>거래를 생성하는 이 함수는 거래 내역(<code>G.TRX</code>)에 새로운 거래를 추가하는 것을 목표로 합니다. 인자로 돈을 보내는 주소(<code>fromAddress</code>), 받는 주소(<code>toAddress</code>), 보내는 양(<code>amount</code>)를 받습니다. 받은 인자를 객체로 감싸 거래 내역에 넣어주면(push) 이 함수의 역할은 끝이 납니다. 다만 잔액이 보낼 양보다 많아야하겠죠. 이를 위해 <code>get_balance</code> 함수를 호출합니다.  </p>\n<h4 id=\"get-balance\"><a href=\"#get-balance\" class=\"headerlink\" title=\"get_balance\"></a>get_balance</h4><p>이전에 생성된 거래 내역(<code>G.TRX</code>)을 주소값(<code>address</code>)으로 조회해서 잔액을 확인합니다. 보내는 입장이었다면 빼고 받는 입장이었다면 더합니다. 이 과정에 <code>reduce</code> 메서드를 사용했습니다. 해당 메서드는 첫번째 인자로 어떻게 값을 줄여나갈지 정하는 함수를 받고 두번째로는 어떤 값으로 시작할지 지정해주는 값을 받습니다. 이때 시작이 되는 값은 체인에서 조회한 잔액입니다. <code>balance_from_chain</code> 함수가 체인에서 잔액을 조회해주죠.</p>\n<p>(이 함수에서 첫번째 줄은 주소값이 ‘0000’일 때 무조건 1000을 반환합니다. 이는 주소값 ‘0000’은 보상을 주는 노드라고 가정했기 때문입니다.)</p>\n<h4 id=\"balance-from-chain\"><a href=\"#balance-from-chain\" class=\"headerlink\" title=\"balance_from_chain\"></a>balance_from_chain</h4><p>체인에 기록된 거래 내역은 블록 단위로 돌면서 내부의 거래 내역(<code>transactions</code>)을 돌면서 잔액을 구해야합니다. 위와 같이 <code>reduce</code> 메서드를 중첩해서 사용하면 원하는 값을 얻을 수 있습니다. 화살표 함수와 중첩해서 사용하니 조금 복잡한듯 보입니다만 그리 어려운 내용은 아닙니다.</p>\n<p>다만 아쉬운 점은 잔액을 조회하는 코드가 중복된다는 점입니다. 리팩토링할 필요가 있겠군요.</p>\n<h2 id=\"리팩토링\"><a href=\"#리팩토링\" class=\"headerlink\" title=\"리팩토링\"></a>리팩토링</h2><p>우선 중복되는 부분을 바깥으로 꺼내 함수로 만들려고 합니다. <code>sum_balance</code>라고 이름 지은 함수를 만들었습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum_balance</span>(<span class=\"params\">trx, init, address</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> trx.reduce(<span class=\"function\">(<span class=\"params\">b, t</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t.fromAddress === address) b -= t.amount;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t.toAddress === address) b += t.amount;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  &#125;, init);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sum-balance\"><a href=\"#sum-balance\" class=\"headerlink\" title=\"sum_balance\"></a>sum_balance</h4><p>코드 전체를 축약하는 김에 변수명도 조금 짧게 줄였습니다. 앞글자만 남겨버렸네요. 인자를 보시면 배열인 거래 내역(<code>trx</code>)과 초기값(<code>init</code>), 주소값(<code>address</code>)을 받았습니다. 이 녀석들이 있으면 잔액을 구할 수 있습니다.    </p>\n<p>덕분에 두 함수(<code>get_balance</code>, <code>balance_from_chain</code>)가 아래와 같이 간결해졌습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get_balance</span>(<span class=\"params\">address</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (address === <span class=\"string\">'0000'</span>) <span class=\"keyword\">return</span> <span class=\"number\">1000</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum_balance(G.TRX, balance_from_chain(address), address);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">balance_from_chain</span>(<span class=\"params\">address</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(G.CHAIN).reduce(<span class=\"function\">(<span class=\"params\">sum, key</span>) =&gt;</span> sum_balance(G.CHAIN[key].transactions, sum, address), <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>눈치채신 분들도 계시겠지만 잔액을 위와 같은 방법으로 조회하게되면 이전에 만들었던 <code>G.USERS</code> 변수가 필요 없습니다. 그러면 보상을 주는 함수(<a href=\"/programming/block-chain-js-2/#reward-to\"><code>reward_to</code></a>)도 수정이 필요합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reward_to</span>(<span class=\"params\">address</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">is_success</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/* 변경 전 */</span></span><br><span class=\"line\"><span class=\"comment\">//     if (is_success) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       G.USERS[address].balance += G.DIFF * 10;</span></span><br><span class=\"line\"><span class=\"comment\">//       G.DIFF++;</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 변경 후 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_success) &#123;</span><br><span class=\"line\">      G.TRX = [];</span><br><span class=\"line\">      transaction(<span class=\"string\">'0000'</span>, address, G.DIFF * <span class=\"number\">10</span>);</span><br><span class=\"line\">      G.DIFF++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"reward-to\"><a href=\"#reward-to\" class=\"headerlink\" title=\"reward_to\"></a>reward_to</h4><p>이전과 마찬가지로 고차 함수인 <code>reward_to</code> 함수는 주소값(<code>address</code>)을 인자로 받고 함수를 반환합니다. 이후 채굴 성공 여부(<code>is_success</code>)를 인자로 전달 받는 것까지 완전히 동일하지만 보상을 주는 방식이 다릅니다. 우선 기존의 거래 내역(<code>G.TRX</code>)을 초기화합니다. 그리고 거래를 발생시켜 채굴자의 잔액을 늘려 보상을 줍니다. 이 거래가 다음 블록의 첫번째 거래가 되는 것이죠. 이후 이전과 마찬가지로 난이도를 증가시키고 함수를 끝냅니다.</p>\n<h2 id=\"테스트\"><a href=\"#테스트\" class=\"headerlink\" title=\"테스트\"></a>테스트</h2><p>이제 아래와 같이 테스트 해볼 수 있습니다. 몇차례의 거래(잔액이 부족한 거래는 무시하죠.)가 일어나고 블록을 채굴합니다. 또 다시 거래가 일어나고 채굴을 합니다. 거래 내역(<code>transactions</code>)를 잘 보세요.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MY_ADDRESS = <span class=\"string\">'0001'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">transaction(<span class=\"string\">'0000'</span>, <span class=\"string\">'0001'</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">transaction(MY_ADDRESS, <span class=\"string\">'0002'</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">transaction(MY_ADDRESS, <span class=\"string\">'0003'</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">transaction(MY_ADDRESS, <span class=\"string\">'0003'</span>, <span class=\"number\">300</span>); <span class=\"comment\">// &lt;-- 잔액 부족!</span></span><br><span class=\"line\"></span><br><span class=\"line\">go(mining(G.HEAD, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(), G.TRX, G.DIFF),</span><br><span class=\"line\">  add_block,</span><br><span class=\"line\">  reward_to(MY_ADDRESS));</span><br><span class=\"line\"></span><br><span class=\"line\">transaction(<span class=\"string\">'0003'</span>, MY_ADDRESS, <span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">go(mining(G.HEAD, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(), G.TRX, G.DIFF),</span><br><span class=\"line\">  add_block,</span><br><span class=\"line\">  reward_to(MY_ADDRESS),</span><br><span class=\"line\">  () =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'Block Chain:'</span>, G.CHAIN),</span><br><span class=\"line\">  () =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'My Balance:'</span>, get_balance(MY_ADDRESS)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Block Chain: &#123; '005d4d146a89f67c0daaba4dd414d5086f051c968b12d985e157f773ed617fb6': </span></span><br><span class=\"line\"><span class=\"comment\">//    &#123; previousHash: '',</span></span><br><span class=\"line\"><span class=\"comment\">//      timestamp: 2018-06-28T05:27:49.102Z,</span></span><br><span class=\"line\"><span class=\"comment\">//      transactions: [ [Object], [Object], [Object] ],</span></span><br><span class=\"line\"><span class=\"comment\">//      nonce: 36,</span></span><br><span class=\"line\"><span class=\"comment\">//      hash: '005d4d146a89f67c0daaba4dd414d5086f051c968b12d985e157f773ed617fb6' &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//   '0004c4254f3ea25adb367c71244f7b0e4938d13245c8ea6603c1708020d88d14': </span></span><br><span class=\"line\"><span class=\"comment\">//    &#123; previousHash: '005d4d146a89f67c0daaba4dd414d5086f051c968b12d985e157f773ed617fb6',</span></span><br><span class=\"line\"><span class=\"comment\">//      timestamp: 2018-06-28T05:27:49.115Z,</span></span><br><span class=\"line\"><span class=\"comment\">//      transactions: [ [Object], [Object] ],</span></span><br><span class=\"line\"><span class=\"comment\">//      nonce: 4267,</span></span><br><span class=\"line\"><span class=\"comment\">//      hash: '0004c4254f3ea25adb367c71244f7b0e4938d13245c8ea6603c1708020d88d14' &#125; &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// My Balance: 110</span></span><br></pre></td></tr></table></figure>\n\n<p>오늘의 코드는 <a href=\"https://github.com/joeunha/block-js/blob/master/v03.js\" target=\"_blank\" rel=\"noopener\">Github</a>에서 확인하실 수 있습니다. 다음 시간에는 체인 유효성 검사를 해보겠습니다.</p>\n"},{"title":"자바스크립트로 블록체인 - is_chain_valid","date":"2018-07-01T15:00:00.000Z","description":"자바스크립트로 블록체인을 구현해보자","_content":"_자바스크립트로 블록체인을 구현해보자_\n\n__\\*주의: 해당 글은 대략적인 구조를 설명함으로 실제 암호화폐의 구현과 다를 수 있습니다.__\n\n## 구현\n\n지금까지 [블록의 구조를 살펴보는 것](/programming/block-chain-js/)으로 시작해 [채굴](/programming/block-chain-js-1/), [블록 추가](/programming/block-chain-js-2/), [거래 생성](/programming/block-chain-js-3/)과 관련된 코드를 구현했습니다. 오늘은 체인의 유효성을 검사하는 함수를 만들겠습니다. 이를 통해 거래 내역등의 변경을 감지해보도록 하겠습니다. 구현은 아래와 같이 합니다.\n\n```javascript\nconst every = (coll, fn) => \n  Array.isArray(coll) ? coll.every(fn) : keys(coll).every(key => fn(coll[key], key, coll));\n\nfunction is_chain_valid(chain) {\n  return every(chain, block => {\n    const previous = chain[block.previousHash];\n    if (block.hash !== calculate_hash(block)) return false;\n    if (block.previousHash === '') return true; // Genesis Block\n    if (block.previousHash !== calculate_hash(previous)) return false;\n    return true;\n  });\n}\n```\n\n#### every\n\n쉽게 생각해서 체인에 얽혀있는 __모든 블록을 순회하며 문제가 없는지 확인__하는게 오늘의 주요 과제입니다. 이때 제격인 함수가 [`every`라는 함수](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/every)입니다. 원래 Array의 메서드로 존재하는 이 함수를 객체인 `G.CHAIN`도 순회할 수 있도록 하기 위해 `every`와 같은 함수로 만들어줍니다. 이를 이용해서 `is_chain_valid`를 구현합니다. \n\n#### is_chain_valid\n\n우리가 확인해야할 내용은 크게 두가지 입니다. \n1. 현재의 블록이 유효한지\n2. 이전 블록과 잘 연결되어 있는지\n\n현재의 블록이 유효한지 확인하기 위해 해시값을 다시 계산해봅니다. 채굴하면서 생성한 해시값과 일치하지 않는다면 문제가 생긴 것으로 간주합니다. 그리고 지금 알고 있는 이전 블록의 해시값(`previousHash`)을 기반으로 블록을 찾고 마찬가지로 해시값을 다시 계산해서 유효성을 확인합니다. 만약 이전 블록의 해시값이 없다면 제네시스 블록이라고 간주합니다.\n\n\n## 테스트\n\n이전에 생성된 블록이 있다는 가정해에 아래와 같이 테스트해볼 수 있습니다. 특정 거래의 금액을 조정하면 아래와 같이 유효성 검사에 통과하지 못합니다.\n\n```javascript\nlet hash_key = keys(G.CHAIN)[1];\n\nconsole.log('[ Before ]\\n Chain Valid: ', is_chain_valid(G.CHAIN)); // true\nconsole.log('Transactions: ', G.CHAIN[hash_key].transactions, '\\n');\n\nG.CHAIN[hash_key].transactions[1].amount = 0; // 거래를 조작\n\nconsole.log('[ After ]\\n Chain Valid: ', is_chain_valid(G.CHAIN)); // false\nconsole.log('Transactions: ', G.CHAIN[hash_key].transactions);\n```\n\n오늘의 코드는 [Github](https://github.com/joeunha/block-js/blob/master/v04.js)에서 확인하실 수 있습니다. 다음 시간부터는 각 기능을 조금씩 고도화 해보겠습니다.\n\n\n## 사소한 라이브러리\n\n구현부에서 살펴본 것처럼 `every` 같은 함수를 몇개 만들어두면 객체도 순회하며 원하는 일을 할 수 있습니다. 이를 위해 사용할 수 있는 라이브러리가 있지만 간단한 내용을 처리함으로 직접 만들어 사용하려고 합니다. functions.js라는 이름으로 파일을 만들고 함수 모음을 만들어 필요할때마다 꺼내서 사용하려고 합니다. 해당 코드는 [Github](https://github.com/joeunha/block-js/blob/master/lib/functions.js)에서 확인하실 수 있습니다.    ","source":"_posts/block-chain-js-4.md","raw":"---\ntitle: '자바스크립트로 블록체인 - is_chain_valid'\ncategories:\n  - programming\ntags:\n  - javascript\n  - 자바스크립트\n  - blockchain\n  - 블록체인\ndate: 2018-07-02 00:00:00\ndescription: 자바스크립트로 블록체인을 구현해보자\n---\n_자바스크립트로 블록체인을 구현해보자_\n\n__\\*주의: 해당 글은 대략적인 구조를 설명함으로 실제 암호화폐의 구현과 다를 수 있습니다.__\n\n## 구현\n\n지금까지 [블록의 구조를 살펴보는 것](/programming/block-chain-js/)으로 시작해 [채굴](/programming/block-chain-js-1/), [블록 추가](/programming/block-chain-js-2/), [거래 생성](/programming/block-chain-js-3/)과 관련된 코드를 구현했습니다. 오늘은 체인의 유효성을 검사하는 함수를 만들겠습니다. 이를 통해 거래 내역등의 변경을 감지해보도록 하겠습니다. 구현은 아래와 같이 합니다.\n\n```javascript\nconst every = (coll, fn) => \n  Array.isArray(coll) ? coll.every(fn) : keys(coll).every(key => fn(coll[key], key, coll));\n\nfunction is_chain_valid(chain) {\n  return every(chain, block => {\n    const previous = chain[block.previousHash];\n    if (block.hash !== calculate_hash(block)) return false;\n    if (block.previousHash === '') return true; // Genesis Block\n    if (block.previousHash !== calculate_hash(previous)) return false;\n    return true;\n  });\n}\n```\n\n#### every\n\n쉽게 생각해서 체인에 얽혀있는 __모든 블록을 순회하며 문제가 없는지 확인__하는게 오늘의 주요 과제입니다. 이때 제격인 함수가 [`every`라는 함수](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/every)입니다. 원래 Array의 메서드로 존재하는 이 함수를 객체인 `G.CHAIN`도 순회할 수 있도록 하기 위해 `every`와 같은 함수로 만들어줍니다. 이를 이용해서 `is_chain_valid`를 구현합니다. \n\n#### is_chain_valid\n\n우리가 확인해야할 내용은 크게 두가지 입니다. \n1. 현재의 블록이 유효한지\n2. 이전 블록과 잘 연결되어 있는지\n\n현재의 블록이 유효한지 확인하기 위해 해시값을 다시 계산해봅니다. 채굴하면서 생성한 해시값과 일치하지 않는다면 문제가 생긴 것으로 간주합니다. 그리고 지금 알고 있는 이전 블록의 해시값(`previousHash`)을 기반으로 블록을 찾고 마찬가지로 해시값을 다시 계산해서 유효성을 확인합니다. 만약 이전 블록의 해시값이 없다면 제네시스 블록이라고 간주합니다.\n\n\n## 테스트\n\n이전에 생성된 블록이 있다는 가정해에 아래와 같이 테스트해볼 수 있습니다. 특정 거래의 금액을 조정하면 아래와 같이 유효성 검사에 통과하지 못합니다.\n\n```javascript\nlet hash_key = keys(G.CHAIN)[1];\n\nconsole.log('[ Before ]\\n Chain Valid: ', is_chain_valid(G.CHAIN)); // true\nconsole.log('Transactions: ', G.CHAIN[hash_key].transactions, '\\n');\n\nG.CHAIN[hash_key].transactions[1].amount = 0; // 거래를 조작\n\nconsole.log('[ After ]\\n Chain Valid: ', is_chain_valid(G.CHAIN)); // false\nconsole.log('Transactions: ', G.CHAIN[hash_key].transactions);\n```\n\n오늘의 코드는 [Github](https://github.com/joeunha/block-js/blob/master/v04.js)에서 확인하실 수 있습니다. 다음 시간부터는 각 기능을 조금씩 고도화 해보겠습니다.\n\n\n## 사소한 라이브러리\n\n구현부에서 살펴본 것처럼 `every` 같은 함수를 몇개 만들어두면 객체도 순회하며 원하는 일을 할 수 있습니다. 이를 위해 사용할 수 있는 라이브러리가 있지만 간단한 내용을 처리함으로 직접 만들어 사용하려고 합니다. functions.js라는 이름으로 파일을 만들고 함수 모음을 만들어 필요할때마다 꺼내서 사용하려고 합니다. 해당 코드는 [Github](https://github.com/joeunha/block-js/blob/master/lib/functions.js)에서 확인하실 수 있습니다.    ","slug":"block-chain-js-4","published":1,"updated":"2019-07-15T12:07:30.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9ey000fdirv99jhkmpj","content":"<p><em>자바스크립트로 블록체인을 구현해보자</em></p>\n<p><strong>*주의: 해당 글은 대략적인 구조를 설명함으로 실제 암호화폐의 구현과 다를 수 있습니다.</strong></p>\n<h2 id=\"구현\"><a href=\"#구현\" class=\"headerlink\" title=\"구현\"></a>구현</h2><p>지금까지 <a href=\"/programming/block-chain-js/\">블록의 구조를 살펴보는 것</a>으로 시작해 <a href=\"/programming/block-chain-js-1/\">채굴</a>, <a href=\"/programming/block-chain-js-2/\">블록 추가</a>, <a href=\"/programming/block-chain-js-3/\">거래 생성</a>과 관련된 코드를 구현했습니다. 오늘은 체인의 유효성을 검사하는 함수를 만들겠습니다. 이를 통해 거래 내역등의 변경을 감지해보도록 하겠습니다. 구현은 아래와 같이 합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> every = <span class=\"function\">(<span class=\"params\">coll, fn</span>) =&gt;</span> </span><br><span class=\"line\">  <span class=\"built_in\">Array</span>.isArray(coll) ? coll.every(fn) : keys(coll).every(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> fn(coll[key], key, coll));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">is_chain_valid</span>(<span class=\"params\">chain</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> every(chain, block =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> previous = chain[block.previousHash];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (block.hash !== calculate_hash(block)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (block.previousHash === <span class=\"string\">''</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// Genesis Block</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (block.previousHash !== calculate_hash(previous)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every\"></a>every</h4><p>쉽게 생각해서 체인에 얽혀있는 <strong>모든 블록을 순회하며 문제가 없는지 확인</strong>하는게 오늘의 주요 과제입니다. 이때 제격인 함수가 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/every\" target=\"_blank\" rel=\"noopener\"><code>every</code>라는 함수</a>입니다. 원래 Array의 메서드로 존재하는 이 함수를 객체인 <code>G.CHAIN</code>도 순회할 수 있도록 하기 위해 <code>every</code>와 같은 함수로 만들어줍니다. 이를 이용해서 <code>is_chain_valid</code>를 구현합니다. </p>\n<h4 id=\"is-chain-valid\"><a href=\"#is-chain-valid\" class=\"headerlink\" title=\"is_chain_valid\"></a>is_chain_valid</h4><p>우리가 확인해야할 내용은 크게 두가지 입니다. </p>\n<ol>\n<li>현재의 블록이 유효한지</li>\n<li>이전 블록과 잘 연결되어 있는지</li>\n</ol>\n<p>현재의 블록이 유효한지 확인하기 위해 해시값을 다시 계산해봅니다. 채굴하면서 생성한 해시값과 일치하지 않는다면 문제가 생긴 것으로 간주합니다. 그리고 지금 알고 있는 이전 블록의 해시값(<code>previousHash</code>)을 기반으로 블록을 찾고 마찬가지로 해시값을 다시 계산해서 유효성을 확인합니다. 만약 이전 블록의 해시값이 없다면 제네시스 블록이라고 간주합니다.</p>\n<h2 id=\"테스트\"><a href=\"#테스트\" class=\"headerlink\" title=\"테스트\"></a>테스트</h2><p>이전에 생성된 블록이 있다는 가정해에 아래와 같이 테스트해볼 수 있습니다. 특정 거래의 금액을 조정하면 아래와 같이 유효성 검사에 통과하지 못합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hash_key = keys(G.CHAIN)[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'[ Before ]\\n Chain Valid: '</span>, is_chain_valid(G.CHAIN)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Transactions: '</span>, G.CHAIN[hash_key].transactions, <span class=\"string\">'\\n'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">G.CHAIN[hash_key].transactions[<span class=\"number\">1</span>].amount = <span class=\"number\">0</span>; <span class=\"comment\">// 거래를 조작</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'[ After ]\\n Chain Valid: '</span>, is_chain_valid(G.CHAIN)); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Transactions: '</span>, G.CHAIN[hash_key].transactions);</span><br></pre></td></tr></table></figure>\n\n<p>오늘의 코드는 <a href=\"https://github.com/joeunha/block-js/blob/master/v04.js\" target=\"_blank\" rel=\"noopener\">Github</a>에서 확인하실 수 있습니다. 다음 시간부터는 각 기능을 조금씩 고도화 해보겠습니다.</p>\n<h2 id=\"사소한-라이브러리\"><a href=\"#사소한-라이브러리\" class=\"headerlink\" title=\"사소한 라이브러리\"></a>사소한 라이브러리</h2><p>구현부에서 살펴본 것처럼 <code>every</code> 같은 함수를 몇개 만들어두면 객체도 순회하며 원하는 일을 할 수 있습니다. 이를 위해 사용할 수 있는 라이브러리가 있지만 간단한 내용을 처리함으로 직접 만들어 사용하려고 합니다. functions.js라는 이름으로 파일을 만들고 함수 모음을 만들어 필요할때마다 꺼내서 사용하려고 합니다. 해당 코드는 <a href=\"https://github.com/joeunha/block-js/blob/master/lib/functions.js\" target=\"_blank\" rel=\"noopener\">Github</a>에서 확인하실 수 있습니다.    </p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>자바스크립트로 블록체인을 구현해보자</em></p>\n<p><strong>*주의: 해당 글은 대략적인 구조를 설명함으로 실제 암호화폐의 구현과 다를 수 있습니다.</strong></p>\n<h2 id=\"구현\"><a href=\"#구현\" class=\"headerlink\" title=\"구현\"></a>구현</h2><p>지금까지 <a href=\"/programming/block-chain-js/\">블록의 구조를 살펴보는 것</a>으로 시작해 <a href=\"/programming/block-chain-js-1/\">채굴</a>, <a href=\"/programming/block-chain-js-2/\">블록 추가</a>, <a href=\"/programming/block-chain-js-3/\">거래 생성</a>과 관련된 코드를 구현했습니다. 오늘은 체인의 유효성을 검사하는 함수를 만들겠습니다. 이를 통해 거래 내역등의 변경을 감지해보도록 하겠습니다. 구현은 아래와 같이 합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> every = <span class=\"function\">(<span class=\"params\">coll, fn</span>) =&gt;</span> </span><br><span class=\"line\">  <span class=\"built_in\">Array</span>.isArray(coll) ? coll.every(fn) : keys(coll).every(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> fn(coll[key], key, coll));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">is_chain_valid</span>(<span class=\"params\">chain</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> every(chain, block =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> previous = chain[block.previousHash];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (block.hash !== calculate_hash(block)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (block.previousHash === <span class=\"string\">''</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// Genesis Block</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (block.previousHash !== calculate_hash(previous)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"every\"><a href=\"#every\" class=\"headerlink\" title=\"every\"></a>every</h4><p>쉽게 생각해서 체인에 얽혀있는 <strong>모든 블록을 순회하며 문제가 없는지 확인</strong>하는게 오늘의 주요 과제입니다. 이때 제격인 함수가 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/every\" target=\"_blank\" rel=\"noopener\"><code>every</code>라는 함수</a>입니다. 원래 Array의 메서드로 존재하는 이 함수를 객체인 <code>G.CHAIN</code>도 순회할 수 있도록 하기 위해 <code>every</code>와 같은 함수로 만들어줍니다. 이를 이용해서 <code>is_chain_valid</code>를 구현합니다. </p>\n<h4 id=\"is-chain-valid\"><a href=\"#is-chain-valid\" class=\"headerlink\" title=\"is_chain_valid\"></a>is_chain_valid</h4><p>우리가 확인해야할 내용은 크게 두가지 입니다. </p>\n<ol>\n<li>현재의 블록이 유효한지</li>\n<li>이전 블록과 잘 연결되어 있는지</li>\n</ol>\n<p>현재의 블록이 유효한지 확인하기 위해 해시값을 다시 계산해봅니다. 채굴하면서 생성한 해시값과 일치하지 않는다면 문제가 생긴 것으로 간주합니다. 그리고 지금 알고 있는 이전 블록의 해시값(<code>previousHash</code>)을 기반으로 블록을 찾고 마찬가지로 해시값을 다시 계산해서 유효성을 확인합니다. 만약 이전 블록의 해시값이 없다면 제네시스 블록이라고 간주합니다.</p>\n<h2 id=\"테스트\"><a href=\"#테스트\" class=\"headerlink\" title=\"테스트\"></a>테스트</h2><p>이전에 생성된 블록이 있다는 가정해에 아래와 같이 테스트해볼 수 있습니다. 특정 거래의 금액을 조정하면 아래와 같이 유효성 검사에 통과하지 못합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hash_key = keys(G.CHAIN)[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'[ Before ]\\n Chain Valid: '</span>, is_chain_valid(G.CHAIN)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Transactions: '</span>, G.CHAIN[hash_key].transactions, <span class=\"string\">'\\n'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">G.CHAIN[hash_key].transactions[<span class=\"number\">1</span>].amount = <span class=\"number\">0</span>; <span class=\"comment\">// 거래를 조작</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'[ After ]\\n Chain Valid: '</span>, is_chain_valid(G.CHAIN)); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Transactions: '</span>, G.CHAIN[hash_key].transactions);</span><br></pre></td></tr></table></figure>\n\n<p>오늘의 코드는 <a href=\"https://github.com/joeunha/block-js/blob/master/v04.js\" target=\"_blank\" rel=\"noopener\">Github</a>에서 확인하실 수 있습니다. 다음 시간부터는 각 기능을 조금씩 고도화 해보겠습니다.</p>\n<h2 id=\"사소한-라이브러리\"><a href=\"#사소한-라이브러리\" class=\"headerlink\" title=\"사소한 라이브러리\"></a>사소한 라이브러리</h2><p>구현부에서 살펴본 것처럼 <code>every</code> 같은 함수를 몇개 만들어두면 객체도 순회하며 원하는 일을 할 수 있습니다. 이를 위해 사용할 수 있는 라이브러리가 있지만 간단한 내용을 처리함으로 직접 만들어 사용하려고 합니다. functions.js라는 이름으로 파일을 만들고 함수 모음을 만들어 필요할때마다 꺼내서 사용하려고 합니다. 해당 코드는 <a href=\"https://github.com/joeunha/block-js/blob/master/lib/functions.js\" target=\"_blank\" rel=\"noopener\">Github</a>에서 확인하실 수 있습니다.    </p>\n"},{"id":"544","title":"[Challenge] Portfolio Page 만들기","date":"2016-06-05T11:17:26.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=544","_content":"Tribute Page 만들기의 뒤를 잇는 두번째 Challenge는 &#8216;[개인 Portfoilo Page 만들기](https://www.freecodecamp.com/challenges/build-a-personal-portfolio-webpage)&#8216; 입니다. 예전부터 포트폴리오를 만들어야지 하면서 Github에 페이지를 만들어두기도 했는데 뭐부터 해야할지 몰라 시작조차 못했던 일을 FCC를 통해 하게 되었습니다.\n\n이전과 마찬가지로 [CodePen](http://codepen.io/)을 사용합니다. 역시나 [예시](https://codepen.io/FreeCodeCamp/full/YqLyXB/)를 주는데요. 예시의 코드를 볼 순 없습니다. 사실 클릭 한번이면 코드를 다 볼 수 있지만, 양심에 맡깁니다. 그게 실력이 느는 일 이니까요. 이를 만들기 위해 몇가지 기본적으로 갖춰야할 기능에 대해 설명합니다. 기본적으로 단일 페이지를 스크롤해서 모든 컨텐츠를 볼 수 있도록 만들어야합니다. Bootstrap 이외의 라이브러리를 사용해도 괜찮다고 합니다. 클릭해서 다른 소셜 미디어로의 이동이 가능한  버튼을 만들어야합니다.\n\n며칠간 바빠서 미루다가 하루정도 마음 잡고 이것 저것 찾아가며 허접한 [포트폴리오](http://codepen.io/rabbylab/full/gMOOBK/)를 만들었습니다. 사실 마땅히 들어갈 작업물이 없어서 그냥 형태만 갖췄습니다. 이후에 작업물이 생기면 업데이트할 생각입니다. 전반적인 기능도 미흡합니다. 예시를 보면 스크롤하면 특정 세션에 이를때 버튼이 자동으로 활성화/비활성화 되는데, 저는 그 부분은 구현하지 않았습니다. 또 Contact Me 파트를 통해 연락하는 기능도 없습니다.정말 기본으로 해야할 것만 했습니다.\n\n이번 과제를 통해 배운 것이 있다면 <section> 이라는 태그가 있다는 점, 이를 이용해서 단일 페이지 내에서 링크로 이동이 가능하다는 점입니다. 그리고 Bootstrap의 스크립트 기능을 사용하기 위해선 .js 파일을 따로 추가해줘야한다는&#8230;상식적인 부분도 깨쳤습니다. (이 부분을 몰라서 navbar의 collapse 기능이 동작하지 않아서 제법 오래 당황했었습니다. 부끄럽네요.)\n\n아직도 모르겠는 부분은 페이지 구조를 구성할 때 얼마나 조밀하게 짜야하는가 하는 부분입니다. 또 얼마나 CSS 를 사용해서 커스텀 해야하고 얼마나 기본의 라이브러리를 활용해야하는 부분입니다. 실컷 CSS 로 스타일을 지정 했는데 막상 더 예쁜 기본값을 라이브러리에서 발견할 때면 어디까지 라이브러리를 써야하고 어디까지 직접 코딩 해야하는지 잘 모르겠습니다.\n\n이제부터는 Javascript를 사용하는 방법을 배울 것 같습니다. 기초가 되는 부분은 빨리 진행하고 조금 깊은 자바스크립트를 다뤄보고 싶네요. 이후에 객체지향도 다루고 기초적인 알고리즘도 다루는 것 같아 기대가 됩니다.","source":"_posts/challenge-portfolio-page.md","raw":"---\nid: 544\ntitle: '[Challenge] Portfolio Page 만들기'\ndate: 2016-06-05T20:17:26+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=544\npermalink: /challenge-portfolio-page/\ncategories:\n  - rabbylab\ntags:\n  - freecodecamp\n---\nTribute Page 만들기의 뒤를 잇는 두번째 Challenge는 &#8216;[개인 Portfoilo Page 만들기](https://www.freecodecamp.com/challenges/build-a-personal-portfolio-webpage)&#8216; 입니다. 예전부터 포트폴리오를 만들어야지 하면서 Github에 페이지를 만들어두기도 했는데 뭐부터 해야할지 몰라 시작조차 못했던 일을 FCC를 통해 하게 되었습니다.\n\n이전과 마찬가지로 [CodePen](http://codepen.io/)을 사용합니다. 역시나 [예시](https://codepen.io/FreeCodeCamp/full/YqLyXB/)를 주는데요. 예시의 코드를 볼 순 없습니다. 사실 클릭 한번이면 코드를 다 볼 수 있지만, 양심에 맡깁니다. 그게 실력이 느는 일 이니까요. 이를 만들기 위해 몇가지 기본적으로 갖춰야할 기능에 대해 설명합니다. 기본적으로 단일 페이지를 스크롤해서 모든 컨텐츠를 볼 수 있도록 만들어야합니다. Bootstrap 이외의 라이브러리를 사용해도 괜찮다고 합니다. 클릭해서 다른 소셜 미디어로의 이동이 가능한  버튼을 만들어야합니다.\n\n며칠간 바빠서 미루다가 하루정도 마음 잡고 이것 저것 찾아가며 허접한 [포트폴리오](http://codepen.io/rabbylab/full/gMOOBK/)를 만들었습니다. 사실 마땅히 들어갈 작업물이 없어서 그냥 형태만 갖췄습니다. 이후에 작업물이 생기면 업데이트할 생각입니다. 전반적인 기능도 미흡합니다. 예시를 보면 스크롤하면 특정 세션에 이를때 버튼이 자동으로 활성화/비활성화 되는데, 저는 그 부분은 구현하지 않았습니다. 또 Contact Me 파트를 통해 연락하는 기능도 없습니다.정말 기본으로 해야할 것만 했습니다.\n\n이번 과제를 통해 배운 것이 있다면 <section> 이라는 태그가 있다는 점, 이를 이용해서 단일 페이지 내에서 링크로 이동이 가능하다는 점입니다. 그리고 Bootstrap의 스크립트 기능을 사용하기 위해선 .js 파일을 따로 추가해줘야한다는&#8230;상식적인 부분도 깨쳤습니다. (이 부분을 몰라서 navbar의 collapse 기능이 동작하지 않아서 제법 오래 당황했었습니다. 부끄럽네요.)\n\n아직도 모르겠는 부분은 페이지 구조를 구성할 때 얼마나 조밀하게 짜야하는가 하는 부분입니다. 또 얼마나 CSS 를 사용해서 커스텀 해야하고 얼마나 기본의 라이브러리를 활용해야하는 부분입니다. 실컷 CSS 로 스타일을 지정 했는데 막상 더 예쁜 기본값을 라이브러리에서 발견할 때면 어디까지 라이브러리를 써야하고 어디까지 직접 코딩 해야하는지 잘 모르겠습니다.\n\n이제부터는 Javascript를 사용하는 방법을 배울 것 같습니다. 기초가 되는 부분은 빨리 진행하고 조금 깊은 자바스크립트를 다뤄보고 싶네요. 이후에 객체지향도 다루고 기초적인 알고리즘도 다루는 것 같아 기대가 됩니다.","slug":"/challenge-portfolio-page/","published":1,"updated":"2019-12-05T15:05:29.482Z","comments":1,"photos":[],"link":"","_id":"ck6jcr9f1000hdirv61nn999k","content":"<p>Tribute Page 만들기의 뒤를 잇는 두번째 Challenge는 &#8216;<a href=\"https://www.freecodecamp.com/challenges/build-a-personal-portfolio-webpage\" target=\"_blank\" rel=\"noopener\">개인 Portfoilo Page 만들기</a>&#8216; 입니다. 예전부터 포트폴리오를 만들어야지 하면서 Github에 페이지를 만들어두기도 했는데 뭐부터 해야할지 몰라 시작조차 못했던 일을 FCC를 통해 하게 되었습니다.</p>\n<p>이전과 마찬가지로 <a href=\"http://codepen.io/\" target=\"_blank\" rel=\"noopener\">CodePen</a>을 사용합니다. 역시나 <a href=\"https://codepen.io/FreeCodeCamp/full/YqLyXB/\" target=\"_blank\" rel=\"noopener\">예시</a>를 주는데요. 예시의 코드를 볼 순 없습니다. 사실 클릭 한번이면 코드를 다 볼 수 있지만, 양심에 맡깁니다. 그게 실력이 느는 일 이니까요. 이를 만들기 위해 몇가지 기본적으로 갖춰야할 기능에 대해 설명합니다. 기본적으로 단일 페이지를 스크롤해서 모든 컨텐츠를 볼 수 있도록 만들어야합니다. Bootstrap 이외의 라이브러리를 사용해도 괜찮다고 합니다. 클릭해서 다른 소셜 미디어로의 이동이 가능한  버튼을 만들어야합니다.</p>\n<p>며칠간 바빠서 미루다가 하루정도 마음 잡고 이것 저것 찾아가며 허접한 <a href=\"http://codepen.io/rabbylab/full/gMOOBK/\" target=\"_blank\" rel=\"noopener\">포트폴리오</a>를 만들었습니다. 사실 마땅히 들어갈 작업물이 없어서 그냥 형태만 갖췄습니다. 이후에 작업물이 생기면 업데이트할 생각입니다. 전반적인 기능도 미흡합니다. 예시를 보면 스크롤하면 특정 세션에 이를때 버튼이 자동으로 활성화/비활성화 되는데, 저는 그 부분은 구현하지 않았습니다. 또 Contact Me 파트를 통해 연락하는 기능도 없습니다.정말 기본으로 해야할 것만 했습니다.</p>\n<p>이번 과제를 통해 배운 것이 있다면 <section> 이라는 태그가 있다는 점, 이를 이용해서 단일 페이지 내에서 링크로 이동이 가능하다는 점입니다. 그리고 Bootstrap의 스크립트 기능을 사용하기 위해선 .js 파일을 따로 추가해줘야한다는&#8230;상식적인 부분도 깨쳤습니다. (이 부분을 몰라서 navbar의 collapse 기능이 동작하지 않아서 제법 오래 당황했었습니다. 부끄럽네요.)</section></p>\n<p>아직도 모르겠는 부분은 페이지 구조를 구성할 때 얼마나 조밀하게 짜야하는가 하는 부분입니다. 또 얼마나 CSS 를 사용해서 커스텀 해야하고 얼마나 기본의 라이브러리를 활용해야하는 부분입니다. 실컷 CSS 로 스타일을 지정 했는데 막상 더 예쁜 기본값을 라이브러리에서 발견할 때면 어디까지 라이브러리를 써야하고 어디까지 직접 코딩 해야하는지 잘 모르겠습니다.</p>\n<p>이제부터는 Javascript를 사용하는 방법을 배울 것 같습니다. 기초가 되는 부분은 빨리 진행하고 조금 깊은 자바스크립트를 다뤄보고 싶네요. 이후에 객체지향도 다루고 기초적인 알고리즘도 다루는 것 같아 기대가 됩니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Tribute Page 만들기의 뒤를 잇는 두번째 Challenge는 &#8216;<a href=\"https://www.freecodecamp.com/challenges/build-a-personal-portfolio-webpage\" target=\"_blank\" rel=\"noopener\">개인 Portfoilo Page 만들기</a>&#8216; 입니다. 예전부터 포트폴리오를 만들어야지 하면서 Github에 페이지를 만들어두기도 했는데 뭐부터 해야할지 몰라 시작조차 못했던 일을 FCC를 통해 하게 되었습니다.</p>\n<p>이전과 마찬가지로 <a href=\"http://codepen.io/\" target=\"_blank\" rel=\"noopener\">CodePen</a>을 사용합니다. 역시나 <a href=\"https://codepen.io/FreeCodeCamp/full/YqLyXB/\" target=\"_blank\" rel=\"noopener\">예시</a>를 주는데요. 예시의 코드를 볼 순 없습니다. 사실 클릭 한번이면 코드를 다 볼 수 있지만, 양심에 맡깁니다. 그게 실력이 느는 일 이니까요. 이를 만들기 위해 몇가지 기본적으로 갖춰야할 기능에 대해 설명합니다. 기본적으로 단일 페이지를 스크롤해서 모든 컨텐츠를 볼 수 있도록 만들어야합니다. Bootstrap 이외의 라이브러리를 사용해도 괜찮다고 합니다. 클릭해서 다른 소셜 미디어로의 이동이 가능한  버튼을 만들어야합니다.</p>\n<p>며칠간 바빠서 미루다가 하루정도 마음 잡고 이것 저것 찾아가며 허접한 <a href=\"http://codepen.io/rabbylab/full/gMOOBK/\" target=\"_blank\" rel=\"noopener\">포트폴리오</a>를 만들었습니다. 사실 마땅히 들어갈 작업물이 없어서 그냥 형태만 갖췄습니다. 이후에 작업물이 생기면 업데이트할 생각입니다. 전반적인 기능도 미흡합니다. 예시를 보면 스크롤하면 특정 세션에 이를때 버튼이 자동으로 활성화/비활성화 되는데, 저는 그 부분은 구현하지 않았습니다. 또 Contact Me 파트를 통해 연락하는 기능도 없습니다.정말 기본으로 해야할 것만 했습니다.</p>\n<p>이번 과제를 통해 배운 것이 있다면 <section> 이라는 태그가 있다는 점, 이를 이용해서 단일 페이지 내에서 링크로 이동이 가능하다는 점입니다. 그리고 Bootstrap의 스크립트 기능을 사용하기 위해선 .js 파일을 따로 추가해줘야한다는&#8230;상식적인 부분도 깨쳤습니다. (이 부분을 몰라서 navbar의 collapse 기능이 동작하지 않아서 제법 오래 당황했었습니다. 부끄럽네요.)</section></p>\n<p>아직도 모르겠는 부분은 페이지 구조를 구성할 때 얼마나 조밀하게 짜야하는가 하는 부분입니다. 또 얼마나 CSS 를 사용해서 커스텀 해야하고 얼마나 기본의 라이브러리를 활용해야하는 부분입니다. 실컷 CSS 로 스타일을 지정 했는데 막상 더 예쁜 기본값을 라이브러리에서 발견할 때면 어디까지 라이브러리를 써야하고 어디까지 직접 코딩 해야하는지 잘 모르겠습니다.</p>\n<p>이제부터는 Javascript를 사용하는 방법을 배울 것 같습니다. 기초가 되는 부분은 빨리 진행하고 조금 깊은 자바스크립트를 다뤄보고 싶네요. 이후에 객체지향도 다루고 기초적인 알고리즘도 다루는 것 같아 기대가 됩니다.</p>\n"},{"title":"자바스크립트로 블록체인 - block","date":"2018-06-21T02:37:34.000Z","description":"자바스크립트로 블록체인을 구현해보자","_content":"_자바스크립트로 블록체인을 구현해보자_\n\n## Intro\n\n블록체인에 대한 막연한 호기심을 가지고 있다가, 대략의 원리라도 알아야겠다 싶어 공부를 했습니다. 분산형 장부, 암호화 기술로 만들어지는 경제와 그곳에서 통용되는 화폐인 암호 화폐에 대한 이야기를 조금씩 공부했습니다. 책도 읽어보고 영상도 찾아봤습니다.  \n띄엄띄엄 이해가 되지만 역시 코드로 구현해보지 않고서는 제대로 이해할 수가 없었습니다. 그래서 검색했습니다. 'JavaScript', 'BlockChain' 등의 키워드로 검색했더니 아니나다를까 이미 자바스크립트로 블록체인을 구현한 자료가 많았습니다.\n\n저는 그 중에 Savjee라는 분이 유튜브에 올려둔 [영상](https://youtu.be/zVqczFZr124)과 [코드](https://github.com/SavjeeTutorials/SavjeeCoin)를 참고했습니다. 객체 지향으로 구현한 방식을 제 방식으로 풀어서 정리해보려고 합니다. 이전에 소개해드린 함수들도 사용하면서 다소 정신 없이 코드를 써내려가볼까 합니다. 몇차례 쓰게 될지 모르지만 일단 시작합니다.\n\n**앞으로의 글은 아주 대략적으로 제가 이해하고 있는 수준에서만 설명하겠습니다. 이하 모든 내용은 정확한 설명이 아닐 수 있음을 미리 밝힙니다.**  \n\n## 기본 개념\n\n블록체인에서 말하는 블록은 거래내역을 모아둔 데이터 구조 단위입니다. 여기에 블록이 체인이 되기 위해 다른 블록의 주소값을 가지고 있죠. 그리고 블록이 생성된 시간과 자신의 주소값을 가지고 있습니다. 그래서 아래와 같은 데이터 구조를 갖습니다. (구현을 위한 간략한 구조입니다.)\n\n```javascript\nlet Block = { \n  previousHash: '',\n  timestamp: '2018-06-22T07:29:19.198Z',\n  transactions: [ { a: 10, b: -10 }, { a: -10, b: 20, c: -10 } ],\n  nonce: 79431,\n  hash: '0000c067110339dd0f6d844112fa3a7a02142ccb133aad2dc6ebb4709c7651c7'\n};\n```\n\n#### previousHash\n__이전 블록의 해시값입니다.__ 예제의 경우 `previousHash`가 빈 문자열이 담겨있는데, 이는 해당 블록이 최초의 블록이기 때문입니다. 블록체인에서는 최초의 블록을 Genesis Block이라고 부릅니다. 두번째로 생기는 블록은 이 블록의 해시값을 `previousHash`로 갖게 됩니다.\n\n#### timestamp\n__블록이 생성된 시간 데이터입니다.__ 이 부분에 대해서도 제대로 다룰려면 글 하나를 써야할 것 같습니다. [참고한 글](https://jscript.me/2018/04/16/공부하자-블록체인2-타임스탬프서버에-대해-이해하/)에 따르면 블록체인에서의 타임스탬프는 기존의 그것과 다른 점이 많다고 합니다. 우선은 블록이 생성된 시간이라고 알아두죠.\n\n#### transactions\n__발생한 거래의 내역(리스트)입니다.__ 실제로는 머클트리(Merkle Tree)라는 구조로 거래 내역을 담아두고 이를 저장합니다. 저는 간단하게 배열의 형태로 거래 내역을 담아두겠습니다. 거래는 객체 형태로 담아두는데 `{ a: 10, b: -10 }` 이렇게 적어둔건 그냥 'a의 잔고가 10만큼 늘었고, b의 잔고는 10만큼 줄었다.'는 뜻이라고 해두겠습니다.\n\n#### nonce\n__해시값을 얻기 위해 찾아야하는 값입니다.__ 미리 설명하지 않은 이 값은 채굴(mining)이라고 일컫는 작업을 통해 구해지는 값 중 하나입니다. 여기서 채굴에 대해 잠시 언급하고 지나가면, 아시다시피 노드(참가자)들은 채굴을 통해 보상(화폐)을 얻습니다. 여기서 말하는 __채굴은 `hash`라는 값을 구하는 활동__입니다. 원하는 `hash` 값을 얻기 위해서 `nonce`라는 값을 계속 바꿔보면서 결과 값을 맞춰봐야 합니다. 결과적으로 우리가 원하는 형태의 `hash`가 생성되면 그때 사용된 `nonce`가 블록에 기록되는 것입니다. (이렇게 만들어진 값을 가지고 다른 노드들이 제대로 `hash`가 만들어진 것인지 확인하는 작업이 바로 작업증명(PoW: Proof of Work)인 것이죠.)\n \n#### hash\n__해당 블록의 주소 값입니다.__ 채굴을 통해 얻어진 값인 `hash`는 예제와 같이 아주 길고 복잡한 문자열로 구성되어 있습니다. 16진수(Hexadecimal)로 표기되는 값으로 암호화 알고리즘인 SHA256으로 만들어진 해시함수가 생성한 값입니다. 이때 해시함수에 인자로 주어지는 값들은 `previousHash`, `timestamp`, `transactions`, `nonce`입니다. 이 값들의 조합은 유니크합니다. 때문에 이 값을 해시함수에 통과시키면 본 블록만의 유니크한 `hash`값을 만들 수 있습니다.\n\n아마 이쯤에서 의문이 생기거나 뭔가 아다리(?)가 맞지 않는다고 느껴지실 겁니다. 도대체 `hash` 값이 어떻게 생겨먹어야하길래 보상을 줄만큼 구하기 어렵다는 것이냐, 그냥 `nonce`에 아무 숫자나 때려 넣으면 되는 것 아니냐 하는 생각이 드실 겁니다. 당연한 생각입니다. 블록체인에서는 원하는 `hash` 값에 제약 조건을 겁니다. 이 조건은 특정 숫자보다 `hash` 값이 작아야한다는 조건입니다. 특정 숫자를 구하는 방식은 [여길 참고](https://brunch.co.kr/@loum/35)하시면 됩니다. \n\n#### difficulty\n예제의 데이터 구조에는 포함하지 않았지만, 제약 조건이 얼마나 어려운 제약인지를 설명하는 것을 난이도(Difficulty)라고 부릅니다. 조금 쉽게 구현하기 위해 저는 __난이도만큼의 0을 `hash`가 앞자리로 가져야한다는 조건__으로 제약을 두고 구현할 예정입니다. 예제의 경우는 `hash`값의 시작 지점에 0이 4개(`0000c067...`)임으로 난이도가 4입니다.  \n ","source":"_posts/block-chain-js-0.md","raw":"---\ntitle: '자바스크립트로 블록체인 - block'\ncategories:\n  - programming\ntags:\n  - javascript\n  - 자바스크립트\n  - blockchain\n  - 블록체인\ndate: 2018-06-21 11:37:34\ndescription: 자바스크립트로 블록체인을 구현해보자\n---\n_자바스크립트로 블록체인을 구현해보자_\n\n## Intro\n\n블록체인에 대한 막연한 호기심을 가지고 있다가, 대략의 원리라도 알아야겠다 싶어 공부를 했습니다. 분산형 장부, 암호화 기술로 만들어지는 경제와 그곳에서 통용되는 화폐인 암호 화폐에 대한 이야기를 조금씩 공부했습니다. 책도 읽어보고 영상도 찾아봤습니다.  \n띄엄띄엄 이해가 되지만 역시 코드로 구현해보지 않고서는 제대로 이해할 수가 없었습니다. 그래서 검색했습니다. 'JavaScript', 'BlockChain' 등의 키워드로 검색했더니 아니나다를까 이미 자바스크립트로 블록체인을 구현한 자료가 많았습니다.\n\n저는 그 중에 Savjee라는 분이 유튜브에 올려둔 [영상](https://youtu.be/zVqczFZr124)과 [코드](https://github.com/SavjeeTutorials/SavjeeCoin)를 참고했습니다. 객체 지향으로 구현한 방식을 제 방식으로 풀어서 정리해보려고 합니다. 이전에 소개해드린 함수들도 사용하면서 다소 정신 없이 코드를 써내려가볼까 합니다. 몇차례 쓰게 될지 모르지만 일단 시작합니다.\n\n**앞으로의 글은 아주 대략적으로 제가 이해하고 있는 수준에서만 설명하겠습니다. 이하 모든 내용은 정확한 설명이 아닐 수 있음을 미리 밝힙니다.**  \n\n## 기본 개념\n\n블록체인에서 말하는 블록은 거래내역을 모아둔 데이터 구조 단위입니다. 여기에 블록이 체인이 되기 위해 다른 블록의 주소값을 가지고 있죠. 그리고 블록이 생성된 시간과 자신의 주소값을 가지고 있습니다. 그래서 아래와 같은 데이터 구조를 갖습니다. (구현을 위한 간략한 구조입니다.)\n\n```javascript\nlet Block = { \n  previousHash: '',\n  timestamp: '2018-06-22T07:29:19.198Z',\n  transactions: [ { a: 10, b: -10 }, { a: -10, b: 20, c: -10 } ],\n  nonce: 79431,\n  hash: '0000c067110339dd0f6d844112fa3a7a02142ccb133aad2dc6ebb4709c7651c7'\n};\n```\n\n#### previousHash\n__이전 블록의 해시값입니다.__ 예제의 경우 `previousHash`가 빈 문자열이 담겨있는데, 이는 해당 블록이 최초의 블록이기 때문입니다. 블록체인에서는 최초의 블록을 Genesis Block이라고 부릅니다. 두번째로 생기는 블록은 이 블록의 해시값을 `previousHash`로 갖게 됩니다.\n\n#### timestamp\n__블록이 생성된 시간 데이터입니다.__ 이 부분에 대해서도 제대로 다룰려면 글 하나를 써야할 것 같습니다. [참고한 글](https://jscript.me/2018/04/16/공부하자-블록체인2-타임스탬프서버에-대해-이해하/)에 따르면 블록체인에서의 타임스탬프는 기존의 그것과 다른 점이 많다고 합니다. 우선은 블록이 생성된 시간이라고 알아두죠.\n\n#### transactions\n__발생한 거래의 내역(리스트)입니다.__ 실제로는 머클트리(Merkle Tree)라는 구조로 거래 내역을 담아두고 이를 저장합니다. 저는 간단하게 배열의 형태로 거래 내역을 담아두겠습니다. 거래는 객체 형태로 담아두는데 `{ a: 10, b: -10 }` 이렇게 적어둔건 그냥 'a의 잔고가 10만큼 늘었고, b의 잔고는 10만큼 줄었다.'는 뜻이라고 해두겠습니다.\n\n#### nonce\n__해시값을 얻기 위해 찾아야하는 값입니다.__ 미리 설명하지 않은 이 값은 채굴(mining)이라고 일컫는 작업을 통해 구해지는 값 중 하나입니다. 여기서 채굴에 대해 잠시 언급하고 지나가면, 아시다시피 노드(참가자)들은 채굴을 통해 보상(화폐)을 얻습니다. 여기서 말하는 __채굴은 `hash`라는 값을 구하는 활동__입니다. 원하는 `hash` 값을 얻기 위해서 `nonce`라는 값을 계속 바꿔보면서 결과 값을 맞춰봐야 합니다. 결과적으로 우리가 원하는 형태의 `hash`가 생성되면 그때 사용된 `nonce`가 블록에 기록되는 것입니다. (이렇게 만들어진 값을 가지고 다른 노드들이 제대로 `hash`가 만들어진 것인지 확인하는 작업이 바로 작업증명(PoW: Proof of Work)인 것이죠.)\n \n#### hash\n__해당 블록의 주소 값입니다.__ 채굴을 통해 얻어진 값인 `hash`는 예제와 같이 아주 길고 복잡한 문자열로 구성되어 있습니다. 16진수(Hexadecimal)로 표기되는 값으로 암호화 알고리즘인 SHA256으로 만들어진 해시함수가 생성한 값입니다. 이때 해시함수에 인자로 주어지는 값들은 `previousHash`, `timestamp`, `transactions`, `nonce`입니다. 이 값들의 조합은 유니크합니다. 때문에 이 값을 해시함수에 통과시키면 본 블록만의 유니크한 `hash`값을 만들 수 있습니다.\n\n아마 이쯤에서 의문이 생기거나 뭔가 아다리(?)가 맞지 않는다고 느껴지실 겁니다. 도대체 `hash` 값이 어떻게 생겨먹어야하길래 보상을 줄만큼 구하기 어렵다는 것이냐, 그냥 `nonce`에 아무 숫자나 때려 넣으면 되는 것 아니냐 하는 생각이 드실 겁니다. 당연한 생각입니다. 블록체인에서는 원하는 `hash` 값에 제약 조건을 겁니다. 이 조건은 특정 숫자보다 `hash` 값이 작아야한다는 조건입니다. 특정 숫자를 구하는 방식은 [여길 참고](https://brunch.co.kr/@loum/35)하시면 됩니다. \n\n#### difficulty\n예제의 데이터 구조에는 포함하지 않았지만, 제약 조건이 얼마나 어려운 제약인지를 설명하는 것을 난이도(Difficulty)라고 부릅니다. 조금 쉽게 구현하기 위해 저는 __난이도만큼의 0을 `hash`가 앞자리로 가져야한다는 조건__으로 제약을 두고 구현할 예정입니다. 예제의 경우는 `hash`값의 시작 지점에 0이 4개(`0000c067...`)임으로 난이도가 4입니다.  \n ","slug":"block-chain-js-0","published":1,"updated":"2019-12-05T15:06:08.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9f3000kdirvepeii5ne","content":"<p><em>자바스크립트로 블록체인을 구현해보자</em></p>\n<h2 id=\"Intro\"><a href=\"#Intro\" class=\"headerlink\" title=\"Intro\"></a>Intro</h2><p>블록체인에 대한 막연한 호기심을 가지고 있다가, 대략의 원리라도 알아야겠다 싶어 공부를 했습니다. 분산형 장부, 암호화 기술로 만들어지는 경제와 그곳에서 통용되는 화폐인 암호 화폐에 대한 이야기를 조금씩 공부했습니다. 책도 읽어보고 영상도 찾아봤습니다.<br>띄엄띄엄 이해가 되지만 역시 코드로 구현해보지 않고서는 제대로 이해할 수가 없었습니다. 그래서 검색했습니다. ‘JavaScript’, ‘BlockChain’ 등의 키워드로 검색했더니 아니나다를까 이미 자바스크립트로 블록체인을 구현한 자료가 많았습니다.</p>\n<p>저는 그 중에 Savjee라는 분이 유튜브에 올려둔 <a href=\"https://youtu.be/zVqczFZr124\" target=\"_blank\" rel=\"noopener\">영상</a>과 <a href=\"https://github.com/SavjeeTutorials/SavjeeCoin\" target=\"_blank\" rel=\"noopener\">코드</a>를 참고했습니다. 객체 지향으로 구현한 방식을 제 방식으로 풀어서 정리해보려고 합니다. 이전에 소개해드린 함수들도 사용하면서 다소 정신 없이 코드를 써내려가볼까 합니다. 몇차례 쓰게 될지 모르지만 일단 시작합니다.</p>\n<p><strong>앞으로의 글은 아주 대략적으로 제가 이해하고 있는 수준에서만 설명하겠습니다. 이하 모든 내용은 정확한 설명이 아닐 수 있음을 미리 밝힙니다.</strong>  </p>\n<h2 id=\"기본-개념\"><a href=\"#기본-개념\" class=\"headerlink\" title=\"기본 개념\"></a>기본 개념</h2><p>블록체인에서 말하는 블록은 거래내역을 모아둔 데이터 구조 단위입니다. 여기에 블록이 체인이 되기 위해 다른 블록의 주소값을 가지고 있죠. 그리고 블록이 생성된 시간과 자신의 주소값을 가지고 있습니다. 그래서 아래와 같은 데이터 구조를 갖습니다. (구현을 위한 간략한 구조입니다.)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Block = &#123; </span><br><span class=\"line\">  previousHash: <span class=\"string\">''</span>,</span><br><span class=\"line\">  timestamp: <span class=\"string\">'2018-06-22T07:29:19.198Z'</span>,</span><br><span class=\"line\">  transactions: [ &#123; <span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">-10</span> &#125;, &#123; <span class=\"attr\">a</span>: <span class=\"number\">-10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span>, <span class=\"attr\">c</span>: <span class=\"number\">-10</span> &#125; ],</span><br><span class=\"line\">  nonce: <span class=\"number\">79431</span>,</span><br><span class=\"line\">  hash: <span class=\"string\">'0000c067110339dd0f6d844112fa3a7a02142ccb133aad2dc6ebb4709c7651c7'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"previousHash\"><a href=\"#previousHash\" class=\"headerlink\" title=\"previousHash\"></a>previousHash</h4><p><strong>이전 블록의 해시값입니다.</strong> 예제의 경우 <code>previousHash</code>가 빈 문자열이 담겨있는데, 이는 해당 블록이 최초의 블록이기 때문입니다. 블록체인에서는 최초의 블록을 Genesis Block이라고 부릅니다. 두번째로 생기는 블록은 이 블록의 해시값을 <code>previousHash</code>로 갖게 됩니다.</p>\n<h4 id=\"timestamp\"><a href=\"#timestamp\" class=\"headerlink\" title=\"timestamp\"></a>timestamp</h4><p><strong>블록이 생성된 시간 데이터입니다.</strong> 이 부분에 대해서도 제대로 다룰려면 글 하나를 써야할 것 같습니다. <a href=\"https://jscript.me/2018/04/16/공부하자-블록체인2-타임스탬프서버에-대해-이해하/\" target=\"_blank\" rel=\"noopener\">참고한 글</a>에 따르면 블록체인에서의 타임스탬프는 기존의 그것과 다른 점이 많다고 합니다. 우선은 블록이 생성된 시간이라고 알아두죠.</p>\n<h4 id=\"transactions\"><a href=\"#transactions\" class=\"headerlink\" title=\"transactions\"></a>transactions</h4><p><strong>발생한 거래의 내역(리스트)입니다.</strong> 실제로는 머클트리(Merkle Tree)라는 구조로 거래 내역을 담아두고 이를 저장합니다. 저는 간단하게 배열의 형태로 거래 내역을 담아두겠습니다. 거래는 객체 형태로 담아두는데 <code>{ a: 10, b: -10 }</code> 이렇게 적어둔건 그냥 ‘a의 잔고가 10만큼 늘었고, b의 잔고는 10만큼 줄었다.’는 뜻이라고 해두겠습니다.</p>\n<h4 id=\"nonce\"><a href=\"#nonce\" class=\"headerlink\" title=\"nonce\"></a>nonce</h4><p><strong>해시값을 얻기 위해 찾아야하는 값입니다.</strong> 미리 설명하지 않은 이 값은 채굴(mining)이라고 일컫는 작업을 통해 구해지는 값 중 하나입니다. 여기서 채굴에 대해 잠시 언급하고 지나가면, 아시다시피 노드(참가자)들은 채굴을 통해 보상(화폐)을 얻습니다. 여기서 말하는 <strong>채굴은 <code>hash</code>라는 값을 구하는 활동</strong>입니다. 원하는 <code>hash</code> 값을 얻기 위해서 <code>nonce</code>라는 값을 계속 바꿔보면서 결과 값을 맞춰봐야 합니다. 결과적으로 우리가 원하는 형태의 <code>hash</code>가 생성되면 그때 사용된 <code>nonce</code>가 블록에 기록되는 것입니다. (이렇게 만들어진 값을 가지고 다른 노드들이 제대로 <code>hash</code>가 만들어진 것인지 확인하는 작업이 바로 작업증명(PoW: Proof of Work)인 것이죠.)</p>\n<h4 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h4><p><strong>해당 블록의 주소 값입니다.</strong> 채굴을 통해 얻어진 값인 <code>hash</code>는 예제와 같이 아주 길고 복잡한 문자열로 구성되어 있습니다. 16진수(Hexadecimal)로 표기되는 값으로 암호화 알고리즘인 SHA256으로 만들어진 해시함수가 생성한 값입니다. 이때 해시함수에 인자로 주어지는 값들은 <code>previousHash</code>, <code>timestamp</code>, <code>transactions</code>, <code>nonce</code>입니다. 이 값들의 조합은 유니크합니다. 때문에 이 값을 해시함수에 통과시키면 본 블록만의 유니크한 <code>hash</code>값을 만들 수 있습니다.</p>\n<p>아마 이쯤에서 의문이 생기거나 뭔가 아다리(?)가 맞지 않는다고 느껴지실 겁니다. 도대체 <code>hash</code> 값이 어떻게 생겨먹어야하길래 보상을 줄만큼 구하기 어렵다는 것이냐, 그냥 <code>nonce</code>에 아무 숫자나 때려 넣으면 되는 것 아니냐 하는 생각이 드실 겁니다. 당연한 생각입니다. 블록체인에서는 원하는 <code>hash</code> 값에 제약 조건을 겁니다. 이 조건은 특정 숫자보다 <code>hash</code> 값이 작아야한다는 조건입니다. 특정 숫자를 구하는 방식은 <a href=\"https://brunch.co.kr/@loum/35\" target=\"_blank\" rel=\"noopener\">여길 참고</a>하시면 됩니다. </p>\n<h4 id=\"difficulty\"><a href=\"#difficulty\" class=\"headerlink\" title=\"difficulty\"></a>difficulty</h4><p>예제의 데이터 구조에는 포함하지 않았지만, 제약 조건이 얼마나 어려운 제약인지를 설명하는 것을 난이도(Difficulty)라고 부릅니다. 조금 쉽게 구현하기 위해 저는 <strong>난이도만큼의 0을 <code>hash</code>가 앞자리로 가져야한다는 조건</strong>으로 제약을 두고 구현할 예정입니다. 예제의 경우는 <code>hash</code>값의 시작 지점에 0이 4개(<code>0000c067...</code>)임으로 난이도가 4입니다.  </p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>자바스크립트로 블록체인을 구현해보자</em></p>\n<h2 id=\"Intro\"><a href=\"#Intro\" class=\"headerlink\" title=\"Intro\"></a>Intro</h2><p>블록체인에 대한 막연한 호기심을 가지고 있다가, 대략의 원리라도 알아야겠다 싶어 공부를 했습니다. 분산형 장부, 암호화 기술로 만들어지는 경제와 그곳에서 통용되는 화폐인 암호 화폐에 대한 이야기를 조금씩 공부했습니다. 책도 읽어보고 영상도 찾아봤습니다.<br>띄엄띄엄 이해가 되지만 역시 코드로 구현해보지 않고서는 제대로 이해할 수가 없었습니다. 그래서 검색했습니다. ‘JavaScript’, ‘BlockChain’ 등의 키워드로 검색했더니 아니나다를까 이미 자바스크립트로 블록체인을 구현한 자료가 많았습니다.</p>\n<p>저는 그 중에 Savjee라는 분이 유튜브에 올려둔 <a href=\"https://youtu.be/zVqczFZr124\" target=\"_blank\" rel=\"noopener\">영상</a>과 <a href=\"https://github.com/SavjeeTutorials/SavjeeCoin\" target=\"_blank\" rel=\"noopener\">코드</a>를 참고했습니다. 객체 지향으로 구현한 방식을 제 방식으로 풀어서 정리해보려고 합니다. 이전에 소개해드린 함수들도 사용하면서 다소 정신 없이 코드를 써내려가볼까 합니다. 몇차례 쓰게 될지 모르지만 일단 시작합니다.</p>\n<p><strong>앞으로의 글은 아주 대략적으로 제가 이해하고 있는 수준에서만 설명하겠습니다. 이하 모든 내용은 정확한 설명이 아닐 수 있음을 미리 밝힙니다.</strong>  </p>\n<h2 id=\"기본-개념\"><a href=\"#기본-개념\" class=\"headerlink\" title=\"기본 개념\"></a>기본 개념</h2><p>블록체인에서 말하는 블록은 거래내역을 모아둔 데이터 구조 단위입니다. 여기에 블록이 체인이 되기 위해 다른 블록의 주소값을 가지고 있죠. 그리고 블록이 생성된 시간과 자신의 주소값을 가지고 있습니다. 그래서 아래와 같은 데이터 구조를 갖습니다. (구현을 위한 간략한 구조입니다.)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Block = &#123; </span><br><span class=\"line\">  previousHash: <span class=\"string\">''</span>,</span><br><span class=\"line\">  timestamp: <span class=\"string\">'2018-06-22T07:29:19.198Z'</span>,</span><br><span class=\"line\">  transactions: [ &#123; <span class=\"attr\">a</span>: <span class=\"number\">10</span>, <span class=\"attr\">b</span>: <span class=\"number\">-10</span> &#125;, &#123; <span class=\"attr\">a</span>: <span class=\"number\">-10</span>, <span class=\"attr\">b</span>: <span class=\"number\">20</span>, <span class=\"attr\">c</span>: <span class=\"number\">-10</span> &#125; ],</span><br><span class=\"line\">  nonce: <span class=\"number\">79431</span>,</span><br><span class=\"line\">  hash: <span class=\"string\">'0000c067110339dd0f6d844112fa3a7a02142ccb133aad2dc6ebb4709c7651c7'</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"previousHash\"><a href=\"#previousHash\" class=\"headerlink\" title=\"previousHash\"></a>previousHash</h4><p><strong>이전 블록의 해시값입니다.</strong> 예제의 경우 <code>previousHash</code>가 빈 문자열이 담겨있는데, 이는 해당 블록이 최초의 블록이기 때문입니다. 블록체인에서는 최초의 블록을 Genesis Block이라고 부릅니다. 두번째로 생기는 블록은 이 블록의 해시값을 <code>previousHash</code>로 갖게 됩니다.</p>\n<h4 id=\"timestamp\"><a href=\"#timestamp\" class=\"headerlink\" title=\"timestamp\"></a>timestamp</h4><p><strong>블록이 생성된 시간 데이터입니다.</strong> 이 부분에 대해서도 제대로 다룰려면 글 하나를 써야할 것 같습니다. <a href=\"https://jscript.me/2018/04/16/공부하자-블록체인2-타임스탬프서버에-대해-이해하/\" target=\"_blank\" rel=\"noopener\">참고한 글</a>에 따르면 블록체인에서의 타임스탬프는 기존의 그것과 다른 점이 많다고 합니다. 우선은 블록이 생성된 시간이라고 알아두죠.</p>\n<h4 id=\"transactions\"><a href=\"#transactions\" class=\"headerlink\" title=\"transactions\"></a>transactions</h4><p><strong>발생한 거래의 내역(리스트)입니다.</strong> 실제로는 머클트리(Merkle Tree)라는 구조로 거래 내역을 담아두고 이를 저장합니다. 저는 간단하게 배열의 형태로 거래 내역을 담아두겠습니다. 거래는 객체 형태로 담아두는데 <code>{ a: 10, b: -10 }</code> 이렇게 적어둔건 그냥 ‘a의 잔고가 10만큼 늘었고, b의 잔고는 10만큼 줄었다.’는 뜻이라고 해두겠습니다.</p>\n<h4 id=\"nonce\"><a href=\"#nonce\" class=\"headerlink\" title=\"nonce\"></a>nonce</h4><p><strong>해시값을 얻기 위해 찾아야하는 값입니다.</strong> 미리 설명하지 않은 이 값은 채굴(mining)이라고 일컫는 작업을 통해 구해지는 값 중 하나입니다. 여기서 채굴에 대해 잠시 언급하고 지나가면, 아시다시피 노드(참가자)들은 채굴을 통해 보상(화폐)을 얻습니다. 여기서 말하는 <strong>채굴은 <code>hash</code>라는 값을 구하는 활동</strong>입니다. 원하는 <code>hash</code> 값을 얻기 위해서 <code>nonce</code>라는 값을 계속 바꿔보면서 결과 값을 맞춰봐야 합니다. 결과적으로 우리가 원하는 형태의 <code>hash</code>가 생성되면 그때 사용된 <code>nonce</code>가 블록에 기록되는 것입니다. (이렇게 만들어진 값을 가지고 다른 노드들이 제대로 <code>hash</code>가 만들어진 것인지 확인하는 작업이 바로 작업증명(PoW: Proof of Work)인 것이죠.)</p>\n<h4 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h4><p><strong>해당 블록의 주소 값입니다.</strong> 채굴을 통해 얻어진 값인 <code>hash</code>는 예제와 같이 아주 길고 복잡한 문자열로 구성되어 있습니다. 16진수(Hexadecimal)로 표기되는 값으로 암호화 알고리즘인 SHA256으로 만들어진 해시함수가 생성한 값입니다. 이때 해시함수에 인자로 주어지는 값들은 <code>previousHash</code>, <code>timestamp</code>, <code>transactions</code>, <code>nonce</code>입니다. 이 값들의 조합은 유니크합니다. 때문에 이 값을 해시함수에 통과시키면 본 블록만의 유니크한 <code>hash</code>값을 만들 수 있습니다.</p>\n<p>아마 이쯤에서 의문이 생기거나 뭔가 아다리(?)가 맞지 않는다고 느껴지실 겁니다. 도대체 <code>hash</code> 값이 어떻게 생겨먹어야하길래 보상을 줄만큼 구하기 어렵다는 것이냐, 그냥 <code>nonce</code>에 아무 숫자나 때려 넣으면 되는 것 아니냐 하는 생각이 드실 겁니다. 당연한 생각입니다. 블록체인에서는 원하는 <code>hash</code> 값에 제약 조건을 겁니다. 이 조건은 특정 숫자보다 <code>hash</code> 값이 작아야한다는 조건입니다. 특정 숫자를 구하는 방식은 <a href=\"https://brunch.co.kr/@loum/35\" target=\"_blank\" rel=\"noopener\">여길 참고</a>하시면 됩니다. </p>\n<h4 id=\"difficulty\"><a href=\"#difficulty\" class=\"headerlink\" title=\"difficulty\"></a>difficulty</h4><p>예제의 데이터 구조에는 포함하지 않았지만, 제약 조건이 얼마나 어려운 제약인지를 설명하는 것을 난이도(Difficulty)라고 부릅니다. 조금 쉽게 구현하기 위해 저는 <strong>난이도만큼의 0을 <code>hash</code>가 앞자리로 가져야한다는 조건</strong>으로 제약을 두고 구현할 예정입니다. 예제의 경우는 <code>hash</code>값의 시작 지점에 0이 4개(<code>0000c067...</code>)임으로 난이도가 4입니다.  </p>\n"},{"title":"클린 코드 - 협업을 위한 코드 3","description":"함수와 주석 그리고 오류 처리","date":"2020-01-17T11:00:00.000Z","_content":"\n[클린 코드를 주제로 했던 강의](https://speakerdeck.com/joeun_ha/200107-ssafy)를 글로 정리합니다. (강의 내용과 글의 코드가 상이할 수 있습니다.)\n\n---\n\n## 클린 코드\n\n[로버트 마틴(Robert C. Martin)](https://en.wikipedia.org/wiki/Robert_C._Martin)의 책을 통해 클린 코드를 알게 됐습니다. 협업을 잘하기 위해 회사에서 동료들과 함께 스터디를 진행했습니다. 이를 통해 배운 클린 코드에 대한 몇 가지 지식을 추려봤습니다. 간단한 예시와 실제 사례도 담았습니다.\n\n### 함수와 주석\n> 프로그래밍은 여느 글짓기와 비슷하다 - Robert C. Martin\n\n함수는 코드를 문장처럼 읽히게 하는데 가장 큰 역할을 합니다. 간단한 사례를 통해 프로그래밍이 글짓기와 비슷해질 수 있는 이유를 살펴보겠습니다.\n\n```tsx\nconst renderSubFigure = subFigure => (\n  subFigure && <figure>{ subFigure }</figure>\n);\n```\n\n간단한 컴포넌트를 그려주는 함수입니다. 여기서 포인트는 `data`의 존재 여부에 따라 엘리먼트를 그릴지 말지 검사하는 부분입니다. `&&` 연산자를 이용해 값이 참으로 평가되어 존재한다고 판단되면 `<figure>`를 그리도록 하고 있죠. 이에 대해서도 리뷰가 남습니다.\n\n<img src=\"/images/clean-code/code-review-4.png\" style=\"border-radius: 4px;\"/>\n\n조금 더 명시적으로 변경했으면 좋겠다는 리뷰입니다. 명시적이란 표현은 '내용이나 뜻을 분명하게 드러내 보이는. 또는 그런 것'이라고 사전에서 정의하고 있습니다. 어찌 보면 의미 있는 이름을 짓는 것과 같은 내용이네요. 동료인 리뷰어는 `!!`를 사용하거나 `optional` 함수를 사용하길 제안합니다. 제안을 받아들이고 코드를 개선했습니다.\n\n```tsx\n// !!를 사용해 참/거짓을 평가하고 있음을 명시적으로 드러냄\nconst renderSubFigure = subFigure => (\n  !!subFigure && <figure>{ subFigure }</figure>\n);\n```\n\n```tsx\n// optional을 사용해 값의 존재 유무에 따라 동작하는 코드임을 명시적으로 드러냄\nconst renderSubFigure = subFigure => (\n  optional(subFigure, it => <figure>{ it }</figure>)\n);\n```\n\n두 방법 모두 명시적으로 어떤 행위를 하는지 표현하고 있습니다. optional 함수에 대한 이해가 있다면 두번째 경우가 조금 더 읽기 좋은 코드가 될 것 같습니다. 함수를 하나만 더 사용한다면 더 명시적으로 표현할 수도 있죠.\n\n```tsx\nconst renderFigure = it => <figure>{ it }</figure>;\n\nconst renderSubFigure = subFigure => (\n  optional(subFigure, renderFigure)\n);\n```\n\n`renderSubFigure` 함수 내부가 이제 이렇게 읽힙니다. \"optional한 subFigure 값이 존재한다면 figure를 render 한다\"\n\n> 코드 자체가 글인데 주석은 왜 써야해?\n\n함수만으로 코드를 명시적으로 풀어낼 수 있다면 주석이 필요 없습니다. 주석에 의존하기 시작하면 코드의 가독성이 떨어집니다. 주석 없이 코드만으로 이해 가능한 코드를 작성해야합니다. 따라서 주석 사용은 지양해야합니다. 서술적이고 명시적인 이름을 지어 주석 대신 코드로 이야기할 수 있는 코드가 좋은 코드입니다.\n\n### 오류 처리\n> 논리와 오류 코드를 뒤섞지 마라 - Robert C. Martin\n\n로버트 마틴이 주장하는 논리와 오류 코드를 뒤섞지마라는 얘기는 비즈니스 로직에 집중할 수 있게 하라는 의미입니다. 비즈니스 로직, 유저에게 영향을 주는 코드에 온전히 집중할 수 있도록 그 외의 코드를 뒤섞지마라는 이 조언을 어떻게 받아드려야 할까요. 앞서서 [잘 쓴 문장처럼 읽히도록 바꿔둔 코드](/clean-code/#깨끗한-코드)에 로깅 코드를 추가해봄으로써 어떻게 이 조언을 실천할 수 있을지 확인해보겠습니다.\n\n우리가 바꿔둔 아래의 함수는 유저가 필터를 적용할 때마다 실행되는 코드입니다. 어떤 필터가 적용했는지 로그를 남길 수 있는 코드를 추가해달라는 요구 사항을 반영하려면 어떻게 해야할까요?\n\n```js\non_click(\"#is_prime\", ({ currentTarget }) => {\n  const has_class_all = has_class(currentTarget, \"all\");\n  let filter_name = ''; // 1\n\n  if (has_class_all) {\n    const is_prime = loan => loan.is_prime;\n    const filtered_loans = current.loans.filter(is_prime);\n\n    filter_name = \"prime_only\"; // 2\n    set_state({ loans: filtered_loans });\n  } else {\n    const compare_function = compare_functions[current.sort_by];\n    const sorted_loans = origin.loans.sort(compare_function);\n\n    filter_name = \"all\"; // 3\n    set_state({ loans: sorted_loans });\n  }\n\n  console.log(filter_name); // 4\n  render(current.loans);\n});\n```\n\n이렇게 기존의 코드에 네 줄의 코드에 넣어서 원하는 로그를 남길 수 있습니다. 아주 쉽죠. 하지만 문제는 비즈니스 로직을 읽는 중에 흐름을 끊고 있다는 점입니다. \"'all' 클래스를 가졌다면 현재 데이터(current.loans) 중에서 필터링하고, **필터 이름을 정해준다.** 그렇지 않다면 기존 데이터(origin.loans)를 정렬하고, **필터 이름을 정해준다.** 그리고 **로그를 남긴 뒤**, 랜더링한다.\" 코드를 읽는 중에 다른 논리가 계속 끼어들고 있죠. 두가지 논리가 뒤섞여 있습니다. 정리가 필요해보이네요.\n\n```js\non_click(\"#is_prime\", ({ currentTarget }) => {\n  const has_class_all = has_class(currentTarget, \"all\");\n\n  if (has_class_all) {\n    const is_prime = loan => loan.is_prime;\n    const filtered_loans = current.loans.filter(is_prime);\n\n    set_state({ loans: filtered_loans });\n  } else {\n    const compare_function = compare_functions[current.sort_by];\n    const sorted_loans = origin.loans.sort(compare_function);\n\n    set_state({ loans: sorted_loans });\n  }\n\n  render(current.loans);\n  event_log(has_class_all); // 1\n});\n\nconst event_log = has_class_all => {\n  const filter_name = has_class_all ? \"prime_only\" : \"all\";\n  console.log(filter_name);\n}\n```\n\n이제는 기존 함수 내에 한 줄의 코드만 넣어서 원하는 바를 이루고 있습니다. 이렇게 읽을 수 있죠. \"'all' 필터링 된 이후에, **그걸 기준으로 로그를 남기는구나**\" 숨어든 논리가 밖으로 표현됩니다. 이제는 기능 추가나 디버깅을 할때도 고쳐야할 부분이 적어진 상황이죠. 논리가 분명해져서 읽기 좋은 코드가 됐습니다.\n\n---\n\n마지막 글은 클린 코드를 배우고 어떤 변화가 있었는지 그리고 클린 코드를 적용함에 있어 주의해야할 내용에 대해 다룹니다.\n","source":"_posts/clean-code-2.md","raw":"---\ntitle: 클린 코드 - 협업을 위한 코드 3\ncategories:\n  - joeun.dev\ntags:\n  - clean code\n  - 클린 코드\ndescription: 함수와 주석 그리고 오류 처리\ndate: 2020-01-17 20:00:00\n---\n\n[클린 코드를 주제로 했던 강의](https://speakerdeck.com/joeun_ha/200107-ssafy)를 글로 정리합니다. (강의 내용과 글의 코드가 상이할 수 있습니다.)\n\n---\n\n## 클린 코드\n\n[로버트 마틴(Robert C. Martin)](https://en.wikipedia.org/wiki/Robert_C._Martin)의 책을 통해 클린 코드를 알게 됐습니다. 협업을 잘하기 위해 회사에서 동료들과 함께 스터디를 진행했습니다. 이를 통해 배운 클린 코드에 대한 몇 가지 지식을 추려봤습니다. 간단한 예시와 실제 사례도 담았습니다.\n\n### 함수와 주석\n> 프로그래밍은 여느 글짓기와 비슷하다 - Robert C. Martin\n\n함수는 코드를 문장처럼 읽히게 하는데 가장 큰 역할을 합니다. 간단한 사례를 통해 프로그래밍이 글짓기와 비슷해질 수 있는 이유를 살펴보겠습니다.\n\n```tsx\nconst renderSubFigure = subFigure => (\n  subFigure && <figure>{ subFigure }</figure>\n);\n```\n\n간단한 컴포넌트를 그려주는 함수입니다. 여기서 포인트는 `data`의 존재 여부에 따라 엘리먼트를 그릴지 말지 검사하는 부분입니다. `&&` 연산자를 이용해 값이 참으로 평가되어 존재한다고 판단되면 `<figure>`를 그리도록 하고 있죠. 이에 대해서도 리뷰가 남습니다.\n\n<img src=\"/images/clean-code/code-review-4.png\" style=\"border-radius: 4px;\"/>\n\n조금 더 명시적으로 변경했으면 좋겠다는 리뷰입니다. 명시적이란 표현은 '내용이나 뜻을 분명하게 드러내 보이는. 또는 그런 것'이라고 사전에서 정의하고 있습니다. 어찌 보면 의미 있는 이름을 짓는 것과 같은 내용이네요. 동료인 리뷰어는 `!!`를 사용하거나 `optional` 함수를 사용하길 제안합니다. 제안을 받아들이고 코드를 개선했습니다.\n\n```tsx\n// !!를 사용해 참/거짓을 평가하고 있음을 명시적으로 드러냄\nconst renderSubFigure = subFigure => (\n  !!subFigure && <figure>{ subFigure }</figure>\n);\n```\n\n```tsx\n// optional을 사용해 값의 존재 유무에 따라 동작하는 코드임을 명시적으로 드러냄\nconst renderSubFigure = subFigure => (\n  optional(subFigure, it => <figure>{ it }</figure>)\n);\n```\n\n두 방법 모두 명시적으로 어떤 행위를 하는지 표현하고 있습니다. optional 함수에 대한 이해가 있다면 두번째 경우가 조금 더 읽기 좋은 코드가 될 것 같습니다. 함수를 하나만 더 사용한다면 더 명시적으로 표현할 수도 있죠.\n\n```tsx\nconst renderFigure = it => <figure>{ it }</figure>;\n\nconst renderSubFigure = subFigure => (\n  optional(subFigure, renderFigure)\n);\n```\n\n`renderSubFigure` 함수 내부가 이제 이렇게 읽힙니다. \"optional한 subFigure 값이 존재한다면 figure를 render 한다\"\n\n> 코드 자체가 글인데 주석은 왜 써야해?\n\n함수만으로 코드를 명시적으로 풀어낼 수 있다면 주석이 필요 없습니다. 주석에 의존하기 시작하면 코드의 가독성이 떨어집니다. 주석 없이 코드만으로 이해 가능한 코드를 작성해야합니다. 따라서 주석 사용은 지양해야합니다. 서술적이고 명시적인 이름을 지어 주석 대신 코드로 이야기할 수 있는 코드가 좋은 코드입니다.\n\n### 오류 처리\n> 논리와 오류 코드를 뒤섞지 마라 - Robert C. Martin\n\n로버트 마틴이 주장하는 논리와 오류 코드를 뒤섞지마라는 얘기는 비즈니스 로직에 집중할 수 있게 하라는 의미입니다. 비즈니스 로직, 유저에게 영향을 주는 코드에 온전히 집중할 수 있도록 그 외의 코드를 뒤섞지마라는 이 조언을 어떻게 받아드려야 할까요. 앞서서 [잘 쓴 문장처럼 읽히도록 바꿔둔 코드](/clean-code/#깨끗한-코드)에 로깅 코드를 추가해봄으로써 어떻게 이 조언을 실천할 수 있을지 확인해보겠습니다.\n\n우리가 바꿔둔 아래의 함수는 유저가 필터를 적용할 때마다 실행되는 코드입니다. 어떤 필터가 적용했는지 로그를 남길 수 있는 코드를 추가해달라는 요구 사항을 반영하려면 어떻게 해야할까요?\n\n```js\non_click(\"#is_prime\", ({ currentTarget }) => {\n  const has_class_all = has_class(currentTarget, \"all\");\n  let filter_name = ''; // 1\n\n  if (has_class_all) {\n    const is_prime = loan => loan.is_prime;\n    const filtered_loans = current.loans.filter(is_prime);\n\n    filter_name = \"prime_only\"; // 2\n    set_state({ loans: filtered_loans });\n  } else {\n    const compare_function = compare_functions[current.sort_by];\n    const sorted_loans = origin.loans.sort(compare_function);\n\n    filter_name = \"all\"; // 3\n    set_state({ loans: sorted_loans });\n  }\n\n  console.log(filter_name); // 4\n  render(current.loans);\n});\n```\n\n이렇게 기존의 코드에 네 줄의 코드에 넣어서 원하는 로그를 남길 수 있습니다. 아주 쉽죠. 하지만 문제는 비즈니스 로직을 읽는 중에 흐름을 끊고 있다는 점입니다. \"'all' 클래스를 가졌다면 현재 데이터(current.loans) 중에서 필터링하고, **필터 이름을 정해준다.** 그렇지 않다면 기존 데이터(origin.loans)를 정렬하고, **필터 이름을 정해준다.** 그리고 **로그를 남긴 뒤**, 랜더링한다.\" 코드를 읽는 중에 다른 논리가 계속 끼어들고 있죠. 두가지 논리가 뒤섞여 있습니다. 정리가 필요해보이네요.\n\n```js\non_click(\"#is_prime\", ({ currentTarget }) => {\n  const has_class_all = has_class(currentTarget, \"all\");\n\n  if (has_class_all) {\n    const is_prime = loan => loan.is_prime;\n    const filtered_loans = current.loans.filter(is_prime);\n\n    set_state({ loans: filtered_loans });\n  } else {\n    const compare_function = compare_functions[current.sort_by];\n    const sorted_loans = origin.loans.sort(compare_function);\n\n    set_state({ loans: sorted_loans });\n  }\n\n  render(current.loans);\n  event_log(has_class_all); // 1\n});\n\nconst event_log = has_class_all => {\n  const filter_name = has_class_all ? \"prime_only\" : \"all\";\n  console.log(filter_name);\n}\n```\n\n이제는 기존 함수 내에 한 줄의 코드만 넣어서 원하는 바를 이루고 있습니다. 이렇게 읽을 수 있죠. \"'all' 필터링 된 이후에, **그걸 기준으로 로그를 남기는구나**\" 숨어든 논리가 밖으로 표현됩니다. 이제는 기능 추가나 디버깅을 할때도 고쳐야할 부분이 적어진 상황이죠. 논리가 분명해져서 읽기 좋은 코드가 됐습니다.\n\n---\n\n마지막 글은 클린 코드를 배우고 어떤 변화가 있었는지 그리고 클린 코드를 적용함에 있어 주의해야할 내용에 대해 다룹니다.\n","slug":"clean-code-2","published":1,"updated":"2020-02-09T14:20:01.162Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9f5000ndirvsl9fzuzv","content":"<p><a href=\"https://speakerdeck.com/joeun_ha/200107-ssafy\" target=\"_blank\" rel=\"noopener\">클린 코드를 주제로 했던 강의</a>를 글로 정리합니다. (강의 내용과 글의 코드가 상이할 수 있습니다.)</p>\n<hr>\n<h2 id=\"클린-코드\"><a href=\"#클린-코드\" class=\"headerlink\" title=\"클린 코드\"></a>클린 코드</h2><p><a href=\"https://en.wikipedia.org/wiki/Robert_C._Martin\" target=\"_blank\" rel=\"noopener\">로버트 마틴(Robert C. Martin)</a>의 책을 통해 클린 코드를 알게 됐습니다. 협업을 잘하기 위해 회사에서 동료들과 함께 스터디를 진행했습니다. 이를 통해 배운 클린 코드에 대한 몇 가지 지식을 추려봤습니다. 간단한 예시와 실제 사례도 담았습니다.</p>\n<h3 id=\"함수와-주석\"><a href=\"#함수와-주석\" class=\"headerlink\" title=\"함수와 주석\"></a>함수와 주석</h3><blockquote>\n<p>프로그래밍은 여느 글짓기와 비슷하다 - Robert C. Martin</p>\n</blockquote>\n<p>함수는 코드를 문장처럼 읽히게 하는데 가장 큰 역할을 합니다. 간단한 사례를 통해 프로그래밍이 글짓기와 비슷해질 수 있는 이유를 살펴보겠습니다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const renderSubFigure = subFigure =&gt; (</span><br><span class=\"line\">  subFigure &amp;&amp; &lt;figure&gt;&#123; subFigure &#125;&lt;/figure&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>간단한 컴포넌트를 그려주는 함수입니다. 여기서 포인트는 <code>data</code>의 존재 여부에 따라 엘리먼트를 그릴지 말지 검사하는 부분입니다. <code>&amp;&amp;</code> 연산자를 이용해 값이 참으로 평가되어 존재한다고 판단되면 <code>&lt;figure&gt;</code>를 그리도록 하고 있죠. 이에 대해서도 리뷰가 남습니다.</p>\n<img src=\"/images/clean-code/code-review-4.png\" style=\"border-radius: 4px;\">\n\n<p>조금 더 명시적으로 변경했으면 좋겠다는 리뷰입니다. 명시적이란 표현은 ‘내용이나 뜻을 분명하게 드러내 보이는. 또는 그런 것’이라고 사전에서 정의하고 있습니다. 어찌 보면 의미 있는 이름을 짓는 것과 같은 내용이네요. 동료인 리뷰어는 <code>!!</code>를 사용하거나 <code>optional</code> 함수를 사용하길 제안합니다. 제안을 받아들이고 코드를 개선했습니다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// !!를 사용해 참/거짓을 평가하고 있음을 명시적으로 드러냄</span><br><span class=\"line\">const renderSubFigure = subFigure =&gt; (</span><br><span class=\"line\">  !!subFigure &amp;&amp; &lt;figure&gt;&#123; subFigure &#125;&lt;/figure&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// optional을 사용해 값의 존재 유무에 따라 동작하는 코드임을 명시적으로 드러냄</span><br><span class=\"line\">const renderSubFigure = subFigure =&gt; (</span><br><span class=\"line\">  optional(subFigure, it =&gt; &lt;figure&gt;&#123; it &#125;&lt;/figure&gt;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>두 방법 모두 명시적으로 어떤 행위를 하는지 표현하고 있습니다. optional 함수에 대한 이해가 있다면 두번째 경우가 조금 더 읽기 좋은 코드가 될 것 같습니다. 함수를 하나만 더 사용한다면 더 명시적으로 표현할 수도 있죠.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const renderFigure = it =&gt; &lt;figure&gt;&#123; it &#125;&lt;/figure&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">const renderSubFigure = subFigure =&gt; (</span><br><span class=\"line\">  optional(subFigure, renderFigure)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><code>renderSubFigure</code> 함수 내부가 이제 이렇게 읽힙니다. “optional한 subFigure 값이 존재한다면 figure를 render 한다”</p>\n<blockquote>\n<p>코드 자체가 글인데 주석은 왜 써야해?</p>\n</blockquote>\n<p>함수만으로 코드를 명시적으로 풀어낼 수 있다면 주석이 필요 없습니다. 주석에 의존하기 시작하면 코드의 가독성이 떨어집니다. 주석 없이 코드만으로 이해 가능한 코드를 작성해야합니다. 따라서 주석 사용은 지양해야합니다. 서술적이고 명시적인 이름을 지어 주석 대신 코드로 이야기할 수 있는 코드가 좋은 코드입니다.</p>\n<h3 id=\"오류-처리\"><a href=\"#오류-처리\" class=\"headerlink\" title=\"오류 처리\"></a>오류 처리</h3><blockquote>\n<p>논리와 오류 코드를 뒤섞지 마라 - Robert C. Martin</p>\n</blockquote>\n<p>로버트 마틴이 주장하는 논리와 오류 코드를 뒤섞지마라는 얘기는 비즈니스 로직에 집중할 수 있게 하라는 의미입니다. 비즈니스 로직, 유저에게 영향을 주는 코드에 온전히 집중할 수 있도록 그 외의 코드를 뒤섞지마라는 이 조언을 어떻게 받아드려야 할까요. 앞서서 <a href=\"/clean-code/#깨끗한-코드\">잘 쓴 문장처럼 읽히도록 바꿔둔 코드</a>에 로깅 코드를 추가해봄으로써 어떻게 이 조언을 실천할 수 있을지 확인해보겠습니다.</p>\n<p>우리가 바꿔둔 아래의 함수는 유저가 필터를 적용할 때마다 실행되는 코드입니다. 어떤 필터가 적용했는지 로그를 남길 수 있는 코드를 추가해달라는 요구 사항을 반영하려면 어떻게 해야할까요?</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on_click(<span class=\"string\">\"#is_prime\"</span>, (&#123; currentTarget &#125;) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> has_class_all = has_class(currentTarget, <span class=\"string\">\"all\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> filter_name = <span class=\"string\">''</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (has_class_all) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> is_prime = <span class=\"function\"><span class=\"params\">loan</span> =&gt;</span> loan.is_prime;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> filtered_loans = current.loans.filter(is_prime);</span><br><span class=\"line\"></span><br><span class=\"line\">    filter_name = <span class=\"string\">\"prime_only\"</span>; <span class=\"comment\">// 2</span></span><br><span class=\"line\">    set_state(&#123; <span class=\"attr\">loans</span>: filtered_loans &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> compare_function = compare_functions[current.sort_by];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> sorted_loans = origin.loans.sort(compare_function);</span><br><span class=\"line\"></span><br><span class=\"line\">    filter_name = <span class=\"string\">\"all\"</span>; <span class=\"comment\">// 3</span></span><br><span class=\"line\">    set_state(&#123; <span class=\"attr\">loans</span>: sorted_loans &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(filter_name); <span class=\"comment\">// 4</span></span><br><span class=\"line\">  render(current.loans);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>이렇게 기존의 코드에 네 줄의 코드에 넣어서 원하는 로그를 남길 수 있습니다. 아주 쉽죠. 하지만 문제는 비즈니스 로직을 읽는 중에 흐름을 끊고 있다는 점입니다. “‘all’ 클래스를 가졌다면 현재 데이터(current.loans) 중에서 필터링하고, <strong>필터 이름을 정해준다.</strong> 그렇지 않다면 기존 데이터(origin.loans)를 정렬하고, <strong>필터 이름을 정해준다.</strong> 그리고 <strong>로그를 남긴 뒤</strong>, 랜더링한다.” 코드를 읽는 중에 다른 논리가 계속 끼어들고 있죠. 두가지 논리가 뒤섞여 있습니다. 정리가 필요해보이네요.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on_click(<span class=\"string\">\"#is_prime\"</span>, (&#123; currentTarget &#125;) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> has_class_all = has_class(currentTarget, <span class=\"string\">\"all\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (has_class_all) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> is_prime = <span class=\"function\"><span class=\"params\">loan</span> =&gt;</span> loan.is_prime;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> filtered_loans = current.loans.filter(is_prime);</span><br><span class=\"line\"></span><br><span class=\"line\">    set_state(&#123; <span class=\"attr\">loans</span>: filtered_loans &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> compare_function = compare_functions[current.sort_by];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> sorted_loans = origin.loans.sort(compare_function);</span><br><span class=\"line\"></span><br><span class=\"line\">    set_state(&#123; <span class=\"attr\">loans</span>: sorted_loans &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render(current.loans);</span><br><span class=\"line\">  event_log(has_class_all); <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> event_log = <span class=\"function\"><span class=\"params\">has_class_all</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> filter_name = has_class_all ? <span class=\"string\">\"prime_only\"</span> : <span class=\"string\">\"all\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(filter_name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이제는 기존 함수 내에 한 줄의 코드만 넣어서 원하는 바를 이루고 있습니다. 이렇게 읽을 수 있죠. “‘all’ 필터링 된 이후에, <strong>그걸 기준으로 로그를 남기는구나</strong>“ 숨어든 논리가 밖으로 표현됩니다. 이제는 기능 추가나 디버깅을 할때도 고쳐야할 부분이 적어진 상황이죠. 논리가 분명해져서 읽기 좋은 코드가 됐습니다.</p>\n<hr>\n<p>마지막 글은 클린 코드를 배우고 어떤 변화가 있었는지 그리고 클린 코드를 적용함에 있어 주의해야할 내용에 대해 다룹니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://speakerdeck.com/joeun_ha/200107-ssafy\" target=\"_blank\" rel=\"noopener\">클린 코드를 주제로 했던 강의</a>를 글로 정리합니다. (강의 내용과 글의 코드가 상이할 수 있습니다.)</p>\n<hr>\n<h2 id=\"클린-코드\"><a href=\"#클린-코드\" class=\"headerlink\" title=\"클린 코드\"></a>클린 코드</h2><p><a href=\"https://en.wikipedia.org/wiki/Robert_C._Martin\" target=\"_blank\" rel=\"noopener\">로버트 마틴(Robert C. Martin)</a>의 책을 통해 클린 코드를 알게 됐습니다. 협업을 잘하기 위해 회사에서 동료들과 함께 스터디를 진행했습니다. 이를 통해 배운 클린 코드에 대한 몇 가지 지식을 추려봤습니다. 간단한 예시와 실제 사례도 담았습니다.</p>\n<h3 id=\"함수와-주석\"><a href=\"#함수와-주석\" class=\"headerlink\" title=\"함수와 주석\"></a>함수와 주석</h3><blockquote>\n<p>프로그래밍은 여느 글짓기와 비슷하다 - Robert C. Martin</p>\n</blockquote>\n<p>함수는 코드를 문장처럼 읽히게 하는데 가장 큰 역할을 합니다. 간단한 사례를 통해 프로그래밍이 글짓기와 비슷해질 수 있는 이유를 살펴보겠습니다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const renderSubFigure = subFigure =&gt; (</span><br><span class=\"line\">  subFigure &amp;&amp; &lt;figure&gt;&#123; subFigure &#125;&lt;/figure&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>간단한 컴포넌트를 그려주는 함수입니다. 여기서 포인트는 <code>data</code>의 존재 여부에 따라 엘리먼트를 그릴지 말지 검사하는 부분입니다. <code>&amp;&amp;</code> 연산자를 이용해 값이 참으로 평가되어 존재한다고 판단되면 <code>&lt;figure&gt;</code>를 그리도록 하고 있죠. 이에 대해서도 리뷰가 남습니다.</p>\n<img src=\"/images/clean-code/code-review-4.png\" style=\"border-radius: 4px;\">\n\n<p>조금 더 명시적으로 변경했으면 좋겠다는 리뷰입니다. 명시적이란 표현은 ‘내용이나 뜻을 분명하게 드러내 보이는. 또는 그런 것’이라고 사전에서 정의하고 있습니다. 어찌 보면 의미 있는 이름을 짓는 것과 같은 내용이네요. 동료인 리뷰어는 <code>!!</code>를 사용하거나 <code>optional</code> 함수를 사용하길 제안합니다. 제안을 받아들이고 코드를 개선했습니다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// !!를 사용해 참/거짓을 평가하고 있음을 명시적으로 드러냄</span><br><span class=\"line\">const renderSubFigure = subFigure =&gt; (</span><br><span class=\"line\">  !!subFigure &amp;&amp; &lt;figure&gt;&#123; subFigure &#125;&lt;/figure&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// optional을 사용해 값의 존재 유무에 따라 동작하는 코드임을 명시적으로 드러냄</span><br><span class=\"line\">const renderSubFigure = subFigure =&gt; (</span><br><span class=\"line\">  optional(subFigure, it =&gt; &lt;figure&gt;&#123; it &#125;&lt;/figure&gt;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>두 방법 모두 명시적으로 어떤 행위를 하는지 표현하고 있습니다. optional 함수에 대한 이해가 있다면 두번째 경우가 조금 더 읽기 좋은 코드가 될 것 같습니다. 함수를 하나만 더 사용한다면 더 명시적으로 표현할 수도 있죠.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const renderFigure = it =&gt; &lt;figure&gt;&#123; it &#125;&lt;/figure&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">const renderSubFigure = subFigure =&gt; (</span><br><span class=\"line\">  optional(subFigure, renderFigure)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><code>renderSubFigure</code> 함수 내부가 이제 이렇게 읽힙니다. “optional한 subFigure 값이 존재한다면 figure를 render 한다”</p>\n<blockquote>\n<p>코드 자체가 글인데 주석은 왜 써야해?</p>\n</blockquote>\n<p>함수만으로 코드를 명시적으로 풀어낼 수 있다면 주석이 필요 없습니다. 주석에 의존하기 시작하면 코드의 가독성이 떨어집니다. 주석 없이 코드만으로 이해 가능한 코드를 작성해야합니다. 따라서 주석 사용은 지양해야합니다. 서술적이고 명시적인 이름을 지어 주석 대신 코드로 이야기할 수 있는 코드가 좋은 코드입니다.</p>\n<h3 id=\"오류-처리\"><a href=\"#오류-처리\" class=\"headerlink\" title=\"오류 처리\"></a>오류 처리</h3><blockquote>\n<p>논리와 오류 코드를 뒤섞지 마라 - Robert C. Martin</p>\n</blockquote>\n<p>로버트 마틴이 주장하는 논리와 오류 코드를 뒤섞지마라는 얘기는 비즈니스 로직에 집중할 수 있게 하라는 의미입니다. 비즈니스 로직, 유저에게 영향을 주는 코드에 온전히 집중할 수 있도록 그 외의 코드를 뒤섞지마라는 이 조언을 어떻게 받아드려야 할까요. 앞서서 <a href=\"/clean-code/#깨끗한-코드\">잘 쓴 문장처럼 읽히도록 바꿔둔 코드</a>에 로깅 코드를 추가해봄으로써 어떻게 이 조언을 실천할 수 있을지 확인해보겠습니다.</p>\n<p>우리가 바꿔둔 아래의 함수는 유저가 필터를 적용할 때마다 실행되는 코드입니다. 어떤 필터가 적용했는지 로그를 남길 수 있는 코드를 추가해달라는 요구 사항을 반영하려면 어떻게 해야할까요?</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on_click(<span class=\"string\">\"#is_prime\"</span>, (&#123; currentTarget &#125;) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> has_class_all = has_class(currentTarget, <span class=\"string\">\"all\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> filter_name = <span class=\"string\">''</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (has_class_all) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> is_prime = <span class=\"function\"><span class=\"params\">loan</span> =&gt;</span> loan.is_prime;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> filtered_loans = current.loans.filter(is_prime);</span><br><span class=\"line\"></span><br><span class=\"line\">    filter_name = <span class=\"string\">\"prime_only\"</span>; <span class=\"comment\">// 2</span></span><br><span class=\"line\">    set_state(&#123; <span class=\"attr\">loans</span>: filtered_loans &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> compare_function = compare_functions[current.sort_by];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> sorted_loans = origin.loans.sort(compare_function);</span><br><span class=\"line\"></span><br><span class=\"line\">    filter_name = <span class=\"string\">\"all\"</span>; <span class=\"comment\">// 3</span></span><br><span class=\"line\">    set_state(&#123; <span class=\"attr\">loans</span>: sorted_loans &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(filter_name); <span class=\"comment\">// 4</span></span><br><span class=\"line\">  render(current.loans);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>이렇게 기존의 코드에 네 줄의 코드에 넣어서 원하는 로그를 남길 수 있습니다. 아주 쉽죠. 하지만 문제는 비즈니스 로직을 읽는 중에 흐름을 끊고 있다는 점입니다. “‘all’ 클래스를 가졌다면 현재 데이터(current.loans) 중에서 필터링하고, <strong>필터 이름을 정해준다.</strong> 그렇지 않다면 기존 데이터(origin.loans)를 정렬하고, <strong>필터 이름을 정해준다.</strong> 그리고 <strong>로그를 남긴 뒤</strong>, 랜더링한다.” 코드를 읽는 중에 다른 논리가 계속 끼어들고 있죠. 두가지 논리가 뒤섞여 있습니다. 정리가 필요해보이네요.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on_click(<span class=\"string\">\"#is_prime\"</span>, (&#123; currentTarget &#125;) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> has_class_all = has_class(currentTarget, <span class=\"string\">\"all\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (has_class_all) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> is_prime = <span class=\"function\"><span class=\"params\">loan</span> =&gt;</span> loan.is_prime;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> filtered_loans = current.loans.filter(is_prime);</span><br><span class=\"line\"></span><br><span class=\"line\">    set_state(&#123; <span class=\"attr\">loans</span>: filtered_loans &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> compare_function = compare_functions[current.sort_by];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> sorted_loans = origin.loans.sort(compare_function);</span><br><span class=\"line\"></span><br><span class=\"line\">    set_state(&#123; <span class=\"attr\">loans</span>: sorted_loans &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render(current.loans);</span><br><span class=\"line\">  event_log(has_class_all); <span class=\"comment\">// 1</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> event_log = <span class=\"function\"><span class=\"params\">has_class_all</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> filter_name = has_class_all ? <span class=\"string\">\"prime_only\"</span> : <span class=\"string\">\"all\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(filter_name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이제는 기존 함수 내에 한 줄의 코드만 넣어서 원하는 바를 이루고 있습니다. 이렇게 읽을 수 있죠. “‘all’ 필터링 된 이후에, <strong>그걸 기준으로 로그를 남기는구나</strong>“ 숨어든 논리가 밖으로 표현됩니다. 이제는 기능 추가나 디버깅을 할때도 고쳐야할 부분이 적어진 상황이죠. 논리가 분명해져서 읽기 좋은 코드가 됐습니다.</p>\n<hr>\n<p>마지막 글은 클린 코드를 배우고 어떤 변화가 있었는지 그리고 클린 코드를 적용함에 있어 주의해야할 내용에 대해 다룹니다.</p>\n"},{"title":"클린 코드 - 협업을 위한 코드 1","description":"야생 개발자, 클린 코드를 만나다","date":"2020-01-13T11:00:00.000Z","_content":"\n[클린 코드를 주제로 했던 강의](https://speakerdeck.com/joeun_ha/200107-ssafy)를 글로 정리합니다. (강의 내용과 글의 코드가 상이할 수 있습니다.)\n\n---\n\n## 야생 개발자\n> Wild [waɪld]: animals or plants live or grow in natural surroundings and are not looked after by people.\n\n사람들과 협업 경험이 적은 개발자, 그게 제 상황이었습니다. 문과 출신 개발자인 저는 개발에 입문하기 전엔 나름대로 문학소년이었죠. 그래서인지 처음 프로그래밍을 배우면서 [\"프로그래밍, 이거 제법 문과스러운데? 🤔\"](/like-me-2/#문과스러운-프로그래밍)라고 생각했었습니다. 문학소년 입장에서 문과의 꽃은 시라고 생각했습니다. 프로그래밍도 시 쓰듯 하는 게 좋은 게 아닐까 생각했죠.\n\n### 멋진 코드는 함축적인 코드\n시는 함축적인 의미를 담고 있는 경우가 많죠. 코드도 그래야 한다고 생각했습니다. 짧은 내용에 의미를 담으면 멋진 것으로 생각했죠.\n\n```js\nevt1('#is_prime', ({ currentTarget }) => (\n    rend(current.loans = has_c(currentTarget, 'all') ?\n        current.loans.filter(loan => loan.is_prime) :\n        origin.loans.sort(compare[current.sort_by]))\n    && toggle_c(currentTarget, 'all')\n));\n```\n\n위의 코드에서처럼 짧은 변수명으로 설명해도 문제없다고 생각했습니다. 오히려 멋진 게 아닐까 생각했죠. 처음엔 어렵지만, 나중에 생각해보면 다 이해가 가니까요.\n\n### 우아한 코드는 적당히 어려운 코드\n시도 그렇습니다. 처음에는 이해가 가질 않죠. 이게 무슨 말인고 적당히 어려워하다가 어느 날 그 의미가 와닿습니다. 그 짜릿함이 코드에도 녹아들어야 한다고 생각했습니다.\n\n```js\nevt1('#is_prime', ({ currentTarget }) => (\n    rend(current.loans = has_c(currentTarget, 'all') ?\n        current.loans.filter(loan => loan.is_prime) :\n        origin.loans.sort(compare[current.sort_by]))\n    && toggle_c(currentTarget, 'all')\n));\n```\n\n처음 나온 코드와 같은 코드입니다. `=`, `&&`가 적당한 어려움을 주고 있죠. 할당과 동시에 값을 함수에 넘기기도 하고 중괄호 없는 화살표 함수 내에서 두개의 동작을 하기도 하죠. 처음엔 알아보기 힘들지만 깨닫고 나면 제법 뭔가 있어보이는 코드. 그게 우아한 코드라고 생각했습니다.\n\n### 깨끗한 코드는 짧고 예쁜 모양의 코드\n앞선 코드들을 보시면 코드가 간결하고 전체 형태가 사각형 안에 들어오고 있습니다. 이런 형태의 코드가 좋은 코드라고 생각했습니다. 작은 사격형 안에 들어가면서 짧게 정리된 코드. 그게 바로 깨끗한 코드라고 생각했죠.\n\n### 협업을 위한 코드\n조금 어렵긴 해도 제가 여러분에게 설명드린 것처럼 옆에 있는 동료에게 설명하면 충분히 이해할 수 있는 코드니까 문제될거 없다고 생각했습니다. 사실 그렇지 않더군요. 항상 동료 옆에 붙어 있을 수 없을뿐더러. 기민하게 대응해야하는 상황에 위와 같은 코드는 실수할 여지가 많이 생긴다는걸 알게 됐습니다.\n\n---\n\n그렇다면 협업을 위한 코드, 클린 코드는 무엇을 강조하고 있을까요. [다음 글](/clean-code-1)에서 확인해보세요.\n","source":"_posts/clean-code-0.md","raw":"---\ntitle: 클린 코드 - 협업을 위한 코드 1\ncategories:\n  - joeun.dev\ntags:\n  - clean code\n  - 클린 코드\ndescription: '야생 개발자, 클린 코드를 만나다'\ndate: 2020-01-13 20:00:00\n---\n\n[클린 코드를 주제로 했던 강의](https://speakerdeck.com/joeun_ha/200107-ssafy)를 글로 정리합니다. (강의 내용과 글의 코드가 상이할 수 있습니다.)\n\n---\n\n## 야생 개발자\n> Wild [waɪld]: animals or plants live or grow in natural surroundings and are not looked after by people.\n\n사람들과 협업 경험이 적은 개발자, 그게 제 상황이었습니다. 문과 출신 개발자인 저는 개발에 입문하기 전엔 나름대로 문학소년이었죠. 그래서인지 처음 프로그래밍을 배우면서 [\"프로그래밍, 이거 제법 문과스러운데? 🤔\"](/like-me-2/#문과스러운-프로그래밍)라고 생각했었습니다. 문학소년 입장에서 문과의 꽃은 시라고 생각했습니다. 프로그래밍도 시 쓰듯 하는 게 좋은 게 아닐까 생각했죠.\n\n### 멋진 코드는 함축적인 코드\n시는 함축적인 의미를 담고 있는 경우가 많죠. 코드도 그래야 한다고 생각했습니다. 짧은 내용에 의미를 담으면 멋진 것으로 생각했죠.\n\n```js\nevt1('#is_prime', ({ currentTarget }) => (\n    rend(current.loans = has_c(currentTarget, 'all') ?\n        current.loans.filter(loan => loan.is_prime) :\n        origin.loans.sort(compare[current.sort_by]))\n    && toggle_c(currentTarget, 'all')\n));\n```\n\n위의 코드에서처럼 짧은 변수명으로 설명해도 문제없다고 생각했습니다. 오히려 멋진 게 아닐까 생각했죠. 처음엔 어렵지만, 나중에 생각해보면 다 이해가 가니까요.\n\n### 우아한 코드는 적당히 어려운 코드\n시도 그렇습니다. 처음에는 이해가 가질 않죠. 이게 무슨 말인고 적당히 어려워하다가 어느 날 그 의미가 와닿습니다. 그 짜릿함이 코드에도 녹아들어야 한다고 생각했습니다.\n\n```js\nevt1('#is_prime', ({ currentTarget }) => (\n    rend(current.loans = has_c(currentTarget, 'all') ?\n        current.loans.filter(loan => loan.is_prime) :\n        origin.loans.sort(compare[current.sort_by]))\n    && toggle_c(currentTarget, 'all')\n));\n```\n\n처음 나온 코드와 같은 코드입니다. `=`, `&&`가 적당한 어려움을 주고 있죠. 할당과 동시에 값을 함수에 넘기기도 하고 중괄호 없는 화살표 함수 내에서 두개의 동작을 하기도 하죠. 처음엔 알아보기 힘들지만 깨닫고 나면 제법 뭔가 있어보이는 코드. 그게 우아한 코드라고 생각했습니다.\n\n### 깨끗한 코드는 짧고 예쁜 모양의 코드\n앞선 코드들을 보시면 코드가 간결하고 전체 형태가 사각형 안에 들어오고 있습니다. 이런 형태의 코드가 좋은 코드라고 생각했습니다. 작은 사격형 안에 들어가면서 짧게 정리된 코드. 그게 바로 깨끗한 코드라고 생각했죠.\n\n### 협업을 위한 코드\n조금 어렵긴 해도 제가 여러분에게 설명드린 것처럼 옆에 있는 동료에게 설명하면 충분히 이해할 수 있는 코드니까 문제될거 없다고 생각했습니다. 사실 그렇지 않더군요. 항상 동료 옆에 붙어 있을 수 없을뿐더러. 기민하게 대응해야하는 상황에 위와 같은 코드는 실수할 여지가 많이 생긴다는걸 알게 됐습니다.\n\n---\n\n그렇다면 협업을 위한 코드, 클린 코드는 무엇을 강조하고 있을까요. [다음 글](/clean-code-1)에서 확인해보세요.\n","slug":"clean-code-0","published":1,"updated":"2020-02-11T11:18:56.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9f8000rdirve6nr21sc","content":"<p><a href=\"https://speakerdeck.com/joeun_ha/200107-ssafy\" target=\"_blank\" rel=\"noopener\">클린 코드를 주제로 했던 강의</a>를 글로 정리합니다. (강의 내용과 글의 코드가 상이할 수 있습니다.)</p>\n<hr>\n<h2 id=\"야생-개발자\"><a href=\"#야생-개발자\" class=\"headerlink\" title=\"야생 개발자\"></a>야생 개발자</h2><blockquote>\n<p>Wild [waɪld]: animals or plants live or grow in natural surroundings and are not looked after by people.</p>\n</blockquote>\n<p>사람들과 협업 경험이 적은 개발자, 그게 제 상황이었습니다. 문과 출신 개발자인 저는 개발에 입문하기 전엔 나름대로 문학소년이었죠. 그래서인지 처음 프로그래밍을 배우면서 <a href=\"/like-me-2/#문과스러운-프로그래밍\">“프로그래밍, 이거 제법 문과스러운데? 🤔”</a>라고 생각했었습니다. 문학소년 입장에서 문과의 꽃은 시라고 생각했습니다. 프로그래밍도 시 쓰듯 하는 게 좋은 게 아닐까 생각했죠.</p>\n<h3 id=\"멋진-코드는-함축적인-코드\"><a href=\"#멋진-코드는-함축적인-코드\" class=\"headerlink\" title=\"멋진 코드는 함축적인 코드\"></a>멋진 코드는 함축적인 코드</h3><p>시는 함축적인 의미를 담고 있는 경우가 많죠. 코드도 그래야 한다고 생각했습니다. 짧은 내용에 의미를 담으면 멋진 것으로 생각했죠.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evt1(<span class=\"string\">'#is_prime'</span>, (&#123; currentTarget &#125;) =&gt; (</span><br><span class=\"line\">    rend(current.loans = has_c(currentTarget, <span class=\"string\">'all'</span>) ?</span><br><span class=\"line\">        current.loans.filter(<span class=\"function\"><span class=\"params\">loan</span> =&gt;</span> loan.is_prime) :</span><br><span class=\"line\">        origin.loans.sort(compare[current.sort_by]))</span><br><span class=\"line\">    &amp;&amp; toggle_c(currentTarget, <span class=\"string\">'all'</span>)</span><br><span class=\"line\">));</span><br></pre></td></tr></table></figure>\n\n<p>위의 코드에서처럼 짧은 변수명으로 설명해도 문제없다고 생각했습니다. 오히려 멋진 게 아닐까 생각했죠. 처음엔 어렵지만, 나중에 생각해보면 다 이해가 가니까요.</p>\n<h3 id=\"우아한-코드는-적당히-어려운-코드\"><a href=\"#우아한-코드는-적당히-어려운-코드\" class=\"headerlink\" title=\"우아한 코드는 적당히 어려운 코드\"></a>우아한 코드는 적당히 어려운 코드</h3><p>시도 그렇습니다. 처음에는 이해가 가질 않죠. 이게 무슨 말인고 적당히 어려워하다가 어느 날 그 의미가 와닿습니다. 그 짜릿함이 코드에도 녹아들어야 한다고 생각했습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evt1(<span class=\"string\">'#is_prime'</span>, (&#123; currentTarget &#125;) =&gt; (</span><br><span class=\"line\">    rend(current.loans = has_c(currentTarget, <span class=\"string\">'all'</span>) ?</span><br><span class=\"line\">        current.loans.filter(<span class=\"function\"><span class=\"params\">loan</span> =&gt;</span> loan.is_prime) :</span><br><span class=\"line\">        origin.loans.sort(compare[current.sort_by]))</span><br><span class=\"line\">    &amp;&amp; toggle_c(currentTarget, <span class=\"string\">'all'</span>)</span><br><span class=\"line\">));</span><br></pre></td></tr></table></figure>\n\n<p>처음 나온 코드와 같은 코드입니다. <code>=</code>, <code>&amp;&amp;</code>가 적당한 어려움을 주고 있죠. 할당과 동시에 값을 함수에 넘기기도 하고 중괄호 없는 화살표 함수 내에서 두개의 동작을 하기도 하죠. 처음엔 알아보기 힘들지만 깨닫고 나면 제법 뭔가 있어보이는 코드. 그게 우아한 코드라고 생각했습니다.</p>\n<h3 id=\"깨끗한-코드는-짧고-예쁜-모양의-코드\"><a href=\"#깨끗한-코드는-짧고-예쁜-모양의-코드\" class=\"headerlink\" title=\"깨끗한 코드는 짧고 예쁜 모양의 코드\"></a>깨끗한 코드는 짧고 예쁜 모양의 코드</h3><p>앞선 코드들을 보시면 코드가 간결하고 전체 형태가 사각형 안에 들어오고 있습니다. 이런 형태의 코드가 좋은 코드라고 생각했습니다. 작은 사격형 안에 들어가면서 짧게 정리된 코드. 그게 바로 깨끗한 코드라고 생각했죠.</p>\n<h3 id=\"협업을-위한-코드\"><a href=\"#협업을-위한-코드\" class=\"headerlink\" title=\"협업을 위한 코드\"></a>협업을 위한 코드</h3><p>조금 어렵긴 해도 제가 여러분에게 설명드린 것처럼 옆에 있는 동료에게 설명하면 충분히 이해할 수 있는 코드니까 문제될거 없다고 생각했습니다. 사실 그렇지 않더군요. 항상 동료 옆에 붙어 있을 수 없을뿐더러. 기민하게 대응해야하는 상황에 위와 같은 코드는 실수할 여지가 많이 생긴다는걸 알게 됐습니다.</p>\n<hr>\n<p>그렇다면 협업을 위한 코드, 클린 코드는 무엇을 강조하고 있을까요. <a href=\"/clean-code-1\">다음 글</a>에서 확인해보세요.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://speakerdeck.com/joeun_ha/200107-ssafy\" target=\"_blank\" rel=\"noopener\">클린 코드를 주제로 했던 강의</a>를 글로 정리합니다. (강의 내용과 글의 코드가 상이할 수 있습니다.)</p>\n<hr>\n<h2 id=\"야생-개발자\"><a href=\"#야생-개발자\" class=\"headerlink\" title=\"야생 개발자\"></a>야생 개발자</h2><blockquote>\n<p>Wild [waɪld]: animals or plants live or grow in natural surroundings and are not looked after by people.</p>\n</blockquote>\n<p>사람들과 협업 경험이 적은 개발자, 그게 제 상황이었습니다. 문과 출신 개발자인 저는 개발에 입문하기 전엔 나름대로 문학소년이었죠. 그래서인지 처음 프로그래밍을 배우면서 <a href=\"/like-me-2/#문과스러운-프로그래밍\">“프로그래밍, 이거 제법 문과스러운데? 🤔”</a>라고 생각했었습니다. 문학소년 입장에서 문과의 꽃은 시라고 생각했습니다. 프로그래밍도 시 쓰듯 하는 게 좋은 게 아닐까 생각했죠.</p>\n<h3 id=\"멋진-코드는-함축적인-코드\"><a href=\"#멋진-코드는-함축적인-코드\" class=\"headerlink\" title=\"멋진 코드는 함축적인 코드\"></a>멋진 코드는 함축적인 코드</h3><p>시는 함축적인 의미를 담고 있는 경우가 많죠. 코드도 그래야 한다고 생각했습니다. 짧은 내용에 의미를 담으면 멋진 것으로 생각했죠.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evt1(<span class=\"string\">'#is_prime'</span>, (&#123; currentTarget &#125;) =&gt; (</span><br><span class=\"line\">    rend(current.loans = has_c(currentTarget, <span class=\"string\">'all'</span>) ?</span><br><span class=\"line\">        current.loans.filter(<span class=\"function\"><span class=\"params\">loan</span> =&gt;</span> loan.is_prime) :</span><br><span class=\"line\">        origin.loans.sort(compare[current.sort_by]))</span><br><span class=\"line\">    &amp;&amp; toggle_c(currentTarget, <span class=\"string\">'all'</span>)</span><br><span class=\"line\">));</span><br></pre></td></tr></table></figure>\n\n<p>위의 코드에서처럼 짧은 변수명으로 설명해도 문제없다고 생각했습니다. 오히려 멋진 게 아닐까 생각했죠. 처음엔 어렵지만, 나중에 생각해보면 다 이해가 가니까요.</p>\n<h3 id=\"우아한-코드는-적당히-어려운-코드\"><a href=\"#우아한-코드는-적당히-어려운-코드\" class=\"headerlink\" title=\"우아한 코드는 적당히 어려운 코드\"></a>우아한 코드는 적당히 어려운 코드</h3><p>시도 그렇습니다. 처음에는 이해가 가질 않죠. 이게 무슨 말인고 적당히 어려워하다가 어느 날 그 의미가 와닿습니다. 그 짜릿함이 코드에도 녹아들어야 한다고 생각했습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evt1(<span class=\"string\">'#is_prime'</span>, (&#123; currentTarget &#125;) =&gt; (</span><br><span class=\"line\">    rend(current.loans = has_c(currentTarget, <span class=\"string\">'all'</span>) ?</span><br><span class=\"line\">        current.loans.filter(<span class=\"function\"><span class=\"params\">loan</span> =&gt;</span> loan.is_prime) :</span><br><span class=\"line\">        origin.loans.sort(compare[current.sort_by]))</span><br><span class=\"line\">    &amp;&amp; toggle_c(currentTarget, <span class=\"string\">'all'</span>)</span><br><span class=\"line\">));</span><br></pre></td></tr></table></figure>\n\n<p>처음 나온 코드와 같은 코드입니다. <code>=</code>, <code>&amp;&amp;</code>가 적당한 어려움을 주고 있죠. 할당과 동시에 값을 함수에 넘기기도 하고 중괄호 없는 화살표 함수 내에서 두개의 동작을 하기도 하죠. 처음엔 알아보기 힘들지만 깨닫고 나면 제법 뭔가 있어보이는 코드. 그게 우아한 코드라고 생각했습니다.</p>\n<h3 id=\"깨끗한-코드는-짧고-예쁜-모양의-코드\"><a href=\"#깨끗한-코드는-짧고-예쁜-모양의-코드\" class=\"headerlink\" title=\"깨끗한 코드는 짧고 예쁜 모양의 코드\"></a>깨끗한 코드는 짧고 예쁜 모양의 코드</h3><p>앞선 코드들을 보시면 코드가 간결하고 전체 형태가 사각형 안에 들어오고 있습니다. 이런 형태의 코드가 좋은 코드라고 생각했습니다. 작은 사격형 안에 들어가면서 짧게 정리된 코드. 그게 바로 깨끗한 코드라고 생각했죠.</p>\n<h3 id=\"협업을-위한-코드\"><a href=\"#협업을-위한-코드\" class=\"headerlink\" title=\"협업을 위한 코드\"></a>협업을 위한 코드</h3><p>조금 어렵긴 해도 제가 여러분에게 설명드린 것처럼 옆에 있는 동료에게 설명하면 충분히 이해할 수 있는 코드니까 문제될거 없다고 생각했습니다. 사실 그렇지 않더군요. 항상 동료 옆에 붙어 있을 수 없을뿐더러. 기민하게 대응해야하는 상황에 위와 같은 코드는 실수할 여지가 많이 생긴다는걸 알게 됐습니다.</p>\n<hr>\n<p>그렇다면 협업을 위한 코드, 클린 코드는 무엇을 강조하고 있을까요. <a href=\"/clean-code-1\">다음 글</a>에서 확인해보세요.</p>\n"},{"title":"클린 코드 - 오해와 진실","description":"안녕이라 말하기 전에","date":"2020-01-29T11:00:00.000Z","_content":"\n## 협업을 위하여\n\n클린 코드에 대한 [세번째 글](/clean-code-2)을 마무리하고 있을 때쯤 Dan Abramov(이하 댄)의 블로그에 [GoodBye, Clean Code](https://overreacted.io/goodbye-clean-code/)라는 글이 올라왔습니다. 한국어로 [잘가, 클린 코드](https://overreacted.io/ko/goodbye-clean-code/)로 번역된 이 글은 한동안 제 페이스북 피드에 오르내렸습니다. 제목을 보며 '이제 내 블로그 글은 이제 어쩌나...' 싶었죠. 클린 코드에 대해 부정적인 입장인 것처럼 보였기 때문입니다. 하지만 자극적인 제목과 달리 실제 내용은 지나치게 한가지 관점에 얽매이지 말라는 내용이었습니다.\n\n> Don’t be a clean code zealot. Clean code is not a goal.\n> Let clean code guide you. Then let it go.\n\n댄은 본문에서 클린 코드에 지나치게 몰입한 탓에 재앙을 불러일으켰다고 고백합니다. 그중 하나가 코드를 작성한 사람과 변경에 대해 논의하지 않은 것이라고 말합니다. 협업에서 이처럼 업무를 처리하는 것은 최악이기 때문이며 서로 신뢰가 필요한 엔지니어링 팀에서 이는 안 좋은 영향을 미칠 수밖에 없다고 말합니다. 클린 코드 협업을 방해해선 안 된다는 것이죠.\n\n## 함께 개발하기 위한 약속\n\n클린 코드는 협업을 위한 도구가 되어야 합니다. 클린 코드는 약속입니다. **\"코드도 글이니까 쉽게 읽히도록 작성합시다\"라고 개발자들 사이에서 암묵적으로 합의한 약속**인 겁니다. 다른 말로 하자면 당신이 작성한 코드는 언젠가 다른 사람이 볼 것이기 때문에 최소한의 예의를 지켜달라는 권고이기도 합니다. 다른 사람이 읽고 이해할 수 있도록 해달라는 겁니다. 코드를 그저 프로그램이 동작하게 만드는 명령어의 집합으로만 생각하지 말자는거죠. 컴퓨터만 이해할 수 있게 하지 말고 옆의 동료도 좀 이해할 수 있게 쓰라는 겁니다.\n\n## 동료를 생각하는 개발자가 되기까지\n\n저도 뱅크샐러드에 입사하기 전에 추상화에 매몰되어 있었습니다. 지금도 추상화하고 함수로 표현하는 것을 좋아하지만 당시에는 더 심했습니다. 다른 사람이 제 코드를 못 읽는 건 수준이 낮아서라고 생각했죠. 지금 생각하면 아찔합니다. 어렵더라도 짧게 적는 게 최고라고 생각했습니다. 오히려 어렵게 짠 코드를 근사하다고 생각했습니다.\n\n개인적으로는 클린 코드를 배우고 옆의 동료를 더 많이 생각하게 됐습니다. 지금 쓰는 이 코드를 다른 사람들이 한눈에 알아볼 수 있을까. 이름을 이렇게 지어도 괜찮을까. 처음 코드를 보는 사람이 이해하기 쉽게 짜려면 어떻게 해야할까. 어떤 배치로 코드를 구성해야 매끄럽게 이해가 될까. 계속 그런 고민을 하며 코드를 작성합니다. 이런 변화에 클린 코드가 지대한 영향을 끼쳤습니다.\n\n## 얽매이지 않기 위해서 생각해야할 것\n\n클린 코드라는 주제에서 벗어나는 내용이지만 언급하고 글을 맺을까 합니다. 클린 코드건 추상화건 어떤 도구를 처음 배우게되면 계속 그 도구를 사용하고 싶어집니다. 아이에게 망치를 주면 모든 것이 못으로 보이는 것과 같은 원리죠. 망치로 해결되지 않는 문제도 망치로 해결하려고 한다는 겁니다. 개발에서도 마찬가지입니다. 하나의 도구로 모든 것을 해결하려고 해선 안됩니다. **문제를 마주했을 때 이 문제를 해결하는데 내가 배운이 도구가 적합한지를 먼저 따져야합니다.** 그 과정을 동료들이 도와줄 수 있다면 정말 좋겠죠. 동료들에게 문제를 공유하고 해결책을 함께 고민해야합니다. 그리고 다시 망치를 들어도 늦지 않습니다.\n\n**클린 코드도 도구일 뿐입니다.** 많은 분들이 이 도구를 잘 활용해서 성공적인 개발을 할 수 있었으면 좋겠습니다. 감사합니다.\n","source":"_posts/clean-code-3.md","raw":"---\ntitle: 클린 코드 - 오해와 진실\ncategories:\n  - joeun.dev\ntags:\n  - clean code\n  - 클린코드\ndescription: 안녕이라 말하기 전에\ndate: 2020-01-29 20:00:00\n---\n\n## 협업을 위하여\n\n클린 코드에 대한 [세번째 글](/clean-code-2)을 마무리하고 있을 때쯤 Dan Abramov(이하 댄)의 블로그에 [GoodBye, Clean Code](https://overreacted.io/goodbye-clean-code/)라는 글이 올라왔습니다. 한국어로 [잘가, 클린 코드](https://overreacted.io/ko/goodbye-clean-code/)로 번역된 이 글은 한동안 제 페이스북 피드에 오르내렸습니다. 제목을 보며 '이제 내 블로그 글은 이제 어쩌나...' 싶었죠. 클린 코드에 대해 부정적인 입장인 것처럼 보였기 때문입니다. 하지만 자극적인 제목과 달리 실제 내용은 지나치게 한가지 관점에 얽매이지 말라는 내용이었습니다.\n\n> Don’t be a clean code zealot. Clean code is not a goal.\n> Let clean code guide you. Then let it go.\n\n댄은 본문에서 클린 코드에 지나치게 몰입한 탓에 재앙을 불러일으켰다고 고백합니다. 그중 하나가 코드를 작성한 사람과 변경에 대해 논의하지 않은 것이라고 말합니다. 협업에서 이처럼 업무를 처리하는 것은 최악이기 때문이며 서로 신뢰가 필요한 엔지니어링 팀에서 이는 안 좋은 영향을 미칠 수밖에 없다고 말합니다. 클린 코드 협업을 방해해선 안 된다는 것이죠.\n\n## 함께 개발하기 위한 약속\n\n클린 코드는 협업을 위한 도구가 되어야 합니다. 클린 코드는 약속입니다. **\"코드도 글이니까 쉽게 읽히도록 작성합시다\"라고 개발자들 사이에서 암묵적으로 합의한 약속**인 겁니다. 다른 말로 하자면 당신이 작성한 코드는 언젠가 다른 사람이 볼 것이기 때문에 최소한의 예의를 지켜달라는 권고이기도 합니다. 다른 사람이 읽고 이해할 수 있도록 해달라는 겁니다. 코드를 그저 프로그램이 동작하게 만드는 명령어의 집합으로만 생각하지 말자는거죠. 컴퓨터만 이해할 수 있게 하지 말고 옆의 동료도 좀 이해할 수 있게 쓰라는 겁니다.\n\n## 동료를 생각하는 개발자가 되기까지\n\n저도 뱅크샐러드에 입사하기 전에 추상화에 매몰되어 있었습니다. 지금도 추상화하고 함수로 표현하는 것을 좋아하지만 당시에는 더 심했습니다. 다른 사람이 제 코드를 못 읽는 건 수준이 낮아서라고 생각했죠. 지금 생각하면 아찔합니다. 어렵더라도 짧게 적는 게 최고라고 생각했습니다. 오히려 어렵게 짠 코드를 근사하다고 생각했습니다.\n\n개인적으로는 클린 코드를 배우고 옆의 동료를 더 많이 생각하게 됐습니다. 지금 쓰는 이 코드를 다른 사람들이 한눈에 알아볼 수 있을까. 이름을 이렇게 지어도 괜찮을까. 처음 코드를 보는 사람이 이해하기 쉽게 짜려면 어떻게 해야할까. 어떤 배치로 코드를 구성해야 매끄럽게 이해가 될까. 계속 그런 고민을 하며 코드를 작성합니다. 이런 변화에 클린 코드가 지대한 영향을 끼쳤습니다.\n\n## 얽매이지 않기 위해서 생각해야할 것\n\n클린 코드라는 주제에서 벗어나는 내용이지만 언급하고 글을 맺을까 합니다. 클린 코드건 추상화건 어떤 도구를 처음 배우게되면 계속 그 도구를 사용하고 싶어집니다. 아이에게 망치를 주면 모든 것이 못으로 보이는 것과 같은 원리죠. 망치로 해결되지 않는 문제도 망치로 해결하려고 한다는 겁니다. 개발에서도 마찬가지입니다. 하나의 도구로 모든 것을 해결하려고 해선 안됩니다. **문제를 마주했을 때 이 문제를 해결하는데 내가 배운이 도구가 적합한지를 먼저 따져야합니다.** 그 과정을 동료들이 도와줄 수 있다면 정말 좋겠죠. 동료들에게 문제를 공유하고 해결책을 함께 고민해야합니다. 그리고 다시 망치를 들어도 늦지 않습니다.\n\n**클린 코드도 도구일 뿐입니다.** 많은 분들이 이 도구를 잘 활용해서 성공적인 개발을 할 수 있었으면 좋겠습니다. 감사합니다.\n","slug":"clean-code-3","published":1,"updated":"2020-02-09T14:20:01.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9f9000vdirvj1w8h2hy","content":"<h2 id=\"협업을-위하여\"><a href=\"#협업을-위하여\" class=\"headerlink\" title=\"협업을 위하여\"></a>협업을 위하여</h2><p>클린 코드에 대한 <a href=\"/clean-code-2\">세번째 글</a>을 마무리하고 있을 때쯤 Dan Abramov(이하 댄)의 블로그에 <a href=\"https://overreacted.io/goodbye-clean-code/\" target=\"_blank\" rel=\"noopener\">GoodBye, Clean Code</a>라는 글이 올라왔습니다. 한국어로 <a href=\"https://overreacted.io/ko/goodbye-clean-code/\" target=\"_blank\" rel=\"noopener\">잘가, 클린 코드</a>로 번역된 이 글은 한동안 제 페이스북 피드에 오르내렸습니다. 제목을 보며 ‘이제 내 블로그 글은 이제 어쩌나…’ 싶었죠. 클린 코드에 대해 부정적인 입장인 것처럼 보였기 때문입니다. 하지만 자극적인 제목과 달리 실제 내용은 지나치게 한가지 관점에 얽매이지 말라는 내용이었습니다.</p>\n<blockquote>\n<p>Don’t be a clean code zealot. Clean code is not a goal.<br>Let clean code guide you. Then let it go.</p>\n</blockquote>\n<p>댄은 본문에서 클린 코드에 지나치게 몰입한 탓에 재앙을 불러일으켰다고 고백합니다. 그중 하나가 코드를 작성한 사람과 변경에 대해 논의하지 않은 것이라고 말합니다. 협업에서 이처럼 업무를 처리하는 것은 최악이기 때문이며 서로 신뢰가 필요한 엔지니어링 팀에서 이는 안 좋은 영향을 미칠 수밖에 없다고 말합니다. 클린 코드 협업을 방해해선 안 된다는 것이죠.</p>\n<h2 id=\"함께-개발하기-위한-약속\"><a href=\"#함께-개발하기-위한-약속\" class=\"headerlink\" title=\"함께 개발하기 위한 약속\"></a>함께 개발하기 위한 약속</h2><p>클린 코드는 협업을 위한 도구가 되어야 합니다. 클린 코드는 약속입니다. <strong>“코드도 글이니까 쉽게 읽히도록 작성합시다”라고 개발자들 사이에서 암묵적으로 합의한 약속</strong>인 겁니다. 다른 말로 하자면 당신이 작성한 코드는 언젠가 다른 사람이 볼 것이기 때문에 최소한의 예의를 지켜달라는 권고이기도 합니다. 다른 사람이 읽고 이해할 수 있도록 해달라는 겁니다. 코드를 그저 프로그램이 동작하게 만드는 명령어의 집합으로만 생각하지 말자는거죠. 컴퓨터만 이해할 수 있게 하지 말고 옆의 동료도 좀 이해할 수 있게 쓰라는 겁니다.</p>\n<h2 id=\"동료를-생각하는-개발자가-되기까지\"><a href=\"#동료를-생각하는-개발자가-되기까지\" class=\"headerlink\" title=\"동료를 생각하는 개발자가 되기까지\"></a>동료를 생각하는 개발자가 되기까지</h2><p>저도 뱅크샐러드에 입사하기 전에 추상화에 매몰되어 있었습니다. 지금도 추상화하고 함수로 표현하는 것을 좋아하지만 당시에는 더 심했습니다. 다른 사람이 제 코드를 못 읽는 건 수준이 낮아서라고 생각했죠. 지금 생각하면 아찔합니다. 어렵더라도 짧게 적는 게 최고라고 생각했습니다. 오히려 어렵게 짠 코드를 근사하다고 생각했습니다.</p>\n<p>개인적으로는 클린 코드를 배우고 옆의 동료를 더 많이 생각하게 됐습니다. 지금 쓰는 이 코드를 다른 사람들이 한눈에 알아볼 수 있을까. 이름을 이렇게 지어도 괜찮을까. 처음 코드를 보는 사람이 이해하기 쉽게 짜려면 어떻게 해야할까. 어떤 배치로 코드를 구성해야 매끄럽게 이해가 될까. 계속 그런 고민을 하며 코드를 작성합니다. 이런 변화에 클린 코드가 지대한 영향을 끼쳤습니다.</p>\n<h2 id=\"얽매이지-않기-위해서-생각해야할-것\"><a href=\"#얽매이지-않기-위해서-생각해야할-것\" class=\"headerlink\" title=\"얽매이지 않기 위해서 생각해야할 것\"></a>얽매이지 않기 위해서 생각해야할 것</h2><p>클린 코드라는 주제에서 벗어나는 내용이지만 언급하고 글을 맺을까 합니다. 클린 코드건 추상화건 어떤 도구를 처음 배우게되면 계속 그 도구를 사용하고 싶어집니다. 아이에게 망치를 주면 모든 것이 못으로 보이는 것과 같은 원리죠. 망치로 해결되지 않는 문제도 망치로 해결하려고 한다는 겁니다. 개발에서도 마찬가지입니다. 하나의 도구로 모든 것을 해결하려고 해선 안됩니다. <strong>문제를 마주했을 때 이 문제를 해결하는데 내가 배운이 도구가 적합한지를 먼저 따져야합니다.</strong> 그 과정을 동료들이 도와줄 수 있다면 정말 좋겠죠. 동료들에게 문제를 공유하고 해결책을 함께 고민해야합니다. 그리고 다시 망치를 들어도 늦지 않습니다.</p>\n<p><strong>클린 코드도 도구일 뿐입니다.</strong> 많은 분들이 이 도구를 잘 활용해서 성공적인 개발을 할 수 있었으면 좋겠습니다. 감사합니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"협업을-위하여\"><a href=\"#협업을-위하여\" class=\"headerlink\" title=\"협업을 위하여\"></a>협업을 위하여</h2><p>클린 코드에 대한 <a href=\"/clean-code-2\">세번째 글</a>을 마무리하고 있을 때쯤 Dan Abramov(이하 댄)의 블로그에 <a href=\"https://overreacted.io/goodbye-clean-code/\" target=\"_blank\" rel=\"noopener\">GoodBye, Clean Code</a>라는 글이 올라왔습니다. 한국어로 <a href=\"https://overreacted.io/ko/goodbye-clean-code/\" target=\"_blank\" rel=\"noopener\">잘가, 클린 코드</a>로 번역된 이 글은 한동안 제 페이스북 피드에 오르내렸습니다. 제목을 보며 ‘이제 내 블로그 글은 이제 어쩌나…’ 싶었죠. 클린 코드에 대해 부정적인 입장인 것처럼 보였기 때문입니다. 하지만 자극적인 제목과 달리 실제 내용은 지나치게 한가지 관점에 얽매이지 말라는 내용이었습니다.</p>\n<blockquote>\n<p>Don’t be a clean code zealot. Clean code is not a goal.<br>Let clean code guide you. Then let it go.</p>\n</blockquote>\n<p>댄은 본문에서 클린 코드에 지나치게 몰입한 탓에 재앙을 불러일으켰다고 고백합니다. 그중 하나가 코드를 작성한 사람과 변경에 대해 논의하지 않은 것이라고 말합니다. 협업에서 이처럼 업무를 처리하는 것은 최악이기 때문이며 서로 신뢰가 필요한 엔지니어링 팀에서 이는 안 좋은 영향을 미칠 수밖에 없다고 말합니다. 클린 코드 협업을 방해해선 안 된다는 것이죠.</p>\n<h2 id=\"함께-개발하기-위한-약속\"><a href=\"#함께-개발하기-위한-약속\" class=\"headerlink\" title=\"함께 개발하기 위한 약속\"></a>함께 개발하기 위한 약속</h2><p>클린 코드는 협업을 위한 도구가 되어야 합니다. 클린 코드는 약속입니다. <strong>“코드도 글이니까 쉽게 읽히도록 작성합시다”라고 개발자들 사이에서 암묵적으로 합의한 약속</strong>인 겁니다. 다른 말로 하자면 당신이 작성한 코드는 언젠가 다른 사람이 볼 것이기 때문에 최소한의 예의를 지켜달라는 권고이기도 합니다. 다른 사람이 읽고 이해할 수 있도록 해달라는 겁니다. 코드를 그저 프로그램이 동작하게 만드는 명령어의 집합으로만 생각하지 말자는거죠. 컴퓨터만 이해할 수 있게 하지 말고 옆의 동료도 좀 이해할 수 있게 쓰라는 겁니다.</p>\n<h2 id=\"동료를-생각하는-개발자가-되기까지\"><a href=\"#동료를-생각하는-개발자가-되기까지\" class=\"headerlink\" title=\"동료를 생각하는 개발자가 되기까지\"></a>동료를 생각하는 개발자가 되기까지</h2><p>저도 뱅크샐러드에 입사하기 전에 추상화에 매몰되어 있었습니다. 지금도 추상화하고 함수로 표현하는 것을 좋아하지만 당시에는 더 심했습니다. 다른 사람이 제 코드를 못 읽는 건 수준이 낮아서라고 생각했죠. 지금 생각하면 아찔합니다. 어렵더라도 짧게 적는 게 최고라고 생각했습니다. 오히려 어렵게 짠 코드를 근사하다고 생각했습니다.</p>\n<p>개인적으로는 클린 코드를 배우고 옆의 동료를 더 많이 생각하게 됐습니다. 지금 쓰는 이 코드를 다른 사람들이 한눈에 알아볼 수 있을까. 이름을 이렇게 지어도 괜찮을까. 처음 코드를 보는 사람이 이해하기 쉽게 짜려면 어떻게 해야할까. 어떤 배치로 코드를 구성해야 매끄럽게 이해가 될까. 계속 그런 고민을 하며 코드를 작성합니다. 이런 변화에 클린 코드가 지대한 영향을 끼쳤습니다.</p>\n<h2 id=\"얽매이지-않기-위해서-생각해야할-것\"><a href=\"#얽매이지-않기-위해서-생각해야할-것\" class=\"headerlink\" title=\"얽매이지 않기 위해서 생각해야할 것\"></a>얽매이지 않기 위해서 생각해야할 것</h2><p>클린 코드라는 주제에서 벗어나는 내용이지만 언급하고 글을 맺을까 합니다. 클린 코드건 추상화건 어떤 도구를 처음 배우게되면 계속 그 도구를 사용하고 싶어집니다. 아이에게 망치를 주면 모든 것이 못으로 보이는 것과 같은 원리죠. 망치로 해결되지 않는 문제도 망치로 해결하려고 한다는 겁니다. 개발에서도 마찬가지입니다. 하나의 도구로 모든 것을 해결하려고 해선 안됩니다. <strong>문제를 마주했을 때 이 문제를 해결하는데 내가 배운이 도구가 적합한지를 먼저 따져야합니다.</strong> 그 과정을 동료들이 도와줄 수 있다면 정말 좋겠죠. 동료들에게 문제를 공유하고 해결책을 함께 고민해야합니다. 그리고 다시 망치를 들어도 늦지 않습니다.</p>\n<p><strong>클린 코드도 도구일 뿐입니다.</strong> 많은 분들이 이 도구를 잘 활용해서 성공적인 개발을 할 수 있었으면 좋겠습니다. 감사합니다.</p>\n"},{"title":"클린 코드 - 협업을 위한 코드 2","description":"깨끗한 코드와 의미 있는 이름","date":"2020-01-15T11:00:00.000Z","_content":"\n[클린 코드를 주제로 했던 강의](https://speakerdeck.com/joeun_ha/200107-ssafy)를 글로 정리합니다. (강의 내용과 글의 코드가 상이할 수 있습니다.)\n\n---\n\n## 클린 코드\n\n[로버트 마틴(Robert C. Martin)](https://en.wikipedia.org/wiki/Robert_C._Martin)의 책을 통해 클린 코드를 알게 됐습니다. 협업을 잘하기 위해 회사에서 동료들과 함께 스터디를 진행했습니다. 이를 통해 배운 클린 코드에 대한 몇 가지 지식을 추려봤습니다. 간단한 예시와 실제 사례도 담았습니다.\n\n### 깨끗한 코드\n> 깨끗한 코드는 잘 쓴 문장처럼 읽힌다 - Grady Booch\n\n![](/images/clean-code/code-quality-wtf.jpg)\n\n위의 이미지는 클린 코드가 무엇인지 단적으로 표현하고 있습니다. 좋은 코드와 나쁜 코드를 판별하는 지표로 '분당 WTF의 횟수'를 사용할 수 있다고 말하고 있죠. WTF은 우리말로 표현하자면 \"이건 뭐지...?\" 정도가 되지 않을까 싶습니다. 코드를 읽는 중에 \"이건 뭐지?\"하고 이해하기 어려운 코드가 자주 나올수록 나쁜 코드라는 의미죠. 앞에 나온 예시를 다시 보겠습니다.\n\n```js\nevt1('#is_prime', ({ currentTarget }) => (\n    rend(current.loans = has_c(currentTarget, 'all') ?\n        current.loans.filter(loan => loan.is_prime) :\n        origin.loans.sort(compare[current.sort_by]))\n    && toggle_c(currentTarget, 'all')\n));\n```\n\n곳곳에서 WTF을 외치게 되죠. 이 짧은 코드에 적어도 일곱 번은 이건 무슨 소릴까 하는 의문이 생길 겁니다. 명백히 나쁜 코드네요. 책에서 소개되는 대가 중 한 명인 [그래디 부치(Grady Booch)](https://en.wikipedia.org/wiki/Grady_Booch)는 **깨끗한 코드는 잘 쓴 문장처럼 읽힌다**고 말합니다. 예시를 잘 쓴 문장처럼 바꾸면 어떻게될까요?\n\n```js\non_click(\"#is_prime\", ({ currentTarget }) => {\n  const has_class_all = has_class(currentTarget, \"all\");\n\n  if (has_class_all) {\n    const is_prime = loan => loan.is_prime;\n    const filtered_loans = current.loans.filter(is_prime);\n\n    set_state({ loans: filtered_loans });\n  } else {\n    const compare_function = compare_functions[current.sort_by];\n    const sorted_loans = origin.loans.sort(compare_function);\n\n    set_state({ loans: sorted_loans });\n  }\n\n  render(current.loans);\n  toggle_class(currentTarget, \"all\");\n});\n```\n\n'all' 클래스를 가졌다면 현재 데이터(current.loans) 중에서 필터링해 랜더링 하고, 그렇지 않다면 기존 데이터(origin.loans)를 정렬해 랜더링 하고 있습니다. 확실히 이제는 문장처럼 읽힙니다.\n\n### 의미 있는 이름\n> 의도를 분명하게 밝혀라 - Robert C. Martin\n\n이번에는 실제 코드 리뷰 중에 있었던 사례를 살펴보겠습니다. 여기 `clearEmptyKey`라는 함수가 있습니다. `undefined` 혹은 `null`을 빈 값(empty)으로 보고 지워버리는 함수입니다. (함수 선언부 내에 사용되는 함수는 [immutable.js에서 제공하는 함수](https://immutable-js.github.io/immutable-js/docs/#/Collection/filter)입니다.)\n\n```js\nconst clearEmptyKey = data => (\n  Map(data).filter(item => (\n    item !== undefined && item !== null\n  )).toObject()\n);\n\nconst userInfo = {\n  id: 327,\n  name: \"joeunha\",\n  gender: null\n};\n\nconsole.log(clearEmptyKey(userInfo));\n// { id: 327, name: \"joeunha\" }\n```\n\n기존에 준비되어 있던 이 함수를 활용해서 PR을 날렸고 리뷰가 시작됐습니다. 해당 함수의 이름에 대해 의문이 제기됐습니다.\n\n<img src=\"/images/clean-code/code-review-0.png\" style=\"border-radius: 4px;\"/>\n\n함수의 의도가 분명하게 드러나지 않은 상황이었죠. 실제 함수의 의도를 댓글로 설명하며 더 좋은 이름을 찾기 시작합니다.\n\n<img src=\"/images/clean-code/code-review-1.png\" style=\"border-radius: 4px;\"/>\n\n새로운 함수의 이름을 제안하고 근거를 제시했습니다. 실제로 [underscore와 같은 라이브러리에서 compact](https://underscorejs.org/#compact)는 무의미한 값(falsy)을 제거하는 함수로 사용됩니다.\n\n<img src=\"/images/clean-code/code-review-2.png\" style=\"border-radius: 4px;\"/>\n\n각자의 생각을 공유하며 의미있는 이름을 도출해가고 있습니다. underscore에서와 같이 compact로만 이름을 짓기 어려운 이유는 대상이 되는 값의 타입이 다양할 수 있기 때문입니다. 저는 이를 추상화 레벨이 너무 높다고 표헌하고 있네요.\n\n<img src=\"/images/clean-code/code-review-3.png\" style=\"border-radius: 4px;\"/>\n\n이에 동료들이 동의하는 뜻을 표합니다. 제시한 함수의 이름이 제 의도를 드러낸다고 동의한 것이죠. 타입 앞에 `compact-`라는 접두사를 붙여 함수 이름을 지어 시리즈로 함수를 만들기로 했습니다.\n\n```js\nconst compactObject = data => (\n  Map(data).filter(item => (\n    item !== undefined && item !== null\n  )).toObject()\n);\n\nconst compactString = data => (\n  data.replace(/ /g, '')\n);\n\nconst compactValues = data => (\n  Map(data)\n    .map(item => (\n      typeof item === 'string' ? compactString(item) : item)\n    )).toObject()\n);\n```\n\n이처럼 함수는 의도를 분명히 밝혀야합니다. 리뷰를 통해 clear 대신 compact라는 이름을 사용해서 의도를 분명하게 했죠. 이제 compact로 시작하는 함수를 보면 그 의도를 쉽게 알아차려 코드를 문장처럼 읽을 수 있습니다. **의미 있는 이름은 의도를 분명히 드러내 팀을 코드만으로 소통하게 만듭니다.**\n\n---\n\n[다음 글](/clean-code-2)은 함수와 주석 그리고 오류 처리에 대해 다룹니다.\n","source":"_posts/clean-code-1.md","raw":"---\ntitle: 클린 코드 - 협업을 위한 코드 2\ncategories:\n  - joeun.dev\ntags:\n  - clean code\n  - 클린 코드\ndescription: 깨끗한 코드와 의미 있는 이름\ndate: 2020-01-15 20:00:00\n---\n\n[클린 코드를 주제로 했던 강의](https://speakerdeck.com/joeun_ha/200107-ssafy)를 글로 정리합니다. (강의 내용과 글의 코드가 상이할 수 있습니다.)\n\n---\n\n## 클린 코드\n\n[로버트 마틴(Robert C. Martin)](https://en.wikipedia.org/wiki/Robert_C._Martin)의 책을 통해 클린 코드를 알게 됐습니다. 협업을 잘하기 위해 회사에서 동료들과 함께 스터디를 진행했습니다. 이를 통해 배운 클린 코드에 대한 몇 가지 지식을 추려봤습니다. 간단한 예시와 실제 사례도 담았습니다.\n\n### 깨끗한 코드\n> 깨끗한 코드는 잘 쓴 문장처럼 읽힌다 - Grady Booch\n\n![](/images/clean-code/code-quality-wtf.jpg)\n\n위의 이미지는 클린 코드가 무엇인지 단적으로 표현하고 있습니다. 좋은 코드와 나쁜 코드를 판별하는 지표로 '분당 WTF의 횟수'를 사용할 수 있다고 말하고 있죠. WTF은 우리말로 표현하자면 \"이건 뭐지...?\" 정도가 되지 않을까 싶습니다. 코드를 읽는 중에 \"이건 뭐지?\"하고 이해하기 어려운 코드가 자주 나올수록 나쁜 코드라는 의미죠. 앞에 나온 예시를 다시 보겠습니다.\n\n```js\nevt1('#is_prime', ({ currentTarget }) => (\n    rend(current.loans = has_c(currentTarget, 'all') ?\n        current.loans.filter(loan => loan.is_prime) :\n        origin.loans.sort(compare[current.sort_by]))\n    && toggle_c(currentTarget, 'all')\n));\n```\n\n곳곳에서 WTF을 외치게 되죠. 이 짧은 코드에 적어도 일곱 번은 이건 무슨 소릴까 하는 의문이 생길 겁니다. 명백히 나쁜 코드네요. 책에서 소개되는 대가 중 한 명인 [그래디 부치(Grady Booch)](https://en.wikipedia.org/wiki/Grady_Booch)는 **깨끗한 코드는 잘 쓴 문장처럼 읽힌다**고 말합니다. 예시를 잘 쓴 문장처럼 바꾸면 어떻게될까요?\n\n```js\non_click(\"#is_prime\", ({ currentTarget }) => {\n  const has_class_all = has_class(currentTarget, \"all\");\n\n  if (has_class_all) {\n    const is_prime = loan => loan.is_prime;\n    const filtered_loans = current.loans.filter(is_prime);\n\n    set_state({ loans: filtered_loans });\n  } else {\n    const compare_function = compare_functions[current.sort_by];\n    const sorted_loans = origin.loans.sort(compare_function);\n\n    set_state({ loans: sorted_loans });\n  }\n\n  render(current.loans);\n  toggle_class(currentTarget, \"all\");\n});\n```\n\n'all' 클래스를 가졌다면 현재 데이터(current.loans) 중에서 필터링해 랜더링 하고, 그렇지 않다면 기존 데이터(origin.loans)를 정렬해 랜더링 하고 있습니다. 확실히 이제는 문장처럼 읽힙니다.\n\n### 의미 있는 이름\n> 의도를 분명하게 밝혀라 - Robert C. Martin\n\n이번에는 실제 코드 리뷰 중에 있었던 사례를 살펴보겠습니다. 여기 `clearEmptyKey`라는 함수가 있습니다. `undefined` 혹은 `null`을 빈 값(empty)으로 보고 지워버리는 함수입니다. (함수 선언부 내에 사용되는 함수는 [immutable.js에서 제공하는 함수](https://immutable-js.github.io/immutable-js/docs/#/Collection/filter)입니다.)\n\n```js\nconst clearEmptyKey = data => (\n  Map(data).filter(item => (\n    item !== undefined && item !== null\n  )).toObject()\n);\n\nconst userInfo = {\n  id: 327,\n  name: \"joeunha\",\n  gender: null\n};\n\nconsole.log(clearEmptyKey(userInfo));\n// { id: 327, name: \"joeunha\" }\n```\n\n기존에 준비되어 있던 이 함수를 활용해서 PR을 날렸고 리뷰가 시작됐습니다. 해당 함수의 이름에 대해 의문이 제기됐습니다.\n\n<img src=\"/images/clean-code/code-review-0.png\" style=\"border-radius: 4px;\"/>\n\n함수의 의도가 분명하게 드러나지 않은 상황이었죠. 실제 함수의 의도를 댓글로 설명하며 더 좋은 이름을 찾기 시작합니다.\n\n<img src=\"/images/clean-code/code-review-1.png\" style=\"border-radius: 4px;\"/>\n\n새로운 함수의 이름을 제안하고 근거를 제시했습니다. 실제로 [underscore와 같은 라이브러리에서 compact](https://underscorejs.org/#compact)는 무의미한 값(falsy)을 제거하는 함수로 사용됩니다.\n\n<img src=\"/images/clean-code/code-review-2.png\" style=\"border-radius: 4px;\"/>\n\n각자의 생각을 공유하며 의미있는 이름을 도출해가고 있습니다. underscore에서와 같이 compact로만 이름을 짓기 어려운 이유는 대상이 되는 값의 타입이 다양할 수 있기 때문입니다. 저는 이를 추상화 레벨이 너무 높다고 표헌하고 있네요.\n\n<img src=\"/images/clean-code/code-review-3.png\" style=\"border-radius: 4px;\"/>\n\n이에 동료들이 동의하는 뜻을 표합니다. 제시한 함수의 이름이 제 의도를 드러낸다고 동의한 것이죠. 타입 앞에 `compact-`라는 접두사를 붙여 함수 이름을 지어 시리즈로 함수를 만들기로 했습니다.\n\n```js\nconst compactObject = data => (\n  Map(data).filter(item => (\n    item !== undefined && item !== null\n  )).toObject()\n);\n\nconst compactString = data => (\n  data.replace(/ /g, '')\n);\n\nconst compactValues = data => (\n  Map(data)\n    .map(item => (\n      typeof item === 'string' ? compactString(item) : item)\n    )).toObject()\n);\n```\n\n이처럼 함수는 의도를 분명히 밝혀야합니다. 리뷰를 통해 clear 대신 compact라는 이름을 사용해서 의도를 분명하게 했죠. 이제 compact로 시작하는 함수를 보면 그 의도를 쉽게 알아차려 코드를 문장처럼 읽을 수 있습니다. **의미 있는 이름은 의도를 분명히 드러내 팀을 코드만으로 소통하게 만듭니다.**\n\n---\n\n[다음 글](/clean-code-2)은 함수와 주석 그리고 오류 처리에 대해 다룹니다.\n","slug":"clean-code-1","published":1,"updated":"2020-02-09T14:20:01.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9fb000zdirv2ye64d2s","content":"<p><a href=\"https://speakerdeck.com/joeun_ha/200107-ssafy\" target=\"_blank\" rel=\"noopener\">클린 코드를 주제로 했던 강의</a>를 글로 정리합니다. (강의 내용과 글의 코드가 상이할 수 있습니다.)</p>\n<hr>\n<h2 id=\"클린-코드\"><a href=\"#클린-코드\" class=\"headerlink\" title=\"클린 코드\"></a>클린 코드</h2><p><a href=\"https://en.wikipedia.org/wiki/Robert_C._Martin\" target=\"_blank\" rel=\"noopener\">로버트 마틴(Robert C. Martin)</a>의 책을 통해 클린 코드를 알게 됐습니다. 협업을 잘하기 위해 회사에서 동료들과 함께 스터디를 진행했습니다. 이를 통해 배운 클린 코드에 대한 몇 가지 지식을 추려봤습니다. 간단한 예시와 실제 사례도 담았습니다.</p>\n<h3 id=\"깨끗한-코드\"><a href=\"#깨끗한-코드\" class=\"headerlink\" title=\"깨끗한 코드\"></a>깨끗한 코드</h3><blockquote>\n<p>깨끗한 코드는 잘 쓴 문장처럼 읽힌다 - Grady Booch</p>\n</blockquote>\n<p><img src=\"/images/clean-code/code-quality-wtf.jpg\" alt></p>\n<p>위의 이미지는 클린 코드가 무엇인지 단적으로 표현하고 있습니다. 좋은 코드와 나쁜 코드를 판별하는 지표로 ‘분당 WTF의 횟수’를 사용할 수 있다고 말하고 있죠. WTF은 우리말로 표현하자면 “이건 뭐지…?” 정도가 되지 않을까 싶습니다. 코드를 읽는 중에 “이건 뭐지?”하고 이해하기 어려운 코드가 자주 나올수록 나쁜 코드라는 의미죠. 앞에 나온 예시를 다시 보겠습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evt1(<span class=\"string\">'#is_prime'</span>, (&#123; currentTarget &#125;) =&gt; (</span><br><span class=\"line\">    rend(current.loans = has_c(currentTarget, <span class=\"string\">'all'</span>) ?</span><br><span class=\"line\">        current.loans.filter(<span class=\"function\"><span class=\"params\">loan</span> =&gt;</span> loan.is_prime) :</span><br><span class=\"line\">        origin.loans.sort(compare[current.sort_by]))</span><br><span class=\"line\">    &amp;&amp; toggle_c(currentTarget, <span class=\"string\">'all'</span>)</span><br><span class=\"line\">));</span><br></pre></td></tr></table></figure>\n\n<p>곳곳에서 WTF을 외치게 되죠. 이 짧은 코드에 적어도 일곱 번은 이건 무슨 소릴까 하는 의문이 생길 겁니다. 명백히 나쁜 코드네요. 책에서 소개되는 대가 중 한 명인 <a href=\"https://en.wikipedia.org/wiki/Grady_Booch\" target=\"_blank\" rel=\"noopener\">그래디 부치(Grady Booch)</a>는 <strong>깨끗한 코드는 잘 쓴 문장처럼 읽힌다</strong>고 말합니다. 예시를 잘 쓴 문장처럼 바꾸면 어떻게될까요?</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on_click(<span class=\"string\">\"#is_prime\"</span>, (&#123; currentTarget &#125;) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> has_class_all = has_class(currentTarget, <span class=\"string\">\"all\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (has_class_all) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> is_prime = <span class=\"function\"><span class=\"params\">loan</span> =&gt;</span> loan.is_prime;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> filtered_loans = current.loans.filter(is_prime);</span><br><span class=\"line\"></span><br><span class=\"line\">    set_state(&#123; <span class=\"attr\">loans</span>: filtered_loans &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> compare_function = compare_functions[current.sort_by];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> sorted_loans = origin.loans.sort(compare_function);</span><br><span class=\"line\"></span><br><span class=\"line\">    set_state(&#123; <span class=\"attr\">loans</span>: sorted_loans &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render(current.loans);</span><br><span class=\"line\">  toggle_class(currentTarget, <span class=\"string\">\"all\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>‘all’ 클래스를 가졌다면 현재 데이터(current.loans) 중에서 필터링해 랜더링 하고, 그렇지 않다면 기존 데이터(origin.loans)를 정렬해 랜더링 하고 있습니다. 확실히 이제는 문장처럼 읽힙니다.</p>\n<h3 id=\"의미-있는-이름\"><a href=\"#의미-있는-이름\" class=\"headerlink\" title=\"의미 있는 이름\"></a>의미 있는 이름</h3><blockquote>\n<p>의도를 분명하게 밝혀라 - Robert C. Martin</p>\n</blockquote>\n<p>이번에는 실제 코드 리뷰 중에 있었던 사례를 살펴보겠습니다. 여기 <code>clearEmptyKey</code>라는 함수가 있습니다. <code>undefined</code> 혹은 <code>null</code>을 빈 값(empty)으로 보고 지워버리는 함수입니다. (함수 선언부 내에 사용되는 함수는 <a href=\"https://immutable-js.github.io/immutable-js/docs/#/Collection/filter\" target=\"_blank\" rel=\"noopener\">immutable.js에서 제공하는 함수</a>입니다.)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> clearEmptyKey = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> (</span><br><span class=\"line\">  <span class=\"built_in\">Map</span>(data).filter(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> (</span><br><span class=\"line\">    item !== <span class=\"literal\">undefined</span> &amp;&amp; item !== <span class=\"literal\">null</span></span><br><span class=\"line\">  )).toObject()</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> userInfo = &#123;</span><br><span class=\"line\">  id: <span class=\"number\">327</span>,</span><br><span class=\"line\">  name: <span class=\"string\">\"joeunha\"</span>,</span><br><span class=\"line\">  gender: <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(clearEmptyKey(userInfo));</span><br><span class=\"line\"><span class=\"comment\">// &#123; id: 327, name: \"joeunha\" &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>기존에 준비되어 있던 이 함수를 활용해서 PR을 날렸고 리뷰가 시작됐습니다. 해당 함수의 이름에 대해 의문이 제기됐습니다.</p>\n<img src=\"/images/clean-code/code-review-0.png\" style=\"border-radius: 4px;\">\n\n<p>함수의 의도가 분명하게 드러나지 않은 상황이었죠. 실제 함수의 의도를 댓글로 설명하며 더 좋은 이름을 찾기 시작합니다.</p>\n<img src=\"/images/clean-code/code-review-1.png\" style=\"border-radius: 4px;\">\n\n<p>새로운 함수의 이름을 제안하고 근거를 제시했습니다. 실제로 <a href=\"https://underscorejs.org/#compact\" target=\"_blank\" rel=\"noopener\">underscore와 같은 라이브러리에서 compact</a>는 무의미한 값(falsy)을 제거하는 함수로 사용됩니다.</p>\n<img src=\"/images/clean-code/code-review-2.png\" style=\"border-radius: 4px;\">\n\n<p>각자의 생각을 공유하며 의미있는 이름을 도출해가고 있습니다. underscore에서와 같이 compact로만 이름을 짓기 어려운 이유는 대상이 되는 값의 타입이 다양할 수 있기 때문입니다. 저는 이를 추상화 레벨이 너무 높다고 표헌하고 있네요.</p>\n<img src=\"/images/clean-code/code-review-3.png\" style=\"border-radius: 4px;\">\n\n<p>이에 동료들이 동의하는 뜻을 표합니다. 제시한 함수의 이름이 제 의도를 드러낸다고 동의한 것이죠. 타입 앞에 <code>compact-</code>라는 접두사를 붙여 함수 이름을 지어 시리즈로 함수를 만들기로 했습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compactObject = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> (</span><br><span class=\"line\">  <span class=\"built_in\">Map</span>(data).filter(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> (</span><br><span class=\"line\">    item !== <span class=\"literal\">undefined</span> &amp;&amp; item !== <span class=\"literal\">null</span></span><br><span class=\"line\">  )).toObject()</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> compactString = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> (</span><br><span class=\"line\">  data.replace(<span class=\"regexp\">/ /g</span>, <span class=\"string\">''</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> compactValues = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> (</span><br><span class=\"line\">  <span class=\"built_in\">Map</span>(data)</span><br><span class=\"line\">    .map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> (</span><br><span class=\"line\">      <span class=\"keyword\">typeof</span> item === <span class=\"string\">'string'</span> ? compactString(item) : item)</span><br><span class=\"line\">    )).toObject()</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>이처럼 함수는 의도를 분명히 밝혀야합니다. 리뷰를 통해 clear 대신 compact라는 이름을 사용해서 의도를 분명하게 했죠. 이제 compact로 시작하는 함수를 보면 그 의도를 쉽게 알아차려 코드를 문장처럼 읽을 수 있습니다. <strong>의미 있는 이름은 의도를 분명히 드러내 팀을 코드만으로 소통하게 만듭니다.</strong></p>\n<hr>\n<p><a href=\"/clean-code-2\">다음 글</a>은 함수와 주석 그리고 오류 처리에 대해 다룹니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://speakerdeck.com/joeun_ha/200107-ssafy\" target=\"_blank\" rel=\"noopener\">클린 코드를 주제로 했던 강의</a>를 글로 정리합니다. (강의 내용과 글의 코드가 상이할 수 있습니다.)</p>\n<hr>\n<h2 id=\"클린-코드\"><a href=\"#클린-코드\" class=\"headerlink\" title=\"클린 코드\"></a>클린 코드</h2><p><a href=\"https://en.wikipedia.org/wiki/Robert_C._Martin\" target=\"_blank\" rel=\"noopener\">로버트 마틴(Robert C. Martin)</a>의 책을 통해 클린 코드를 알게 됐습니다. 협업을 잘하기 위해 회사에서 동료들과 함께 스터디를 진행했습니다. 이를 통해 배운 클린 코드에 대한 몇 가지 지식을 추려봤습니다. 간단한 예시와 실제 사례도 담았습니다.</p>\n<h3 id=\"깨끗한-코드\"><a href=\"#깨끗한-코드\" class=\"headerlink\" title=\"깨끗한 코드\"></a>깨끗한 코드</h3><blockquote>\n<p>깨끗한 코드는 잘 쓴 문장처럼 읽힌다 - Grady Booch</p>\n</blockquote>\n<p><img src=\"/images/clean-code/code-quality-wtf.jpg\" alt></p>\n<p>위의 이미지는 클린 코드가 무엇인지 단적으로 표현하고 있습니다. 좋은 코드와 나쁜 코드를 판별하는 지표로 ‘분당 WTF의 횟수’를 사용할 수 있다고 말하고 있죠. WTF은 우리말로 표현하자면 “이건 뭐지…?” 정도가 되지 않을까 싶습니다. 코드를 읽는 중에 “이건 뭐지?”하고 이해하기 어려운 코드가 자주 나올수록 나쁜 코드라는 의미죠. 앞에 나온 예시를 다시 보겠습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evt1(<span class=\"string\">'#is_prime'</span>, (&#123; currentTarget &#125;) =&gt; (</span><br><span class=\"line\">    rend(current.loans = has_c(currentTarget, <span class=\"string\">'all'</span>) ?</span><br><span class=\"line\">        current.loans.filter(<span class=\"function\"><span class=\"params\">loan</span> =&gt;</span> loan.is_prime) :</span><br><span class=\"line\">        origin.loans.sort(compare[current.sort_by]))</span><br><span class=\"line\">    &amp;&amp; toggle_c(currentTarget, <span class=\"string\">'all'</span>)</span><br><span class=\"line\">));</span><br></pre></td></tr></table></figure>\n\n<p>곳곳에서 WTF을 외치게 되죠. 이 짧은 코드에 적어도 일곱 번은 이건 무슨 소릴까 하는 의문이 생길 겁니다. 명백히 나쁜 코드네요. 책에서 소개되는 대가 중 한 명인 <a href=\"https://en.wikipedia.org/wiki/Grady_Booch\" target=\"_blank\" rel=\"noopener\">그래디 부치(Grady Booch)</a>는 <strong>깨끗한 코드는 잘 쓴 문장처럼 읽힌다</strong>고 말합니다. 예시를 잘 쓴 문장처럼 바꾸면 어떻게될까요?</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">on_click(<span class=\"string\">\"#is_prime\"</span>, (&#123; currentTarget &#125;) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> has_class_all = has_class(currentTarget, <span class=\"string\">\"all\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (has_class_all) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> is_prime = <span class=\"function\"><span class=\"params\">loan</span> =&gt;</span> loan.is_prime;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> filtered_loans = current.loans.filter(is_prime);</span><br><span class=\"line\"></span><br><span class=\"line\">    set_state(&#123; <span class=\"attr\">loans</span>: filtered_loans &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> compare_function = compare_functions[current.sort_by];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> sorted_loans = origin.loans.sort(compare_function);</span><br><span class=\"line\"></span><br><span class=\"line\">    set_state(&#123; <span class=\"attr\">loans</span>: sorted_loans &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render(current.loans);</span><br><span class=\"line\">  toggle_class(currentTarget, <span class=\"string\">\"all\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>‘all’ 클래스를 가졌다면 현재 데이터(current.loans) 중에서 필터링해 랜더링 하고, 그렇지 않다면 기존 데이터(origin.loans)를 정렬해 랜더링 하고 있습니다. 확실히 이제는 문장처럼 읽힙니다.</p>\n<h3 id=\"의미-있는-이름\"><a href=\"#의미-있는-이름\" class=\"headerlink\" title=\"의미 있는 이름\"></a>의미 있는 이름</h3><blockquote>\n<p>의도를 분명하게 밝혀라 - Robert C. Martin</p>\n</blockquote>\n<p>이번에는 실제 코드 리뷰 중에 있었던 사례를 살펴보겠습니다. 여기 <code>clearEmptyKey</code>라는 함수가 있습니다. <code>undefined</code> 혹은 <code>null</code>을 빈 값(empty)으로 보고 지워버리는 함수입니다. (함수 선언부 내에 사용되는 함수는 <a href=\"https://immutable-js.github.io/immutable-js/docs/#/Collection/filter\" target=\"_blank\" rel=\"noopener\">immutable.js에서 제공하는 함수</a>입니다.)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> clearEmptyKey = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> (</span><br><span class=\"line\">  <span class=\"built_in\">Map</span>(data).filter(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> (</span><br><span class=\"line\">    item !== <span class=\"literal\">undefined</span> &amp;&amp; item !== <span class=\"literal\">null</span></span><br><span class=\"line\">  )).toObject()</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> userInfo = &#123;</span><br><span class=\"line\">  id: <span class=\"number\">327</span>,</span><br><span class=\"line\">  name: <span class=\"string\">\"joeunha\"</span>,</span><br><span class=\"line\">  gender: <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(clearEmptyKey(userInfo));</span><br><span class=\"line\"><span class=\"comment\">// &#123; id: 327, name: \"joeunha\" &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>기존에 준비되어 있던 이 함수를 활용해서 PR을 날렸고 리뷰가 시작됐습니다. 해당 함수의 이름에 대해 의문이 제기됐습니다.</p>\n<img src=\"/images/clean-code/code-review-0.png\" style=\"border-radius: 4px;\">\n\n<p>함수의 의도가 분명하게 드러나지 않은 상황이었죠. 실제 함수의 의도를 댓글로 설명하며 더 좋은 이름을 찾기 시작합니다.</p>\n<img src=\"/images/clean-code/code-review-1.png\" style=\"border-radius: 4px;\">\n\n<p>새로운 함수의 이름을 제안하고 근거를 제시했습니다. 실제로 <a href=\"https://underscorejs.org/#compact\" target=\"_blank\" rel=\"noopener\">underscore와 같은 라이브러리에서 compact</a>는 무의미한 값(falsy)을 제거하는 함수로 사용됩니다.</p>\n<img src=\"/images/clean-code/code-review-2.png\" style=\"border-radius: 4px;\">\n\n<p>각자의 생각을 공유하며 의미있는 이름을 도출해가고 있습니다. underscore에서와 같이 compact로만 이름을 짓기 어려운 이유는 대상이 되는 값의 타입이 다양할 수 있기 때문입니다. 저는 이를 추상화 레벨이 너무 높다고 표헌하고 있네요.</p>\n<img src=\"/images/clean-code/code-review-3.png\" style=\"border-radius: 4px;\">\n\n<p>이에 동료들이 동의하는 뜻을 표합니다. 제시한 함수의 이름이 제 의도를 드러낸다고 동의한 것이죠. 타입 앞에 <code>compact-</code>라는 접두사를 붙여 함수 이름을 지어 시리즈로 함수를 만들기로 했습니다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compactObject = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> (</span><br><span class=\"line\">  <span class=\"built_in\">Map</span>(data).filter(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> (</span><br><span class=\"line\">    item !== <span class=\"literal\">undefined</span> &amp;&amp; item !== <span class=\"literal\">null</span></span><br><span class=\"line\">  )).toObject()</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> compactString = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> (</span><br><span class=\"line\">  data.replace(<span class=\"regexp\">/ /g</span>, <span class=\"string\">''</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> compactValues = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> (</span><br><span class=\"line\">  <span class=\"built_in\">Map</span>(data)</span><br><span class=\"line\">    .map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> (</span><br><span class=\"line\">      <span class=\"keyword\">typeof</span> item === <span class=\"string\">'string'</span> ? compactString(item) : item)</span><br><span class=\"line\">    )).toObject()</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>이처럼 함수는 의도를 분명히 밝혀야합니다. 리뷰를 통해 clear 대신 compact라는 이름을 사용해서 의도를 분명하게 했죠. 이제 compact로 시작하는 함수를 보면 그 의도를 쉽게 알아차려 코드를 문장처럼 읽을 수 있습니다. <strong>의미 있는 이름은 의도를 분명히 드러내 팀을 코드만으로 소통하게 만듭니다.</strong></p>\n<hr>\n<p><a href=\"/clean-code-2\">다음 글</a>은 함수와 주석 그리고 오류 처리에 대해 다룹니다.</p>\n"},{"id":"531","title":"[CSS] Color, Hex Code and RGB","date":"2016-05-12T06:21:07.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=531","_content":"CSS에서 색을 표현할 때 간단하게 &#8216;red&#8217;, &#8216;white&#8217;, &#8216;black&#8217;등으로 표기하기도 합니다. 하지만 실제로는 다양한 색을 표현하기 위해 다른 방식을 더 자주 쓰게 됩니다. &#8216;#FF0000&#8217; 혹은 &#8216;rgb(255, 0, 0)&#8217;처럼 표기하는 경우입니다. 이 두가지 표현 방법에 대해 다루겠습니다.\n\n**Hex Code &#8211; #<span style=\"color: #ff0000;\">00</span><span style=\"color: #00ff00;\">00</span><span style=\"color: #0000ff;\">00</span>**\n  \n우선은 Hexadecimal Code의 준말인 Hex Code로 `#FF0000`처럼 표기하는 방법입니다. Hexadecimal은 16진법을 의미합니다. 일반적으로 표기하는 방식은 10진법입니다. 16진법은 0부터 15까지의 수를 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F로 표기합니다. A는 10을 의미하게 되는 것이죠. 이 방식을 이용하면 한자리 수로 16까지 표기 가능하고 두자리로 255까지 표기 가능합니다.\n\n해당 표기법으로 색을 표현할 때는 단순한 규칙을 가집니다.\n\n  * 샵(#)기호 이후의 여섯자리의 숫자가 온다.\n  * 첫번째,두번째 숫자는 빨간색(RED)의 정도를 의미한다.\n  * 세번째,네번째 숫자는 초록색(GREEN)의 정도를 의미한다.\n  * 다섯번째,여섯번째 숫자는 파란색(BLUE)의 정도를 의미한다.\n  * 숫자가 클수록 정도(색의 농도)가 높아(짙어)진다.\n\n예를 들어 `#FF0000`의 경우 빨간색입니다. 왜냐하면 가장 앞의 두자리가 FF로 가장 높은 정도를 가지고 뒤의 네자리는 0이기 때문입니다. 같은 원리로 `#00FF00`는 초록색입니다. 이때 색을 섞어서 다양한 색을 표현할 수 있는데 그 표현의 가지수는 256\\*256\\*256 만큼입니다. 약 1,600만개입니다.\n\n**RGB Code &#8211; rgb(<span style=\"color: #ff0000;\">255</span>, <span style=\"color: #00ff00;\">255</span>, <span style=\"color: #0000ff;\">255</span>)**\n  \n다음은 RGB Code인데 Red, Green, Blue의 정도를 숫자(10진법)으로 `rgb(255, 0, 0)`처럼 표기하는 방법입니다. 쉼표로 각 색의 정도를 구분짓습니다. 앞선 Hex Code를 이해하셨다면 쉽게 사용하실 수 있습니다. 위의 표기는 빨간색이겠죠?","source":"_posts/css-color-hex-code-and-rgb.md","raw":"---\nid: 531\ntitle: '[CSS] Color, Hex Code and RGB'\ndate: 2016-05-12T15:21:07+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=531\npermalink: /css-color-hex-code-and-rgb/\ncategories:\n  - rabbylab\ntags:\n  - css\n---\nCSS에서 색을 표현할 때 간단하게 &#8216;red&#8217;, &#8216;white&#8217;, &#8216;black&#8217;등으로 표기하기도 합니다. 하지만 실제로는 다양한 색을 표현하기 위해 다른 방식을 더 자주 쓰게 됩니다. &#8216;#FF0000&#8217; 혹은 &#8216;rgb(255, 0, 0)&#8217;처럼 표기하는 경우입니다. 이 두가지 표현 방법에 대해 다루겠습니다.\n\n**Hex Code &#8211; #<span style=\"color: #ff0000;\">00</span><span style=\"color: #00ff00;\">00</span><span style=\"color: #0000ff;\">00</span>**\n  \n우선은 Hexadecimal Code의 준말인 Hex Code로 `#FF0000`처럼 표기하는 방법입니다. Hexadecimal은 16진법을 의미합니다. 일반적으로 표기하는 방식은 10진법입니다. 16진법은 0부터 15까지의 수를 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F로 표기합니다. A는 10을 의미하게 되는 것이죠. 이 방식을 이용하면 한자리 수로 16까지 표기 가능하고 두자리로 255까지 표기 가능합니다.\n\n해당 표기법으로 색을 표현할 때는 단순한 규칙을 가집니다.\n\n  * 샵(#)기호 이후의 여섯자리의 숫자가 온다.\n  * 첫번째,두번째 숫자는 빨간색(RED)의 정도를 의미한다.\n  * 세번째,네번째 숫자는 초록색(GREEN)의 정도를 의미한다.\n  * 다섯번째,여섯번째 숫자는 파란색(BLUE)의 정도를 의미한다.\n  * 숫자가 클수록 정도(색의 농도)가 높아(짙어)진다.\n\n예를 들어 `#FF0000`의 경우 빨간색입니다. 왜냐하면 가장 앞의 두자리가 FF로 가장 높은 정도를 가지고 뒤의 네자리는 0이기 때문입니다. 같은 원리로 `#00FF00`는 초록색입니다. 이때 색을 섞어서 다양한 색을 표현할 수 있는데 그 표현의 가지수는 256\\*256\\*256 만큼입니다. 약 1,600만개입니다.\n\n**RGB Code &#8211; rgb(<span style=\"color: #ff0000;\">255</span>, <span style=\"color: #00ff00;\">255</span>, <span style=\"color: #0000ff;\">255</span>)**\n  \n다음은 RGB Code인데 Red, Green, Blue의 정도를 숫자(10진법)으로 `rgb(255, 0, 0)`처럼 표기하는 방법입니다. 쉼표로 각 색의 정도를 구분짓습니다. 앞선 Hex Code를 이해하셨다면 쉽게 사용하실 수 있습니다. 위의 표기는 빨간색이겠죠?","slug":"/css-color-hex-code-and-rgb/","published":1,"updated":"2019-12-05T15:05:29.482Z","comments":1,"photos":[],"link":"","_id":"ck6jcr9fc0012dirv1yvfxzjp","content":"<p>CSS에서 색을 표현할 때 간단하게 &#8216;red&#8217;, &#8216;white&#8217;, &#8216;black&#8217;등으로 표기하기도 합니다. 하지만 실제로는 다양한 색을 표현하기 위해 다른 방식을 더 자주 쓰게 됩니다. &#8216;#FF0000&#8217; 혹은 &#8216;rgb(255, 0, 0)&#8217;처럼 표기하는 경우입니다. 이 두가지 표현 방법에 대해 다루겠습니다.</p>\n<p><strong>Hex Code &#8211; #<span style=\"color: #ff0000;\">00</span><span style=\"color: #00ff00;\">00</span><span style=\"color: #0000ff;\">00</span></strong></p>\n<p>우선은 Hexadecimal Code의 준말인 Hex Code로 <code>#FF0000</code>처럼 표기하는 방법입니다. Hexadecimal은 16진법을 의미합니다. 일반적으로 표기하는 방식은 10진법입니다. 16진법은 0부터 15까지의 수를 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F로 표기합니다. A는 10을 의미하게 되는 것이죠. 이 방식을 이용하면 한자리 수로 16까지 표기 가능하고 두자리로 255까지 표기 가능합니다.</p>\n<p>해당 표기법으로 색을 표현할 때는 단순한 규칙을 가집니다.</p>\n<ul>\n<li>샵(#)기호 이후의 여섯자리의 숫자가 온다.</li>\n<li>첫번째,두번째 숫자는 빨간색(RED)의 정도를 의미한다.</li>\n<li>세번째,네번째 숫자는 초록색(GREEN)의 정도를 의미한다.</li>\n<li>다섯번째,여섯번째 숫자는 파란색(BLUE)의 정도를 의미한다.</li>\n<li>숫자가 클수록 정도(색의 농도)가 높아(짙어)진다.</li>\n</ul>\n<p>예를 들어 <code>#FF0000</code>의 경우 빨간색입니다. 왜냐하면 가장 앞의 두자리가 FF로 가장 높은 정도를 가지고 뒤의 네자리는 0이기 때문입니다. 같은 원리로 <code>#00FF00</code>는 초록색입니다. 이때 색을 섞어서 다양한 색을 표현할 수 있는데 그 표현의 가지수는 256*256*256 만큼입니다. 약 1,600만개입니다.</p>\n<p><strong>RGB Code &#8211; rgb(<span style=\"color: #ff0000;\">255</span>, <span style=\"color: #00ff00;\">255</span>, <span style=\"color: #0000ff;\">255</span>)</strong></p>\n<p>다음은 RGB Code인데 Red, Green, Blue의 정도를 숫자(10진법)으로 <code>rgb(255, 0, 0)</code>처럼 표기하는 방법입니다. 쉼표로 각 색의 정도를 구분짓습니다. 앞선 Hex Code를 이해하셨다면 쉽게 사용하실 수 있습니다. 위의 표기는 빨간색이겠죠?</p>\n","site":{"data":{}},"excerpt":"","more":"<p>CSS에서 색을 표현할 때 간단하게 &#8216;red&#8217;, &#8216;white&#8217;, &#8216;black&#8217;등으로 표기하기도 합니다. 하지만 실제로는 다양한 색을 표현하기 위해 다른 방식을 더 자주 쓰게 됩니다. &#8216;#FF0000&#8217; 혹은 &#8216;rgb(255, 0, 0)&#8217;처럼 표기하는 경우입니다. 이 두가지 표현 방법에 대해 다루겠습니다.</p>\n<p><strong>Hex Code &#8211; #<span style=\"color: #ff0000;\">00</span><span style=\"color: #00ff00;\">00</span><span style=\"color: #0000ff;\">00</span></strong></p>\n<p>우선은 Hexadecimal Code의 준말인 Hex Code로 <code>#FF0000</code>처럼 표기하는 방법입니다. Hexadecimal은 16진법을 의미합니다. 일반적으로 표기하는 방식은 10진법입니다. 16진법은 0부터 15까지의 수를 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F로 표기합니다. A는 10을 의미하게 되는 것이죠. 이 방식을 이용하면 한자리 수로 16까지 표기 가능하고 두자리로 255까지 표기 가능합니다.</p>\n<p>해당 표기법으로 색을 표현할 때는 단순한 규칙을 가집니다.</p>\n<ul>\n<li>샵(#)기호 이후의 여섯자리의 숫자가 온다.</li>\n<li>첫번째,두번째 숫자는 빨간색(RED)의 정도를 의미한다.</li>\n<li>세번째,네번째 숫자는 초록색(GREEN)의 정도를 의미한다.</li>\n<li>다섯번째,여섯번째 숫자는 파란색(BLUE)의 정도를 의미한다.</li>\n<li>숫자가 클수록 정도(색의 농도)가 높아(짙어)진다.</li>\n</ul>\n<p>예를 들어 <code>#FF0000</code>의 경우 빨간색입니다. 왜냐하면 가장 앞의 두자리가 FF로 가장 높은 정도를 가지고 뒤의 네자리는 0이기 때문입니다. 같은 원리로 <code>#00FF00</code>는 초록색입니다. 이때 색을 섞어서 다양한 색을 표현할 수 있는데 그 표현의 가지수는 256*256*256 만큼입니다. 약 1,600만개입니다.</p>\n<p><strong>RGB Code &#8211; rgb(<span style=\"color: #ff0000;\">255</span>, <span style=\"color: #00ff00;\">255</span>, <span style=\"color: #0000ff;\">255</span>)</strong></p>\n<p>다음은 RGB Code인데 Red, Green, Blue의 정도를 숫자(10진법)으로 <code>rgb(255, 0, 0)</code>처럼 표기하는 방법입니다. 쉼표로 각 색의 정도를 구분짓습니다. 앞선 Hex Code를 이해하셨다면 쉽게 사용하실 수 있습니다. 위의 표기는 빨간색이겠죠?</p>\n"},{"id":"520","title":"[CSS] Style Override","date":"2016-05-11T06:52:47.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=520","_content":"CSS Style Override는 컴포넌트, 라이브러리를 커스텀하기 위해 사용됩니다. 어떤 식으로 Override가 가능한지 살펴보겠습니다.\n\nCSS 파일은 위에서 아래로 순차적으로 실행됩니다. 때문에 동일한 Element에 동시에 적용되는 경우, 가장 마지막에 선언된 Style이 가장 높은 우선순위를 갖습니다.\n\n예를 들어 아래와 같은 상황에서 h1은 blue-text 속성 값을 지니고 파란색으로 표기되죠.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">&lt;style&gt;\n  body {\n    background-color: black;\n    font-family: Monospace;\n    color: green;\n  }\n  .pink-text {\n    color: pink;\n  }\n  .blue-text {\n    color: blue;\n  }\n&lt;/style&gt;\n\n\n&lt;h1 class=\"pink-text blue-text\"&gt;Hello World!&lt;/h1&gt; //파란색\n\n</pre>\n\n다만 id로 속성을 지정할 경우에는 어떤 class보다 높은 우선순위를 가집니다. 결국 아래와 같은 코드는 `<h1>`이 주황색으로 표기됩니다.\n\n```\n<style>\n  body {\n    background-color: black;\n    font-family: Monospace;\n    color: green;\n  }\n  #orange-text {\n    color: orange;\n  }\n  .pink-text {\n    color: pink;\n  }\n  .blue-text {\n    color: blue;\n  }\n</style>\n\n<h1 id=\"orange-text\" class=\"pink-text blue-text\">Hello World!</h1> //주황색\n```\n\nid 값보다 높은 우선순위를 갖는 방법은 in-line으로 스타일을 지정하는 방법입니다. 위의 코드에서 h1에 `style=\"color: white\"`를 추가해주면 다른 class/id보다 높은 우선순위를 가진 in-line style에 의해 h1는 흰색으로 표기됩니다.\n\n하지만 이 모든 방법보다 우위의 순위를 가질 수 있는 방법이 있습니다. 바로 `!important`를 추가하는 것이죠. 예를들어 모든 class와 id 그리고 in-line style에 의해 가장 마지막으로 밀린 pink-text를 최상위 스타일로 적용하고 싶다면, `color: pink !important;`를 적용해주면 된다. 이 결과로 h1은 분홍색으로 표기됩니다.\n\n**정리하자면 CSS Style의 우선순위는**\n\n  1. **동일한 class일 경우 가장 마지막에 선언된 Style이 높다.**\n  2. **(1번을 포함하고) class보다 id가 높다.**\n  3. **id보다 in-line style이 높다.**\n  4. **!important는 앞선 모든 것보다 높다.**\n\n**라고 정의할 수 있습니다.**","source":"_posts/css-style-override.md","raw":"---\nid: 520\ntitle: '[CSS] Style Override'\ndate: 2016-05-11T15:52:47+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=520\npermalink: /css-style-override/\ncategories:\n  - rabbylab\ntags:\n  - css\n---\nCSS Style Override는 컴포넌트, 라이브러리를 커스텀하기 위해 사용됩니다. 어떤 식으로 Override가 가능한지 살펴보겠습니다.\n\nCSS 파일은 위에서 아래로 순차적으로 실행됩니다. 때문에 동일한 Element에 동시에 적용되는 경우, 가장 마지막에 선언된 Style이 가장 높은 우선순위를 갖습니다.\n\n예를 들어 아래와 같은 상황에서 h1은 blue-text 속성 값을 지니고 파란색으로 표기되죠.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">&lt;style&gt;\n  body {\n    background-color: black;\n    font-family: Monospace;\n    color: green;\n  }\n  .pink-text {\n    color: pink;\n  }\n  .blue-text {\n    color: blue;\n  }\n&lt;/style&gt;\n\n\n&lt;h1 class=\"pink-text blue-text\"&gt;Hello World!&lt;/h1&gt; //파란색\n\n</pre>\n\n다만 id로 속성을 지정할 경우에는 어떤 class보다 높은 우선순위를 가집니다. 결국 아래와 같은 코드는 `<h1>`이 주황색으로 표기됩니다.\n\n```\n<style>\n  body {\n    background-color: black;\n    font-family: Monospace;\n    color: green;\n  }\n  #orange-text {\n    color: orange;\n  }\n  .pink-text {\n    color: pink;\n  }\n  .blue-text {\n    color: blue;\n  }\n</style>\n\n<h1 id=\"orange-text\" class=\"pink-text blue-text\">Hello World!</h1> //주황색\n```\n\nid 값보다 높은 우선순위를 갖는 방법은 in-line으로 스타일을 지정하는 방법입니다. 위의 코드에서 h1에 `style=\"color: white\"`를 추가해주면 다른 class/id보다 높은 우선순위를 가진 in-line style에 의해 h1는 흰색으로 표기됩니다.\n\n하지만 이 모든 방법보다 우위의 순위를 가질 수 있는 방법이 있습니다. 바로 `!important`를 추가하는 것이죠. 예를들어 모든 class와 id 그리고 in-line style에 의해 가장 마지막으로 밀린 pink-text를 최상위 스타일로 적용하고 싶다면, `color: pink !important;`를 적용해주면 된다. 이 결과로 h1은 분홍색으로 표기됩니다.\n\n**정리하자면 CSS Style의 우선순위는**\n\n  1. **동일한 class일 경우 가장 마지막에 선언된 Style이 높다.**\n  2. **(1번을 포함하고) class보다 id가 높다.**\n  3. **id보다 in-line style이 높다.**\n  4. **!important는 앞선 모든 것보다 높다.**\n\n**라고 정의할 수 있습니다.**","slug":"/css-style-override/","published":1,"updated":"2019-12-05T15:05:29.482Z","comments":1,"photos":[],"link":"","_id":"ck6jcr9fe0014dirvayib7dbw","content":"<p>CSS Style Override는 컴포넌트, 라이브러리를 커스텀하기 위해 사용됩니다. 어떤 식으로 Override가 가능한지 살펴보겠습니다.</p>\n<p>CSS 파일은 위에서 아래로 순차적으로 실행됩니다. 때문에 동일한 Element에 동시에 적용되는 경우, 가장 마지막에 선언된 Style이 가장 높은 우선순위를 갖습니다.</p>\n<p>예를 들어 아래와 같은 상황에서 h1은 blue-text 속성 값을 지니고 파란색으로 표기되죠.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title>&lt;style&gt;\n  body {\n    background-color: black;\n    font-family: Monospace;\n    color: green;\n  }\n  .pink-text {\n    color: pink;\n  }\n  .blue-text {\n    color: blue;\n  }\n&lt;/style&gt;\n\n\n&lt;h1 class=\"pink-text blue-text\"&gt;Hello World!&lt;/h1&gt; //파란색\n\n</pre>\n\n<p>다만 id로 속성을 지정할 경우에는 어떤 class보다 높은 우선순위를 가집니다. 결국 아래와 같은 코드는 <code>&lt;h1&gt;</code>이 주황색으로 표기됩니다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">  body &#123;</span><br><span class=\"line\">    background-color: black;</span><br><span class=\"line\">    font-family: Monospace;</span><br><span class=\"line\">    color: green;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-id\">#orange-text</span> &#123;</span></span><br><span class=\"line\">    color: orange;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-class\">.pink-text</span> &#123;</span></span><br><span class=\"line\">    color: pink;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-class\">.blue-text</span> &#123;</span></span><br><span class=\"line\">    color: blue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">id</span>=<span class=\"string\">\"orange-text\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"pink-text blue-text\"</span>&gt;</span>Hello World!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span> //주황색</span><br></pre></td></tr></table></figure>\n\n<p>id 값보다 높은 우선순위를 갖는 방법은 in-line으로 스타일을 지정하는 방법입니다. 위의 코드에서 h1에 <code>style=&quot;color: white&quot;</code>를 추가해주면 다른 class/id보다 높은 우선순위를 가진 in-line style에 의해 h1는 흰색으로 표기됩니다.</p>\n<p>하지만 이 모든 방법보다 우위의 순위를 가질 수 있는 방법이 있습니다. 바로 <code>!important</code>를 추가하는 것이죠. 예를들어 모든 class와 id 그리고 in-line style에 의해 가장 마지막으로 밀린 pink-text를 최상위 스타일로 적용하고 싶다면, <code>color: pink !important;</code>를 적용해주면 된다. 이 결과로 h1은 분홍색으로 표기됩니다.</p>\n<p><strong>정리하자면 CSS Style의 우선순위는</strong></p>\n<ol>\n<li><strong>동일한 class일 경우 가장 마지막에 선언된 Style이 높다.</strong></li>\n<li><strong>(1번을 포함하고) class보다 id가 높다.</strong></li>\n<li><strong>id보다 in-line style이 높다.</strong></li>\n<li><strong>!important는 앞선 모든 것보다 높다.</strong></li>\n</ol>\n<p><strong>라고 정의할 수 있습니다.</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>CSS Style Override는 컴포넌트, 라이브러리를 커스텀하기 위해 사용됩니다. 어떤 식으로 Override가 가능한지 살펴보겠습니다.</p>\n<p>CSS 파일은 위에서 아래로 순차적으로 실행됩니다. 때문에 동일한 Element에 동시에 적용되는 경우, 가장 마지막에 선언된 Style이 가장 높은 우선순위를 갖습니다.</p>\n<p>예를 들어 아래와 같은 상황에서 h1은 blue-text 속성 값을 지니고 파란색으로 표기되죠.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title>&lt;style&gt;\n  body {\n    background-color: black;\n    font-family: Monospace;\n    color: green;\n  }\n  .pink-text {\n    color: pink;\n  }\n  .blue-text {\n    color: blue;\n  }\n&lt;/style&gt;\n\n\n&lt;h1 class=\"pink-text blue-text\"&gt;Hello World!&lt;/h1&gt; //파란색\n\n</pre>\n\n<p>다만 id로 속성을 지정할 경우에는 어떤 class보다 높은 우선순위를 가집니다. 결국 아래와 같은 코드는 <code>&lt;h1&gt;</code>이 주황색으로 표기됩니다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">  body &#123;</span><br><span class=\"line\">    background-color: black;</span><br><span class=\"line\">    font-family: Monospace;</span><br><span class=\"line\">    color: green;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-id\">#orange-text</span> &#123;</span></span><br><span class=\"line\">    color: orange;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-class\">.pink-text</span> &#123;</span></span><br><span class=\"line\">    color: pink;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-class\">.blue-text</span> &#123;</span></span><br><span class=\"line\">    color: blue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">id</span>=<span class=\"string\">\"orange-text\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"pink-text blue-text\"</span>&gt;</span>Hello World!<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span> //주황색</span><br></pre></td></tr></table></figure>\n\n<p>id 값보다 높은 우선순위를 갖는 방법은 in-line으로 스타일을 지정하는 방법입니다. 위의 코드에서 h1에 <code>style=&quot;color: white&quot;</code>를 추가해주면 다른 class/id보다 높은 우선순위를 가진 in-line style에 의해 h1는 흰색으로 표기됩니다.</p>\n<p>하지만 이 모든 방법보다 우위의 순위를 가질 수 있는 방법이 있습니다. 바로 <code>!important</code>를 추가하는 것이죠. 예를들어 모든 class와 id 그리고 in-line style에 의해 가장 마지막으로 밀린 pink-text를 최상위 스타일로 적용하고 싶다면, <code>color: pink !important;</code>를 적용해주면 된다. 이 결과로 h1은 분홍색으로 표기됩니다.</p>\n<p><strong>정리하자면 CSS Style의 우선순위는</strong></p>\n<ol>\n<li><strong>동일한 class일 경우 가장 마지막에 선언된 Style이 높다.</strong></li>\n<li><strong>(1번을 포함하고) class보다 id가 높다.</strong></li>\n<li><strong>id보다 in-line style이 높다.</strong></li>\n<li><strong>!important는 앞선 모든 것보다 높다.</strong></li>\n</ol>\n<p><strong>라고 정의할 수 있습니다.</strong></p>\n"},{"id":"479","title":"[Group] COIN, 함께 성장하기","date":"2016-03-26T17:08:18.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=479","_content":"학기의 시작을 앞두고 평소 함께 진로를 고민하던 <a href=\"http://oyabun.xyz\" target=\"_blank\">친한 형님</a>과 이야기를 나눌 기회가 있었습니다. 둘다 졸업을 앞둔 시기라 취업에 관한 이야기가 주를 이뤘죠. 어떻게 준비하면 개발자로 일을 시작할 수 있을까하고 이야기를 나누다보니 나름대로 비슷한 것을 준비하고 있다는 것을 알게되었습니다. 블로그를 운영하고 기술면접(코딩인터뷰)을 준비하고 있다는 사실이 그랬죠. 그리고 학교에서 제공하는 취업 관련 컨설팅이 저희 같은 개발자에게 부족한 부분이 많다는 것을 서로 공감했습니다. 이에 함께 이런 이야기를 할 수 있는 자리를 만들고 비슷한 고민을 하는 친구들을 모아서 동아리를 운영해보자는 이야기까지 나왔습니다. 마침 학교에서 취업 관련 동아리를 지원해주고 있었기에 저희는 각자 사람을 모으고 일을 추진했습니다.\n\n1주일 후인 3월 4일에 여섯명이 첫모임을 가졌습니다. 그 모임의 이름이 &#8216;**COIN(코인)**&#8216; 입니다. **코**딩**인**터뷰 준비하는 사람들의 모임 혹은 **코**딩하는 **인**간들의 모임이라는 의미를 갖습니다. 저희는 모여서 함께 데이터구조, 알고리즘을 중점적으로 복습 및 학습하고 교재인 <코딩인터뷰 완전분석>이라는 책에 등장하는 예제를 풀어볼 생각입니다. 취업 관련 정보/팁 공유는 덤입니다. 저희 모임을 위해 교내 경력개발실에서도 지원해주고 있습니다.\n\nCOIN 덕분에 저희는 함께 성장할 것 같습니다. 블로그가 풍성해지는 것은 덤이겠지요. 조금씩 더 성장하는 모습 계속 지켜봐주세요. 감사합니다.","source":"_posts/coin.md","raw":"---\nid: 479\ntitle: '[Group] COIN, 함께 성장하기'\ndate: 2016-03-27T02:08:18+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=479\npermalink: /coin/\ncategories:\n  - rabbylab\ntags:\n  - coin\n---\n학기의 시작을 앞두고 평소 함께 진로를 고민하던 <a href=\"http://oyabun.xyz\" target=\"_blank\">친한 형님</a>과 이야기를 나눌 기회가 있었습니다. 둘다 졸업을 앞둔 시기라 취업에 관한 이야기가 주를 이뤘죠. 어떻게 준비하면 개발자로 일을 시작할 수 있을까하고 이야기를 나누다보니 나름대로 비슷한 것을 준비하고 있다는 것을 알게되었습니다. 블로그를 운영하고 기술면접(코딩인터뷰)을 준비하고 있다는 사실이 그랬죠. 그리고 학교에서 제공하는 취업 관련 컨설팅이 저희 같은 개발자에게 부족한 부분이 많다는 것을 서로 공감했습니다. 이에 함께 이런 이야기를 할 수 있는 자리를 만들고 비슷한 고민을 하는 친구들을 모아서 동아리를 운영해보자는 이야기까지 나왔습니다. 마침 학교에서 취업 관련 동아리를 지원해주고 있었기에 저희는 각자 사람을 모으고 일을 추진했습니다.\n\n1주일 후인 3월 4일에 여섯명이 첫모임을 가졌습니다. 그 모임의 이름이 &#8216;**COIN(코인)**&#8216; 입니다. **코**딩**인**터뷰 준비하는 사람들의 모임 혹은 **코**딩하는 **인**간들의 모임이라는 의미를 갖습니다. 저희는 모여서 함께 데이터구조, 알고리즘을 중점적으로 복습 및 학습하고 교재인 <코딩인터뷰 완전분석>이라는 책에 등장하는 예제를 풀어볼 생각입니다. 취업 관련 정보/팁 공유는 덤입니다. 저희 모임을 위해 교내 경력개발실에서도 지원해주고 있습니다.\n\nCOIN 덕분에 저희는 함께 성장할 것 같습니다. 블로그가 풍성해지는 것은 덤이겠지요. 조금씩 더 성장하는 모습 계속 지켜봐주세요. 감사합니다.","slug":"/coin/","published":1,"updated":"2019-12-05T15:05:29.482Z","comments":1,"photos":[],"link":"","_id":"ck6jcr9ff0016dirvsronrnsa","content":"<p>학기의 시작을 앞두고 평소 함께 진로를 고민하던 <a href=\"http://oyabun.xyz\" target=\"_blank\">친한 형님</a>과 이야기를 나눌 기회가 있었습니다. 둘다 졸업을 앞둔 시기라 취업에 관한 이야기가 주를 이뤘죠. 어떻게 준비하면 개발자로 일을 시작할 수 있을까하고 이야기를 나누다보니 나름대로 비슷한 것을 준비하고 있다는 것을 알게되었습니다. 블로그를 운영하고 기술면접(코딩인터뷰)을 준비하고 있다는 사실이 그랬죠. 그리고 학교에서 제공하는 취업 관련 컨설팅이 저희 같은 개발자에게 부족한 부분이 많다는 것을 서로 공감했습니다. 이에 함께 이런 이야기를 할 수 있는 자리를 만들고 비슷한 고민을 하는 친구들을 모아서 동아리를 운영해보자는 이야기까지 나왔습니다. 마침 학교에서 취업 관련 동아리를 지원해주고 있었기에 저희는 각자 사람을 모으고 일을 추진했습니다.</p>\n<p>1주일 후인 3월 4일에 여섯명이 첫모임을 가졌습니다. 그 모임의 이름이 &#8216;<strong>COIN(코인)</strong>&#8216; 입니다. <strong>코</strong>딩<strong>인</strong>터뷰 준비하는 사람들의 모임 혹은 <strong>코</strong>딩하는 <strong>인</strong>간들의 모임이라는 의미를 갖습니다. 저희는 모여서 함께 데이터구조, 알고리즘을 중점적으로 복습 및 학습하고 교재인 &lt;코딩인터뷰 완전분석&gt;이라는 책에 등장하는 예제를 풀어볼 생각입니다. 취업 관련 정보/팁 공유는 덤입니다. 저희 모임을 위해 교내 경력개발실에서도 지원해주고 있습니다.</p>\n<p>COIN 덕분에 저희는 함께 성장할 것 같습니다. 블로그가 풍성해지는 것은 덤이겠지요. 조금씩 더 성장하는 모습 계속 지켜봐주세요. 감사합니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>학기의 시작을 앞두고 평소 함께 진로를 고민하던 <a href=\"http://oyabun.xyz\" target=\"_blank\">친한 형님</a>과 이야기를 나눌 기회가 있었습니다. 둘다 졸업을 앞둔 시기라 취업에 관한 이야기가 주를 이뤘죠. 어떻게 준비하면 개발자로 일을 시작할 수 있을까하고 이야기를 나누다보니 나름대로 비슷한 것을 준비하고 있다는 것을 알게되었습니다. 블로그를 운영하고 기술면접(코딩인터뷰)을 준비하고 있다는 사실이 그랬죠. 그리고 학교에서 제공하는 취업 관련 컨설팅이 저희 같은 개발자에게 부족한 부분이 많다는 것을 서로 공감했습니다. 이에 함께 이런 이야기를 할 수 있는 자리를 만들고 비슷한 고민을 하는 친구들을 모아서 동아리를 운영해보자는 이야기까지 나왔습니다. 마침 학교에서 취업 관련 동아리를 지원해주고 있었기에 저희는 각자 사람을 모으고 일을 추진했습니다.</p>\n<p>1주일 후인 3월 4일에 여섯명이 첫모임을 가졌습니다. 그 모임의 이름이 &#8216;<strong>COIN(코인)</strong>&#8216; 입니다. <strong>코</strong>딩<strong>인</strong>터뷰 준비하는 사람들의 모임 혹은 <strong>코</strong>딩하는 <strong>인</strong>간들의 모임이라는 의미를 갖습니다. 저희는 모여서 함께 데이터구조, 알고리즘을 중점적으로 복습 및 학습하고 교재인 &lt;코딩인터뷰 완전분석&gt;이라는 책에 등장하는 예제를 풀어볼 생각입니다. 취업 관련 정보/팁 공유는 덤입니다. 저희 모임을 위해 교내 경력개발실에서도 지원해주고 있습니다.</p>\n<p>COIN 덕분에 저희는 함께 성장할 것 같습니다. 블로그가 풍성해지는 것은 덤이겠지요. 조금씩 더 성장하는 모습 계속 지켜봐주세요. 감사합니다.</p>\n"},{"id":"570","title":"[Daily Commit] Today I Learned","date":"2016-07-17T14:19:46.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=570","_content":"한동안 개발 활동이 뜸했습니다. 취미 관련 글에서 언급한 것처럼 계절학기로 인해 바빴기 때문입니다. 지난 7월 12일 이후로 학교와 관련된 모든 일을 끝냈습니다. 이제 새로운 곳에서 일을 시작할 예정입니다. (바로 내일부터군요!) 앞으로는 조금 더 꾸준히 개발 공부만 할 수 있을 것 같습니다. 직업이 학생에서 개발자로 바뀌는 덕입니다. 그토록 바라던 개발자라는 직업을 갖게된만큼 더 꾸준히, 체계적으로 개발 활동을 하기 위해 주말동안 물밑작업을 좀 했습니다.\n\n이전부터 다른 블로그에서 [&#8216;일일커밋&#8217;에 관한 글](https://blog.outsider.ne.kr/1141)을 보면서 도전해보고 싶다는 생각을 해왔습니다. 그 중에서도 [Jay Jin님의 블로그](https://milooy.wordpress.com/2015/10/08/daily-commit/)를 통해 알게된 TIL(Today I Learned)을 따라 해보고 싶다는 생각을 해왔습니다. 그래서 주말에 [Jay Jin님의 Github](https://github.com/milooy/TIL)을 찾아가 기본 골격을 본따서 [저만의 TIL](https://github.com/joeunha/TIL)을 구성했습니다.\n\nTIL은 말처럼 그날 배운 내용을 정리해서 커밋(commit)하는 저장소입니다. 무의미한 내용은 커밋하지 않는다는 조건에 따라 의미있는 내용을 커밋합니다. 이로써 일일커밋 활동을 해나갈 수 있고 제가 배워나가는 지식을 저장해서 저만의 위키(wiki)를 만들 수 있습니다. 아마 저는 FreeCodeCamp를 통해서 배우는 내용을 정리하는 것으로 커밋하는 경우가 많을 것 같습니다. 더불어 회사에서 일하면서 배우게 되는 내용을 그날 그날 정리하면 커밋할 내용이 제법될 것 같습니다.\n\n우선은 30일로 일일커밋의 목표를 설정하겠습니다. 무작정 100일로 목표를 세우면 미리부터 지칠것 같아 작게 여러번 가겠습니다.","source":"_posts/daily-commit-today-i-learned.md","raw":"---\nid: 570\ntitle: '[Daily Commit] Today I Learned'\ndate: 2016-07-17T23:19:46+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=570\npermalink: /daily-commit-today-i-learned/\ncategories:\n  - rabbylab\ntags:\n  - daily-commit\n---\n한동안 개발 활동이 뜸했습니다. 취미 관련 글에서 언급한 것처럼 계절학기로 인해 바빴기 때문입니다. 지난 7월 12일 이후로 학교와 관련된 모든 일을 끝냈습니다. 이제 새로운 곳에서 일을 시작할 예정입니다. (바로 내일부터군요!) 앞으로는 조금 더 꾸준히 개발 공부만 할 수 있을 것 같습니다. 직업이 학생에서 개발자로 바뀌는 덕입니다. 그토록 바라던 개발자라는 직업을 갖게된만큼 더 꾸준히, 체계적으로 개발 활동을 하기 위해 주말동안 물밑작업을 좀 했습니다.\n\n이전부터 다른 블로그에서 [&#8216;일일커밋&#8217;에 관한 글](https://blog.outsider.ne.kr/1141)을 보면서 도전해보고 싶다는 생각을 해왔습니다. 그 중에서도 [Jay Jin님의 블로그](https://milooy.wordpress.com/2015/10/08/daily-commit/)를 통해 알게된 TIL(Today I Learned)을 따라 해보고 싶다는 생각을 해왔습니다. 그래서 주말에 [Jay Jin님의 Github](https://github.com/milooy/TIL)을 찾아가 기본 골격을 본따서 [저만의 TIL](https://github.com/joeunha/TIL)을 구성했습니다.\n\nTIL은 말처럼 그날 배운 내용을 정리해서 커밋(commit)하는 저장소입니다. 무의미한 내용은 커밋하지 않는다는 조건에 따라 의미있는 내용을 커밋합니다. 이로써 일일커밋 활동을 해나갈 수 있고 제가 배워나가는 지식을 저장해서 저만의 위키(wiki)를 만들 수 있습니다. 아마 저는 FreeCodeCamp를 통해서 배우는 내용을 정리하는 것으로 커밋하는 경우가 많을 것 같습니다. 더불어 회사에서 일하면서 배우게 되는 내용을 그날 그날 정리하면 커밋할 내용이 제법될 것 같습니다.\n\n우선은 30일로 일일커밋의 목표를 설정하겠습니다. 무작정 100일로 목표를 세우면 미리부터 지칠것 같아 작게 여러번 가겠습니다.","slug":"/daily-commit-today-i-learned/","published":1,"updated":"2019-12-05T15:05:29.482Z","comments":1,"photos":[],"link":"","_id":"ck6jcr9fg0019dirv9zouctiy","content":"<p>한동안 개발 활동이 뜸했습니다. 취미 관련 글에서 언급한 것처럼 계절학기로 인해 바빴기 때문입니다. 지난 7월 12일 이후로 학교와 관련된 모든 일을 끝냈습니다. 이제 새로운 곳에서 일을 시작할 예정입니다. (바로 내일부터군요!) 앞으로는 조금 더 꾸준히 개발 공부만 할 수 있을 것 같습니다. 직업이 학생에서 개발자로 바뀌는 덕입니다. 그토록 바라던 개발자라는 직업을 갖게된만큼 더 꾸준히, 체계적으로 개발 활동을 하기 위해 주말동안 물밑작업을 좀 했습니다.</p>\n<p>이전부터 다른 블로그에서 <a href=\"https://blog.outsider.ne.kr/1141\" target=\"_blank\" rel=\"noopener\">&#8216;일일커밋&#8217;에 관한 글</a>을 보면서 도전해보고 싶다는 생각을 해왔습니다. 그 중에서도 <a href=\"https://milooy.wordpress.com/2015/10/08/daily-commit/\" target=\"_blank\" rel=\"noopener\">Jay Jin님의 블로그</a>를 통해 알게된 TIL(Today I Learned)을 따라 해보고 싶다는 생각을 해왔습니다. 그래서 주말에 <a href=\"https://github.com/milooy/TIL\" target=\"_blank\" rel=\"noopener\">Jay Jin님의 Github</a>을 찾아가 기본 골격을 본따서 <a href=\"https://github.com/joeunha/TIL\" target=\"_blank\" rel=\"noopener\">저만의 TIL</a>을 구성했습니다.</p>\n<p>TIL은 말처럼 그날 배운 내용을 정리해서 커밋(commit)하는 저장소입니다. 무의미한 내용은 커밋하지 않는다는 조건에 따라 의미있는 내용을 커밋합니다. 이로써 일일커밋 활동을 해나갈 수 있고 제가 배워나가는 지식을 저장해서 저만의 위키(wiki)를 만들 수 있습니다. 아마 저는 FreeCodeCamp를 통해서 배우는 내용을 정리하는 것으로 커밋하는 경우가 많을 것 같습니다. 더불어 회사에서 일하면서 배우게 되는 내용을 그날 그날 정리하면 커밋할 내용이 제법될 것 같습니다.</p>\n<p>우선은 30일로 일일커밋의 목표를 설정하겠습니다. 무작정 100일로 목표를 세우면 미리부터 지칠것 같아 작게 여러번 가겠습니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>한동안 개발 활동이 뜸했습니다. 취미 관련 글에서 언급한 것처럼 계절학기로 인해 바빴기 때문입니다. 지난 7월 12일 이후로 학교와 관련된 모든 일을 끝냈습니다. 이제 새로운 곳에서 일을 시작할 예정입니다. (바로 내일부터군요!) 앞으로는 조금 더 꾸준히 개발 공부만 할 수 있을 것 같습니다. 직업이 학생에서 개발자로 바뀌는 덕입니다. 그토록 바라던 개발자라는 직업을 갖게된만큼 더 꾸준히, 체계적으로 개발 활동을 하기 위해 주말동안 물밑작업을 좀 했습니다.</p>\n<p>이전부터 다른 블로그에서 <a href=\"https://blog.outsider.ne.kr/1141\" target=\"_blank\" rel=\"noopener\">&#8216;일일커밋&#8217;에 관한 글</a>을 보면서 도전해보고 싶다는 생각을 해왔습니다. 그 중에서도 <a href=\"https://milooy.wordpress.com/2015/10/08/daily-commit/\" target=\"_blank\" rel=\"noopener\">Jay Jin님의 블로그</a>를 통해 알게된 TIL(Today I Learned)을 따라 해보고 싶다는 생각을 해왔습니다. 그래서 주말에 <a href=\"https://github.com/milooy/TIL\" target=\"_blank\" rel=\"noopener\">Jay Jin님의 Github</a>을 찾아가 기본 골격을 본따서 <a href=\"https://github.com/joeunha/TIL\" target=\"_blank\" rel=\"noopener\">저만의 TIL</a>을 구성했습니다.</p>\n<p>TIL은 말처럼 그날 배운 내용을 정리해서 커밋(commit)하는 저장소입니다. 무의미한 내용은 커밋하지 않는다는 조건에 따라 의미있는 내용을 커밋합니다. 이로써 일일커밋 활동을 해나갈 수 있고 제가 배워나가는 지식을 저장해서 저만의 위키(wiki)를 만들 수 있습니다. 아마 저는 FreeCodeCamp를 통해서 배우는 내용을 정리하는 것으로 커밋하는 경우가 많을 것 같습니다. 더불어 회사에서 일하면서 배우게 되는 내용을 그날 그날 정리하면 커밋할 내용이 제법될 것 같습니다.</p>\n<p>우선은 30일로 일일커밋의 목표를 설정하겠습니다. 무작정 100일로 목표를 세우면 미리부터 지칠것 같아 작게 여러번 가겠습니다.</p>\n"},{"title":"오늘의 함수 - pick","date":"2017-03-07T14:28:18.000Z","description":"많은 데이터를 가진 객체 하나에서 여러 개의 값을 꺼내오려면 어떻게 할까요?","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## pick 함수\n\n__자바스크립트에서 객체는 키(key)와 값(value)의 쌍으로 이루어져있습니다.__ 프로그래밍을 하는 과정에서 키를 기준으로 값을 객체로부터 꺼내는 일을 반복합니다. 많은 데이터를 가진 객체 하나에서 여러 개의 값을 꺼내오려면 어떻게 할까요?\n\n#### 1번 - 어제의 함수\n```javascript\nvar user_1 = { // [1] 기존의 데이터\n  id: 1,\n  first_name: 'Joeun',\n  last_name: 'Ha',\n  age: 28,\n  country: 'South Korea',\n  city: 'Seoul',\n  mobile_phone: '010-0000-0000',\n  email: 'imjoeunha@gmail.com',\n  blog_url: 'http://joeun.dev',\n  };\n\nvar user_data = { // [2] 필요한 데이터\n  id: user_1.id,\n  first_name: user_1.first_name,\n  last_name: user_1.last_name\n  };\n\n$.post('/api/user_name/check', user_data)\n  .done(redirect('/main')); // [3] '오늘의 함수 redirect' 편을 참고하세요.\n```\n\n위의 코드는 기존의 데이터를 가공해서 원하는 데이터만을 추려내서 특정 api로 전송하고 있습니다. 아래와 같은 `pick` 함수를 사용한다면 보다 쉽게 원하는 데이터를 추려낼 수 있습니다. [underscore.js](underscorejs.org)라는 라이브러리에서 볼 수 있는 함수입니다. 아래는 그보다 단순하게 구현되어 있습니다. 원본 객체와 함께 꺼내길 원하는 키 값을 배열로 전달하면 추려진 객체를 반환합니다.\n\n#### 2번 - 오늘의 함수\n```javascript\nvar user_1 = { // [1] 기존의 데이터\n  id: 1,\n  first_name: 'Joeun',\n  last_name: 'Ha',\n  age: 28,\n  country: 'South Korea',\n  city: 'Seoul',\n  mobile_phone: '010-0000-0000',\n  email: 'imjoeunha@gmail.com',\n  blog_url: 'http://joeun.dev',\n  };\n\nfunction pick(target, keys) {\n  return keys.reduce(function(obj, key) {\n    return obj[key] = target[key], obj;\n  }, {});\n}\n\n\nconsole.log(pick(user_1, ['age', 'id'])); // [2] 출력 결과는 { age: 28, id: 1 } 입니다. 이때, 객체 값의 순서가 배열로 전달한 키의 순서대로 반환됩니다.\n\n$.post('/api/user_name/check', pick(user_1, ['id', 'first_name', 'last_name'])) // [3] 간편하게 반복해서 원하는 객체를 만들 수 있습니다.\n  .done(redirect('/main'));\n\n$.post('/api/city/check', pick(user_1, ['id', 'city']))\n  .done(redirect('/main'));\n```\n","source":"_posts/daily-fp-1.md","raw":"---\ntitle: '오늘의 함수 - pick'\ndate: 2017-03-07 23:28:18\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: 많은 데이터를 가진 객체 하나에서 여러 개의 값을 꺼내오려면 어떻게 할까요?\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## pick 함수\n\n__자바스크립트에서 객체는 키(key)와 값(value)의 쌍으로 이루어져있습니다.__ 프로그래밍을 하는 과정에서 키를 기준으로 값을 객체로부터 꺼내는 일을 반복합니다. 많은 데이터를 가진 객체 하나에서 여러 개의 값을 꺼내오려면 어떻게 할까요?\n\n#### 1번 - 어제의 함수\n```javascript\nvar user_1 = { // [1] 기존의 데이터\n  id: 1,\n  first_name: 'Joeun',\n  last_name: 'Ha',\n  age: 28,\n  country: 'South Korea',\n  city: 'Seoul',\n  mobile_phone: '010-0000-0000',\n  email: 'imjoeunha@gmail.com',\n  blog_url: 'http://joeun.dev',\n  };\n\nvar user_data = { // [2] 필요한 데이터\n  id: user_1.id,\n  first_name: user_1.first_name,\n  last_name: user_1.last_name\n  };\n\n$.post('/api/user_name/check', user_data)\n  .done(redirect('/main')); // [3] '오늘의 함수 redirect' 편을 참고하세요.\n```\n\n위의 코드는 기존의 데이터를 가공해서 원하는 데이터만을 추려내서 특정 api로 전송하고 있습니다. 아래와 같은 `pick` 함수를 사용한다면 보다 쉽게 원하는 데이터를 추려낼 수 있습니다. [underscore.js](underscorejs.org)라는 라이브러리에서 볼 수 있는 함수입니다. 아래는 그보다 단순하게 구현되어 있습니다. 원본 객체와 함께 꺼내길 원하는 키 값을 배열로 전달하면 추려진 객체를 반환합니다.\n\n#### 2번 - 오늘의 함수\n```javascript\nvar user_1 = { // [1] 기존의 데이터\n  id: 1,\n  first_name: 'Joeun',\n  last_name: 'Ha',\n  age: 28,\n  country: 'South Korea',\n  city: 'Seoul',\n  mobile_phone: '010-0000-0000',\n  email: 'imjoeunha@gmail.com',\n  blog_url: 'http://joeun.dev',\n  };\n\nfunction pick(target, keys) {\n  return keys.reduce(function(obj, key) {\n    return obj[key] = target[key], obj;\n  }, {});\n}\n\n\nconsole.log(pick(user_1, ['age', 'id'])); // [2] 출력 결과는 { age: 28, id: 1 } 입니다. 이때, 객체 값의 순서가 배열로 전달한 키의 순서대로 반환됩니다.\n\n$.post('/api/user_name/check', pick(user_1, ['id', 'first_name', 'last_name'])) // [3] 간편하게 반복해서 원하는 객체를 만들 수 있습니다.\n  .done(redirect('/main'));\n\n$.post('/api/city/check', pick(user_1, ['id', 'city']))\n  .done(redirect('/main'));\n```\n","slug":"daily-fp-1","published":1,"updated":"2020-02-09T14:20:01.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9fh001bdirv4ez14ja4","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"pick-함수\"><a href=\"#pick-함수\" class=\"headerlink\" title=\"pick 함수\"></a>pick 함수</h2><p><strong>자바스크립트에서 객체는 키(key)와 값(value)의 쌍으로 이루어져있습니다.</strong> 프로그래밍을 하는 과정에서 키를 기준으로 값을 객체로부터 꺼내는 일을 반복합니다. 많은 데이터를 가진 객체 하나에서 여러 개의 값을 꺼내오려면 어떻게 할까요?</p>\n<h4 id=\"1번-어제의-함수\"><a href=\"#1번-어제의-함수\" class=\"headerlink\" title=\"1번 - 어제의 함수\"></a>1번 - 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> user_1 = &#123; <span class=\"comment\">// [1] 기존의 데이터</span></span><br><span class=\"line\">  id: <span class=\"number\">1</span>,</span><br><span class=\"line\">  first_name: <span class=\"string\">'Joeun'</span>,</span><br><span class=\"line\">  last_name: <span class=\"string\">'Ha'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">28</span>,</span><br><span class=\"line\">  country: <span class=\"string\">'South Korea'</span>,</span><br><span class=\"line\">  city: <span class=\"string\">'Seoul'</span>,</span><br><span class=\"line\">  mobile_phone: <span class=\"string\">'010-0000-0000'</span>,</span><br><span class=\"line\">  email: <span class=\"string\">'imjoeunha@gmail.com'</span>,</span><br><span class=\"line\">  blog_url: <span class=\"string\">'http://joeun.dev'</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> user_data = &#123; <span class=\"comment\">// [2] 필요한 데이터</span></span><br><span class=\"line\">  id: user_1.id,</span><br><span class=\"line\">  first_name: user_1.first_name,</span><br><span class=\"line\">  last_name: user_1.last_name</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/user_name/check'</span>, user_data)</span><br><span class=\"line\">  .done(redirect(<span class=\"string\">'/main'</span>)); <span class=\"comment\">// [3] '오늘의 함수 redirect' 편을 참고하세요.</span></span><br></pre></td></tr></table></figure>\n\n<p>위의 코드는 기존의 데이터를 가공해서 원하는 데이터만을 추려내서 특정 api로 전송하고 있습니다. 아래와 같은 <code>pick</code> 함수를 사용한다면 보다 쉽게 원하는 데이터를 추려낼 수 있습니다. <a href=\"underscorejs.org\">underscore.js</a>라는 라이브러리에서 볼 수 있는 함수입니다. 아래는 그보다 단순하게 구현되어 있습니다. 원본 객체와 함께 꺼내길 원하는 키 값을 배열로 전달하면 추려진 객체를 반환합니다.</p>\n<h4 id=\"2번-오늘의-함수\"><a href=\"#2번-오늘의-함수\" class=\"headerlink\" title=\"2번 - 오늘의 함수\"></a>2번 - 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> user_1 = &#123; <span class=\"comment\">// [1] 기존의 데이터</span></span><br><span class=\"line\">  id: <span class=\"number\">1</span>,</span><br><span class=\"line\">  first_name: <span class=\"string\">'Joeun'</span>,</span><br><span class=\"line\">  last_name: <span class=\"string\">'Ha'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">28</span>,</span><br><span class=\"line\">  country: <span class=\"string\">'South Korea'</span>,</span><br><span class=\"line\">  city: <span class=\"string\">'Seoul'</span>,</span><br><span class=\"line\">  mobile_phone: <span class=\"string\">'010-0000-0000'</span>,</span><br><span class=\"line\">  email: <span class=\"string\">'imjoeunha@gmail.com'</span>,</span><br><span class=\"line\">  blog_url: <span class=\"string\">'http://joeun.dev'</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pick</span>(<span class=\"params\">target, keys</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> keys.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj[key] = target[key], obj;</span><br><span class=\"line\">  &#125;, &#123;&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pick(user_1, [<span class=\"string\">'age'</span>, <span class=\"string\">'id'</span>])); <span class=\"comment\">// [2] 출력 결과는 &#123; age: 28, id: 1 &#125; 입니다. 이때, 객체 값의 순서가 배열로 전달한 키의 순서대로 반환됩니다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/user_name/check'</span>, pick(user_1, [<span class=\"string\">'id'</span>, <span class=\"string\">'first_name'</span>, <span class=\"string\">'last_name'</span>])) <span class=\"comment\">// [3] 간편하게 반복해서 원하는 객체를 만들 수 있습니다.</span></span><br><span class=\"line\">  .done(redirect(<span class=\"string\">'/main'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/city/check'</span>, pick(user_1, [<span class=\"string\">'id'</span>, <span class=\"string\">'city'</span>]))</span><br><span class=\"line\">  .done(redirect(<span class=\"string\">'/main'</span>));</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"pick-함수\"><a href=\"#pick-함수\" class=\"headerlink\" title=\"pick 함수\"></a>pick 함수</h2><p><strong>자바스크립트에서 객체는 키(key)와 값(value)의 쌍으로 이루어져있습니다.</strong> 프로그래밍을 하는 과정에서 키를 기준으로 값을 객체로부터 꺼내는 일을 반복합니다. 많은 데이터를 가진 객체 하나에서 여러 개의 값을 꺼내오려면 어떻게 할까요?</p>\n<h4 id=\"1번-어제의-함수\"><a href=\"#1번-어제의-함수\" class=\"headerlink\" title=\"1번 - 어제의 함수\"></a>1번 - 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> user_1 = &#123; <span class=\"comment\">// [1] 기존의 데이터</span></span><br><span class=\"line\">  id: <span class=\"number\">1</span>,</span><br><span class=\"line\">  first_name: <span class=\"string\">'Joeun'</span>,</span><br><span class=\"line\">  last_name: <span class=\"string\">'Ha'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">28</span>,</span><br><span class=\"line\">  country: <span class=\"string\">'South Korea'</span>,</span><br><span class=\"line\">  city: <span class=\"string\">'Seoul'</span>,</span><br><span class=\"line\">  mobile_phone: <span class=\"string\">'010-0000-0000'</span>,</span><br><span class=\"line\">  email: <span class=\"string\">'imjoeunha@gmail.com'</span>,</span><br><span class=\"line\">  blog_url: <span class=\"string\">'http://joeun.dev'</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> user_data = &#123; <span class=\"comment\">// [2] 필요한 데이터</span></span><br><span class=\"line\">  id: user_1.id,</span><br><span class=\"line\">  first_name: user_1.first_name,</span><br><span class=\"line\">  last_name: user_1.last_name</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/user_name/check'</span>, user_data)</span><br><span class=\"line\">  .done(redirect(<span class=\"string\">'/main'</span>)); <span class=\"comment\">// [3] '오늘의 함수 redirect' 편을 참고하세요.</span></span><br></pre></td></tr></table></figure>\n\n<p>위의 코드는 기존의 데이터를 가공해서 원하는 데이터만을 추려내서 특정 api로 전송하고 있습니다. 아래와 같은 <code>pick</code> 함수를 사용한다면 보다 쉽게 원하는 데이터를 추려낼 수 있습니다. <a href=\"underscorejs.org\">underscore.js</a>라는 라이브러리에서 볼 수 있는 함수입니다. 아래는 그보다 단순하게 구현되어 있습니다. 원본 객체와 함께 꺼내길 원하는 키 값을 배열로 전달하면 추려진 객체를 반환합니다.</p>\n<h4 id=\"2번-오늘의-함수\"><a href=\"#2번-오늘의-함수\" class=\"headerlink\" title=\"2번 - 오늘의 함수\"></a>2번 - 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> user_1 = &#123; <span class=\"comment\">// [1] 기존의 데이터</span></span><br><span class=\"line\">  id: <span class=\"number\">1</span>,</span><br><span class=\"line\">  first_name: <span class=\"string\">'Joeun'</span>,</span><br><span class=\"line\">  last_name: <span class=\"string\">'Ha'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">28</span>,</span><br><span class=\"line\">  country: <span class=\"string\">'South Korea'</span>,</span><br><span class=\"line\">  city: <span class=\"string\">'Seoul'</span>,</span><br><span class=\"line\">  mobile_phone: <span class=\"string\">'010-0000-0000'</span>,</span><br><span class=\"line\">  email: <span class=\"string\">'imjoeunha@gmail.com'</span>,</span><br><span class=\"line\">  blog_url: <span class=\"string\">'http://joeun.dev'</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pick</span>(<span class=\"params\">target, keys</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> keys.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj[key] = target[key], obj;</span><br><span class=\"line\">  &#125;, &#123;&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(pick(user_1, [<span class=\"string\">'age'</span>, <span class=\"string\">'id'</span>])); <span class=\"comment\">// [2] 출력 결과는 &#123; age: 28, id: 1 &#125; 입니다. 이때, 객체 값의 순서가 배열로 전달한 키의 순서대로 반환됩니다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/user_name/check'</span>, pick(user_1, [<span class=\"string\">'id'</span>, <span class=\"string\">'first_name'</span>, <span class=\"string\">'last_name'</span>])) <span class=\"comment\">// [3] 간편하게 반복해서 원하는 객체를 만들 수 있습니다.</span></span><br><span class=\"line\">  .done(redirect(<span class=\"string\">'/main'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/city/check'</span>, pick(user_1, [<span class=\"string\">'id'</span>, <span class=\"string\">'city'</span>]))</span><br><span class=\"line\">  .done(redirect(<span class=\"string\">'/main'</span>));</span><br></pre></td></tr></table></figure>\n\n"},{"title":"오늘의 함수 - redirect","date":"2017-03-02T06:11:12.000Z","description":"서버로 데이터를 보내거나 요청할 때 별다른 문제 없이 통신에 성공한 이후에 특정 페이지로 이동하도록 조치하는 경우가 종종 있습니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## redirect 함수\n\n서버로 데이터를 보내거나 요청할 때 __별다른 문제 없이 통신에 성공한 이후에 특정 페이지로 이동하도록 조치하는 경우__가 종종 있습니다. 아래의 1번 방법과 같이 `$.post`를 이용한다고 할때 일반적으로 콜백 함수를 작성해서 응답을 처리합니다.\n\n#### 1번 - 어제의 함수\n```javascript\nvar data = {title: 'hello', content: 'world!'};\n\n$.post('/api/post/create', data)\n  .done(function(res) { // [1] 통신에 의해 데이터가 성공적으로 전달되면 새로운 페이지로 이동하도록 콜백 함수를 정의했습니다.\n    if (res) {\n      return window.location.href = '/main/newsfeed';\n    } else {\n      console.error('return data:', res);\n    }\n  });\n```\n\n때론 위와 같은 동작이 ‘자주’ 일어납니다. 특정 페이지로 이동하기 전에 통신의 성공 여부를 확인하기만 하는 것인데 코드가 계속 반복될 생각을 하니 뭔가 괴롭습니다. 그래서 저는 아래와 같이 `redirect` 함수를 만들었습니다. 함수를 반환하는 고차함수입니다.\n\n#### 2번 - 오늘의 함수\n```javascript\nvar redirect = function(path) {\n  return function(res) {\n    if (res) {\n      return window.location.href = path;\n    } else {\n      console.error('return data:', res);\n    } \n  }\n};\n\n\nvar data = {title: 'hello', content: 'world!'};\n\n$.post('/api/post/create', data)\n  .done(redirect('/main/newsfeed')); // [1] URL을 인자로 전달해두면 어디로 이동할지 미리 정해둔 함수가 콜백 함수로 남게 됩니다. \n\n$.post('/api/post/update', data)\n  .done(redirect('/main/editor')); // [2] 이렇게 URL만 바꿔서 다른 통신에서도 재활용할 수 있는 함수가 되었습니다.\n\n$.post('/api/post/delete', data)\n  .done(redirect('/main/home'));\n```","source":"_posts/daily-fp-0.md","raw":"---\ntitle: '오늘의 함수 - redirect'\ndate: 2017-03-02 15:11:12\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: 서버로 데이터를 보내거나 요청할 때 별다른 문제 없이 통신에 성공한 이후에 특정 페이지로 이동하도록 조치하는 경우가 종종 있습니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## redirect 함수\n\n서버로 데이터를 보내거나 요청할 때 __별다른 문제 없이 통신에 성공한 이후에 특정 페이지로 이동하도록 조치하는 경우__가 종종 있습니다. 아래의 1번 방법과 같이 `$.post`를 이용한다고 할때 일반적으로 콜백 함수를 작성해서 응답을 처리합니다.\n\n#### 1번 - 어제의 함수\n```javascript\nvar data = {title: 'hello', content: 'world!'};\n\n$.post('/api/post/create', data)\n  .done(function(res) { // [1] 통신에 의해 데이터가 성공적으로 전달되면 새로운 페이지로 이동하도록 콜백 함수를 정의했습니다.\n    if (res) {\n      return window.location.href = '/main/newsfeed';\n    } else {\n      console.error('return data:', res);\n    }\n  });\n```\n\n때론 위와 같은 동작이 ‘자주’ 일어납니다. 특정 페이지로 이동하기 전에 통신의 성공 여부를 확인하기만 하는 것인데 코드가 계속 반복될 생각을 하니 뭔가 괴롭습니다. 그래서 저는 아래와 같이 `redirect` 함수를 만들었습니다. 함수를 반환하는 고차함수입니다.\n\n#### 2번 - 오늘의 함수\n```javascript\nvar redirect = function(path) {\n  return function(res) {\n    if (res) {\n      return window.location.href = path;\n    } else {\n      console.error('return data:', res);\n    } \n  }\n};\n\n\nvar data = {title: 'hello', content: 'world!'};\n\n$.post('/api/post/create', data)\n  .done(redirect('/main/newsfeed')); // [1] URL을 인자로 전달해두면 어디로 이동할지 미리 정해둔 함수가 콜백 함수로 남게 됩니다. \n\n$.post('/api/post/update', data)\n  .done(redirect('/main/editor')); // [2] 이렇게 URL만 바꿔서 다른 통신에서도 재활용할 수 있는 함수가 되었습니다.\n\n$.post('/api/post/delete', data)\n  .done(redirect('/main/home'));\n```","slug":"daily-fp-0","published":1,"updated":"2019-12-05T15:06:08.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9fj001edirvpzka1mgf","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"redirect-함수\"><a href=\"#redirect-함수\" class=\"headerlink\" title=\"redirect 함수\"></a>redirect 함수</h2><p>서버로 데이터를 보내거나 요청할 때 <strong>별다른 문제 없이 통신에 성공한 이후에 특정 페이지로 이동하도록 조치하는 경우</strong>가 종종 있습니다. 아래의 1번 방법과 같이 <code>$.post</code>를 이용한다고 할때 일반적으로 콜백 함수를 작성해서 응답을 처리합니다.</p>\n<h4 id=\"1번-어제의-함수\"><a href=\"#1번-어제의-함수\" class=\"headerlink\" title=\"1번 - 어제의 함수\"></a>1번 - 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data)</span><br><span class=\"line\">  .done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123; <span class=\"comment\">// [1] 통신에 의해 데이터가 성공적으로 전달되면 새로운 페이지로 이동하도록 콜백 함수를 정의했습니다.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = <span class=\"string\">'/main/newsfeed'</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>때론 위와 같은 동작이 ‘자주’ 일어납니다. 특정 페이지로 이동하기 전에 통신의 성공 여부를 확인하기만 하는 것인데 코드가 계속 반복될 생각을 하니 뭔가 괴롭습니다. 그래서 저는 아래와 같이 <code>redirect</code> 함수를 만들었습니다. 함수를 반환하는 고차함수입니다.</p>\n<h4 id=\"2번-오늘의-함수\"><a href=\"#2번-오늘의-함수\" class=\"headerlink\" title=\"2번 - 오늘의 함수\"></a>2번 - 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> redirect = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = path;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data)</span><br><span class=\"line\">  .done(redirect(<span class=\"string\">'/main/newsfeed'</span>)); <span class=\"comment\">// [1] URL을 인자로 전달해두면 어디로 이동할지 미리 정해둔 함수가 콜백 함수로 남게 됩니다. </span></span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/update'</span>, data)</span><br><span class=\"line\">  .done(redirect(<span class=\"string\">'/main/editor'</span>)); <span class=\"comment\">// [2] 이렇게 URL만 바꿔서 다른 통신에서도 재활용할 수 있는 함수가 되었습니다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/delete'</span>, data)</span><br><span class=\"line\">  .done(redirect(<span class=\"string\">'/main/home'</span>));</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"redirect-함수\"><a href=\"#redirect-함수\" class=\"headerlink\" title=\"redirect 함수\"></a>redirect 함수</h2><p>서버로 데이터를 보내거나 요청할 때 <strong>별다른 문제 없이 통신에 성공한 이후에 특정 페이지로 이동하도록 조치하는 경우</strong>가 종종 있습니다. 아래의 1번 방법과 같이 <code>$.post</code>를 이용한다고 할때 일반적으로 콜백 함수를 작성해서 응답을 처리합니다.</p>\n<h4 id=\"1번-어제의-함수\"><a href=\"#1번-어제의-함수\" class=\"headerlink\" title=\"1번 - 어제의 함수\"></a>1번 - 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data)</span><br><span class=\"line\">  .done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123; <span class=\"comment\">// [1] 통신에 의해 데이터가 성공적으로 전달되면 새로운 페이지로 이동하도록 콜백 함수를 정의했습니다.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = <span class=\"string\">'/main/newsfeed'</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>때론 위와 같은 동작이 ‘자주’ 일어납니다. 특정 페이지로 이동하기 전에 통신의 성공 여부를 확인하기만 하는 것인데 코드가 계속 반복될 생각을 하니 뭔가 괴롭습니다. 그래서 저는 아래와 같이 <code>redirect</code> 함수를 만들었습니다. 함수를 반환하는 고차함수입니다.</p>\n<h4 id=\"2번-오늘의-함수\"><a href=\"#2번-오늘의-함수\" class=\"headerlink\" title=\"2번 - 오늘의 함수\"></a>2번 - 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> redirect = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = path;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data)</span><br><span class=\"line\">  .done(redirect(<span class=\"string\">'/main/newsfeed'</span>)); <span class=\"comment\">// [1] URL을 인자로 전달해두면 어디로 이동할지 미리 정해둔 함수가 콜백 함수로 남게 됩니다. </span></span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/update'</span>, data)</span><br><span class=\"line\">  .done(redirect(<span class=\"string\">'/main/editor'</span>)); <span class=\"comment\">// [2] 이렇게 URL만 바꿔서 다른 통신에서도 재활용할 수 있는 함수가 되었습니다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/delete'</span>, data)</span><br><span class=\"line\">  .done(redirect(<span class=\"string\">'/main/home'</span>));</span><br></pre></td></tr></table></figure>"},{"title":"오늘의 함수 - redirect3","date":"2017-11-28T08:59:00.000Z","description":"검색, 필터링, 정렬한 페이지를 다시 로드하는 `redirect3` 함수의 사용 패턴을 살펴보겠습니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## redirect3\n\n같은 함수를 세번째 다룹니다. 오늘은 함수 구현 방법에 대한 이야기 뿐만 아니라 검색, 필터링, 정렬한 페이지를 다시 로드하는 `redirect3` 함수의 사용 패턴을 살펴보겠습니다. (본문에서 [Partial.js](https://github.com/marpple/partial.js)가 제공하는 함수를 사용했습니다.)\n\n#### (1) 어제의 함수\n[이전에 만들었던 `redirect2` 함수](/programming/javascript-daily-function-2/)는 쿼리문을 포함하는 URL인 경우를 구분하기 위해 새로운 인자를 부여했습니다. \n\n```javascript\nvar redirect2 = function(path, query) { // [1] query라는 새로운 argument를 만들어 둡니다.\n  return function(res) {\n    if (res) {\n      return window.location.href = query ? path + res[query] : path; // [2] query가 존재하면 get 방식으로 URL 지정합니다.\n    } else {\n      console.error('return data:', res);\n    } \n  }\n};\n\nvar data = {title: 'hello', content: 'world!'};\n$.post('/api/post/create', data).done(redirect2('/main/newsfeed?id=', 'id')); // [3] id라는 문자열을 키로 갖는 값을 찾아서 리다이렉트 합니다.\n```\n\n위와 같은 방법은 하나의 쿼리만을 날릴 수 있습니다. 물론 배열을 받도록 코드를 변경해서 보다 나은 형태로 개선할 여지는 있습니다. 하지만 더 좋은 방법도 있습니다. URL만으로 쿼리가 포함될 것인지 구분하면 됩니다.\n\n#### (2) 오늘의 함수\nURL에 문자열 '?'가 포함된 경우에 이후에 들어오는 객체가 쿼리 데이터라고 가정하는 것입니다. 물음표가 있다면 URL에 퀴리를 붙여서 리다이렉트하고 그렇지 않으면 그냥 리다이렉트하면 됩니다.\n\n```javascript\nvar redirect3 = function(path) { // [1] query를 받지 않아도 됩니다.\n  return function(res) {\n    if (res) {\n      return window.location.href = /\\?$/.test(path) ? // [2-1] 물음표가 존재하면\n      _.reduce(res, function(m, v, k) { return v ? m += '&'+k+'='+v : m }, path) // [2-2] 쿼리문을 생성합니다.\n      : path; \n    } else {\n      console.error('return data:', res);\n    } \n  }\n};\n```\n\n이 함수는 검색, 정렬, 필터링이 필요한 경우에 그 힘을 발휘합니다. 유저가 검색어를 넣고 이후에 추가로 필터링과 정렬 작업을 한다고 가정해보겠습니다. URL에 검색어를 포함해서 쿼리를 날리고 다시 필터링의 기준을 포함해서 쿼리를 날리고 또 다시 정렬의 기준을 포함해서 쿼리를 날려야하는 상황입니다. 쿼리가 누적되는 상황입니다. 쉽게 접근할 수 있는 방법은 `window.location.search`에 있는 문자열을 저장해두고 거기에 추가로 쿼리를 붙여서 날리는 방법입니다. 허나 몇가지 동작에서 정상 작동하겠지만 기존에 있던 필터를 제거하고 다시 쿼리를 날려야하는 경우에 복잡한 문제가 생길 수 있습니다. 이전 쿼리에 포함된 문자열을 조사해서 필요 없는 문자열을 제거하는 작업이 필요할겁니다. 이러한 상황을 타개할 함수가 `redirect3` 함수입니다. 물론 함수 하나로 모든걸 할 수는 없습니다. \n\n```javascript\nvar parse_query_obj = _.if(__( // [1] 만약에 데이터가 있다면 아래의 코드를 실행합니다.\n  str => str.slice(1).split('&'),\n  _.compact, // [2] 빈 문자열은 제외합니다.\n  _.reduce(function(obj, str) { \n    var arr = str.split('='); // [3] 등호를 기준으로 앞에는 키 뒤에는 값입니다.\n    obj[arr[0]] = arr[1];\n    return obj;\n  }, {})))\n  .else(_.always({})); // [4] 만약에 데이터가 없다면 빈 객체를 반환합니다.\n```\n\n위의 함수는 `window.location.search` 문자열을 받아서 쿼리가 있으면 쿼리 객체를 만들어 반환하는 함수입니다. 이 함수 덕분에 `redirect3` 함수를 유용하게 사용할 수 있습니다. 이제 유저가 정렬이나 필터등을 요구하면 `parse_query_obj`가 만들어낸 객체를 수정해서 `redirect3` 함수에게 전달하면 됩니다. 객체를 수정하는 함수가 하나 더 있으면 좋겠습니다. \n\n```javascript\nvar make_query_obj = _.go(\n  window.location.search, // [1-1] 쿼리문을 사용해서\n  parse_query_obj, // [1-2] 쿼리 객체를 만듭니다. \n  function(query_obj) {\n    return function(key, value) { // [2] query_obj를 기억하는 함수(클로저)를 반환합니다.\n      query_obj[key] = value; \n      return query_obj;\n    }\n  });\n```\n\n이제 준비가 되었습니다. 유저가 검색을 요구하면 검색어와 키를 `make_query_obj`에 넣어주면 됩니다. 그 후에 `redirect3` 함수를 호출하면 끝입니다.\n\n```javascript\n// click, change 이벤트의 함수\nfunction(e) {\n  var current_target = e.currentTarget; // [1] 엘리먼트(current_target)의 id가 키, value가 값이라고 가정하겠습니다.\n  var query_obj = make_query_obj(current_target.id, current_target.value);\n  redirect3('/search/?')(query_obj); // [2] 즉시 리다이렉트 됩니다.\n}\n```","source":"_posts/daily-fp-10.md","raw":"---\ntitle: '오늘의 함수 - redirect3'\ndate: 2017-11-28 17:59:00\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: 검색, 필터링, 정렬한 페이지를 다시 로드하는 `redirect3` 함수의 사용 패턴을 살펴보겠습니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## redirect3\n\n같은 함수를 세번째 다룹니다. 오늘은 함수 구현 방법에 대한 이야기 뿐만 아니라 검색, 필터링, 정렬한 페이지를 다시 로드하는 `redirect3` 함수의 사용 패턴을 살펴보겠습니다. (본문에서 [Partial.js](https://github.com/marpple/partial.js)가 제공하는 함수를 사용했습니다.)\n\n#### (1) 어제의 함수\n[이전에 만들었던 `redirect2` 함수](/programming/javascript-daily-function-2/)는 쿼리문을 포함하는 URL인 경우를 구분하기 위해 새로운 인자를 부여했습니다. \n\n```javascript\nvar redirect2 = function(path, query) { // [1] query라는 새로운 argument를 만들어 둡니다.\n  return function(res) {\n    if (res) {\n      return window.location.href = query ? path + res[query] : path; // [2] query가 존재하면 get 방식으로 URL 지정합니다.\n    } else {\n      console.error('return data:', res);\n    } \n  }\n};\n\nvar data = {title: 'hello', content: 'world!'};\n$.post('/api/post/create', data).done(redirect2('/main/newsfeed?id=', 'id')); // [3] id라는 문자열을 키로 갖는 값을 찾아서 리다이렉트 합니다.\n```\n\n위와 같은 방법은 하나의 쿼리만을 날릴 수 있습니다. 물론 배열을 받도록 코드를 변경해서 보다 나은 형태로 개선할 여지는 있습니다. 하지만 더 좋은 방법도 있습니다. URL만으로 쿼리가 포함될 것인지 구분하면 됩니다.\n\n#### (2) 오늘의 함수\nURL에 문자열 '?'가 포함된 경우에 이후에 들어오는 객체가 쿼리 데이터라고 가정하는 것입니다. 물음표가 있다면 URL에 퀴리를 붙여서 리다이렉트하고 그렇지 않으면 그냥 리다이렉트하면 됩니다.\n\n```javascript\nvar redirect3 = function(path) { // [1] query를 받지 않아도 됩니다.\n  return function(res) {\n    if (res) {\n      return window.location.href = /\\?$/.test(path) ? // [2-1] 물음표가 존재하면\n      _.reduce(res, function(m, v, k) { return v ? m += '&'+k+'='+v : m }, path) // [2-2] 쿼리문을 생성합니다.\n      : path; \n    } else {\n      console.error('return data:', res);\n    } \n  }\n};\n```\n\n이 함수는 검색, 정렬, 필터링이 필요한 경우에 그 힘을 발휘합니다. 유저가 검색어를 넣고 이후에 추가로 필터링과 정렬 작업을 한다고 가정해보겠습니다. URL에 검색어를 포함해서 쿼리를 날리고 다시 필터링의 기준을 포함해서 쿼리를 날리고 또 다시 정렬의 기준을 포함해서 쿼리를 날려야하는 상황입니다. 쿼리가 누적되는 상황입니다. 쉽게 접근할 수 있는 방법은 `window.location.search`에 있는 문자열을 저장해두고 거기에 추가로 쿼리를 붙여서 날리는 방법입니다. 허나 몇가지 동작에서 정상 작동하겠지만 기존에 있던 필터를 제거하고 다시 쿼리를 날려야하는 경우에 복잡한 문제가 생길 수 있습니다. 이전 쿼리에 포함된 문자열을 조사해서 필요 없는 문자열을 제거하는 작업이 필요할겁니다. 이러한 상황을 타개할 함수가 `redirect3` 함수입니다. 물론 함수 하나로 모든걸 할 수는 없습니다. \n\n```javascript\nvar parse_query_obj = _.if(__( // [1] 만약에 데이터가 있다면 아래의 코드를 실행합니다.\n  str => str.slice(1).split('&'),\n  _.compact, // [2] 빈 문자열은 제외합니다.\n  _.reduce(function(obj, str) { \n    var arr = str.split('='); // [3] 등호를 기준으로 앞에는 키 뒤에는 값입니다.\n    obj[arr[0]] = arr[1];\n    return obj;\n  }, {})))\n  .else(_.always({})); // [4] 만약에 데이터가 없다면 빈 객체를 반환합니다.\n```\n\n위의 함수는 `window.location.search` 문자열을 받아서 쿼리가 있으면 쿼리 객체를 만들어 반환하는 함수입니다. 이 함수 덕분에 `redirect3` 함수를 유용하게 사용할 수 있습니다. 이제 유저가 정렬이나 필터등을 요구하면 `parse_query_obj`가 만들어낸 객체를 수정해서 `redirect3` 함수에게 전달하면 됩니다. 객체를 수정하는 함수가 하나 더 있으면 좋겠습니다. \n\n```javascript\nvar make_query_obj = _.go(\n  window.location.search, // [1-1] 쿼리문을 사용해서\n  parse_query_obj, // [1-2] 쿼리 객체를 만듭니다. \n  function(query_obj) {\n    return function(key, value) { // [2] query_obj를 기억하는 함수(클로저)를 반환합니다.\n      query_obj[key] = value; \n      return query_obj;\n    }\n  });\n```\n\n이제 준비가 되었습니다. 유저가 검색을 요구하면 검색어와 키를 `make_query_obj`에 넣어주면 됩니다. 그 후에 `redirect3` 함수를 호출하면 끝입니다.\n\n```javascript\n// click, change 이벤트의 함수\nfunction(e) {\n  var current_target = e.currentTarget; // [1] 엘리먼트(current_target)의 id가 키, value가 값이라고 가정하겠습니다.\n  var query_obj = make_query_obj(current_target.id, current_target.value);\n  redirect3('/search/?')(query_obj); // [2] 즉시 리다이렉트 됩니다.\n}\n```","slug":"daily-fp-10","published":1,"updated":"2019-12-05T15:06:08.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9fk001hdirvglb8s495","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"redirect3\"><a href=\"#redirect3\" class=\"headerlink\" title=\"redirect3\"></a>redirect3</h2><p>같은 함수를 세번째 다룹니다. 오늘은 함수 구현 방법에 대한 이야기 뿐만 아니라 검색, 필터링, 정렬한 페이지를 다시 로드하는 <code>redirect3</code> 함수의 사용 패턴을 살펴보겠습니다. (본문에서 <a href=\"https://github.com/marpple/partial.js\" target=\"_blank\" rel=\"noopener\">Partial.js</a>가 제공하는 함수를 사용했습니다.)</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><p><a href=\"/programming/javascript-daily-function-2/\">이전에 만들었던 <code>redirect2</code> 함수</a>는 쿼리문을 포함하는 URL인 경우를 구분하기 위해 새로운 인자를 부여했습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> redirect2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, query</span>) </span>&#123; <span class=\"comment\">// [1] query라는 새로운 argument를 만들어 둡니다.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = query ? path + res[query] : path; <span class=\"comment\">// [2] query가 존재하면 get 방식으로 URL 지정합니다.</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data).done(redirect2(<span class=\"string\">'/main/newsfeed?id='</span>, <span class=\"string\">'id'</span>)); <span class=\"comment\">// [3] id라는 문자열을 키로 갖는 값을 찾아서 리다이렉트 합니다.</span></span><br></pre></td></tr></table></figure>\n\n<p>위와 같은 방법은 하나의 쿼리만을 날릴 수 있습니다. 물론 배열을 받도록 코드를 변경해서 보다 나은 형태로 개선할 여지는 있습니다. 하지만 더 좋은 방법도 있습니다. URL만으로 쿼리가 포함될 것인지 구분하면 됩니다.</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><p>URL에 문자열 ‘?’가 포함된 경우에 이후에 들어오는 객체가 쿼리 데이터라고 가정하는 것입니다. 물음표가 있다면 URL에 퀴리를 붙여서 리다이렉트하고 그렇지 않으면 그냥 리다이렉트하면 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> redirect3 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>) </span>&#123; <span class=\"comment\">// [1] query를 받지 않아도 됩니다.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = <span class=\"regexp\">/\\?$/</span>.test(path) ? <span class=\"comment\">// [2-1] 물음표가 존재하면</span></span><br><span class=\"line\">      _.reduce(res, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m, v, k</span>) </span>&#123; <span class=\"keyword\">return</span> v ? m += <span class=\"string\">'&amp;'</span>+k+<span class=\"string\">'='</span>+v : m &#125;, path) <span class=\"comment\">// [2-2] 쿼리문을 생성합니다.</span></span><br><span class=\"line\">      : path; </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>이 함수는 검색, 정렬, 필터링이 필요한 경우에 그 힘을 발휘합니다. 유저가 검색어를 넣고 이후에 추가로 필터링과 정렬 작업을 한다고 가정해보겠습니다. URL에 검색어를 포함해서 쿼리를 날리고 다시 필터링의 기준을 포함해서 쿼리를 날리고 또 다시 정렬의 기준을 포함해서 쿼리를 날려야하는 상황입니다. 쿼리가 누적되는 상황입니다. 쉽게 접근할 수 있는 방법은 <code>window.location.search</code>에 있는 문자열을 저장해두고 거기에 추가로 쿼리를 붙여서 날리는 방법입니다. 허나 몇가지 동작에서 정상 작동하겠지만 기존에 있던 필터를 제거하고 다시 쿼리를 날려야하는 경우에 복잡한 문제가 생길 수 있습니다. 이전 쿼리에 포함된 문자열을 조사해서 필요 없는 문자열을 제거하는 작업이 필요할겁니다. 이러한 상황을 타개할 함수가 <code>redirect3</code> 함수입니다. 물론 함수 하나로 모든걸 할 수는 없습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parse_query_obj = _.if(__( <span class=\"comment\">// [1] 만약에 데이터가 있다면 아래의 코드를 실행합니다.</span></span><br><span class=\"line\">  str =&gt; str.slice(<span class=\"number\">1</span>).split(<span class=\"string\">'&amp;'</span>),</span><br><span class=\"line\">  _.compact, <span class=\"comment\">// [2] 빈 문자열은 제외합니다.</span></span><br><span class=\"line\">  _.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, str</span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = str.split(<span class=\"string\">'='</span>); <span class=\"comment\">// [3] 등호를 기준으로 앞에는 키 뒤에는 값입니다.</span></span><br><span class=\"line\">    obj[arr[<span class=\"number\">0</span>]] = arr[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">  &#125;, &#123;&#125;)))</span><br><span class=\"line\">  .else(_.always(&#123;&#125;)); <span class=\"comment\">// [4] 만약에 데이터가 없다면 빈 객체를 반환합니다.</span></span><br></pre></td></tr></table></figure>\n\n<p>위의 함수는 <code>window.location.search</code> 문자열을 받아서 쿼리가 있으면 쿼리 객체를 만들어 반환하는 함수입니다. 이 함수 덕분에 <code>redirect3</code> 함수를 유용하게 사용할 수 있습니다. 이제 유저가 정렬이나 필터등을 요구하면 <code>parse_query_obj</code>가 만들어낸 객체를 수정해서 <code>redirect3</code> 함수에게 전달하면 됩니다. 객체를 수정하는 함수가 하나 더 있으면 좋겠습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> make_query_obj = _.go(</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.location.search, <span class=\"comment\">// [1-1] 쿼리문을 사용해서</span></span><br><span class=\"line\">  parse_query_obj, <span class=\"comment\">// [1-2] 쿼리 객체를 만듭니다. </span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">query_obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123; <span class=\"comment\">// [2] query_obj를 기억하는 함수(클로저)를 반환합니다.</span></span><br><span class=\"line\">      query_obj[key] = value; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> query_obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>이제 준비가 되었습니다. 유저가 검색을 요구하면 검색어와 키를 <code>make_query_obj</code>에 넣어주면 됩니다. 그 후에 <code>redirect3</code> 함수를 호출하면 끝입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// click, change 이벤트의 함수</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> current_target = e.currentTarget; <span class=\"comment\">// [1] 엘리먼트(current_target)의 id가 키, value가 값이라고 가정하겠습니다.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> query_obj = make_query_obj(current_target.id, current_target.value);</span><br><span class=\"line\">  redirect3(<span class=\"string\">'/search/?'</span>)(query_obj); <span class=\"comment\">// [2] 즉시 리다이렉트 됩니다.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"redirect3\"><a href=\"#redirect3\" class=\"headerlink\" title=\"redirect3\"></a>redirect3</h2><p>같은 함수를 세번째 다룹니다. 오늘은 함수 구현 방법에 대한 이야기 뿐만 아니라 검색, 필터링, 정렬한 페이지를 다시 로드하는 <code>redirect3</code> 함수의 사용 패턴을 살펴보겠습니다. (본문에서 <a href=\"https://github.com/marpple/partial.js\" target=\"_blank\" rel=\"noopener\">Partial.js</a>가 제공하는 함수를 사용했습니다.)</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><p><a href=\"/programming/javascript-daily-function-2/\">이전에 만들었던 <code>redirect2</code> 함수</a>는 쿼리문을 포함하는 URL인 경우를 구분하기 위해 새로운 인자를 부여했습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> redirect2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, query</span>) </span>&#123; <span class=\"comment\">// [1] query라는 새로운 argument를 만들어 둡니다.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = query ? path + res[query] : path; <span class=\"comment\">// [2] query가 존재하면 get 방식으로 URL 지정합니다.</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data).done(redirect2(<span class=\"string\">'/main/newsfeed?id='</span>, <span class=\"string\">'id'</span>)); <span class=\"comment\">// [3] id라는 문자열을 키로 갖는 값을 찾아서 리다이렉트 합니다.</span></span><br></pre></td></tr></table></figure>\n\n<p>위와 같은 방법은 하나의 쿼리만을 날릴 수 있습니다. 물론 배열을 받도록 코드를 변경해서 보다 나은 형태로 개선할 여지는 있습니다. 하지만 더 좋은 방법도 있습니다. URL만으로 쿼리가 포함될 것인지 구분하면 됩니다.</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><p>URL에 문자열 ‘?’가 포함된 경우에 이후에 들어오는 객체가 쿼리 데이터라고 가정하는 것입니다. 물음표가 있다면 URL에 퀴리를 붙여서 리다이렉트하고 그렇지 않으면 그냥 리다이렉트하면 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> redirect3 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>) </span>&#123; <span class=\"comment\">// [1] query를 받지 않아도 됩니다.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = <span class=\"regexp\">/\\?$/</span>.test(path) ? <span class=\"comment\">// [2-1] 물음표가 존재하면</span></span><br><span class=\"line\">      _.reduce(res, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m, v, k</span>) </span>&#123; <span class=\"keyword\">return</span> v ? m += <span class=\"string\">'&amp;'</span>+k+<span class=\"string\">'='</span>+v : m &#125;, path) <span class=\"comment\">// [2-2] 쿼리문을 생성합니다.</span></span><br><span class=\"line\">      : path; </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>이 함수는 검색, 정렬, 필터링이 필요한 경우에 그 힘을 발휘합니다. 유저가 검색어를 넣고 이후에 추가로 필터링과 정렬 작업을 한다고 가정해보겠습니다. URL에 검색어를 포함해서 쿼리를 날리고 다시 필터링의 기준을 포함해서 쿼리를 날리고 또 다시 정렬의 기준을 포함해서 쿼리를 날려야하는 상황입니다. 쿼리가 누적되는 상황입니다. 쉽게 접근할 수 있는 방법은 <code>window.location.search</code>에 있는 문자열을 저장해두고 거기에 추가로 쿼리를 붙여서 날리는 방법입니다. 허나 몇가지 동작에서 정상 작동하겠지만 기존에 있던 필터를 제거하고 다시 쿼리를 날려야하는 경우에 복잡한 문제가 생길 수 있습니다. 이전 쿼리에 포함된 문자열을 조사해서 필요 없는 문자열을 제거하는 작업이 필요할겁니다. 이러한 상황을 타개할 함수가 <code>redirect3</code> 함수입니다. 물론 함수 하나로 모든걸 할 수는 없습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parse_query_obj = _.if(__( <span class=\"comment\">// [1] 만약에 데이터가 있다면 아래의 코드를 실행합니다.</span></span><br><span class=\"line\">  str =&gt; str.slice(<span class=\"number\">1</span>).split(<span class=\"string\">'&amp;'</span>),</span><br><span class=\"line\">  _.compact, <span class=\"comment\">// [2] 빈 문자열은 제외합니다.</span></span><br><span class=\"line\">  _.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, str</span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = str.split(<span class=\"string\">'='</span>); <span class=\"comment\">// [3] 등호를 기준으로 앞에는 키 뒤에는 값입니다.</span></span><br><span class=\"line\">    obj[arr[<span class=\"number\">0</span>]] = arr[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">  &#125;, &#123;&#125;)))</span><br><span class=\"line\">  .else(_.always(&#123;&#125;)); <span class=\"comment\">// [4] 만약에 데이터가 없다면 빈 객체를 반환합니다.</span></span><br></pre></td></tr></table></figure>\n\n<p>위의 함수는 <code>window.location.search</code> 문자열을 받아서 쿼리가 있으면 쿼리 객체를 만들어 반환하는 함수입니다. 이 함수 덕분에 <code>redirect3</code> 함수를 유용하게 사용할 수 있습니다. 이제 유저가 정렬이나 필터등을 요구하면 <code>parse_query_obj</code>가 만들어낸 객체를 수정해서 <code>redirect3</code> 함수에게 전달하면 됩니다. 객체를 수정하는 함수가 하나 더 있으면 좋겠습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> make_query_obj = _.go(</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.location.search, <span class=\"comment\">// [1-1] 쿼리문을 사용해서</span></span><br><span class=\"line\">  parse_query_obj, <span class=\"comment\">// [1-2] 쿼리 객체를 만듭니다. </span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">query_obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123; <span class=\"comment\">// [2] query_obj를 기억하는 함수(클로저)를 반환합니다.</span></span><br><span class=\"line\">      query_obj[key] = value; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> query_obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>이제 준비가 되었습니다. 유저가 검색을 요구하면 검색어와 키를 <code>make_query_obj</code>에 넣어주면 됩니다. 그 후에 <code>redirect3</code> 함수를 호출하면 끝입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// click, change 이벤트의 함수</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> current_target = e.currentTarget; <span class=\"comment\">// [1] 엘리먼트(current_target)의 id가 키, value가 값이라고 가정하겠습니다.</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> query_obj = make_query_obj(current_target.id, current_target.value);</span><br><span class=\"line\">  redirect3(<span class=\"string\">'/search/?'</span>)(query_obj); <span class=\"comment\">// [2] 즉시 리다이렉트 됩니다.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"오늘의 함수 - if","date":"2017-12-04T07:36:54.000Z","description":"오늘은 조건문인 if를 함수로 구현해보려고 합니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## if\n\n오늘은 조건문인 if를 함수로 구현해보려고 합니다. 조건문은 프로그래밍에 아주 빈번하게 사용됩니다. [지난 시간](/programming/javascript-daily-function-10/)에 `parse_query_obj`라는 함수를 만들기 위해 `_.if` 함수가 잠시 등장했습니다. 이처럼 조건문의 사용은 함수형에도 예외일 수 없습니다. 오늘은 함수형 스타일로 프로그래밍하는 상황에 `_.if` 함수의 유/무가 어떻게 다른지 비교하고 `_.if` 함수의 내부가 어떻게 생겼는지 살펴보겠습니다.\n\n\n#### (1) 어제의 함수\n지난 시간에 만든 `parse_query_obj` 함수가 `_.if` 함수 없이 만들어졌다면 어떤 형태였을까요?\n\n```javascript\n// var parse_query_obj = _.if(_.identity, // [1] _.if의 첫번째 인자는 조건을 확인하는 함수\n//   __(str => str.slice(1).split('&'), // [2] 두번째 인자는 조건이 참이면 실행될 함수\n//     _.compact, \n//     _.reduce(function(obj, str) { \n//       var arr = str.split('='); \n//       obj[arr[0]] = arr[1];\n//       return obj;\n//     }, {})))\n//   .else(_.always({})); \n\nvar parse_query_obj = function(value) {\n  return value ? _.go(value, // [3] value 값이 참이라면 함수들을 즉시 실행합니다.\n    str => str.slice(1).split('&'),\n    _.compact, \n    _.reduce(function(obj, str) { \n      var arr = str.split('=');\n      obj[arr[0]] = arr[1];\n      return obj;\n    }, {})) : {};\n}\n```\n\n딱히 나쁘다고 말할 수준은 아닙니다. 삼항연산자를 사용하니 깔끔하고 이해도 쉽습니다. 그렇다면 `make_query_obj` 함수를 만드는 과정 속에 `parse_query_obj` 함수도 만드는 경우는 어떨까요?\n\n```javascript\nvar make_query_obj = _.go(\n  window.location.search,\n  function(value) { // parse_query_obj\n    return value ? _.go(value, \n      str => str.slice(1).split('&'),\n      _.compact, \n      _.reduce(function(obj, str) { \n        var arr = str.split('=');\n        obj[arr[0]] = arr[1];\n        return obj;\n      }, {})) : {};\n  },\n  // ...\n  );\n```\n\n역시 나쁘지 않지만 아쉽지 않나요? `_.if` 함수가 있었다면 조금 더 읽기 좋은 코드가 되지 않을까요?\n\n```javascript\nvar make_query_obj = _.go(\n  window.location.search,\n  _.if(_.identity, __( \n    str => str.slice(1).split('&'),\n    _.compact, \n    _.reduce(function(obj, str) { \n      var arr = str.split('='); \n      obj[arr[0]] = arr[1];\n      return obj;\n    }, {})))\n  .else(_.always({})),\n  // ...\n  );\n```\n\n`_.if` 함수의 사용으로 보다 직관적이고 이해가 쉬운, 읽기 좋은 코드가 되었습니다. 작성하는 것도 직관적으로 작성할 수 있습니다. 분기가 필요한 순간에 조건문을 작성하듯 `_.if` 함수를 적으면 그만입니다. \n\n\n#### (2) 오늘의 함수\n`_.if` 함수의 사용법을 확인했으니 내부를 살펴보겠습니다.\n\n```javascript\n_.if = function(predi, fn) {\n  var store = [fn ? [predi, fn] : [_.identity, predi]]; // [1]\n  \n  function If() {\n    var context = this, args = arguments; // [2]\n    return _.go(store, // [3] \n      _.find(function(fnset) { return fnset[0].apply(context, args); }), // [4]\n      function(fnset) { return fnset ? fnset[1].apply(context, args) : void 0; }); // [5]\n  }\n\n  return _.extend(If, { // [6]\n    else_if: function(predi, fn) { return store.push(fn ? [predi, fn] : [_.identity, predi]) && If; }, // [7]\n    else: function(fn) { return store.push([_.constant(true), fn]) && If; }\n  });\n};\n```\n\n위의 코드가 `_.if` 함수의 전부입니다. 의외로 짧은 코드입니다. 그 속에 재미난 기법들이 숨어있습니다. 천천히 살펴보겠습니다. 번호를 주석으로 넣어두었으니 순서대로 설명해나가겠습니다. \n\n[1] Line 2 - 우선 `store`라는 배열을 만듭니다. 이 배열은 조건을 판별하는 `predi` 함수와 조건이 참일 경우 실행될 `fn` 함수의 묶음인 배열을 값으로 가진 2차원 배열입니다. 이 과정에 나타나는 삼항연산자는 `fn` 값이 없는 경우, 즉 인자가 1개만 주어진 경우를 확인합니다. 만약에 인자가 1개만 들어왔다면 그건 `predi`가 아니라 `fn`에 해당하는 함수입니다. 따라서 `predi`에 해당하는 조건부를 생략하면 `_.identity`를 `predi`에 넣어줍니다. (상단의 예제에서는 이해를 돕기 위해 첫번째 인자로 `_.identity`를 넣었지만 실제로는 넣지 않아도 동작합니다.)\n\n[2] Line 5 - 본격적인 `If` 함수 내부입니다. 이후에 사용하기 위해 실행 컨텍스트인 `this`와 매개변수를 담은 `arguments`를 변수에 할당해둡니다. \n\n[3] Line 6 - `_.go` 함수로 원하는 동작을 수행한 결과를 리턴합니다. `_.go`의 첫번째 인자는 배열인 `store` 입니다.\n\n[4] Line 7 - `_.find`의 술부에 해당하는 함수를 미리 적용(커링)해둡니다. 이때 술부 내부를 살펴보면 `fnset`이라는 값이 존재하는데 이는 `store`가 가졌던 배열입니다. 이 배열은 `[predi, fn]`의 형태로 생겼습니다. 결국 `fnset[0].apply(context, args)` 이 대목은 `predi`를 실행해보는 것입니다. 이를 통해 참 값이 반환되면 `_.find` 함수가 찾는 값이 됩니다. 따라서 해당 `fnset`이 이후 함수로 전달됩니다.\n\n[5] Line 8 - 전달된 `fnset`의 두번째 인자는 참인 경우 실행될 함수입니다. `fnset[1].apply(context, args)`로 함수를 실행합니다.\n\n[6] Line 11 - 만들어둔 함수 `If`에 몇가지 함수를 더 붙여서 리턴합니다. (클로저 함수가 리턴됩니다.) 자바스크립트에서 함수는 객체이기 때문에 `_.extend`를 이용해 확장이 가능합니다. 추가로 붙는 함수는 `else_if`와 `else` 입니다. \n\n[7] Line 12 - `store`에 추가로 배열을 만들어 넣습니다. 그리고 `If` 함수를 리턴합니다. 클로저로 `store` 값이 기억되고 누적되기 때문에 실제로 `If` 함수가 호출될때 `store`의 길이는 `if`, `else_if`, `else`가 호출된 만큼의 길이를 갖습니다.\n\n이렇게 만들어진 함수는 아래와 같이 사용할 수 있습니다. (feat. [window.functions.js](https://github.com/marpple/window.functions.js))\n\n```javascript\n_go(11,\n  _.if(_lt(10), // [1] 10보다 작으면\n    _pipe(\n      _add(100), \n      console.log)\n  ).else_if(_gte(20), // [2] 20과 같거나 크면\n    _pipe(\n      _add(200), \n      console.log)\n  ).else(\n    _pipe(\n      _add(300), \n      console.log)\n  )); \n  // [3] 결과는 311 입니다.\n```\n\n\n#### (3) 내일의 함수\n`_.if` 함수의 불편한 점을 발견하지 못하셨나요? 인자를 두개 넘겨서 조건부와 실행부를 결정하기 때문에 각 함수를 `_.pipe` 함수와 같은 합성 함수로 묶어줘야 합니다. 아무래도 불편하죠. 실제로 하나의 함수로 모든 일을 하는 경우는 드문 일이니까요. 그냥 알아서 함수를 합성해주면 더 편할텐데요. 그래서 만들어진 `_.if2`를 다음 시간에 소개할까 합니다. 이 함수를 사용하면 코드는 아래처럼 달라집니다.\n\n```javascript\n_go(11,\n  _.if2(_lt(10))(\n    _add(100), \n    console.log\n  ).else_if(_gte(20))(\n    _add(200), \n    console.log\n  ).else(\n    _add(300), \n    console.log\n  ));\n```","source":"_posts/daily-fp-11.md","raw":"---\ntitle: '오늘의 함수 - if'\ndate: 2017-12-04 16:36:54\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\n  - 조건문 함수\ndescription: 오늘은 조건문인 if를 함수로 구현해보려고 합니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## if\n\n오늘은 조건문인 if를 함수로 구현해보려고 합니다. 조건문은 프로그래밍에 아주 빈번하게 사용됩니다. [지난 시간](/programming/javascript-daily-function-10/)에 `parse_query_obj`라는 함수를 만들기 위해 `_.if` 함수가 잠시 등장했습니다. 이처럼 조건문의 사용은 함수형에도 예외일 수 없습니다. 오늘은 함수형 스타일로 프로그래밍하는 상황에 `_.if` 함수의 유/무가 어떻게 다른지 비교하고 `_.if` 함수의 내부가 어떻게 생겼는지 살펴보겠습니다.\n\n\n#### (1) 어제의 함수\n지난 시간에 만든 `parse_query_obj` 함수가 `_.if` 함수 없이 만들어졌다면 어떤 형태였을까요?\n\n```javascript\n// var parse_query_obj = _.if(_.identity, // [1] _.if의 첫번째 인자는 조건을 확인하는 함수\n//   __(str => str.slice(1).split('&'), // [2] 두번째 인자는 조건이 참이면 실행될 함수\n//     _.compact, \n//     _.reduce(function(obj, str) { \n//       var arr = str.split('='); \n//       obj[arr[0]] = arr[1];\n//       return obj;\n//     }, {})))\n//   .else(_.always({})); \n\nvar parse_query_obj = function(value) {\n  return value ? _.go(value, // [3] value 값이 참이라면 함수들을 즉시 실행합니다.\n    str => str.slice(1).split('&'),\n    _.compact, \n    _.reduce(function(obj, str) { \n      var arr = str.split('=');\n      obj[arr[0]] = arr[1];\n      return obj;\n    }, {})) : {};\n}\n```\n\n딱히 나쁘다고 말할 수준은 아닙니다. 삼항연산자를 사용하니 깔끔하고 이해도 쉽습니다. 그렇다면 `make_query_obj` 함수를 만드는 과정 속에 `parse_query_obj` 함수도 만드는 경우는 어떨까요?\n\n```javascript\nvar make_query_obj = _.go(\n  window.location.search,\n  function(value) { // parse_query_obj\n    return value ? _.go(value, \n      str => str.slice(1).split('&'),\n      _.compact, \n      _.reduce(function(obj, str) { \n        var arr = str.split('=');\n        obj[arr[0]] = arr[1];\n        return obj;\n      }, {})) : {};\n  },\n  // ...\n  );\n```\n\n역시 나쁘지 않지만 아쉽지 않나요? `_.if` 함수가 있었다면 조금 더 읽기 좋은 코드가 되지 않을까요?\n\n```javascript\nvar make_query_obj = _.go(\n  window.location.search,\n  _.if(_.identity, __( \n    str => str.slice(1).split('&'),\n    _.compact, \n    _.reduce(function(obj, str) { \n      var arr = str.split('='); \n      obj[arr[0]] = arr[1];\n      return obj;\n    }, {})))\n  .else(_.always({})),\n  // ...\n  );\n```\n\n`_.if` 함수의 사용으로 보다 직관적이고 이해가 쉬운, 읽기 좋은 코드가 되었습니다. 작성하는 것도 직관적으로 작성할 수 있습니다. 분기가 필요한 순간에 조건문을 작성하듯 `_.if` 함수를 적으면 그만입니다. \n\n\n#### (2) 오늘의 함수\n`_.if` 함수의 사용법을 확인했으니 내부를 살펴보겠습니다.\n\n```javascript\n_.if = function(predi, fn) {\n  var store = [fn ? [predi, fn] : [_.identity, predi]]; // [1]\n  \n  function If() {\n    var context = this, args = arguments; // [2]\n    return _.go(store, // [3] \n      _.find(function(fnset) { return fnset[0].apply(context, args); }), // [4]\n      function(fnset) { return fnset ? fnset[1].apply(context, args) : void 0; }); // [5]\n  }\n\n  return _.extend(If, { // [6]\n    else_if: function(predi, fn) { return store.push(fn ? [predi, fn] : [_.identity, predi]) && If; }, // [7]\n    else: function(fn) { return store.push([_.constant(true), fn]) && If; }\n  });\n};\n```\n\n위의 코드가 `_.if` 함수의 전부입니다. 의외로 짧은 코드입니다. 그 속에 재미난 기법들이 숨어있습니다. 천천히 살펴보겠습니다. 번호를 주석으로 넣어두었으니 순서대로 설명해나가겠습니다. \n\n[1] Line 2 - 우선 `store`라는 배열을 만듭니다. 이 배열은 조건을 판별하는 `predi` 함수와 조건이 참일 경우 실행될 `fn` 함수의 묶음인 배열을 값으로 가진 2차원 배열입니다. 이 과정에 나타나는 삼항연산자는 `fn` 값이 없는 경우, 즉 인자가 1개만 주어진 경우를 확인합니다. 만약에 인자가 1개만 들어왔다면 그건 `predi`가 아니라 `fn`에 해당하는 함수입니다. 따라서 `predi`에 해당하는 조건부를 생략하면 `_.identity`를 `predi`에 넣어줍니다. (상단의 예제에서는 이해를 돕기 위해 첫번째 인자로 `_.identity`를 넣었지만 실제로는 넣지 않아도 동작합니다.)\n\n[2] Line 5 - 본격적인 `If` 함수 내부입니다. 이후에 사용하기 위해 실행 컨텍스트인 `this`와 매개변수를 담은 `arguments`를 변수에 할당해둡니다. \n\n[3] Line 6 - `_.go` 함수로 원하는 동작을 수행한 결과를 리턴합니다. `_.go`의 첫번째 인자는 배열인 `store` 입니다.\n\n[4] Line 7 - `_.find`의 술부에 해당하는 함수를 미리 적용(커링)해둡니다. 이때 술부 내부를 살펴보면 `fnset`이라는 값이 존재하는데 이는 `store`가 가졌던 배열입니다. 이 배열은 `[predi, fn]`의 형태로 생겼습니다. 결국 `fnset[0].apply(context, args)` 이 대목은 `predi`를 실행해보는 것입니다. 이를 통해 참 값이 반환되면 `_.find` 함수가 찾는 값이 됩니다. 따라서 해당 `fnset`이 이후 함수로 전달됩니다.\n\n[5] Line 8 - 전달된 `fnset`의 두번째 인자는 참인 경우 실행될 함수입니다. `fnset[1].apply(context, args)`로 함수를 실행합니다.\n\n[6] Line 11 - 만들어둔 함수 `If`에 몇가지 함수를 더 붙여서 리턴합니다. (클로저 함수가 리턴됩니다.) 자바스크립트에서 함수는 객체이기 때문에 `_.extend`를 이용해 확장이 가능합니다. 추가로 붙는 함수는 `else_if`와 `else` 입니다. \n\n[7] Line 12 - `store`에 추가로 배열을 만들어 넣습니다. 그리고 `If` 함수를 리턴합니다. 클로저로 `store` 값이 기억되고 누적되기 때문에 실제로 `If` 함수가 호출될때 `store`의 길이는 `if`, `else_if`, `else`가 호출된 만큼의 길이를 갖습니다.\n\n이렇게 만들어진 함수는 아래와 같이 사용할 수 있습니다. (feat. [window.functions.js](https://github.com/marpple/window.functions.js))\n\n```javascript\n_go(11,\n  _.if(_lt(10), // [1] 10보다 작으면\n    _pipe(\n      _add(100), \n      console.log)\n  ).else_if(_gte(20), // [2] 20과 같거나 크면\n    _pipe(\n      _add(200), \n      console.log)\n  ).else(\n    _pipe(\n      _add(300), \n      console.log)\n  )); \n  // [3] 결과는 311 입니다.\n```\n\n\n#### (3) 내일의 함수\n`_.if` 함수의 불편한 점을 발견하지 못하셨나요? 인자를 두개 넘겨서 조건부와 실행부를 결정하기 때문에 각 함수를 `_.pipe` 함수와 같은 합성 함수로 묶어줘야 합니다. 아무래도 불편하죠. 실제로 하나의 함수로 모든 일을 하는 경우는 드문 일이니까요. 그냥 알아서 함수를 합성해주면 더 편할텐데요. 그래서 만들어진 `_.if2`를 다음 시간에 소개할까 합니다. 이 함수를 사용하면 코드는 아래처럼 달라집니다.\n\n```javascript\n_go(11,\n  _.if2(_lt(10))(\n    _add(100), \n    console.log\n  ).else_if(_gte(20))(\n    _add(200), \n    console.log\n  ).else(\n    _add(300), \n    console.log\n  ));\n```","slug":"daily-fp-11","published":1,"updated":"2019-12-05T15:06:08.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9fm001ldirvybg39qzu","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h2><p>오늘은 조건문인 if를 함수로 구현해보려고 합니다. 조건문은 프로그래밍에 아주 빈번하게 사용됩니다. <a href=\"/programming/javascript-daily-function-10/\">지난 시간</a>에 <code>parse_query_obj</code>라는 함수를 만들기 위해 <code>_.if</code> 함수가 잠시 등장했습니다. 이처럼 조건문의 사용은 함수형에도 예외일 수 없습니다. 오늘은 함수형 스타일로 프로그래밍하는 상황에 <code>_.if</code> 함수의 유/무가 어떻게 다른지 비교하고 <code>_.if</code> 함수의 내부가 어떻게 생겼는지 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><p>지난 시간에 만든 <code>parse_query_obj</code> 함수가 <code>_.if</code> 함수 없이 만들어졌다면 어떤 형태였을까요?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var parse_query_obj = _.if(_.identity, // [1] _.if의 첫번째 인자는 조건을 확인하는 함수</span></span><br><span class=\"line\"><span class=\"comment\">//   __(str =&gt; str.slice(1).split('&amp;'), // [2] 두번째 인자는 조건이 참이면 실행될 함수</span></span><br><span class=\"line\"><span class=\"comment\">//     _.compact, </span></span><br><span class=\"line\"><span class=\"comment\">//     _.reduce(function(obj, str) &#123; </span></span><br><span class=\"line\"><span class=\"comment\">//       var arr = str.split('='); </span></span><br><span class=\"line\"><span class=\"comment\">//       obj[arr[0]] = arr[1];</span></span><br><span class=\"line\"><span class=\"comment\">//       return obj;</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;, &#123;&#125;)))</span></span><br><span class=\"line\"><span class=\"comment\">//   .else(_.always(&#123;&#125;)); </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> parse_query_obj = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value ? _.go(value, <span class=\"comment\">// [3] value 값이 참이라면 함수들을 즉시 실행합니다.</span></span><br><span class=\"line\">    str =&gt; str.slice(<span class=\"number\">1</span>).split(<span class=\"string\">'&amp;'</span>),</span><br><span class=\"line\">    _.compact, </span><br><span class=\"line\">    _.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, str</span>) </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">var</span> arr = str.split(<span class=\"string\">'='</span>);</span><br><span class=\"line\">      obj[arr[<span class=\"number\">0</span>]] = arr[<span class=\"number\">1</span>];</span><br><span class=\"line\">      <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;, &#123;&#125;)) : &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>딱히 나쁘다고 말할 수준은 아닙니다. 삼항연산자를 사용하니 깔끔하고 이해도 쉽습니다. 그렇다면 <code>make_query_obj</code> 함수를 만드는 과정 속에 <code>parse_query_obj</code> 함수도 만드는 경우는 어떨까요?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> make_query_obj = _.go(</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.location.search,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123; <span class=\"comment\">// parse_query_obj</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> value ? _.go(value, </span><br><span class=\"line\">      str =&gt; str.slice(<span class=\"number\">1</span>).split(<span class=\"string\">'&amp;'</span>),</span><br><span class=\"line\">      _.compact, </span><br><span class=\"line\">      _.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, str</span>) </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">var</span> arr = str.split(<span class=\"string\">'='</span>);</span><br><span class=\"line\">        obj[arr[<span class=\"number\">0</span>]] = arr[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">      &#125;, &#123;&#125;)) : &#123;&#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n\n<p>역시 나쁘지 않지만 아쉽지 않나요? <code>_.if</code> 함수가 있었다면 조금 더 읽기 좋은 코드가 되지 않을까요?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> make_query_obj = _.go(</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.location.search,</span><br><span class=\"line\">  _.if(_.identity, __( </span><br><span class=\"line\">    str =&gt; str.slice(<span class=\"number\">1</span>).split(<span class=\"string\">'&amp;'</span>),</span><br><span class=\"line\">    _.compact, </span><br><span class=\"line\">    _.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, str</span>) </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">var</span> arr = str.split(<span class=\"string\">'='</span>); </span><br><span class=\"line\">      obj[arr[<span class=\"number\">0</span>]] = arr[<span class=\"number\">1</span>];</span><br><span class=\"line\">      <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;, &#123;&#125;)))</span><br><span class=\"line\">  .else(_.always(&#123;&#125;)),</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n\n<p><code>_.if</code> 함수의 사용으로 보다 직관적이고 이해가 쉬운, 읽기 좋은 코드가 되었습니다. 작성하는 것도 직관적으로 작성할 수 있습니다. 분기가 필요한 순간에 조건문을 작성하듯 <code>_.if</code> 함수를 적으면 그만입니다. </p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><p><code>_.if</code> 함수의 사용법을 확인했으니 내부를 살펴보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.if = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">predi, fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> store = [fn ? [predi, fn] : [_.identity, predi]]; <span class=\"comment\">// [1]</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">If</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span>, args = <span class=\"built_in\">arguments</span>; <span class=\"comment\">// [2]</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.go(store, <span class=\"comment\">// [3] </span></span><br><span class=\"line\">      _.find(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fnset</span>) </span>&#123; <span class=\"keyword\">return</span> fnset[<span class=\"number\">0</span>].apply(context, args); &#125;), <span class=\"comment\">// [4]</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fnset</span>) </span>&#123; <span class=\"keyword\">return</span> fnset ? fnset[<span class=\"number\">1</span>].apply(context, args) : <span class=\"keyword\">void</span> <span class=\"number\">0</span>; &#125;); <span class=\"comment\">// [5]</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> _.extend(If, &#123; <span class=\"comment\">// [6]</span></span><br><span class=\"line\">    else_if: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">predi, fn</span>) </span>&#123; <span class=\"keyword\">return</span> store.push(fn ? [predi, fn] : [_.identity, predi]) &amp;&amp; If; &#125;, <span class=\"comment\">// [7]</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123; <span class=\"keyword\">return</span> store.push([_.constant(<span class=\"literal\">true</span>), fn]) &amp;&amp; If; &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>위의 코드가 <code>_.if</code> 함수의 전부입니다. 의외로 짧은 코드입니다. 그 속에 재미난 기법들이 숨어있습니다. 천천히 살펴보겠습니다. 번호를 주석으로 넣어두었으니 순서대로 설명해나가겠습니다. </p>\n<p>[1] Line 2 - 우선 <code>store</code>라는 배열을 만듭니다. 이 배열은 조건을 판별하는 <code>predi</code> 함수와 조건이 참일 경우 실행될 <code>fn</code> 함수의 묶음인 배열을 값으로 가진 2차원 배열입니다. 이 과정에 나타나는 삼항연산자는 <code>fn</code> 값이 없는 경우, 즉 인자가 1개만 주어진 경우를 확인합니다. 만약에 인자가 1개만 들어왔다면 그건 <code>predi</code>가 아니라 <code>fn</code>에 해당하는 함수입니다. 따라서 <code>predi</code>에 해당하는 조건부를 생략하면 <code>_.identity</code>를 <code>predi</code>에 넣어줍니다. (상단의 예제에서는 이해를 돕기 위해 첫번째 인자로 <code>_.identity</code>를 넣었지만 실제로는 넣지 않아도 동작합니다.)</p>\n<p>[2] Line 5 - 본격적인 <code>If</code> 함수 내부입니다. 이후에 사용하기 위해 실행 컨텍스트인 <code>this</code>와 매개변수를 담은 <code>arguments</code>를 변수에 할당해둡니다. </p>\n<p>[3] Line 6 - <code>_.go</code> 함수로 원하는 동작을 수행한 결과를 리턴합니다. <code>_.go</code>의 첫번째 인자는 배열인 <code>store</code> 입니다.</p>\n<p>[4] Line 7 - <code>_.find</code>의 술부에 해당하는 함수를 미리 적용(커링)해둡니다. 이때 술부 내부를 살펴보면 <code>fnset</code>이라는 값이 존재하는데 이는 <code>store</code>가 가졌던 배열입니다. 이 배열은 <code>[predi, fn]</code>의 형태로 생겼습니다. 결국 <code>fnset[0].apply(context, args)</code> 이 대목은 <code>predi</code>를 실행해보는 것입니다. 이를 통해 참 값이 반환되면 <code>_.find</code> 함수가 찾는 값이 됩니다. 따라서 해당 <code>fnset</code>이 이후 함수로 전달됩니다.</p>\n<p>[5] Line 8 - 전달된 <code>fnset</code>의 두번째 인자는 참인 경우 실행될 함수입니다. <code>fnset[1].apply(context, args)</code>로 함수를 실행합니다.</p>\n<p>[6] Line 11 - 만들어둔 함수 <code>If</code>에 몇가지 함수를 더 붙여서 리턴합니다. (클로저 함수가 리턴됩니다.) 자바스크립트에서 함수는 객체이기 때문에 <code>_.extend</code>를 이용해 확장이 가능합니다. 추가로 붙는 함수는 <code>else_if</code>와 <code>else</code> 입니다. </p>\n<p>[7] Line 12 - <code>store</code>에 추가로 배열을 만들어 넣습니다. 그리고 <code>If</code> 함수를 리턴합니다. 클로저로 <code>store</code> 값이 기억되고 누적되기 때문에 실제로 <code>If</code> 함수가 호출될때 <code>store</code>의 길이는 <code>if</code>, <code>else_if</code>, <code>else</code>가 호출된 만큼의 길이를 갖습니다.</p>\n<p>이렇게 만들어진 함수는 아래와 같이 사용할 수 있습니다. (feat. <a href=\"https://github.com/marpple/window.functions.js\" target=\"_blank\" rel=\"noopener\">window.functions.js</a>)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_go(<span class=\"number\">11</span>,</span><br><span class=\"line\">  _.if(_lt(<span class=\"number\">10</span>), <span class=\"comment\">// [1] 10보다 작으면</span></span><br><span class=\"line\">    _pipe(</span><br><span class=\"line\">      _add(<span class=\"number\">100</span>), </span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">  ).else_if(_gte(<span class=\"number\">20</span>), <span class=\"comment\">// [2] 20과 같거나 크면</span></span><br><span class=\"line\">    _pipe(</span><br><span class=\"line\">      _add(<span class=\"number\">200</span>), </span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">  ).else(</span><br><span class=\"line\">    _pipe(</span><br><span class=\"line\">      _add(<span class=\"number\">300</span>), </span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">  )); </span><br><span class=\"line\">  <span class=\"comment\">// [3] 결과는 311 입니다.</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-내일의-함수\"><a href=\"#3-내일의-함수\" class=\"headerlink\" title=\"(3) 내일의 함수\"></a>(3) 내일의 함수</h4><p><code>_.if</code> 함수의 불편한 점을 발견하지 못하셨나요? 인자를 두개 넘겨서 조건부와 실행부를 결정하기 때문에 각 함수를 <code>_.pipe</code> 함수와 같은 합성 함수로 묶어줘야 합니다. 아무래도 불편하죠. 실제로 하나의 함수로 모든 일을 하는 경우는 드문 일이니까요. 그냥 알아서 함수를 합성해주면 더 편할텐데요. 그래서 만들어진 <code>_.if2</code>를 다음 시간에 소개할까 합니다. 이 함수를 사용하면 코드는 아래처럼 달라집니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_go(<span class=\"number\">11</span>,</span><br><span class=\"line\">  _.if2(_lt(<span class=\"number\">10</span>))(</span><br><span class=\"line\">    _add(<span class=\"number\">100</span>), </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log</span><br><span class=\"line\">  ).else_if(_gte(<span class=\"number\">20</span>))(</span><br><span class=\"line\">    _add(<span class=\"number\">200</span>), </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log</span><br><span class=\"line\">  ).else(</span><br><span class=\"line\">    _add(<span class=\"number\">300</span>), </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log</span><br><span class=\"line\">  ));</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h2><p>오늘은 조건문인 if를 함수로 구현해보려고 합니다. 조건문은 프로그래밍에 아주 빈번하게 사용됩니다. <a href=\"/programming/javascript-daily-function-10/\">지난 시간</a>에 <code>parse_query_obj</code>라는 함수를 만들기 위해 <code>_.if</code> 함수가 잠시 등장했습니다. 이처럼 조건문의 사용은 함수형에도 예외일 수 없습니다. 오늘은 함수형 스타일로 프로그래밍하는 상황에 <code>_.if</code> 함수의 유/무가 어떻게 다른지 비교하고 <code>_.if</code> 함수의 내부가 어떻게 생겼는지 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><p>지난 시간에 만든 <code>parse_query_obj</code> 함수가 <code>_.if</code> 함수 없이 만들어졌다면 어떤 형태였을까요?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var parse_query_obj = _.if(_.identity, // [1] _.if의 첫번째 인자는 조건을 확인하는 함수</span></span><br><span class=\"line\"><span class=\"comment\">//   __(str =&gt; str.slice(1).split('&amp;'), // [2] 두번째 인자는 조건이 참이면 실행될 함수</span></span><br><span class=\"line\"><span class=\"comment\">//     _.compact, </span></span><br><span class=\"line\"><span class=\"comment\">//     _.reduce(function(obj, str) &#123; </span></span><br><span class=\"line\"><span class=\"comment\">//       var arr = str.split('='); </span></span><br><span class=\"line\"><span class=\"comment\">//       obj[arr[0]] = arr[1];</span></span><br><span class=\"line\"><span class=\"comment\">//       return obj;</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;, &#123;&#125;)))</span></span><br><span class=\"line\"><span class=\"comment\">//   .else(_.always(&#123;&#125;)); </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> parse_query_obj = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value ? _.go(value, <span class=\"comment\">// [3] value 값이 참이라면 함수들을 즉시 실행합니다.</span></span><br><span class=\"line\">    str =&gt; str.slice(<span class=\"number\">1</span>).split(<span class=\"string\">'&amp;'</span>),</span><br><span class=\"line\">    _.compact, </span><br><span class=\"line\">    _.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, str</span>) </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">var</span> arr = str.split(<span class=\"string\">'='</span>);</span><br><span class=\"line\">      obj[arr[<span class=\"number\">0</span>]] = arr[<span class=\"number\">1</span>];</span><br><span class=\"line\">      <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;, &#123;&#125;)) : &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>딱히 나쁘다고 말할 수준은 아닙니다. 삼항연산자를 사용하니 깔끔하고 이해도 쉽습니다. 그렇다면 <code>make_query_obj</code> 함수를 만드는 과정 속에 <code>parse_query_obj</code> 함수도 만드는 경우는 어떨까요?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> make_query_obj = _.go(</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.location.search,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123; <span class=\"comment\">// parse_query_obj</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> value ? _.go(value, </span><br><span class=\"line\">      str =&gt; str.slice(<span class=\"number\">1</span>).split(<span class=\"string\">'&amp;'</span>),</span><br><span class=\"line\">      _.compact, </span><br><span class=\"line\">      _.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, str</span>) </span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">var</span> arr = str.split(<span class=\"string\">'='</span>);</span><br><span class=\"line\">        obj[arr[<span class=\"number\">0</span>]] = arr[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">      &#125;, &#123;&#125;)) : &#123;&#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n\n<p>역시 나쁘지 않지만 아쉽지 않나요? <code>_.if</code> 함수가 있었다면 조금 더 읽기 좋은 코드가 되지 않을까요?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> make_query_obj = _.go(</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.location.search,</span><br><span class=\"line\">  _.if(_.identity, __( </span><br><span class=\"line\">    str =&gt; str.slice(<span class=\"number\">1</span>).split(<span class=\"string\">'&amp;'</span>),</span><br><span class=\"line\">    _.compact, </span><br><span class=\"line\">    _.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj, str</span>) </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">var</span> arr = str.split(<span class=\"string\">'='</span>); </span><br><span class=\"line\">      obj[arr[<span class=\"number\">0</span>]] = arr[<span class=\"number\">1</span>];</span><br><span class=\"line\">      <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;, &#123;&#125;)))</span><br><span class=\"line\">  .else(_.always(&#123;&#125;)),</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure>\n\n<p><code>_.if</code> 함수의 사용으로 보다 직관적이고 이해가 쉬운, 읽기 좋은 코드가 되었습니다. 작성하는 것도 직관적으로 작성할 수 있습니다. 분기가 필요한 순간에 조건문을 작성하듯 <code>_.if</code> 함수를 적으면 그만입니다. </p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><p><code>_.if</code> 함수의 사용법을 확인했으니 내부를 살펴보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.if = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">predi, fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> store = [fn ? [predi, fn] : [_.identity, predi]]; <span class=\"comment\">// [1]</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">If</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span>, args = <span class=\"built_in\">arguments</span>; <span class=\"comment\">// [2]</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.go(store, <span class=\"comment\">// [3] </span></span><br><span class=\"line\">      _.find(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fnset</span>) </span>&#123; <span class=\"keyword\">return</span> fnset[<span class=\"number\">0</span>].apply(context, args); &#125;), <span class=\"comment\">// [4]</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fnset</span>) </span>&#123; <span class=\"keyword\">return</span> fnset ? fnset[<span class=\"number\">1</span>].apply(context, args) : <span class=\"keyword\">void</span> <span class=\"number\">0</span>; &#125;); <span class=\"comment\">// [5]</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> _.extend(If, &#123; <span class=\"comment\">// [6]</span></span><br><span class=\"line\">    else_if: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">predi, fn</span>) </span>&#123; <span class=\"keyword\">return</span> store.push(fn ? [predi, fn] : [_.identity, predi]) &amp;&amp; If; &#125;, <span class=\"comment\">// [7]</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123; <span class=\"keyword\">return</span> store.push([_.constant(<span class=\"literal\">true</span>), fn]) &amp;&amp; If; &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>위의 코드가 <code>_.if</code> 함수의 전부입니다. 의외로 짧은 코드입니다. 그 속에 재미난 기법들이 숨어있습니다. 천천히 살펴보겠습니다. 번호를 주석으로 넣어두었으니 순서대로 설명해나가겠습니다. </p>\n<p>[1] Line 2 - 우선 <code>store</code>라는 배열을 만듭니다. 이 배열은 조건을 판별하는 <code>predi</code> 함수와 조건이 참일 경우 실행될 <code>fn</code> 함수의 묶음인 배열을 값으로 가진 2차원 배열입니다. 이 과정에 나타나는 삼항연산자는 <code>fn</code> 값이 없는 경우, 즉 인자가 1개만 주어진 경우를 확인합니다. 만약에 인자가 1개만 들어왔다면 그건 <code>predi</code>가 아니라 <code>fn</code>에 해당하는 함수입니다. 따라서 <code>predi</code>에 해당하는 조건부를 생략하면 <code>_.identity</code>를 <code>predi</code>에 넣어줍니다. (상단의 예제에서는 이해를 돕기 위해 첫번째 인자로 <code>_.identity</code>를 넣었지만 실제로는 넣지 않아도 동작합니다.)</p>\n<p>[2] Line 5 - 본격적인 <code>If</code> 함수 내부입니다. 이후에 사용하기 위해 실행 컨텍스트인 <code>this</code>와 매개변수를 담은 <code>arguments</code>를 변수에 할당해둡니다. </p>\n<p>[3] Line 6 - <code>_.go</code> 함수로 원하는 동작을 수행한 결과를 리턴합니다. <code>_.go</code>의 첫번째 인자는 배열인 <code>store</code> 입니다.</p>\n<p>[4] Line 7 - <code>_.find</code>의 술부에 해당하는 함수를 미리 적용(커링)해둡니다. 이때 술부 내부를 살펴보면 <code>fnset</code>이라는 값이 존재하는데 이는 <code>store</code>가 가졌던 배열입니다. 이 배열은 <code>[predi, fn]</code>의 형태로 생겼습니다. 결국 <code>fnset[0].apply(context, args)</code> 이 대목은 <code>predi</code>를 실행해보는 것입니다. 이를 통해 참 값이 반환되면 <code>_.find</code> 함수가 찾는 값이 됩니다. 따라서 해당 <code>fnset</code>이 이후 함수로 전달됩니다.</p>\n<p>[5] Line 8 - 전달된 <code>fnset</code>의 두번째 인자는 참인 경우 실행될 함수입니다. <code>fnset[1].apply(context, args)</code>로 함수를 실행합니다.</p>\n<p>[6] Line 11 - 만들어둔 함수 <code>If</code>에 몇가지 함수를 더 붙여서 리턴합니다. (클로저 함수가 리턴됩니다.) 자바스크립트에서 함수는 객체이기 때문에 <code>_.extend</code>를 이용해 확장이 가능합니다. 추가로 붙는 함수는 <code>else_if</code>와 <code>else</code> 입니다. </p>\n<p>[7] Line 12 - <code>store</code>에 추가로 배열을 만들어 넣습니다. 그리고 <code>If</code> 함수를 리턴합니다. 클로저로 <code>store</code> 값이 기억되고 누적되기 때문에 실제로 <code>If</code> 함수가 호출될때 <code>store</code>의 길이는 <code>if</code>, <code>else_if</code>, <code>else</code>가 호출된 만큼의 길이를 갖습니다.</p>\n<p>이렇게 만들어진 함수는 아래와 같이 사용할 수 있습니다. (feat. <a href=\"https://github.com/marpple/window.functions.js\" target=\"_blank\" rel=\"noopener\">window.functions.js</a>)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_go(<span class=\"number\">11</span>,</span><br><span class=\"line\">  _.if(_lt(<span class=\"number\">10</span>), <span class=\"comment\">// [1] 10보다 작으면</span></span><br><span class=\"line\">    _pipe(</span><br><span class=\"line\">      _add(<span class=\"number\">100</span>), </span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">  ).else_if(_gte(<span class=\"number\">20</span>), <span class=\"comment\">// [2] 20과 같거나 크면</span></span><br><span class=\"line\">    _pipe(</span><br><span class=\"line\">      _add(<span class=\"number\">200</span>), </span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">  ).else(</span><br><span class=\"line\">    _pipe(</span><br><span class=\"line\">      _add(<span class=\"number\">300</span>), </span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">  )); </span><br><span class=\"line\">  <span class=\"comment\">// [3] 결과는 311 입니다.</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-내일의-함수\"><a href=\"#3-내일의-함수\" class=\"headerlink\" title=\"(3) 내일의 함수\"></a>(3) 내일의 함수</h4><p><code>_.if</code> 함수의 불편한 점을 발견하지 못하셨나요? 인자를 두개 넘겨서 조건부와 실행부를 결정하기 때문에 각 함수를 <code>_.pipe</code> 함수와 같은 합성 함수로 묶어줘야 합니다. 아무래도 불편하죠. 실제로 하나의 함수로 모든 일을 하는 경우는 드문 일이니까요. 그냥 알아서 함수를 합성해주면 더 편할텐데요. 그래서 만들어진 <code>_.if2</code>를 다음 시간에 소개할까 합니다. 이 함수를 사용하면 코드는 아래처럼 달라집니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_go(<span class=\"number\">11</span>,</span><br><span class=\"line\">  _.if2(_lt(<span class=\"number\">10</span>))(</span><br><span class=\"line\">    _add(<span class=\"number\">100</span>), </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log</span><br><span class=\"line\">  ).else_if(_gte(<span class=\"number\">20</span>))(</span><br><span class=\"line\">    _add(<span class=\"number\">200</span>), </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log</span><br><span class=\"line\">  ).else(</span><br><span class=\"line\">    _add(<span class=\"number\">300</span>), </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log</span><br><span class=\"line\">  ));</span><br></pre></td></tr></table></figure>"},{"title":"오늘의 함수 - if2","date":"2017-12-06T05:12:21.000Z","description":"기존의 _.if와 _.if2의 문법적 차이를 먼저 살펴보고 구현 방식의 차이에 대해서도 이야기해보겠습니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## if2\n\n오늘은 [지난 시간](/programming/javascript-daily-function-11/)에 예고한대로 `_.if2` 함수를 살펴보겠습니다. 기존의 `_.if`와 `_.if2`의 문법적 차이를 먼저 살펴보고 구현 방식의 차이에 대해서도 이야기해보겠습니다. (오늘의 함수를 이해하기 위해 반드시 [오늘의 함수 - if](/programming/javascript-daily-function-11/)를 확인하고 오셔야합니다.)\n\n\n#### (1) 어제의 함수\n기존의 `_.if`는 `_.if(predi, fn)`의 형태로 사용합니다. 조건이 되는 `predi`와 조건에 따라 실행할 `fn`을 인자로 전달하는데 이때 `fn`을 정의하기 위해서 `_pipe`와 같은 합성 함수를 사용해야 합니다. [window.functions.js](https://github.com/marpple/window.functions.js)와 함께 사용하면 아래와 같은 예제를 만들어 볼 수 있습니다.\n\n```javascript\n_go(11,\n  _.if(_lt(10), // [1] 10보다 작으면\n    _pipe(\n      _add(100), \n      console.log)\n  ).else_if(_gte(20), // [2] 20과 같거나 크면\n    _pipe(\n      _add(200), \n      console.log)\n  ).else(\n    _pipe(\n      _add(300), \n      console.log)\n  )); \n  // [3] 결과는 311 입니다.\n```\n\n지난 시간에 이미 보여드린 것처럼 위의 코드는 `_.if2` 함수를 만나 아래와 같은 형태로 다르게 적을 수 있습니다.\n\n```javascript\n_go(11,\n  _.if2(_lt(10))(\n    _add(100), \n    console.log\n  ).else_if(_gte(20))(\n    _add(200), \n    console.log\n  ).else(\n    _add(300), \n    console.log\n  ));\n```\n\n`_.if2`에서는 괄호를 연달아 두번 열어줍니다. 첫번째 괄호는 조건부를 담고 두번째 괄호는 실행부를 담습니다. 각 괄호 안에 몇개의 함수를 담건 합성해서 실행합니다. 코드가 간결해졌을뿐 아니라 본래의 if와 유사한 형태를 띄고 있습니다. 훨씬 직관적인 함수가 되었습니다.\n\n\n#### (2) 오늘의 함수\n이제 `_.if2`가 어떻게 구현되었는지 살펴보겠습니다.\n\n```javascript\n_.if2 = function() {\n  var predi = _.pipe.apply(this, arguments); // [1]\n  return function() {\n    var store = [[predi, _.pipe.apply(this, arguments)]]; // [2]\n    \n    function If() { // [3]\n      var context = this, args = arguments; \n      return _.go(store,\n        _.find(function(fnset) { return fnset[0].apply(context, args); }),\n        function(fnset) { return fnset ? fnset[1].apply(context, args) : void 0; });\n    }\n    \n    return _.extend(If, {\n      else_if: function() {\n        var predi = _.pipe.apply(this, arguments); // [4]\n        return function() { return store.push([predi, _.pipe.apply(this, arguments)]) && If; }; // [5]\n      },\n      else: function() { return store.push([_.constant(true), _.pipe.apply(this, arguments)]) && If; }\n    });\n  };\n};\n```\n\n지난 시간에 살펴본 `_.if` 함수의 내부와 상당히 유사한 코드입니다. 함수의 실행 시기의 차이로 인해 몇가지 다른 점이 보입니다. 이번에도 주석을 따라 순서대로 설명하겠습니다. \n\n[1] Line 2 - 가장 밖에 있는 함수는 인자로 조건부에 해당하는 함수들을 받습니다. 그 함수들을 `_.pipe` 함수로 합성해둡니다. 나중에 `store`에 저장하기 위함입니다.\n\n[2] Line 4 - `_.if` 함수와 마찬가지로 `store`라는 배열을 만듭니다. 이 배열은 위에서 만들어둔 조건 판별 함수인 `predi`와 현재 함수에서 받은 인자로 받은 함수들 즉, 실행될 함수 `fn`을 묶음으로 가진 2차원 배열입니다. 여기서도 `_.pipe`로 인자들을 합성합니다. \n\n[3] Line 6 - `_.if` 함수의 `If` 함수와 동일합니다. [오늘의 함수 - if](/programming/javascript-daily-function-11/)를 참고하세요.\n\n[4] Line 15 - [1]번에서와 같이 `store`에 저장하기 위해 인자로 받은 함수를 합성합니다.\n\n[5] Line 16 - [2]번처럼 실행될 함수를 만들어 조건부 함수와 함께 `store`에 넣어둡니다.","source":"_posts/daily-fp-12.md","raw":"---\ntitle: '오늘의 함수 - if2'\ndate: 2017-12-06 14:12:21\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\n  - 조건문 함수\ndescription: 기존의 _.if와 _.if2의 문법적 차이를 먼저 살펴보고 구현 방식의 차이에 대해서도 이야기해보겠습니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## if2\n\n오늘은 [지난 시간](/programming/javascript-daily-function-11/)에 예고한대로 `_.if2` 함수를 살펴보겠습니다. 기존의 `_.if`와 `_.if2`의 문법적 차이를 먼저 살펴보고 구현 방식의 차이에 대해서도 이야기해보겠습니다. (오늘의 함수를 이해하기 위해 반드시 [오늘의 함수 - if](/programming/javascript-daily-function-11/)를 확인하고 오셔야합니다.)\n\n\n#### (1) 어제의 함수\n기존의 `_.if`는 `_.if(predi, fn)`의 형태로 사용합니다. 조건이 되는 `predi`와 조건에 따라 실행할 `fn`을 인자로 전달하는데 이때 `fn`을 정의하기 위해서 `_pipe`와 같은 합성 함수를 사용해야 합니다. [window.functions.js](https://github.com/marpple/window.functions.js)와 함께 사용하면 아래와 같은 예제를 만들어 볼 수 있습니다.\n\n```javascript\n_go(11,\n  _.if(_lt(10), // [1] 10보다 작으면\n    _pipe(\n      _add(100), \n      console.log)\n  ).else_if(_gte(20), // [2] 20과 같거나 크면\n    _pipe(\n      _add(200), \n      console.log)\n  ).else(\n    _pipe(\n      _add(300), \n      console.log)\n  )); \n  // [3] 결과는 311 입니다.\n```\n\n지난 시간에 이미 보여드린 것처럼 위의 코드는 `_.if2` 함수를 만나 아래와 같은 형태로 다르게 적을 수 있습니다.\n\n```javascript\n_go(11,\n  _.if2(_lt(10))(\n    _add(100), \n    console.log\n  ).else_if(_gte(20))(\n    _add(200), \n    console.log\n  ).else(\n    _add(300), \n    console.log\n  ));\n```\n\n`_.if2`에서는 괄호를 연달아 두번 열어줍니다. 첫번째 괄호는 조건부를 담고 두번째 괄호는 실행부를 담습니다. 각 괄호 안에 몇개의 함수를 담건 합성해서 실행합니다. 코드가 간결해졌을뿐 아니라 본래의 if와 유사한 형태를 띄고 있습니다. 훨씬 직관적인 함수가 되었습니다.\n\n\n#### (2) 오늘의 함수\n이제 `_.if2`가 어떻게 구현되었는지 살펴보겠습니다.\n\n```javascript\n_.if2 = function() {\n  var predi = _.pipe.apply(this, arguments); // [1]\n  return function() {\n    var store = [[predi, _.pipe.apply(this, arguments)]]; // [2]\n    \n    function If() { // [3]\n      var context = this, args = arguments; \n      return _.go(store,\n        _.find(function(fnset) { return fnset[0].apply(context, args); }),\n        function(fnset) { return fnset ? fnset[1].apply(context, args) : void 0; });\n    }\n    \n    return _.extend(If, {\n      else_if: function() {\n        var predi = _.pipe.apply(this, arguments); // [4]\n        return function() { return store.push([predi, _.pipe.apply(this, arguments)]) && If; }; // [5]\n      },\n      else: function() { return store.push([_.constant(true), _.pipe.apply(this, arguments)]) && If; }\n    });\n  };\n};\n```\n\n지난 시간에 살펴본 `_.if` 함수의 내부와 상당히 유사한 코드입니다. 함수의 실행 시기의 차이로 인해 몇가지 다른 점이 보입니다. 이번에도 주석을 따라 순서대로 설명하겠습니다. \n\n[1] Line 2 - 가장 밖에 있는 함수는 인자로 조건부에 해당하는 함수들을 받습니다. 그 함수들을 `_.pipe` 함수로 합성해둡니다. 나중에 `store`에 저장하기 위함입니다.\n\n[2] Line 4 - `_.if` 함수와 마찬가지로 `store`라는 배열을 만듭니다. 이 배열은 위에서 만들어둔 조건 판별 함수인 `predi`와 현재 함수에서 받은 인자로 받은 함수들 즉, 실행될 함수 `fn`을 묶음으로 가진 2차원 배열입니다. 여기서도 `_.pipe`로 인자들을 합성합니다. \n\n[3] Line 6 - `_.if` 함수의 `If` 함수와 동일합니다. [오늘의 함수 - if](/programming/javascript-daily-function-11/)를 참고하세요.\n\n[4] Line 15 - [1]번에서와 같이 `store`에 저장하기 위해 인자로 받은 함수를 합성합니다.\n\n[5] Line 16 - [2]번처럼 실행될 함수를 만들어 조건부 함수와 함께 `store`에 넣어둡니다.","slug":"daily-fp-12","published":1,"updated":"2019-12-05T15:06:08.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9fn001odirvmeo3q0qf","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"if2\"><a href=\"#if2\" class=\"headerlink\" title=\"if2\"></a>if2</h2><p>오늘은 <a href=\"/programming/javascript-daily-function-11/\">지난 시간</a>에 예고한대로 <code>_.if2</code> 함수를 살펴보겠습니다. 기존의 <code>_.if</code>와 <code>_.if2</code>의 문법적 차이를 먼저 살펴보고 구현 방식의 차이에 대해서도 이야기해보겠습니다. (오늘의 함수를 이해하기 위해 반드시 <a href=\"/programming/javascript-daily-function-11/\">오늘의 함수 - if</a>를 확인하고 오셔야합니다.)</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><p>기존의 <code>_.if</code>는 <code>_.if(predi, fn)</code>의 형태로 사용합니다. 조건이 되는 <code>predi</code>와 조건에 따라 실행할 <code>fn</code>을 인자로 전달하는데 이때 <code>fn</code>을 정의하기 위해서 <code>_pipe</code>와 같은 합성 함수를 사용해야 합니다. <a href=\"https://github.com/marpple/window.functions.js\" target=\"_blank\" rel=\"noopener\">window.functions.js</a>와 함께 사용하면 아래와 같은 예제를 만들어 볼 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_go(<span class=\"number\">11</span>,</span><br><span class=\"line\">  _.if(_lt(<span class=\"number\">10</span>), <span class=\"comment\">// [1] 10보다 작으면</span></span><br><span class=\"line\">    _pipe(</span><br><span class=\"line\">      _add(<span class=\"number\">100</span>), </span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">  ).else_if(_gte(<span class=\"number\">20</span>), <span class=\"comment\">// [2] 20과 같거나 크면</span></span><br><span class=\"line\">    _pipe(</span><br><span class=\"line\">      _add(<span class=\"number\">200</span>), </span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">  ).else(</span><br><span class=\"line\">    _pipe(</span><br><span class=\"line\">      _add(<span class=\"number\">300</span>), </span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">  )); </span><br><span class=\"line\">  <span class=\"comment\">// [3] 결과는 311 입니다.</span></span><br></pre></td></tr></table></figure>\n\n<p>지난 시간에 이미 보여드린 것처럼 위의 코드는 <code>_.if2</code> 함수를 만나 아래와 같은 형태로 다르게 적을 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_go(<span class=\"number\">11</span>,</span><br><span class=\"line\">  _.if2(_lt(<span class=\"number\">10</span>))(</span><br><span class=\"line\">    _add(<span class=\"number\">100</span>), </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log</span><br><span class=\"line\">  ).else_if(_gte(<span class=\"number\">20</span>))(</span><br><span class=\"line\">    _add(<span class=\"number\">200</span>), </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log</span><br><span class=\"line\">  ).else(</span><br><span class=\"line\">    _add(<span class=\"number\">300</span>), </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log</span><br><span class=\"line\">  ));</span><br></pre></td></tr></table></figure>\n\n<p><code>_.if2</code>에서는 괄호를 연달아 두번 열어줍니다. 첫번째 괄호는 조건부를 담고 두번째 괄호는 실행부를 담습니다. 각 괄호 안에 몇개의 함수를 담건 합성해서 실행합니다. 코드가 간결해졌을뿐 아니라 본래의 if와 유사한 형태를 띄고 있습니다. 훨씬 직관적인 함수가 되었습니다.</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><p>이제 <code>_.if2</code>가 어떻게 구현되었는지 살펴보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.if2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> predi = _.pipe.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); <span class=\"comment\">// [1]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> store = [[predi, _.pipe.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)]]; <span class=\"comment\">// [2]</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">If</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// [3]</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span>, args = <span class=\"built_in\">arguments</span>; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> _.go(store,</span><br><span class=\"line\">        _.find(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fnset</span>) </span>&#123; <span class=\"keyword\">return</span> fnset[<span class=\"number\">0</span>].apply(context, args); &#125;),</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fnset</span>) </span>&#123; <span class=\"keyword\">return</span> fnset ? fnset[<span class=\"number\">1</span>].apply(context, args) : <span class=\"keyword\">void</span> <span class=\"number\">0</span>; &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.extend(If, &#123;</span><br><span class=\"line\">      else_if: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> predi = _.pipe.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); <span class=\"comment\">// [4]</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> store.push([predi, _.pipe.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)]) &amp;&amp; If; &#125;; <span class=\"comment\">// [5]</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"keyword\">else</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> store.push([_.constant(<span class=\"literal\">true</span>), _.pipe.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)]) &amp;&amp; If; &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>지난 시간에 살펴본 <code>_.if</code> 함수의 내부와 상당히 유사한 코드입니다. 함수의 실행 시기의 차이로 인해 몇가지 다른 점이 보입니다. 이번에도 주석을 따라 순서대로 설명하겠습니다. </p>\n<p>[1] Line 2 - 가장 밖에 있는 함수는 인자로 조건부에 해당하는 함수들을 받습니다. 그 함수들을 <code>_.pipe</code> 함수로 합성해둡니다. 나중에 <code>store</code>에 저장하기 위함입니다.</p>\n<p>[2] Line 4 - <code>_.if</code> 함수와 마찬가지로 <code>store</code>라는 배열을 만듭니다. 이 배열은 위에서 만들어둔 조건 판별 함수인 <code>predi</code>와 현재 함수에서 받은 인자로 받은 함수들 즉, 실행될 함수 <code>fn</code>을 묶음으로 가진 2차원 배열입니다. 여기서도 <code>_.pipe</code>로 인자들을 합성합니다. </p>\n<p>[3] Line 6 - <code>_.if</code> 함수의 <code>If</code> 함수와 동일합니다. <a href=\"/programming/javascript-daily-function-11/\">오늘의 함수 - if</a>를 참고하세요.</p>\n<p>[4] Line 15 - [1]번에서와 같이 <code>store</code>에 저장하기 위해 인자로 받은 함수를 합성합니다.</p>\n<p>[5] Line 16 - [2]번처럼 실행될 함수를 만들어 조건부 함수와 함께 <code>store</code>에 넣어둡니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"if2\"><a href=\"#if2\" class=\"headerlink\" title=\"if2\"></a>if2</h2><p>오늘은 <a href=\"/programming/javascript-daily-function-11/\">지난 시간</a>에 예고한대로 <code>_.if2</code> 함수를 살펴보겠습니다. 기존의 <code>_.if</code>와 <code>_.if2</code>의 문법적 차이를 먼저 살펴보고 구현 방식의 차이에 대해서도 이야기해보겠습니다. (오늘의 함수를 이해하기 위해 반드시 <a href=\"/programming/javascript-daily-function-11/\">오늘의 함수 - if</a>를 확인하고 오셔야합니다.)</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><p>기존의 <code>_.if</code>는 <code>_.if(predi, fn)</code>의 형태로 사용합니다. 조건이 되는 <code>predi</code>와 조건에 따라 실행할 <code>fn</code>을 인자로 전달하는데 이때 <code>fn</code>을 정의하기 위해서 <code>_pipe</code>와 같은 합성 함수를 사용해야 합니다. <a href=\"https://github.com/marpple/window.functions.js\" target=\"_blank\" rel=\"noopener\">window.functions.js</a>와 함께 사용하면 아래와 같은 예제를 만들어 볼 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_go(<span class=\"number\">11</span>,</span><br><span class=\"line\">  _.if(_lt(<span class=\"number\">10</span>), <span class=\"comment\">// [1] 10보다 작으면</span></span><br><span class=\"line\">    _pipe(</span><br><span class=\"line\">      _add(<span class=\"number\">100</span>), </span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">  ).else_if(_gte(<span class=\"number\">20</span>), <span class=\"comment\">// [2] 20과 같거나 크면</span></span><br><span class=\"line\">    _pipe(</span><br><span class=\"line\">      _add(<span class=\"number\">200</span>), </span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">  ).else(</span><br><span class=\"line\">    _pipe(</span><br><span class=\"line\">      _add(<span class=\"number\">300</span>), </span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log)</span><br><span class=\"line\">  )); </span><br><span class=\"line\">  <span class=\"comment\">// [3] 결과는 311 입니다.</span></span><br></pre></td></tr></table></figure>\n\n<p>지난 시간에 이미 보여드린 것처럼 위의 코드는 <code>_.if2</code> 함수를 만나 아래와 같은 형태로 다르게 적을 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_go(<span class=\"number\">11</span>,</span><br><span class=\"line\">  _.if2(_lt(<span class=\"number\">10</span>))(</span><br><span class=\"line\">    _add(<span class=\"number\">100</span>), </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log</span><br><span class=\"line\">  ).else_if(_gte(<span class=\"number\">20</span>))(</span><br><span class=\"line\">    _add(<span class=\"number\">200</span>), </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log</span><br><span class=\"line\">  ).else(</span><br><span class=\"line\">    _add(<span class=\"number\">300</span>), </span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log</span><br><span class=\"line\">  ));</span><br></pre></td></tr></table></figure>\n\n<p><code>_.if2</code>에서는 괄호를 연달아 두번 열어줍니다. 첫번째 괄호는 조건부를 담고 두번째 괄호는 실행부를 담습니다. 각 괄호 안에 몇개의 함수를 담건 합성해서 실행합니다. 코드가 간결해졌을뿐 아니라 본래의 if와 유사한 형태를 띄고 있습니다. 훨씬 직관적인 함수가 되었습니다.</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><p>이제 <code>_.if2</code>가 어떻게 구현되었는지 살펴보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.if2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> predi = _.pipe.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); <span class=\"comment\">// [1]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> store = [[predi, _.pipe.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)]]; <span class=\"comment\">// [2]</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">If</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// [3]</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span>, args = <span class=\"built_in\">arguments</span>; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> _.go(store,</span><br><span class=\"line\">        _.find(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fnset</span>) </span>&#123; <span class=\"keyword\">return</span> fnset[<span class=\"number\">0</span>].apply(context, args); &#125;),</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fnset</span>) </span>&#123; <span class=\"keyword\">return</span> fnset ? fnset[<span class=\"number\">1</span>].apply(context, args) : <span class=\"keyword\">void</span> <span class=\"number\">0</span>; &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.extend(If, &#123;</span><br><span class=\"line\">      else_if: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> predi = _.pipe.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); <span class=\"comment\">// [4]</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> store.push([predi, _.pipe.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)]) &amp;&amp; If; &#125;; <span class=\"comment\">// [5]</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"keyword\">else</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> store.push([_.constant(<span class=\"literal\">true</span>), _.pipe.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)]) &amp;&amp; If; &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>지난 시간에 살펴본 <code>_.if</code> 함수의 내부와 상당히 유사한 코드입니다. 함수의 실행 시기의 차이로 인해 몇가지 다른 점이 보입니다. 이번에도 주석을 따라 순서대로 설명하겠습니다. </p>\n<p>[1] Line 2 - 가장 밖에 있는 함수는 인자로 조건부에 해당하는 함수들을 받습니다. 그 함수들을 <code>_.pipe</code> 함수로 합성해둡니다. 나중에 <code>store</code>에 저장하기 위함입니다.</p>\n<p>[2] Line 4 - <code>_.if</code> 함수와 마찬가지로 <code>store</code>라는 배열을 만듭니다. 이 배열은 위에서 만들어둔 조건 판별 함수인 <code>predi</code>와 현재 함수에서 받은 인자로 받은 함수들 즉, 실행될 함수 <code>fn</code>을 묶음으로 가진 2차원 배열입니다. 여기서도 <code>_.pipe</code>로 인자들을 합성합니다. </p>\n<p>[3] Line 6 - <code>_.if</code> 함수의 <code>If</code> 함수와 동일합니다. <a href=\"/programming/javascript-daily-function-11/\">오늘의 함수 - if</a>를 참고하세요.</p>\n<p>[4] Line 15 - [1]번에서와 같이 <code>store</code>에 저장하기 위해 인자로 받은 함수를 합성합니다.</p>\n<p>[5] Line 16 - [2]번처럼 실행될 함수를 만들어 조건부 함수와 함께 <code>store</code>에 넣어둡니다.</p>\n"},{"title":"오늘의 함수 - all","date":"2018-01-29T12:43:13.000Z","description":"all은 하나의 인자를 다수의 함수에게 전달합니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## all\n\n오늘은 `all`이라는 함수를 소개합니다. [지난 시간](/programming/javascript-daily-function-14/)에 소개해드린 `mr`처럼 `go`나 `pipe`안에서 사용합니다. `all`은 하나의 인자를 다수의 함수에게 전달합니다. 달리 표현하자면 하나의 재료(값)로 여러가지 일(함수)을 처리해야할 때 `all`을 사용합니다.\n\n(예제는 [함수형 JS 스터디 시즌2](https://github.com/joeunha/functional-js-study2)의 [4주차 미션](https://github.com/joeunha/functional-js-study2/issues/4)을 토대로 합니다.)\n\n#### (1) 어제의 함수\n\n```javascript\nvar users = [\n  { id: 1, name: 'ID', age: 36 },\n  { id: 2, name: 'BJ', age: 32 },\n  { id: 3, name: 'JM', age: 34 },\n  { id: 4, name: 'PJ', age: 27 },\n  { id: 5, name: 'HA', age: 25 },\n  { id: 6, name: 'JE', age: 26 },\n  { id: 7, name: 'JI', age: 31 },\n  { id: 8, name: 'MP', age: 23 }\n];\n```\n\n위의 `users`로 세 종류의 데이터를 추출하려고 합니다. \n\n1. 30세 미만의 유저들의 이름 목록\n2. 30세 이상의 유저들의 나이의 총합\n3. 이름이 'JE'인 유저의 나이\n\n```javascript\n// 1. 30세 미만의 유저들의 이름 목록\ngo(users,\n  filter(user => user.age < 30),\n  map(user => user.name),\n  log) // [\"PJ\", \"HA\", \"JE\", \"MP\"]\n\n// 2. 30세 이상의 유저들의 나이의 총합\ngo(users,\n  filter(user => user.age > 30),\n  reduce((age, user) => (age + user.age), 0),\n  log) // 133\n\n// 3. 이름이 'JE'인 유저의 나이 (첫번째로 발견한 'JE')\ngo(users,\n  find(user => user.name === 'JE'),\n  user => user.age,\n  log) // 26\n```\n\n\n#### (2) 오늘의 함수\n어제의 함수들은 `users`라는 공통의 재료를 사용합니다. 각기 다른 `go`에 존재하지만 같은 값을 사용하는 함수들을 하나의 `go` 안에 모아보겠습니다.\n\n```javascript\ngo(users,\n  all(\n    pipe(filter(user => user.age < 30), map(user => user.name)), // 1. 30세 미만의 유저들의 이름 목록\n    pipe(filter(user => user.age > 30), reduce((age, user) => (age + user.age), 0)), // 2. 30세 이상의 유저들의 나이의 총합\n    pipe(find(user => user.name === 'JE'), user => user.age)), // 3. 이름이 'JE'인 유저의 나이\n  log) // [\"PJ\", \"HA\", \"JE\", \"MP\"] 133 26\n```\n\n이렇게 달라집니다. 간단히 살펴보겠습니다. `all` 함수는 함수를 인자로 받습니다. 여러개의 함수를 받고 이후에 들어오는 값을 그 함수들에게 인자로 넘겨줍니다. 위의 코드에선 해야할 일을 묶어서 정리하기 위해 `pipe`로 함수를 합성했습니다. 합성된 함수는 총 세개임으로 `users`는 세 함수에게 값으로 전달됩니다. 그리고 각기 해야할 일을 마친 뒤 `log`에 전달됩니다. (`all`은 내부적으로 `mr`에 의해 여러개의 값을 리턴합니다.) 이제 `all`의 구현을 살펴보겠습니다.\n\n\n```javascript\nfunction all(...fns) { // [1]\n  return function(arg) { // [2]\n    return go(fns, map(fn => fn(arg)), to_mr); // [3]\n  };\n}\n```\n\n생각보다 간결합니다.\n\n[1] `all` 함수는 함수들을 인자로 받습니다. 가변인자(배열)로 함수를 받았습니다.\n[2] 우선 함수(클로저)를 리턴하는데 이 함수는 이후에 호출될 때 재료가 될 값을 받습니다. \n[3] `go`를 실행합니다. 함수들이 담긴 배열을 첫번째 값으로 전달하고 `map`으로 함수가 실행된 결과를 모아둡니다. 그리고 [지난 시간](/programming/javascript-daily-function-14/)에 자매품으로 소개해드린 `to_mr`으로 배열을 멀티 리턴 값으로 바꿔줍니다.","source":"_posts/daily-fp-15.md","raw":"---\ntitle: '오늘의 함수 - all'\ndate: 2018-01-29 21:43:13\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: all은 하나의 인자를 다수의 함수에게 전달합니다. \n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## all\n\n오늘은 `all`이라는 함수를 소개합니다. [지난 시간](/programming/javascript-daily-function-14/)에 소개해드린 `mr`처럼 `go`나 `pipe`안에서 사용합니다. `all`은 하나의 인자를 다수의 함수에게 전달합니다. 달리 표현하자면 하나의 재료(값)로 여러가지 일(함수)을 처리해야할 때 `all`을 사용합니다.\n\n(예제는 [함수형 JS 스터디 시즌2](https://github.com/joeunha/functional-js-study2)의 [4주차 미션](https://github.com/joeunha/functional-js-study2/issues/4)을 토대로 합니다.)\n\n#### (1) 어제의 함수\n\n```javascript\nvar users = [\n  { id: 1, name: 'ID', age: 36 },\n  { id: 2, name: 'BJ', age: 32 },\n  { id: 3, name: 'JM', age: 34 },\n  { id: 4, name: 'PJ', age: 27 },\n  { id: 5, name: 'HA', age: 25 },\n  { id: 6, name: 'JE', age: 26 },\n  { id: 7, name: 'JI', age: 31 },\n  { id: 8, name: 'MP', age: 23 }\n];\n```\n\n위의 `users`로 세 종류의 데이터를 추출하려고 합니다. \n\n1. 30세 미만의 유저들의 이름 목록\n2. 30세 이상의 유저들의 나이의 총합\n3. 이름이 'JE'인 유저의 나이\n\n```javascript\n// 1. 30세 미만의 유저들의 이름 목록\ngo(users,\n  filter(user => user.age < 30),\n  map(user => user.name),\n  log) // [\"PJ\", \"HA\", \"JE\", \"MP\"]\n\n// 2. 30세 이상의 유저들의 나이의 총합\ngo(users,\n  filter(user => user.age > 30),\n  reduce((age, user) => (age + user.age), 0),\n  log) // 133\n\n// 3. 이름이 'JE'인 유저의 나이 (첫번째로 발견한 'JE')\ngo(users,\n  find(user => user.name === 'JE'),\n  user => user.age,\n  log) // 26\n```\n\n\n#### (2) 오늘의 함수\n어제의 함수들은 `users`라는 공통의 재료를 사용합니다. 각기 다른 `go`에 존재하지만 같은 값을 사용하는 함수들을 하나의 `go` 안에 모아보겠습니다.\n\n```javascript\ngo(users,\n  all(\n    pipe(filter(user => user.age < 30), map(user => user.name)), // 1. 30세 미만의 유저들의 이름 목록\n    pipe(filter(user => user.age > 30), reduce((age, user) => (age + user.age), 0)), // 2. 30세 이상의 유저들의 나이의 총합\n    pipe(find(user => user.name === 'JE'), user => user.age)), // 3. 이름이 'JE'인 유저의 나이\n  log) // [\"PJ\", \"HA\", \"JE\", \"MP\"] 133 26\n```\n\n이렇게 달라집니다. 간단히 살펴보겠습니다. `all` 함수는 함수를 인자로 받습니다. 여러개의 함수를 받고 이후에 들어오는 값을 그 함수들에게 인자로 넘겨줍니다. 위의 코드에선 해야할 일을 묶어서 정리하기 위해 `pipe`로 함수를 합성했습니다. 합성된 함수는 총 세개임으로 `users`는 세 함수에게 값으로 전달됩니다. 그리고 각기 해야할 일을 마친 뒤 `log`에 전달됩니다. (`all`은 내부적으로 `mr`에 의해 여러개의 값을 리턴합니다.) 이제 `all`의 구현을 살펴보겠습니다.\n\n\n```javascript\nfunction all(...fns) { // [1]\n  return function(arg) { // [2]\n    return go(fns, map(fn => fn(arg)), to_mr); // [3]\n  };\n}\n```\n\n생각보다 간결합니다.\n\n[1] `all` 함수는 함수들을 인자로 받습니다. 가변인자(배열)로 함수를 받았습니다.\n[2] 우선 함수(클로저)를 리턴하는데 이 함수는 이후에 호출될 때 재료가 될 값을 받습니다. \n[3] `go`를 실행합니다. 함수들이 담긴 배열을 첫번째 값으로 전달하고 `map`으로 함수가 실행된 결과를 모아둡니다. 그리고 [지난 시간](/programming/javascript-daily-function-14/)에 자매품으로 소개해드린 `to_mr`으로 배열을 멀티 리턴 값으로 바꿔줍니다.","slug":"daily-fp-15","published":1,"updated":"2019-12-05T15:06:08.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9fo001sdirvd9fesxa5","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"all\"><a href=\"#all\" class=\"headerlink\" title=\"all\"></a>all</h2><p>오늘은 <code>all</code>이라는 함수를 소개합니다. <a href=\"/programming/javascript-daily-function-14/\">지난 시간</a>에 소개해드린 <code>mr</code>처럼 <code>go</code>나 <code>pipe</code>안에서 사용합니다. <code>all</code>은 하나의 인자를 다수의 함수에게 전달합니다. 달리 표현하자면 하나의 재료(값)로 여러가지 일(함수)을 처리해야할 때 <code>all</code>을 사용합니다.</p>\n<p>(예제는 <a href=\"https://github.com/joeunha/functional-js-study2\" target=\"_blank\" rel=\"noopener\">함수형 JS 스터디 시즌2</a>의 <a href=\"https://github.com/joeunha/functional-js-study2/issues/4\" target=\"_blank\" rel=\"noopener\">4주차 미션</a>을 토대로 합니다.)</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> users = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">'ID'</span>, <span class=\"attr\">age</span>: <span class=\"number\">36</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">name</span>: <span class=\"string\">'BJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">32</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">3</span>, <span class=\"attr\">name</span>: <span class=\"string\">'JM'</span>, <span class=\"attr\">age</span>: <span class=\"number\">34</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">4</span>, <span class=\"attr\">name</span>: <span class=\"string\">'PJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">5</span>, <span class=\"attr\">name</span>: <span class=\"string\">'HA'</span>, <span class=\"attr\">age</span>: <span class=\"number\">25</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">6</span>, <span class=\"attr\">name</span>: <span class=\"string\">'JE'</span>, <span class=\"attr\">age</span>: <span class=\"number\">26</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">7</span>, <span class=\"attr\">name</span>: <span class=\"string\">'JI'</span>, <span class=\"attr\">age</span>: <span class=\"number\">31</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">8</span>, <span class=\"attr\">name</span>: <span class=\"string\">'MP'</span>, <span class=\"attr\">age</span>: <span class=\"number\">23</span> &#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>위의 <code>users</code>로 세 종류의 데이터를 추출하려고 합니다. </p>\n<ol>\n<li>30세 미만의 유저들의 이름 목록</li>\n<li>30세 이상의 유저들의 나이의 총합</li>\n<li>이름이 ‘JE’인 유저의 나이</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 30세 미만의 유저들의 이름 목록</span></span><br><span class=\"line\">go(users,</span><br><span class=\"line\">  filter(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.age &lt; <span class=\"number\">30</span>),</span><br><span class=\"line\">  map(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.name),</span><br><span class=\"line\">  log) <span class=\"comment\">// [\"PJ\", \"HA\", \"JE\", \"MP\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 30세 이상의 유저들의 나이의 총합</span></span><br><span class=\"line\">go(users,</span><br><span class=\"line\">  filter(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.age &gt; <span class=\"number\">30</span>),</span><br><span class=\"line\">  reduce(<span class=\"function\">(<span class=\"params\">age, user</span>) =&gt;</span> (age + user.age), <span class=\"number\">0</span>),</span><br><span class=\"line\">  log) <span class=\"comment\">// 133</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 이름이 'JE'인 유저의 나이 (첫번째로 발견한 'JE')</span></span><br><span class=\"line\">go(users,</span><br><span class=\"line\">  find(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.name === <span class=\"string\">'JE'</span>),</span><br><span class=\"line\">  user =&gt; user.age,</span><br><span class=\"line\">  log) <span class=\"comment\">// 26</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><p>어제의 함수들은 <code>users</code>라는 공통의 재료를 사용합니다. 각기 다른 <code>go</code>에 존재하지만 같은 값을 사용하는 함수들을 하나의 <code>go</code> 안에 모아보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go(users,</span><br><span class=\"line\">  all(</span><br><span class=\"line\">    pipe(filter(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.age &lt; <span class=\"number\">30</span>), map(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.name)), <span class=\"comment\">// 1. 30세 미만의 유저들의 이름 목록</span></span><br><span class=\"line\">    pipe(filter(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.age &gt; <span class=\"number\">30</span>), reduce(<span class=\"function\">(<span class=\"params\">age, user</span>) =&gt;</span> (age + user.age), <span class=\"number\">0</span>)), <span class=\"comment\">// 2. 30세 이상의 유저들의 나이의 총합</span></span><br><span class=\"line\">    pipe(find(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.name === <span class=\"string\">'JE'</span>), user =&gt; user.age)), <span class=\"comment\">// 3. 이름이 'JE'인 유저의 나이</span></span><br><span class=\"line\">  log) <span class=\"comment\">// [\"PJ\", \"HA\", \"JE\", \"MP\"] 133 26</span></span><br></pre></td></tr></table></figure>\n\n<p>이렇게 달라집니다. 간단히 살펴보겠습니다. <code>all</code> 함수는 함수를 인자로 받습니다. 여러개의 함수를 받고 이후에 들어오는 값을 그 함수들에게 인자로 넘겨줍니다. 위의 코드에선 해야할 일을 묶어서 정리하기 위해 <code>pipe</code>로 함수를 합성했습니다. 합성된 함수는 총 세개임으로 <code>users</code>는 세 함수에게 값으로 전달됩니다. 그리고 각기 해야할 일을 마친 뒤 <code>log</code>에 전달됩니다. (<code>all</code>은 내부적으로 <code>mr</code>에 의해 여러개의 값을 리턴합니다.) 이제 <code>all</code>의 구현을 살펴보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">all</span>(<span class=\"params\">...fns</span>) </span>&#123; <span class=\"comment\">// [1]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123; <span class=\"comment\">// [2]</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> go(fns, map(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn(arg)), to_mr); <span class=\"comment\">// [3]</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>생각보다 간결합니다.</p>\n<p>[1] <code>all</code> 함수는 함수들을 인자로 받습니다. 가변인자(배열)로 함수를 받았습니다.<br>[2] 우선 함수(클로저)를 리턴하는데 이 함수는 이후에 호출될 때 재료가 될 값을 받습니다.<br>[3] <code>go</code>를 실행합니다. 함수들이 담긴 배열을 첫번째 값으로 전달하고 <code>map</code>으로 함수가 실행된 결과를 모아둡니다. 그리고 <a href=\"/programming/javascript-daily-function-14/\">지난 시간</a>에 자매품으로 소개해드린 <code>to_mr</code>으로 배열을 멀티 리턴 값으로 바꿔줍니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"all\"><a href=\"#all\" class=\"headerlink\" title=\"all\"></a>all</h2><p>오늘은 <code>all</code>이라는 함수를 소개합니다. <a href=\"/programming/javascript-daily-function-14/\">지난 시간</a>에 소개해드린 <code>mr</code>처럼 <code>go</code>나 <code>pipe</code>안에서 사용합니다. <code>all</code>은 하나의 인자를 다수의 함수에게 전달합니다. 달리 표현하자면 하나의 재료(값)로 여러가지 일(함수)을 처리해야할 때 <code>all</code>을 사용합니다.</p>\n<p>(예제는 <a href=\"https://github.com/joeunha/functional-js-study2\" target=\"_blank\" rel=\"noopener\">함수형 JS 스터디 시즌2</a>의 <a href=\"https://github.com/joeunha/functional-js-study2/issues/4\" target=\"_blank\" rel=\"noopener\">4주차 미션</a>을 토대로 합니다.)</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> users = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">'ID'</span>, <span class=\"attr\">age</span>: <span class=\"number\">36</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">name</span>: <span class=\"string\">'BJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">32</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">3</span>, <span class=\"attr\">name</span>: <span class=\"string\">'JM'</span>, <span class=\"attr\">age</span>: <span class=\"number\">34</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">4</span>, <span class=\"attr\">name</span>: <span class=\"string\">'PJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">5</span>, <span class=\"attr\">name</span>: <span class=\"string\">'HA'</span>, <span class=\"attr\">age</span>: <span class=\"number\">25</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">6</span>, <span class=\"attr\">name</span>: <span class=\"string\">'JE'</span>, <span class=\"attr\">age</span>: <span class=\"number\">26</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">7</span>, <span class=\"attr\">name</span>: <span class=\"string\">'JI'</span>, <span class=\"attr\">age</span>: <span class=\"number\">31</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">8</span>, <span class=\"attr\">name</span>: <span class=\"string\">'MP'</span>, <span class=\"attr\">age</span>: <span class=\"number\">23</span> &#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>위의 <code>users</code>로 세 종류의 데이터를 추출하려고 합니다. </p>\n<ol>\n<li>30세 미만의 유저들의 이름 목록</li>\n<li>30세 이상의 유저들의 나이의 총합</li>\n<li>이름이 ‘JE’인 유저의 나이</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 30세 미만의 유저들의 이름 목록</span></span><br><span class=\"line\">go(users,</span><br><span class=\"line\">  filter(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.age &lt; <span class=\"number\">30</span>),</span><br><span class=\"line\">  map(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.name),</span><br><span class=\"line\">  log) <span class=\"comment\">// [\"PJ\", \"HA\", \"JE\", \"MP\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 30세 이상의 유저들의 나이의 총합</span></span><br><span class=\"line\">go(users,</span><br><span class=\"line\">  filter(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.age &gt; <span class=\"number\">30</span>),</span><br><span class=\"line\">  reduce(<span class=\"function\">(<span class=\"params\">age, user</span>) =&gt;</span> (age + user.age), <span class=\"number\">0</span>),</span><br><span class=\"line\">  log) <span class=\"comment\">// 133</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 이름이 'JE'인 유저의 나이 (첫번째로 발견한 'JE')</span></span><br><span class=\"line\">go(users,</span><br><span class=\"line\">  find(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.name === <span class=\"string\">'JE'</span>),</span><br><span class=\"line\">  user =&gt; user.age,</span><br><span class=\"line\">  log) <span class=\"comment\">// 26</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><p>어제의 함수들은 <code>users</code>라는 공통의 재료를 사용합니다. 각기 다른 <code>go</code>에 존재하지만 같은 값을 사용하는 함수들을 하나의 <code>go</code> 안에 모아보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go(users,</span><br><span class=\"line\">  all(</span><br><span class=\"line\">    pipe(filter(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.age &lt; <span class=\"number\">30</span>), map(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.name)), <span class=\"comment\">// 1. 30세 미만의 유저들의 이름 목록</span></span><br><span class=\"line\">    pipe(filter(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.age &gt; <span class=\"number\">30</span>), reduce(<span class=\"function\">(<span class=\"params\">age, user</span>) =&gt;</span> (age + user.age), <span class=\"number\">0</span>)), <span class=\"comment\">// 2. 30세 이상의 유저들의 나이의 총합</span></span><br><span class=\"line\">    pipe(find(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.name === <span class=\"string\">'JE'</span>), user =&gt; user.age)), <span class=\"comment\">// 3. 이름이 'JE'인 유저의 나이</span></span><br><span class=\"line\">  log) <span class=\"comment\">// [\"PJ\", \"HA\", \"JE\", \"MP\"] 133 26</span></span><br></pre></td></tr></table></figure>\n\n<p>이렇게 달라집니다. 간단히 살펴보겠습니다. <code>all</code> 함수는 함수를 인자로 받습니다. 여러개의 함수를 받고 이후에 들어오는 값을 그 함수들에게 인자로 넘겨줍니다. 위의 코드에선 해야할 일을 묶어서 정리하기 위해 <code>pipe</code>로 함수를 합성했습니다. 합성된 함수는 총 세개임으로 <code>users</code>는 세 함수에게 값으로 전달됩니다. 그리고 각기 해야할 일을 마친 뒤 <code>log</code>에 전달됩니다. (<code>all</code>은 내부적으로 <code>mr</code>에 의해 여러개의 값을 리턴합니다.) 이제 <code>all</code>의 구현을 살펴보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">all</span>(<span class=\"params\">...fns</span>) </span>&#123; <span class=\"comment\">// [1]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>) </span>&#123; <span class=\"comment\">// [2]</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> go(fns, map(<span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> fn(arg)), to_mr); <span class=\"comment\">// [3]</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>생각보다 간결합니다.</p>\n<p>[1] <code>all</code> 함수는 함수들을 인자로 받습니다. 가변인자(배열)로 함수를 받았습니다.<br>[2] 우선 함수(클로저)를 리턴하는데 이 함수는 이후에 호출될 때 재료가 될 값을 받습니다.<br>[3] <code>go</code>를 실행합니다. 함수들이 담긴 배열을 첫번째 값으로 전달하고 <code>map</code>으로 함수가 실행된 결과를 모아둡니다. 그리고 <a href=\"/programming/javascript-daily-function-14/\">지난 시간</a>에 자매품으로 소개해드린 <code>to_mr</code>으로 배열을 멀티 리턴 값으로 바꿔줍니다.</p>\n"},{"title":"오늘의 함수 - mr","date":"2018-01-27T13:51:05.000Z","description":"mr은 Multiple Return의 약자입니다. 여러개의 값을 리턴하기 위해 사용하는 함수죠.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## mr\n\n오늘은 `mr`이라는 함수를 소개합니다. `mr`은 Multiple Return의 약자입니다. 여러개의 값을 리턴하기 위해 사용하는 함수죠. `go`나 [`pipe`같은 함수](/programming/javascript-daily-function-5/) 안에서 사용합니다. 한번 살펴보겠습니다.\n\n\n#### (1) 어제의 함수\n자바스크립트는 하나의 값만 리턴할 수 있습니다. (Go와 같은 언어에서는 자체적으로 이와 같은 [기능을 지원](https://gobyexample.com/multiple-return-values)합니다.)\n\n```javascript\nfunction sum(a, b, c) {\n  return a + b + c;\n}\nconsole.log(sum(1, 2, 3)); // 6\n// go(1,2,3, sum, console.log); // 불가능\n\nfunction sum_arr(arr) {\n  return arr.reduce((a, b) => a + b);\n}\nconsole.log(sum_arr([1, 2, 3])); // 6\ngo([1,2,3], sum_arr, console.log); // 6\n```\n\n여러개의 값을 인자로 전달해서 함수를 실행하기 위해선 반드시 직접 실행하거나 배열로 값을 전달해서 처리하도록 해야만합니다.\n\n\n#### (2) 오늘의 함수\n이때 `mr`함수가 있으면 문제를 해결할 수 있습니다.\n\n```javascript\ngo(mr(1,2,3), \n  sum, \n  console.log); // 6\n```\n\n`mr`이라고 값들을 감싸서 전달하면 `go`함수가 이 값을 다음 함수에 풀어서 전달합니다. 이와 같은 구조로 인해 기존의 `go`함수를 고쳐줘야합니다.\n\n```javascript\nfunction go() { // 기존의 go\n  return reduce(arguments, function(arg, fn) {\n    return fn(args);\n  })\n}\n\nfunction go() { // Multiple Return을 지원하는 go\n  return reduce(arguments, function(arg, fn) {\n    return arg.__mr ? fn(...arg) : fn(arg);\n  })\n}\n```\n\n달라진 것은 `reduce`에게 전달되는 함수 내부에 삼항연산자로 인자에 `__mr` 프로퍼티가 참이면 인자를 풀어서 전달하고 그렇지 않으면 그대로 전달하도록 해준 것이 전부입니다. 이제 `mr`이 어떤 모습일지 상상이 가지 않나요?\n\n```javascript\nfunction mr() {\n  arguments.__mr = true;\n  return arguments;\n}\n```\n\n단지 `arguments`객체에 `__mr`이라는 프로퍼티를 붙이고 거기에 참 값을 넣어 그대로 리턴한 것뿐입니다. 이와 같은 방법으로 `go`와 `pipe`같은 함수 내에서 여러개의 값을 리턴할 수 있습니다. \n\n```javascript\ngo(10,\n  function(a) {\n    return mr(a, 20, 30);\n  },\n  sum,\n  console.log) // 60\n```\n\n자매품으로 일반 배열을 위한 `to_mr`함수도 있습니다.\n\n```javascript\nfunction to_mr(arr) {\n  return arr.__mr = true, arr;\n}\n\ngo([10, 20, 30],\n  to_mr,\n  sum,\n  console.log) // 60\n```","source":"_posts/daily-fp-14.md","raw":"---\ntitle: '오늘의 함수 - mr'\ndate: 2018-01-27 22:51:05\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: mr은 Multiple Return의 약자입니다. 여러개의 값을 리턴하기 위해 사용하는 함수죠.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## mr\n\n오늘은 `mr`이라는 함수를 소개합니다. `mr`은 Multiple Return의 약자입니다. 여러개의 값을 리턴하기 위해 사용하는 함수죠. `go`나 [`pipe`같은 함수](/programming/javascript-daily-function-5/) 안에서 사용합니다. 한번 살펴보겠습니다.\n\n\n#### (1) 어제의 함수\n자바스크립트는 하나의 값만 리턴할 수 있습니다. (Go와 같은 언어에서는 자체적으로 이와 같은 [기능을 지원](https://gobyexample.com/multiple-return-values)합니다.)\n\n```javascript\nfunction sum(a, b, c) {\n  return a + b + c;\n}\nconsole.log(sum(1, 2, 3)); // 6\n// go(1,2,3, sum, console.log); // 불가능\n\nfunction sum_arr(arr) {\n  return arr.reduce((a, b) => a + b);\n}\nconsole.log(sum_arr([1, 2, 3])); // 6\ngo([1,2,3], sum_arr, console.log); // 6\n```\n\n여러개의 값을 인자로 전달해서 함수를 실행하기 위해선 반드시 직접 실행하거나 배열로 값을 전달해서 처리하도록 해야만합니다.\n\n\n#### (2) 오늘의 함수\n이때 `mr`함수가 있으면 문제를 해결할 수 있습니다.\n\n```javascript\ngo(mr(1,2,3), \n  sum, \n  console.log); // 6\n```\n\n`mr`이라고 값들을 감싸서 전달하면 `go`함수가 이 값을 다음 함수에 풀어서 전달합니다. 이와 같은 구조로 인해 기존의 `go`함수를 고쳐줘야합니다.\n\n```javascript\nfunction go() { // 기존의 go\n  return reduce(arguments, function(arg, fn) {\n    return fn(args);\n  })\n}\n\nfunction go() { // Multiple Return을 지원하는 go\n  return reduce(arguments, function(arg, fn) {\n    return arg.__mr ? fn(...arg) : fn(arg);\n  })\n}\n```\n\n달라진 것은 `reduce`에게 전달되는 함수 내부에 삼항연산자로 인자에 `__mr` 프로퍼티가 참이면 인자를 풀어서 전달하고 그렇지 않으면 그대로 전달하도록 해준 것이 전부입니다. 이제 `mr`이 어떤 모습일지 상상이 가지 않나요?\n\n```javascript\nfunction mr() {\n  arguments.__mr = true;\n  return arguments;\n}\n```\n\n단지 `arguments`객체에 `__mr`이라는 프로퍼티를 붙이고 거기에 참 값을 넣어 그대로 리턴한 것뿐입니다. 이와 같은 방법으로 `go`와 `pipe`같은 함수 내에서 여러개의 값을 리턴할 수 있습니다. \n\n```javascript\ngo(10,\n  function(a) {\n    return mr(a, 20, 30);\n  },\n  sum,\n  console.log) // 60\n```\n\n자매품으로 일반 배열을 위한 `to_mr`함수도 있습니다.\n\n```javascript\nfunction to_mr(arr) {\n  return arr.__mr = true, arr;\n}\n\ngo([10, 20, 30],\n  to_mr,\n  sum,\n  console.log) // 60\n```","slug":"daily-fp-14","published":1,"updated":"2019-12-05T15:06:08.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9fq001vdirv82fq0mh9","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"mr\"><a href=\"#mr\" class=\"headerlink\" title=\"mr\"></a>mr</h2><p>오늘은 <code>mr</code>이라는 함수를 소개합니다. <code>mr</code>은 Multiple Return의 약자입니다. 여러개의 값을 리턴하기 위해 사용하는 함수죠. <code>go</code>나 <a href=\"/programming/javascript-daily-function-5/\"><code>pipe</code>같은 함수</a> 안에서 사용합니다. 한번 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><p>자바스크립트는 하나의 값만 리턴할 수 있습니다. (Go와 같은 언어에서는 자체적으로 이와 같은 <a href=\"https://gobyexample.com/multiple-return-values\" target=\"_blank\" rel=\"noopener\">기능을 지원</a>합니다.)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b + c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)); <span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"comment\">// go(1,2,3, sum, console.log); // 불가능</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum_arr</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum_arr([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])); <span class=\"comment\">// 6</span></span><br><span class=\"line\">go([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>], sum_arr, <span class=\"built_in\">console</span>.log); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<p>여러개의 값을 인자로 전달해서 함수를 실행하기 위해선 반드시 직접 실행하거나 배열로 값을 전달해서 처리하도록 해야만합니다.</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><p>이때 <code>mr</code>함수가 있으면 문제를 해결할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go(mr(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>), </span><br><span class=\"line\">  sum, </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<p><code>mr</code>이라고 값들을 감싸서 전달하면 <code>go</code>함수가 이 값을 다음 함수에 풀어서 전달합니다. 이와 같은 구조로 인해 기존의 <code>go</code>함수를 고쳐줘야합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 기존의 go</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce(<span class=\"built_in\">arguments</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg, fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn(args);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// Multiple Return을 지원하는 go</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce(<span class=\"built_in\">arguments</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg, fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg.__mr ? fn(...arg) : fn(arg);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>달라진 것은 <code>reduce</code>에게 전달되는 함수 내부에 삼항연산자로 인자에 <code>__mr</code> 프로퍼티가 참이면 인자를 풀어서 전달하고 그렇지 않으면 그대로 전달하도록 해준 것이 전부입니다. 이제 <code>mr</code>이 어떤 모습일지 상상이 가지 않나요?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mr</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">arguments</span>.__mr = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>단지 <code>arguments</code>객체에 <code>__mr</code>이라는 프로퍼티를 붙이고 거기에 참 값을 넣어 그대로 리턴한 것뿐입니다. 이와 같은 방법으로 <code>go</code>와 <code>pipe</code>같은 함수 내에서 여러개의 값을 리턴할 수 있습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go(<span class=\"number\">10</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mr(a, <span class=\"number\">20</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  sum,</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log) <span class=\"comment\">// 60</span></span><br></pre></td></tr></table></figure>\n\n<p>자매품으로 일반 배열을 위한 <code>to_mr</code>함수도 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">to_mr</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.__mr = <span class=\"literal\">true</span>, arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">go([<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>],</span><br><span class=\"line\">  to_mr,</span><br><span class=\"line\">  sum,</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log) <span class=\"comment\">// 60</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"mr\"><a href=\"#mr\" class=\"headerlink\" title=\"mr\"></a>mr</h2><p>오늘은 <code>mr</code>이라는 함수를 소개합니다. <code>mr</code>은 Multiple Return의 약자입니다. 여러개의 값을 리턴하기 위해 사용하는 함수죠. <code>go</code>나 <a href=\"/programming/javascript-daily-function-5/\"><code>pipe</code>같은 함수</a> 안에서 사용합니다. 한번 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><p>자바스크립트는 하나의 값만 리턴할 수 있습니다. (Go와 같은 언어에서는 자체적으로 이와 같은 <a href=\"https://gobyexample.com/multiple-return-values\" target=\"_blank\" rel=\"noopener\">기능을 지원</a>합니다.)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b + c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)); <span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"comment\">// go(1,2,3, sum, console.log); // 불가능</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum_arr</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum_arr([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])); <span class=\"comment\">// 6</span></span><br><span class=\"line\">go([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>], sum_arr, <span class=\"built_in\">console</span>.log); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<p>여러개의 값을 인자로 전달해서 함수를 실행하기 위해선 반드시 직접 실행하거나 배열로 값을 전달해서 처리하도록 해야만합니다.</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><p>이때 <code>mr</code>함수가 있으면 문제를 해결할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go(mr(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>), </span><br><span class=\"line\">  sum, </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<p><code>mr</code>이라고 값들을 감싸서 전달하면 <code>go</code>함수가 이 값을 다음 함수에 풀어서 전달합니다. 이와 같은 구조로 인해 기존의 <code>go</code>함수를 고쳐줘야합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 기존의 go</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce(<span class=\"built_in\">arguments</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg, fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn(args);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// Multiple Return을 지원하는 go</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce(<span class=\"built_in\">arguments</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg, fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg.__mr ? fn(...arg) : fn(arg);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>달라진 것은 <code>reduce</code>에게 전달되는 함수 내부에 삼항연산자로 인자에 <code>__mr</code> 프로퍼티가 참이면 인자를 풀어서 전달하고 그렇지 않으면 그대로 전달하도록 해준 것이 전부입니다. 이제 <code>mr</code>이 어떤 모습일지 상상이 가지 않나요?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mr</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">arguments</span>.__mr = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>단지 <code>arguments</code>객체에 <code>__mr</code>이라는 프로퍼티를 붙이고 거기에 참 값을 넣어 그대로 리턴한 것뿐입니다. 이와 같은 방법으로 <code>go</code>와 <code>pipe</code>같은 함수 내에서 여러개의 값을 리턴할 수 있습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go(<span class=\"number\">10</span>,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mr(a, <span class=\"number\">20</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  sum,</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log) <span class=\"comment\">// 60</span></span><br></pre></td></tr></table></figure>\n\n<p>자매품으로 일반 배열을 위한 <code>to_mr</code>함수도 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">to_mr</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.__mr = <span class=\"literal\">true</span>, arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">go([<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>],</span><br><span class=\"line\">  to_mr,</span><br><span class=\"line\">  sum,</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log) <span class=\"comment\">// 60</span></span><br></pre></td></tr></table></figure>"},{"title":"오늘의 함수 - memoize","date":"2018-02-12T13:56:22.000Z","description":"메모이제이션(memoization)이라는 기술을 구현한 함수 memoize를 소개합니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## memoize\n\n오늘은 `memoize` 함수를 소개합니다. 이 함수는 '메모이즈' 함수라고 읽는데 이는 메모이제이션(memoization)이라는 기술을 구현한 함수이기 때문입니다. 기술을 구현했다고 표현하니 어렵게 보이기도 하고 멋져보입니다. 여기서 말하는 기술이라고 표현한 메모이제이션을 [위키피디아](https://ko.wikipedia.org/wiki/메모이제이션)에서는 __컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술__이라고 설명합니다. 어떤 경우를 말하는 것이고 또 어떻게 구현하는지 살펴보겠습니다.\n\n#### (1) 어제의 함수\n\n```javascript\nconst arr1 = [1,2,3,4,5], arr2 = [6,7,8,9,10];\nfunction sum(arr) { \n  console.log(\"SUM!\")\n  return arr.reduce((sum, num) => sum + num); \n}\n\nconsole.log(sum(arr1)); // \"SUM!\" 15\nconsole.log(sum(arr2)); // \"SUM!\" 40\n```\n\n`sum`은 배열을 받아서 값을 모두 더하는 함수입니다. 내부에는 로그 함수가 있어서 결과를 리턴하기 전에 \"SUM!\"이라는 문자열을 출력합니다. 이 문자열은 실제로 `sum` 함수가 호출되었는지 확인해주는 역할을 합니다.\n\n```javascript\nconsole.log(sum(arr1)); // \"SUM!\" 15\nconsole.log(sum(arr2)); // \"SUM!\" 40\n\nconsole.log(sum(arr1)); // \"SUM!\" 15\nconsole.log(sum(arr2)); // \"SUM!\" 40\n\nconsole.log(sum(arr1)); // \"SUM!\" 15\nconsole.log(sum(arr2)); // \"SUM!\" 40\n```\n\n이미 실행 결과를 알고 있는 `arr1`, `arr2`를 몇번씩 넣어도 \"SUM!\"은 출력됩니다. 이 지점이 위키피디아에서 정의한 __'컴퓨터 프로그램이 동일한 계산을 반복해야 할 때'__입니다.\n\n\n#### (2) 오늘의 함수\n이제 __'이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거'__하는 작업을 해보겠습니다. 우선 메모리에 계산한 값을 저장해야겠지요.\n\n```javascript\nvar cache = {}; // [1] 계산된 값을 저장해둘 객체(캐시)\nfunction sum2(arr) { \n  if (cache[arr]) return cache[arr]; // [2] 저장된 값이 있으면 저장된 값을 리턴한다.\n  console.log(\"SUM!\");\n  return cache[arr] = arr.reduce((sum, num) => sum + num); // [3] 없다면 값을 저장하고 결과를 리턴한다.\n}\n\nconsole.log(sum2(arr1)); // \"SUM!\" 15\nconsole.log(sum2(arr2)); // \"SUM!\" 40\n\nconsole.log(sum2(arr1)); // 15\nconsole.log(sum2(arr2)); // 40\n```\n\n개선된 `sum2` 함수는 `cache`라고 이름 붙여진 객체에 계산된 값을 저장함으로써 동일한 계산을 반복하지 않도록 했습니다. 덕분에 같은 값을 넣어 함수를 실행하니 \"SUM!\"이 출력되지 않게 되었습니다. __'반복 수행을 제거'__하는 목적을 달성했지만 `cache`의 선언 방식이나 `sum2`의 구현이 그리 근사하지 않습니다. 이제 `memoize`를 사용해보겠습니다. \n\n```javascript\nvar sum = memoize(function(arr) { \n  console.log(\"SUM!\")\n  return arr.reduce((sum, num) => sum + num); \n}, function(key) { return key; });\n\nconsole.log(sum(arr1)); // \"SUM!\" 15\nconsole.log(sum(arr2)); // \"SUM!\" 40\n\nconsole.log(sum(arr1)); // 15\nconsole.log(sum(arr2)); // 40\n```\n\n우리가 원하는 모습입니다. `sum`의 구현인 익명 함수를 `memoize`로 한번 실행시켜 만든 `sum`은 `sum2`와 같이 반복되는 작업을 하지 않습니다. 더군다나 `cache`를 선언하지도 않았습니다. 그럼 어떻게 계산된 값을 저장할까요? 이제 `memoize`의 구현을 살펴볼 시간이네요.\n\n```javascript\nfunction memoize(func, hasher) { // [1]\n  function f(...args) { // [2]\n    var key = hasher(...args); // [3]\n    if (f.cache[key]) return f.cache[key]; // [4]\n    return f.cache[key] = func(...args);\n  }\n  f.cache = {}; // [5]\n  return f;\n}\n```\n\n짧은 코드지만 알찬 코드입니다. 한줄씩 살펴보겠습니다. \n[1] `memoize`는 두개의 함수를 인자로 받습니다. 실제 로직을 담고 있는 `func`와 메모리의 키 값을 만들어낼 `hasher`가 있습니다. \n[2] `f`라고 정의된 함수는 이 함수의 최종 리턴 값입니다. 여기서 받는 `...args`는 `sum`의 경우를 놓고보자면 `arr1`가 됩니다.\n[3] `hasher`는 `f`가 받은 값을 그대로 사용해서 `key`에 해당하는 값을 만들어냅니다. 이 값은 들어온 `args`에 따라 달라지겠죠. 이를 완전히 유니크한 키로 만드는 것은 `hasher` 함수를 잘 정의하는데 달려있습니다.\n[4] 만약에 캐시(`f.cache`)에 이미 저장된 값이 있으면 저장된 값을 리턴합니다. 그렇지 않으면 `func`의 실행 결과를 저장하고 그 값을 리턴합니다.\n[5] 캐시는 함수에 붙어서 리턴됩니다. 앞선 예제의 경우를 생각하면 `sum`에 붙어 있게됩니다. 때문에 원한다면 캐시를 비울 수도 있게 됩니다.\n\n짧은 코드에 적은 데이터를 사용하는 함수이기 때문에 예제만으로 __'프로그램 실행 속도를 빠르게'__했다고 보긴 어렵습니다. 하지만 같은 방식으로 더 큰 데이터를 다루는 코드에서 사용한다면 그 차이를 확연하게 느끼실 수 있습니다.\n","source":"_posts/daily-fp-16.md","raw":"---\ntitle: '오늘의 함수 - memoize'\ndate: 2018-02-12 22:56:22\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: 메모이제이션(memoization)이라는 기술을 구현한 함수 memoize를 소개합니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## memoize\n\n오늘은 `memoize` 함수를 소개합니다. 이 함수는 '메모이즈' 함수라고 읽는데 이는 메모이제이션(memoization)이라는 기술을 구현한 함수이기 때문입니다. 기술을 구현했다고 표현하니 어렵게 보이기도 하고 멋져보입니다. 여기서 말하는 기술이라고 표현한 메모이제이션을 [위키피디아](https://ko.wikipedia.org/wiki/메모이제이션)에서는 __컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술__이라고 설명합니다. 어떤 경우를 말하는 것이고 또 어떻게 구현하는지 살펴보겠습니다.\n\n#### (1) 어제의 함수\n\n```javascript\nconst arr1 = [1,2,3,4,5], arr2 = [6,7,8,9,10];\nfunction sum(arr) { \n  console.log(\"SUM!\")\n  return arr.reduce((sum, num) => sum + num); \n}\n\nconsole.log(sum(arr1)); // \"SUM!\" 15\nconsole.log(sum(arr2)); // \"SUM!\" 40\n```\n\n`sum`은 배열을 받아서 값을 모두 더하는 함수입니다. 내부에는 로그 함수가 있어서 결과를 리턴하기 전에 \"SUM!\"이라는 문자열을 출력합니다. 이 문자열은 실제로 `sum` 함수가 호출되었는지 확인해주는 역할을 합니다.\n\n```javascript\nconsole.log(sum(arr1)); // \"SUM!\" 15\nconsole.log(sum(arr2)); // \"SUM!\" 40\n\nconsole.log(sum(arr1)); // \"SUM!\" 15\nconsole.log(sum(arr2)); // \"SUM!\" 40\n\nconsole.log(sum(arr1)); // \"SUM!\" 15\nconsole.log(sum(arr2)); // \"SUM!\" 40\n```\n\n이미 실행 결과를 알고 있는 `arr1`, `arr2`를 몇번씩 넣어도 \"SUM!\"은 출력됩니다. 이 지점이 위키피디아에서 정의한 __'컴퓨터 프로그램이 동일한 계산을 반복해야 할 때'__입니다.\n\n\n#### (2) 오늘의 함수\n이제 __'이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거'__하는 작업을 해보겠습니다. 우선 메모리에 계산한 값을 저장해야겠지요.\n\n```javascript\nvar cache = {}; // [1] 계산된 값을 저장해둘 객체(캐시)\nfunction sum2(arr) { \n  if (cache[arr]) return cache[arr]; // [2] 저장된 값이 있으면 저장된 값을 리턴한다.\n  console.log(\"SUM!\");\n  return cache[arr] = arr.reduce((sum, num) => sum + num); // [3] 없다면 값을 저장하고 결과를 리턴한다.\n}\n\nconsole.log(sum2(arr1)); // \"SUM!\" 15\nconsole.log(sum2(arr2)); // \"SUM!\" 40\n\nconsole.log(sum2(arr1)); // 15\nconsole.log(sum2(arr2)); // 40\n```\n\n개선된 `sum2` 함수는 `cache`라고 이름 붙여진 객체에 계산된 값을 저장함으로써 동일한 계산을 반복하지 않도록 했습니다. 덕분에 같은 값을 넣어 함수를 실행하니 \"SUM!\"이 출력되지 않게 되었습니다. __'반복 수행을 제거'__하는 목적을 달성했지만 `cache`의 선언 방식이나 `sum2`의 구현이 그리 근사하지 않습니다. 이제 `memoize`를 사용해보겠습니다. \n\n```javascript\nvar sum = memoize(function(arr) { \n  console.log(\"SUM!\")\n  return arr.reduce((sum, num) => sum + num); \n}, function(key) { return key; });\n\nconsole.log(sum(arr1)); // \"SUM!\" 15\nconsole.log(sum(arr2)); // \"SUM!\" 40\n\nconsole.log(sum(arr1)); // 15\nconsole.log(sum(arr2)); // 40\n```\n\n우리가 원하는 모습입니다. `sum`의 구현인 익명 함수를 `memoize`로 한번 실행시켜 만든 `sum`은 `sum2`와 같이 반복되는 작업을 하지 않습니다. 더군다나 `cache`를 선언하지도 않았습니다. 그럼 어떻게 계산된 값을 저장할까요? 이제 `memoize`의 구현을 살펴볼 시간이네요.\n\n```javascript\nfunction memoize(func, hasher) { // [1]\n  function f(...args) { // [2]\n    var key = hasher(...args); // [3]\n    if (f.cache[key]) return f.cache[key]; // [4]\n    return f.cache[key] = func(...args);\n  }\n  f.cache = {}; // [5]\n  return f;\n}\n```\n\n짧은 코드지만 알찬 코드입니다. 한줄씩 살펴보겠습니다. \n[1] `memoize`는 두개의 함수를 인자로 받습니다. 실제 로직을 담고 있는 `func`와 메모리의 키 값을 만들어낼 `hasher`가 있습니다. \n[2] `f`라고 정의된 함수는 이 함수의 최종 리턴 값입니다. 여기서 받는 `...args`는 `sum`의 경우를 놓고보자면 `arr1`가 됩니다.\n[3] `hasher`는 `f`가 받은 값을 그대로 사용해서 `key`에 해당하는 값을 만들어냅니다. 이 값은 들어온 `args`에 따라 달라지겠죠. 이를 완전히 유니크한 키로 만드는 것은 `hasher` 함수를 잘 정의하는데 달려있습니다.\n[4] 만약에 캐시(`f.cache`)에 이미 저장된 값이 있으면 저장된 값을 리턴합니다. 그렇지 않으면 `func`의 실행 결과를 저장하고 그 값을 리턴합니다.\n[5] 캐시는 함수에 붙어서 리턴됩니다. 앞선 예제의 경우를 생각하면 `sum`에 붙어 있게됩니다. 때문에 원한다면 캐시를 비울 수도 있게 됩니다.\n\n짧은 코드에 적은 데이터를 사용하는 함수이기 때문에 예제만으로 __'프로그램 실행 속도를 빠르게'__했다고 보긴 어렵습니다. 하지만 같은 방식으로 더 큰 데이터를 다루는 코드에서 사용한다면 그 차이를 확연하게 느끼실 수 있습니다.\n","slug":"daily-fp-16","published":1,"updated":"2019-12-05T15:06:08.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9fw001zdirv57kp94db","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"memoize\"><a href=\"#memoize\" class=\"headerlink\" title=\"memoize\"></a>memoize</h2><p>오늘은 <code>memoize</code> 함수를 소개합니다. 이 함수는 ‘메모이즈’ 함수라고 읽는데 이는 메모이제이션(memoization)이라는 기술을 구현한 함수이기 때문입니다. 기술을 구현했다고 표현하니 어렵게 보이기도 하고 멋져보입니다. 여기서 말하는 기술이라고 표현한 메모이제이션을 <a href=\"https://ko.wikipedia.org/wiki/메모이제이션\" target=\"_blank\" rel=\"noopener\">위키피디아</a>에서는 <strong>컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술</strong>이라고 설명합니다. 어떤 경우를 말하는 것이고 또 어떻게 구현하는지 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>], arr2 = [<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">arr</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"SUM!\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">sum, num</span>) =&gt;</span> sum + num); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr1)); <span class=\"comment\">// \"SUM!\" 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr2)); <span class=\"comment\">// \"SUM!\" 40</span></span><br></pre></td></tr></table></figure>\n\n<p><code>sum</code>은 배열을 받아서 값을 모두 더하는 함수입니다. 내부에는 로그 함수가 있어서 결과를 리턴하기 전에 “SUM!”이라는 문자열을 출력합니다. 이 문자열은 실제로 <code>sum</code> 함수가 호출되었는지 확인해주는 역할을 합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr1)); <span class=\"comment\">// \"SUM!\" 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr2)); <span class=\"comment\">// \"SUM!\" 40</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr1)); <span class=\"comment\">// \"SUM!\" 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr2)); <span class=\"comment\">// \"SUM!\" 40</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr1)); <span class=\"comment\">// \"SUM!\" 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr2)); <span class=\"comment\">// \"SUM!\" 40</span></span><br></pre></td></tr></table></figure>\n\n<p>이미 실행 결과를 알고 있는 <code>arr1</code>, <code>arr2</code>를 몇번씩 넣어도 “SUM!”은 출력됩니다. 이 지점이 위키피디아에서 정의한 <strong>‘컴퓨터 프로그램이 동일한 계산을 반복해야 할 때’</strong>입니다.</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><p>이제 <strong>‘이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거’</strong>하는 작업을 해보겠습니다. 우선 메모리에 계산한 값을 저장해야겠지요.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cache = &#123;&#125;; <span class=\"comment\">// [1] 계산된 값을 저장해둘 객체(캐시)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum2</span>(<span class=\"params\">arr</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cache[arr]) <span class=\"keyword\">return</span> cache[arr]; <span class=\"comment\">// [2] 저장된 값이 있으면 저장된 값을 리턴한다.</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"SUM!\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> cache[arr] = arr.reduce(<span class=\"function\">(<span class=\"params\">sum, num</span>) =&gt;</span> sum + num); <span class=\"comment\">// [3] 없다면 값을 저장하고 결과를 리턴한다.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum2(arr1)); <span class=\"comment\">// \"SUM!\" 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum2(arr2)); <span class=\"comment\">// \"SUM!\" 40</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum2(arr1)); <span class=\"comment\">// 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum2(arr2)); <span class=\"comment\">// 40</span></span><br></pre></td></tr></table></figure>\n\n<p>개선된 <code>sum2</code> 함수는 <code>cache</code>라고 이름 붙여진 객체에 계산된 값을 저장함으로써 동일한 계산을 반복하지 않도록 했습니다. 덕분에 같은 값을 넣어 함수를 실행하니 “SUM!”이 출력되지 않게 되었습니다. <strong>‘반복 수행을 제거’</strong>하는 목적을 달성했지만 <code>cache</code>의 선언 방식이나 <code>sum2</code>의 구현이 그리 근사하지 않습니다. 이제 <code>memoize</code>를 사용해보겠습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = memoize(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"SUM!\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">sum, num</span>) =&gt;</span> sum + num); </span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123; <span class=\"keyword\">return</span> key; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr1)); <span class=\"comment\">// \"SUM!\" 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr2)); <span class=\"comment\">// \"SUM!\" 40</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr1)); <span class=\"comment\">// 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr2)); <span class=\"comment\">// 40</span></span><br></pre></td></tr></table></figure>\n\n<p>우리가 원하는 모습입니다. <code>sum</code>의 구현인 익명 함수를 <code>memoize</code>로 한번 실행시켜 만든 <code>sum</code>은 <code>sum2</code>와 같이 반복되는 작업을 하지 않습니다. 더군다나 <code>cache</code>를 선언하지도 않았습니다. 그럼 어떻게 계산된 값을 저장할까요? 이제 <code>memoize</code>의 구현을 살펴볼 시간이네요.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">memoize</span>(<span class=\"params\">func, hasher</span>) </span>&#123; <span class=\"comment\">// [1]</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">...args</span>) </span>&#123; <span class=\"comment\">// [2]</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> key = hasher(...args); <span class=\"comment\">// [3]</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f.cache[key]) <span class=\"keyword\">return</span> f.cache[key]; <span class=\"comment\">// [4]</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> f.cache[key] = func(...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  f.cache = &#123;&#125;; <span class=\"comment\">// [5]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>짧은 코드지만 알찬 코드입니다. 한줄씩 살펴보겠습니다.<br>[1] <code>memoize</code>는 두개의 함수를 인자로 받습니다. 실제 로직을 담고 있는 <code>func</code>와 메모리의 키 값을 만들어낼 <code>hasher</code>가 있습니다.<br>[2] <code>f</code>라고 정의된 함수는 이 함수의 최종 리턴 값입니다. 여기서 받는 <code>...args</code>는 <code>sum</code>의 경우를 놓고보자면 <code>arr1</code>가 됩니다.<br>[3] <code>hasher</code>는 <code>f</code>가 받은 값을 그대로 사용해서 <code>key</code>에 해당하는 값을 만들어냅니다. 이 값은 들어온 <code>args</code>에 따라 달라지겠죠. 이를 완전히 유니크한 키로 만드는 것은 <code>hasher</code> 함수를 잘 정의하는데 달려있습니다.<br>[4] 만약에 캐시(<code>f.cache</code>)에 이미 저장된 값이 있으면 저장된 값을 리턴합니다. 그렇지 않으면 <code>func</code>의 실행 결과를 저장하고 그 값을 리턴합니다.<br>[5] 캐시는 함수에 붙어서 리턴됩니다. 앞선 예제의 경우를 생각하면 <code>sum</code>에 붙어 있게됩니다. 때문에 원한다면 캐시를 비울 수도 있게 됩니다.</p>\n<p>짧은 코드에 적은 데이터를 사용하는 함수이기 때문에 예제만으로 <strong>‘프로그램 실행 속도를 빠르게’</strong>했다고 보긴 어렵습니다. 하지만 같은 방식으로 더 큰 데이터를 다루는 코드에서 사용한다면 그 차이를 확연하게 느끼실 수 있습니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"memoize\"><a href=\"#memoize\" class=\"headerlink\" title=\"memoize\"></a>memoize</h2><p>오늘은 <code>memoize</code> 함수를 소개합니다. 이 함수는 ‘메모이즈’ 함수라고 읽는데 이는 메모이제이션(memoization)이라는 기술을 구현한 함수이기 때문입니다. 기술을 구현했다고 표현하니 어렵게 보이기도 하고 멋져보입니다. 여기서 말하는 기술이라고 표현한 메모이제이션을 <a href=\"https://ko.wikipedia.org/wiki/메모이제이션\" target=\"_blank\" rel=\"noopener\">위키피디아</a>에서는 <strong>컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술</strong>이라고 설명합니다. 어떤 경우를 말하는 것이고 또 어떻게 구현하는지 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>], arr2 = [<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">arr</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"SUM!\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">sum, num</span>) =&gt;</span> sum + num); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr1)); <span class=\"comment\">// \"SUM!\" 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr2)); <span class=\"comment\">// \"SUM!\" 40</span></span><br></pre></td></tr></table></figure>\n\n<p><code>sum</code>은 배열을 받아서 값을 모두 더하는 함수입니다. 내부에는 로그 함수가 있어서 결과를 리턴하기 전에 “SUM!”이라는 문자열을 출력합니다. 이 문자열은 실제로 <code>sum</code> 함수가 호출되었는지 확인해주는 역할을 합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr1)); <span class=\"comment\">// \"SUM!\" 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr2)); <span class=\"comment\">// \"SUM!\" 40</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr1)); <span class=\"comment\">// \"SUM!\" 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr2)); <span class=\"comment\">// \"SUM!\" 40</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr1)); <span class=\"comment\">// \"SUM!\" 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr2)); <span class=\"comment\">// \"SUM!\" 40</span></span><br></pre></td></tr></table></figure>\n\n<p>이미 실행 결과를 알고 있는 <code>arr1</code>, <code>arr2</code>를 몇번씩 넣어도 “SUM!”은 출력됩니다. 이 지점이 위키피디아에서 정의한 <strong>‘컴퓨터 프로그램이 동일한 계산을 반복해야 할 때’</strong>입니다.</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><p>이제 <strong>‘이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거’</strong>하는 작업을 해보겠습니다. 우선 메모리에 계산한 값을 저장해야겠지요.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cache = &#123;&#125;; <span class=\"comment\">// [1] 계산된 값을 저장해둘 객체(캐시)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum2</span>(<span class=\"params\">arr</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cache[arr]) <span class=\"keyword\">return</span> cache[arr]; <span class=\"comment\">// [2] 저장된 값이 있으면 저장된 값을 리턴한다.</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"SUM!\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> cache[arr] = arr.reduce(<span class=\"function\">(<span class=\"params\">sum, num</span>) =&gt;</span> sum + num); <span class=\"comment\">// [3] 없다면 값을 저장하고 결과를 리턴한다.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum2(arr1)); <span class=\"comment\">// \"SUM!\" 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum2(arr2)); <span class=\"comment\">// \"SUM!\" 40</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum2(arr1)); <span class=\"comment\">// 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum2(arr2)); <span class=\"comment\">// 40</span></span><br></pre></td></tr></table></figure>\n\n<p>개선된 <code>sum2</code> 함수는 <code>cache</code>라고 이름 붙여진 객체에 계산된 값을 저장함으로써 동일한 계산을 반복하지 않도록 했습니다. 덕분에 같은 값을 넣어 함수를 실행하니 “SUM!”이 출력되지 않게 되었습니다. <strong>‘반복 수행을 제거’</strong>하는 목적을 달성했지만 <code>cache</code>의 선언 방식이나 <code>sum2</code>의 구현이 그리 근사하지 않습니다. 이제 <code>memoize</code>를 사용해보겠습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = memoize(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"SUM!\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">sum, num</span>) =&gt;</span> sum + num); </span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123; <span class=\"keyword\">return</span> key; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr1)); <span class=\"comment\">// \"SUM!\" 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr2)); <span class=\"comment\">// \"SUM!\" 40</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr1)); <span class=\"comment\">// 15</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr2)); <span class=\"comment\">// 40</span></span><br></pre></td></tr></table></figure>\n\n<p>우리가 원하는 모습입니다. <code>sum</code>의 구현인 익명 함수를 <code>memoize</code>로 한번 실행시켜 만든 <code>sum</code>은 <code>sum2</code>와 같이 반복되는 작업을 하지 않습니다. 더군다나 <code>cache</code>를 선언하지도 않았습니다. 그럼 어떻게 계산된 값을 저장할까요? 이제 <code>memoize</code>의 구현을 살펴볼 시간이네요.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">memoize</span>(<span class=\"params\">func, hasher</span>) </span>&#123; <span class=\"comment\">// [1]</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">...args</span>) </span>&#123; <span class=\"comment\">// [2]</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> key = hasher(...args); <span class=\"comment\">// [3]</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (f.cache[key]) <span class=\"keyword\">return</span> f.cache[key]; <span class=\"comment\">// [4]</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> f.cache[key] = func(...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  f.cache = &#123;&#125;; <span class=\"comment\">// [5]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>짧은 코드지만 알찬 코드입니다. 한줄씩 살펴보겠습니다.<br>[1] <code>memoize</code>는 두개의 함수를 인자로 받습니다. 실제 로직을 담고 있는 <code>func</code>와 메모리의 키 값을 만들어낼 <code>hasher</code>가 있습니다.<br>[2] <code>f</code>라고 정의된 함수는 이 함수의 최종 리턴 값입니다. 여기서 받는 <code>...args</code>는 <code>sum</code>의 경우를 놓고보자면 <code>arr1</code>가 됩니다.<br>[3] <code>hasher</code>는 <code>f</code>가 받은 값을 그대로 사용해서 <code>key</code>에 해당하는 값을 만들어냅니다. 이 값은 들어온 <code>args</code>에 따라 달라지겠죠. 이를 완전히 유니크한 키로 만드는 것은 <code>hasher</code> 함수를 잘 정의하는데 달려있습니다.<br>[4] 만약에 캐시(<code>f.cache</code>)에 이미 저장된 값이 있으면 저장된 값을 리턴합니다. 그렇지 않으면 <code>func</code>의 실행 결과를 저장하고 그 값을 리턴합니다.<br>[5] 캐시는 함수에 붙어서 리턴됩니다. 앞선 예제의 경우를 생각하면 <code>sum</code>에 붙어 있게됩니다. 때문에 원한다면 캐시를 비울 수도 있게 됩니다.</p>\n<p>짧은 코드에 적은 데이터를 사용하는 함수이기 때문에 예제만으로 <strong>‘프로그램 실행 속도를 빠르게’</strong>했다고 보긴 어렵습니다. 하지만 같은 방식으로 더 큰 데이터를 다루는 코드에서 사용한다면 그 차이를 확연하게 느끼실 수 있습니다.</p>\n"},{"title":"오늘의 함수 - is_enter","date":"2018-01-21T02:02:13.000Z","description":"_.if2 함수를 응용한 함수를 소개할까 합니다. 일명 is_enter 함수입니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## is_enter\n\n오늘은 [지난 시간](/programming/javascript-daily-function-12/)에 다룬 `_.if2` 함수를 응용한 함수를 소개할까 합니다. 일명 `is_enter` 함수입니다. 우리는 종종 이벤트 리스너에서 `keyCode` 값을 검사해서 특정 동작을 수행하곤 합니다. 특히 Enter 키에 해당하는 13이 입력되면 검색을 수행한다던지 하는 일을 자주 하죠. `is_enter`는 이 경우에 유용한 함수입니다. \n\n\n#### (1) 어제의 함수\n오늘의 예제는 너무 간단합니다. 키다운 이벤트에 해당하는 이벤트 리스너를 정의합니다. 이때 엔터키가 입력되면 특정한 동작을 수행하도록 분기를 만들어야합니다.\n\n```javascript\n$input_element.addEventListener('keydown', function(e) {\n  if (e.keyCode === 13) {\n    action(); // 검색을 하거나 DOM을 제어하는 등 원하는 동작을 정의합니다.\n  }\n})\n```\n\n별거 아닌 이 상황, `if`가 눈에 띕니다. [지난 시간](/programming/javascript-daily-function-12/)에 만들어둔 `_.if2` 함수를 사용할 수 있을 것 같습니다.\n\n\n#### (2) 오늘의 함수\n\n```javascript\n$input_element.addEventListener('keydown', is_enter(function(e) {\n  action(); // 검색을 하거나 DOM을 제어하는 등 원하는 동작을 정의합니다.\n}))\n```\n\n`is_enter` 함수는 함수를 반환하는 함수입니다. 만약에 `keyCode`가 13과 같다면 인자로 받은 함수를 실행시킬 준비가 된 함수를 만듭니다. 어떻게 구현되었는지를 보면 이해가 쉽습니다. \n\n```javascript\nvar is_enter = function(...fns) { // [1]\n  return _.if2(function(e) { return e.keyCode === 13 })(...fns); // [2]\n};\n```\n\n`_.if2` 함수는 총 세차례 실행됩니다. __첫번째 실행에서는 조건을 받고, 두번째 실행에서는 해야할 일을 받습니다. 마지막 실행에서 판단할 데이터를 받습니다.__ 이와 같은 맥락으로 이해하자면 [2]의 `_.if2`는 두번까지만 실행된 상황입니다. 조건을 정의하고 있고 어떤 일을 할지를 받았습니다. 여기서 어떤 일을 정의하는 함수가 여러개임을 알 수 있습니다. [1]에서 스프레드 연산자 (혹은 전개 연산자)를 사용해서 배열로 이루어진 함수 목록 `fns`를 받았습니다. 이를 `_.if2` 함수의 두번째 실행에서 스프레드 연산자로 실행시켰습니다. (기억하시는 것처럼 `_.if2`는 조건과 실행부에서 `_.pipe` 함수를 사용합니다.) 마지막 실행을 남겨둔 채로 `_.if2`는 반환됩니다. 이 상황을 기억하고 다시 위의 예제를 살펴보겠습니다.\n\n\n```javascript\n$input_element.addEventListener('keydown', is_enter(function(e) { // [1]\n  action();\n}))\n```\n\n[1]에서 `is_enter`가 실행되면서 `fns`가 정의됐습니다. 그리고 이제 세번째 실행을 남겨둔 `_.if2` 함수가 그 자리를 대신하고 있는 셈입니다. 세번째로 실행될 때 비로소 판단할 데이터를 받고 미리 가지고 있던 조건부 함수와 해야할 함수 목록인 `fns`를 이용해서 조건이 맞으면(`keyCode`가 13이라면) 계획된 동작을 수행합니다. (여기서 '미리 가지고 있던'이 가능한 이유는 이 함수가 클로저이기 때문입니다.) 근사하죠?\n\n---\n\n#### (3) 이런 함수는 어때요? `key_code`\n\n`is_enter`만 있으니 다른 키보드들이 서운하지 않을까요? 러시아 같은 영토를 자랑하는 스페이스바와 esc 같은 키보드를 위한 함수도 만들어줄 수 있을 것 같습니다. `key_code`라는 함수가 있다면 이 모든 키보드를 위한 함수를 만들어줄 수 있겠네요.\n\n```javascript\nfunction key_code(num) {\n  return function(...fns) {\n    return _.if2(function(e) { return e.keyCode === num })(...fns);\n  }\n}\n\nvar is_enter = key_code(13);\nvar is_space_bar = key_code(32);\nvar is_tab = key_code(9);\nvar is_esc = key_code(27);\n```","source":"_posts/daily-fp-13.md","raw":"---\ntitle: '오늘의 함수 - is_enter'\ndate: 2018-01-21 11:02:13\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: _.if2 함수를 응용한 함수를 소개할까 합니다. 일명 is_enter 함수입니다. \n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## is_enter\n\n오늘은 [지난 시간](/programming/javascript-daily-function-12/)에 다룬 `_.if2` 함수를 응용한 함수를 소개할까 합니다. 일명 `is_enter` 함수입니다. 우리는 종종 이벤트 리스너에서 `keyCode` 값을 검사해서 특정 동작을 수행하곤 합니다. 특히 Enter 키에 해당하는 13이 입력되면 검색을 수행한다던지 하는 일을 자주 하죠. `is_enter`는 이 경우에 유용한 함수입니다. \n\n\n#### (1) 어제의 함수\n오늘의 예제는 너무 간단합니다. 키다운 이벤트에 해당하는 이벤트 리스너를 정의합니다. 이때 엔터키가 입력되면 특정한 동작을 수행하도록 분기를 만들어야합니다.\n\n```javascript\n$input_element.addEventListener('keydown', function(e) {\n  if (e.keyCode === 13) {\n    action(); // 검색을 하거나 DOM을 제어하는 등 원하는 동작을 정의합니다.\n  }\n})\n```\n\n별거 아닌 이 상황, `if`가 눈에 띕니다. [지난 시간](/programming/javascript-daily-function-12/)에 만들어둔 `_.if2` 함수를 사용할 수 있을 것 같습니다.\n\n\n#### (2) 오늘의 함수\n\n```javascript\n$input_element.addEventListener('keydown', is_enter(function(e) {\n  action(); // 검색을 하거나 DOM을 제어하는 등 원하는 동작을 정의합니다.\n}))\n```\n\n`is_enter` 함수는 함수를 반환하는 함수입니다. 만약에 `keyCode`가 13과 같다면 인자로 받은 함수를 실행시킬 준비가 된 함수를 만듭니다. 어떻게 구현되었는지를 보면 이해가 쉽습니다. \n\n```javascript\nvar is_enter = function(...fns) { // [1]\n  return _.if2(function(e) { return e.keyCode === 13 })(...fns); // [2]\n};\n```\n\n`_.if2` 함수는 총 세차례 실행됩니다. __첫번째 실행에서는 조건을 받고, 두번째 실행에서는 해야할 일을 받습니다. 마지막 실행에서 판단할 데이터를 받습니다.__ 이와 같은 맥락으로 이해하자면 [2]의 `_.if2`는 두번까지만 실행된 상황입니다. 조건을 정의하고 있고 어떤 일을 할지를 받았습니다. 여기서 어떤 일을 정의하는 함수가 여러개임을 알 수 있습니다. [1]에서 스프레드 연산자 (혹은 전개 연산자)를 사용해서 배열로 이루어진 함수 목록 `fns`를 받았습니다. 이를 `_.if2` 함수의 두번째 실행에서 스프레드 연산자로 실행시켰습니다. (기억하시는 것처럼 `_.if2`는 조건과 실행부에서 `_.pipe` 함수를 사용합니다.) 마지막 실행을 남겨둔 채로 `_.if2`는 반환됩니다. 이 상황을 기억하고 다시 위의 예제를 살펴보겠습니다.\n\n\n```javascript\n$input_element.addEventListener('keydown', is_enter(function(e) { // [1]\n  action();\n}))\n```\n\n[1]에서 `is_enter`가 실행되면서 `fns`가 정의됐습니다. 그리고 이제 세번째 실행을 남겨둔 `_.if2` 함수가 그 자리를 대신하고 있는 셈입니다. 세번째로 실행될 때 비로소 판단할 데이터를 받고 미리 가지고 있던 조건부 함수와 해야할 함수 목록인 `fns`를 이용해서 조건이 맞으면(`keyCode`가 13이라면) 계획된 동작을 수행합니다. (여기서 '미리 가지고 있던'이 가능한 이유는 이 함수가 클로저이기 때문입니다.) 근사하죠?\n\n---\n\n#### (3) 이런 함수는 어때요? `key_code`\n\n`is_enter`만 있으니 다른 키보드들이 서운하지 않을까요? 러시아 같은 영토를 자랑하는 스페이스바와 esc 같은 키보드를 위한 함수도 만들어줄 수 있을 것 같습니다. `key_code`라는 함수가 있다면 이 모든 키보드를 위한 함수를 만들어줄 수 있겠네요.\n\n```javascript\nfunction key_code(num) {\n  return function(...fns) {\n    return _.if2(function(e) { return e.keyCode === num })(...fns);\n  }\n}\n\nvar is_enter = key_code(13);\nvar is_space_bar = key_code(32);\nvar is_tab = key_code(9);\nvar is_esc = key_code(27);\n```","slug":"daily-fp-13","published":1,"updated":"2019-12-05T15:06:08.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9fx0022dirvhjf8bwle","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"is-enter\"><a href=\"#is-enter\" class=\"headerlink\" title=\"is_enter\"></a>is_enter</h2><p>오늘은 <a href=\"/programming/javascript-daily-function-12/\">지난 시간</a>에 다룬 <code>_.if2</code> 함수를 응용한 함수를 소개할까 합니다. 일명 <code>is_enter</code> 함수입니다. 우리는 종종 이벤트 리스너에서 <code>keyCode</code> 값을 검사해서 특정 동작을 수행하곤 합니다. 특히 Enter 키에 해당하는 13이 입력되면 검색을 수행한다던지 하는 일을 자주 하죠. <code>is_enter</code>는 이 경우에 유용한 함수입니다. </p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><p>오늘의 예제는 너무 간단합니다. 키다운 이벤트에 해당하는 이벤트 리스너를 정의합니다. 이때 엔터키가 입력되면 특정한 동작을 수행하도록 분기를 만들어야합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$input_element.addEventListener(<span class=\"string\">'keydown'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e.keyCode === <span class=\"number\">13</span>) &#123;</span><br><span class=\"line\">    action(); <span class=\"comment\">// 검색을 하거나 DOM을 제어하는 등 원하는 동작을 정의합니다.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>별거 아닌 이 상황, <code>if</code>가 눈에 띕니다. <a href=\"/programming/javascript-daily-function-12/\">지난 시간</a>에 만들어둔 <code>_.if2</code> 함수를 사용할 수 있을 것 같습니다.</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$input_element.addEventListener(<span class=\"string\">'keydown'</span>, is_enter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  action(); <span class=\"comment\">// 검색을 하거나 DOM을 제어하는 등 원하는 동작을 정의합니다.</span></span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n\n<p><code>is_enter</code> 함수는 함수를 반환하는 함수입니다. 만약에 <code>keyCode</code>가 13과 같다면 인자로 받은 함수를 실행시킬 준비가 된 함수를 만듭니다. 어떻게 구현되었는지를 보면 이해가 쉽습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> is_enter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...fns</span>) </span>&#123; <span class=\"comment\">// [1]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> _.if2(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; <span class=\"keyword\">return</span> e.keyCode === <span class=\"number\">13</span> &#125;)(...fns); <span class=\"comment\">// [2]</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>_.if2</code> 함수는 총 세차례 실행됩니다. <strong>첫번째 실행에서는 조건을 받고, 두번째 실행에서는 해야할 일을 받습니다. 마지막 실행에서 판단할 데이터를 받습니다.</strong> 이와 같은 맥락으로 이해하자면 [2]의 <code>_.if2</code>는 두번까지만 실행된 상황입니다. 조건을 정의하고 있고 어떤 일을 할지를 받았습니다. 여기서 어떤 일을 정의하는 함수가 여러개임을 알 수 있습니다. [1]에서 스프레드 연산자 (혹은 전개 연산자)를 사용해서 배열로 이루어진 함수 목록 <code>fns</code>를 받았습니다. 이를 <code>_.if2</code> 함수의 두번째 실행에서 스프레드 연산자로 실행시켰습니다. (기억하시는 것처럼 <code>_.if2</code>는 조건과 실행부에서 <code>_.pipe</code> 함수를 사용합니다.) 마지막 실행을 남겨둔 채로 <code>_.if2</code>는 반환됩니다. 이 상황을 기억하고 다시 위의 예제를 살펴보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$input_element.addEventListener(<span class=\"string\">'keydown'</span>, is_enter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; <span class=\"comment\">// [1]</span></span><br><span class=\"line\">  action();</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n\n<p>[1]에서 <code>is_enter</code>가 실행되면서 <code>fns</code>가 정의됐습니다. 그리고 이제 세번째 실행을 남겨둔 <code>_.if2</code> 함수가 그 자리를 대신하고 있는 셈입니다. 세번째로 실행될 때 비로소 판단할 데이터를 받고 미리 가지고 있던 조건부 함수와 해야할 함수 목록인 <code>fns</code>를 이용해서 조건이 맞으면(<code>keyCode</code>가 13이라면) 계획된 동작을 수행합니다. (여기서 ‘미리 가지고 있던’이 가능한 이유는 이 함수가 클로저이기 때문입니다.) 근사하죠?</p>\n<hr>\n<h4 id=\"3-이런-함수는-어때요-key-code\"><a href=\"#3-이런-함수는-어때요-key-code\" class=\"headerlink\" title=\"(3) 이런 함수는 어때요? key_code\"></a>(3) 이런 함수는 어때요? <code>key_code</code></h4><p><code>is_enter</code>만 있으니 다른 키보드들이 서운하지 않을까요? 러시아 같은 영토를 자랑하는 스페이스바와 esc 같은 키보드를 위한 함수도 만들어줄 수 있을 것 같습니다. <code>key_code</code>라는 함수가 있다면 이 모든 키보드를 위한 함수를 만들어줄 수 있겠네요.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">key_code</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...fns</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.if2(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; <span class=\"keyword\">return</span> e.keyCode === num &#125;)(...fns);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> is_enter = key_code(<span class=\"number\">13</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> is_space_bar = key_code(<span class=\"number\">32</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> is_tab = key_code(<span class=\"number\">9</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> is_esc = key_code(<span class=\"number\">27</span>);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"is-enter\"><a href=\"#is-enter\" class=\"headerlink\" title=\"is_enter\"></a>is_enter</h2><p>오늘은 <a href=\"/programming/javascript-daily-function-12/\">지난 시간</a>에 다룬 <code>_.if2</code> 함수를 응용한 함수를 소개할까 합니다. 일명 <code>is_enter</code> 함수입니다. 우리는 종종 이벤트 리스너에서 <code>keyCode</code> 값을 검사해서 특정 동작을 수행하곤 합니다. 특히 Enter 키에 해당하는 13이 입력되면 검색을 수행한다던지 하는 일을 자주 하죠. <code>is_enter</code>는 이 경우에 유용한 함수입니다. </p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><p>오늘의 예제는 너무 간단합니다. 키다운 이벤트에 해당하는 이벤트 리스너를 정의합니다. 이때 엔터키가 입력되면 특정한 동작을 수행하도록 분기를 만들어야합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$input_element.addEventListener(<span class=\"string\">'keydown'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e.keyCode === <span class=\"number\">13</span>) &#123;</span><br><span class=\"line\">    action(); <span class=\"comment\">// 검색을 하거나 DOM을 제어하는 등 원하는 동작을 정의합니다.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>별거 아닌 이 상황, <code>if</code>가 눈에 띕니다. <a href=\"/programming/javascript-daily-function-12/\">지난 시간</a>에 만들어둔 <code>_.if2</code> 함수를 사용할 수 있을 것 같습니다.</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$input_element.addEventListener(<span class=\"string\">'keydown'</span>, is_enter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  action(); <span class=\"comment\">// 검색을 하거나 DOM을 제어하는 등 원하는 동작을 정의합니다.</span></span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n\n<p><code>is_enter</code> 함수는 함수를 반환하는 함수입니다. 만약에 <code>keyCode</code>가 13과 같다면 인자로 받은 함수를 실행시킬 준비가 된 함수를 만듭니다. 어떻게 구현되었는지를 보면 이해가 쉽습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> is_enter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...fns</span>) </span>&#123; <span class=\"comment\">// [1]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> _.if2(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; <span class=\"keyword\">return</span> e.keyCode === <span class=\"number\">13</span> &#125;)(...fns); <span class=\"comment\">// [2]</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>_.if2</code> 함수는 총 세차례 실행됩니다. <strong>첫번째 실행에서는 조건을 받고, 두번째 실행에서는 해야할 일을 받습니다. 마지막 실행에서 판단할 데이터를 받습니다.</strong> 이와 같은 맥락으로 이해하자면 [2]의 <code>_.if2</code>는 두번까지만 실행된 상황입니다. 조건을 정의하고 있고 어떤 일을 할지를 받았습니다. 여기서 어떤 일을 정의하는 함수가 여러개임을 알 수 있습니다. [1]에서 스프레드 연산자 (혹은 전개 연산자)를 사용해서 배열로 이루어진 함수 목록 <code>fns</code>를 받았습니다. 이를 <code>_.if2</code> 함수의 두번째 실행에서 스프레드 연산자로 실행시켰습니다. (기억하시는 것처럼 <code>_.if2</code>는 조건과 실행부에서 <code>_.pipe</code> 함수를 사용합니다.) 마지막 실행을 남겨둔 채로 <code>_.if2</code>는 반환됩니다. 이 상황을 기억하고 다시 위의 예제를 살펴보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$input_element.addEventListener(<span class=\"string\">'keydown'</span>, is_enter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; <span class=\"comment\">// [1]</span></span><br><span class=\"line\">  action();</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n\n<p>[1]에서 <code>is_enter</code>가 실행되면서 <code>fns</code>가 정의됐습니다. 그리고 이제 세번째 실행을 남겨둔 <code>_.if2</code> 함수가 그 자리를 대신하고 있는 셈입니다. 세번째로 실행될 때 비로소 판단할 데이터를 받고 미리 가지고 있던 조건부 함수와 해야할 함수 목록인 <code>fns</code>를 이용해서 조건이 맞으면(<code>keyCode</code>가 13이라면) 계획된 동작을 수행합니다. (여기서 ‘미리 가지고 있던’이 가능한 이유는 이 함수가 클로저이기 때문입니다.) 근사하죠?</p>\n<hr>\n<h4 id=\"3-이런-함수는-어때요-key-code\"><a href=\"#3-이런-함수는-어때요-key-code\" class=\"headerlink\" title=\"(3) 이런 함수는 어때요? key_code\"></a>(3) 이런 함수는 어때요? <code>key_code</code></h4><p><code>is_enter</code>만 있으니 다른 키보드들이 서운하지 않을까요? 러시아 같은 영토를 자랑하는 스페이스바와 esc 같은 키보드를 위한 함수도 만들어줄 수 있을 것 같습니다. <code>key_code</code>라는 함수가 있다면 이 모든 키보드를 위한 함수를 만들어줄 수 있겠네요.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">key_code</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...fns</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.if2(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; <span class=\"keyword\">return</span> e.keyCode === num &#125;)(...fns);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> is_enter = key_code(<span class=\"number\">13</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> is_space_bar = key_code(<span class=\"number\">32</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> is_tab = key_code(<span class=\"number\">9</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> is_esc = key_code(<span class=\"number\">27</span>);</span><br></pre></td></tr></table></figure>"},{"title":"오늘의 함수 - redirect2","date":"2017-03-09T11:36:40.000Z","description":"redirect 함수의 개량된 버전을 소개합니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## redirect2 함수 \n\n첫번째로 소개해드렸던 `redirect` 함수의 개량된 버전을 소개합니다. 기존의 함수는 단지 새로운 경로로 이동해주는 역할만을 했습니다. 하지만 __때론 URL이 유연하게 결정되어야할 필요가 있습니다.__ `post`방식이 아닌 `get`방식으로 서버와 통신해야할 경우가 있기 때문입니다.\n\n오늘의 예제는 `post`로 가져온 데이터의 아이디 값에 따라 `get`방식으로 다른 페이지를 로드(load) 해야하는 경우를 가정했습니다.\n\n#### 1번 - 어제의 함수\n```javascript\nvar redirect1 = function(path) {\n  return function(res) {\n    if (res) {\n      return window.location.href = path;\n    } else {\n      console.error('return data:', res);\n    } \n  }\n};\n\n\nvar data = {title: 'hello', content: 'world!'};\n\n$.post('/api/post/create', data)\n  .done(function(res) { // [1] URL에 query string을 붙여주기 위해 함수를 새로 열었습니다.\n    redirect1('/main/newsfeed?id=' + res.id); \n  }); \n```\n\n사실 위의 함수도 그리 나쁘지 않습니다. 단지 한줄이 늘었을 뿐이니까요. 그래도 저는 조금 더 단순하게 함수 하나만 넣고 끝내고 싶습니다.\n\n#### 2번 - 오늘의 함수\n```javascript\nvar redirect2 = function(path, query) { // [1] query라는 새로운 argument를 만들어 둡니다.\n  return function(res) {\n    if (res) {\n      return window.location.href = query ? path + res[query] : path; // [2] query가 존재하면 get 방식으로 URL 지정합니다.\n    } else {\n      console.error('return data:', res);\n    } \n  }\n};\n\n\nvar data = {title: 'hello', content: 'world!'};\n\n$.post('/api/post/create', data)\n  .done(redirect2('/main/newsfeed?id=', 'id')); // [3] 두번째 매개변수에 데이터에서 어떤 값을 사용하고 싶은지 키 값을 적어줍니다. \n\n$.post('/api/post/update', data)\n  .done(redirect2('/main/editor?no=', 'no'));\n\n$.post('/api/post/delete', data)\n  .done(redirect2('/main/home')); // [4] 하나의 매개변수를 보내면 redirect1과 동일하게 동작합니다.\n```","source":"_posts/daily-fp-2.md","raw":"---\ntitle: '오늘의 함수 - redirect2'\ndate: 2017-03-09 20:36:40\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: redirect 함수의 개량된 버전을 소개합니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## redirect2 함수 \n\n첫번째로 소개해드렸던 `redirect` 함수의 개량된 버전을 소개합니다. 기존의 함수는 단지 새로운 경로로 이동해주는 역할만을 했습니다. 하지만 __때론 URL이 유연하게 결정되어야할 필요가 있습니다.__ `post`방식이 아닌 `get`방식으로 서버와 통신해야할 경우가 있기 때문입니다.\n\n오늘의 예제는 `post`로 가져온 데이터의 아이디 값에 따라 `get`방식으로 다른 페이지를 로드(load) 해야하는 경우를 가정했습니다.\n\n#### 1번 - 어제의 함수\n```javascript\nvar redirect1 = function(path) {\n  return function(res) {\n    if (res) {\n      return window.location.href = path;\n    } else {\n      console.error('return data:', res);\n    } \n  }\n};\n\n\nvar data = {title: 'hello', content: 'world!'};\n\n$.post('/api/post/create', data)\n  .done(function(res) { // [1] URL에 query string을 붙여주기 위해 함수를 새로 열었습니다.\n    redirect1('/main/newsfeed?id=' + res.id); \n  }); \n```\n\n사실 위의 함수도 그리 나쁘지 않습니다. 단지 한줄이 늘었을 뿐이니까요. 그래도 저는 조금 더 단순하게 함수 하나만 넣고 끝내고 싶습니다.\n\n#### 2번 - 오늘의 함수\n```javascript\nvar redirect2 = function(path, query) { // [1] query라는 새로운 argument를 만들어 둡니다.\n  return function(res) {\n    if (res) {\n      return window.location.href = query ? path + res[query] : path; // [2] query가 존재하면 get 방식으로 URL 지정합니다.\n    } else {\n      console.error('return data:', res);\n    } \n  }\n};\n\n\nvar data = {title: 'hello', content: 'world!'};\n\n$.post('/api/post/create', data)\n  .done(redirect2('/main/newsfeed?id=', 'id')); // [3] 두번째 매개변수에 데이터에서 어떤 값을 사용하고 싶은지 키 값을 적어줍니다. \n\n$.post('/api/post/update', data)\n  .done(redirect2('/main/editor?no=', 'no'));\n\n$.post('/api/post/delete', data)\n  .done(redirect2('/main/home')); // [4] 하나의 매개변수를 보내면 redirect1과 동일하게 동작합니다.\n```","slug":"daily-fp-2","published":1,"updated":"2019-12-05T15:06:08.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9fz0025dirvwatnfln0","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"redirect2-함수\"><a href=\"#redirect2-함수\" class=\"headerlink\" title=\"redirect2 함수\"></a>redirect2 함수</h2><p>첫번째로 소개해드렸던 <code>redirect</code> 함수의 개량된 버전을 소개합니다. 기존의 함수는 단지 새로운 경로로 이동해주는 역할만을 했습니다. 하지만 <strong>때론 URL이 유연하게 결정되어야할 필요가 있습니다.</strong> <code>post</code>방식이 아닌 <code>get</code>방식으로 서버와 통신해야할 경우가 있기 때문입니다.</p>\n<p>오늘의 예제는 <code>post</code>로 가져온 데이터의 아이디 값에 따라 <code>get</code>방식으로 다른 페이지를 로드(load) 해야하는 경우를 가정했습니다.</p>\n<h4 id=\"1번-어제의-함수\"><a href=\"#1번-어제의-함수\" class=\"headerlink\" title=\"1번 - 어제의 함수\"></a>1번 - 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> redirect1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = path;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data)</span><br><span class=\"line\">  .done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123; <span class=\"comment\">// [1] URL에 query string을 붙여주기 위해 함수를 새로 열었습니다.</span></span><br><span class=\"line\">    redirect1(<span class=\"string\">'/main/newsfeed?id='</span> + res.id); </span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>사실 위의 함수도 그리 나쁘지 않습니다. 단지 한줄이 늘었을 뿐이니까요. 그래도 저는 조금 더 단순하게 함수 하나만 넣고 끝내고 싶습니다.</p>\n<h4 id=\"2번-오늘의-함수\"><a href=\"#2번-오늘의-함수\" class=\"headerlink\" title=\"2번 - 오늘의 함수\"></a>2번 - 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> redirect2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, query</span>) </span>&#123; <span class=\"comment\">// [1] query라는 새로운 argument를 만들어 둡니다.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = query ? path + res[query] : path; <span class=\"comment\">// [2] query가 존재하면 get 방식으로 URL 지정합니다.</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data)</span><br><span class=\"line\">  .done(redirect2(<span class=\"string\">'/main/newsfeed?id='</span>, <span class=\"string\">'id'</span>)); <span class=\"comment\">// [3] 두번째 매개변수에 데이터에서 어떤 값을 사용하고 싶은지 키 값을 적어줍니다. </span></span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/update'</span>, data)</span><br><span class=\"line\">  .done(redirect2(<span class=\"string\">'/main/editor?no='</span>, <span class=\"string\">'no'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/delete'</span>, data)</span><br><span class=\"line\">  .done(redirect2(<span class=\"string\">'/main/home'</span>)); <span class=\"comment\">// [4] 하나의 매개변수를 보내면 redirect1과 동일하게 동작합니다.</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"redirect2-함수\"><a href=\"#redirect2-함수\" class=\"headerlink\" title=\"redirect2 함수\"></a>redirect2 함수</h2><p>첫번째로 소개해드렸던 <code>redirect</code> 함수의 개량된 버전을 소개합니다. 기존의 함수는 단지 새로운 경로로 이동해주는 역할만을 했습니다. 하지만 <strong>때론 URL이 유연하게 결정되어야할 필요가 있습니다.</strong> <code>post</code>방식이 아닌 <code>get</code>방식으로 서버와 통신해야할 경우가 있기 때문입니다.</p>\n<p>오늘의 예제는 <code>post</code>로 가져온 데이터의 아이디 값에 따라 <code>get</code>방식으로 다른 페이지를 로드(load) 해야하는 경우를 가정했습니다.</p>\n<h4 id=\"1번-어제의-함수\"><a href=\"#1번-어제의-함수\" class=\"headerlink\" title=\"1번 - 어제의 함수\"></a>1번 - 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> redirect1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = path;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data)</span><br><span class=\"line\">  .done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123; <span class=\"comment\">// [1] URL에 query string을 붙여주기 위해 함수를 새로 열었습니다.</span></span><br><span class=\"line\">    redirect1(<span class=\"string\">'/main/newsfeed?id='</span> + res.id); </span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>사실 위의 함수도 그리 나쁘지 않습니다. 단지 한줄이 늘었을 뿐이니까요. 그래도 저는 조금 더 단순하게 함수 하나만 넣고 끝내고 싶습니다.</p>\n<h4 id=\"2번-오늘의-함수\"><a href=\"#2번-오늘의-함수\" class=\"headerlink\" title=\"2번 - 오늘의 함수\"></a>2번 - 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> redirect2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, query</span>) </span>&#123; <span class=\"comment\">// [1] query라는 새로운 argument를 만들어 둡니다.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href = query ? path + res[query] : path; <span class=\"comment\">// [2] query가 존재하면 get 방식으로 URL 지정합니다.</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'return data:'</span>, res);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">title</span>: <span class=\"string\">'hello'</span>, <span class=\"attr\">content</span>: <span class=\"string\">'world!'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/create'</span>, data)</span><br><span class=\"line\">  .done(redirect2(<span class=\"string\">'/main/newsfeed?id='</span>, <span class=\"string\">'id'</span>)); <span class=\"comment\">// [3] 두번째 매개변수에 데이터에서 어떤 값을 사용하고 싶은지 키 값을 적어줍니다. </span></span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/update'</span>, data)</span><br><span class=\"line\">  .done(redirect2(<span class=\"string\">'/main/editor?no='</span>, <span class=\"string\">'no'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">$.post(<span class=\"string\">'/api/post/delete'</span>, data)</span><br><span class=\"line\">  .done(redirect2(<span class=\"string\">'/main/home'</span>)); <span class=\"comment\">// [4] 하나의 매개변수를 보내면 redirect1과 동일하게 동작합니다.</span></span><br></pre></td></tr></table></figure>"},{"title":"오늘의 함수 - val","date":"2018-02-24T11:16:00.000Z","description":"val은 객체에서 원하는 값 하나만을 반환합니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## [val](https://marpple.github.io/partial.js/docs/#val)\n\n오늘은 짧막한 이름을 가진 `val` 함수를 소개합니다. val이라는 이름은 value의 약자입니다. 여기서 value(값)는 객체에서 프로퍼티의 값을 의미합니다. 오늘 글에서는 '값'이라고 표기하겠습니다. 이름이 유사한 함수로는 `values`가 있는데, 이 함수는 객체에 있는 모든 값을 반환하는 함수입니다. 반면 `val`은 원하는 값 하나만을 반환합니다. \n(기능이 유사한 함수로 [underscore](http://underscorejs.org/#property)의 `_.property`, [ramdajs](http://ramdajs.com/docs/#path)의 `R.path`가 있지만 사용법이 조금 다릅니다.)\n\n예제를 살펴보겠습니다.\n\n#### (1) 어제의 함수\n\n```javascript\nlet person = { \n  name: 'Oliver Queen',\n  status: 'alive',\n  occupation: ['Mayor of Star City', 'Vigilante'],\n  family: {\n    father: {\n      name: 'Robert Queen',\n      status: 'deceased'\n    },\n    mother: {\n      name: 'Moria Queen',\n      status: 'deceased'\n    },\n    sister: {\n      name: 'Thea Queen',\n      status: 'alive'\n    }\n  }\n}\n```\n\n여기 `person`이라는 한 인물의 [데이터](http://arrow.wikia.com/wiki/Oliver_Queen)가 있습니다. 여기서 우리가 원하는 값을 얻는 것은 전혀 어렵지 않습니다. \n\n```javascript\nconsole.log(person.name); // 'Oliver Queen'\nconsole.log(person.occupation[0]); // 'Mayor of Star City'\nconsole.log(person.family.sister.name); // 'Thea Queen'\n\nconsole.log(person.family.brother.name); \n// [에러] Uncaught TypeError: Cannot read property 'name' of undefined\n```\n\n`sister.name`까지는 쉽게 얻었지만 존재하지 않는 값인 `brother.name`을 얻으려고 하니 에러가 났습니다. 당연한 결과입니다. 하지만 개발하는 중에 위와 같은 경우는 흔한 경우입니다. 때문에 아래와 같은 코드로 에러를 방지합니다.\n\n```javascript\nconsole.log(\n  person.family.brother && person.family.brother.name\n); // undefined\n\nconsole.log(\n  person.family.brother ? person.family.brother.name : 'none'\n); // 'none'\n```\n\n`family` 객체는 반드시 존재한다는 가정 아래에선 위와 같은 방법으로 처리가 가능하지만 `family`라는 객체마저 없을 수도 있다면 상황이 귀찮아집니다. 이때 필요한게 오늘의 함수 `val`입니다.\n\n\n#### (2) 오늘의 함수\n\n```javascript\nconsole.log(val(person, 'name')); // 'Oliver Queen'\nconsole.log(val(person, 'family.sister.name')); // 'Thea Queen'\nconsole.log(val(person, 'family.brother.name')); // undefined\nconsole.log(val(person, 'family.brother.name') || 'none'); // 'none'\n```\n\n`val`은 객체와 키(문자열)를 받습니다. 이때 키는 점(.) 연산자를 사용할 수 있습니다. `brother.name` 값을 얻으려 할때 `undefined`를 반환한 것으로 보아, 함수 내부에서 에러를 방지하고 있음을 알 수 있습니다. 내부 구현을 살펴보겠습니다.\n\n```javascript\nfunction val(obj, key) {\n  let keys = key.split('.');\n  let i = 0, len = keys.length;\n  let res = obj[keys[i]];\n  \n  while (++i < len) {\n    if (res === undefined) return;\n    res = res[keys[i]];\n  }\n  return res;\n}\n```\n\n`val` 함수는 객체(`obj`)와 키(`key`)를 받습니다. 여기서 문자열인 키는 곧장 `split`에 의해 배열로 쪼개집니다. `res`는 선언되면서 첫번째로 발견한 값을 담습니다. `keys`의 길이만큼 반복문을 수행합니다. 이때 `res`가 없다면 함수를 끝맺습니다. (아무런 값 없이 `return`하면 `undefined`가 반환됩니다.) 그렇지 않은 경우 다음 `res`를 찾습니다. 이를 반복한 뒤 최종 `res`를 반환합니다.\n\n여기서 `obj[keys[i]]`와 같은 형태로 값을 찾기 때문에 배열을 접근하기 위해선 아래와 같이 해야합니다.\n\n```javascript\nconsole.log(val(person, 'occupation.0')); // 'Mayor of Star City'\n```\n","source":"_posts/daily-fp-18.md","raw":"---\ntitle: '오늘의 함수 - val'\ndate: 2018-02-24 20:16:00\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: val은 객체에서 원하는 값 하나만을 반환합니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## [val](https://marpple.github.io/partial.js/docs/#val)\n\n오늘은 짧막한 이름을 가진 `val` 함수를 소개합니다. val이라는 이름은 value의 약자입니다. 여기서 value(값)는 객체에서 프로퍼티의 값을 의미합니다. 오늘 글에서는 '값'이라고 표기하겠습니다. 이름이 유사한 함수로는 `values`가 있는데, 이 함수는 객체에 있는 모든 값을 반환하는 함수입니다. 반면 `val`은 원하는 값 하나만을 반환합니다. \n(기능이 유사한 함수로 [underscore](http://underscorejs.org/#property)의 `_.property`, [ramdajs](http://ramdajs.com/docs/#path)의 `R.path`가 있지만 사용법이 조금 다릅니다.)\n\n예제를 살펴보겠습니다.\n\n#### (1) 어제의 함수\n\n```javascript\nlet person = { \n  name: 'Oliver Queen',\n  status: 'alive',\n  occupation: ['Mayor of Star City', 'Vigilante'],\n  family: {\n    father: {\n      name: 'Robert Queen',\n      status: 'deceased'\n    },\n    mother: {\n      name: 'Moria Queen',\n      status: 'deceased'\n    },\n    sister: {\n      name: 'Thea Queen',\n      status: 'alive'\n    }\n  }\n}\n```\n\n여기 `person`이라는 한 인물의 [데이터](http://arrow.wikia.com/wiki/Oliver_Queen)가 있습니다. 여기서 우리가 원하는 값을 얻는 것은 전혀 어렵지 않습니다. \n\n```javascript\nconsole.log(person.name); // 'Oliver Queen'\nconsole.log(person.occupation[0]); // 'Mayor of Star City'\nconsole.log(person.family.sister.name); // 'Thea Queen'\n\nconsole.log(person.family.brother.name); \n// [에러] Uncaught TypeError: Cannot read property 'name' of undefined\n```\n\n`sister.name`까지는 쉽게 얻었지만 존재하지 않는 값인 `brother.name`을 얻으려고 하니 에러가 났습니다. 당연한 결과입니다. 하지만 개발하는 중에 위와 같은 경우는 흔한 경우입니다. 때문에 아래와 같은 코드로 에러를 방지합니다.\n\n```javascript\nconsole.log(\n  person.family.brother && person.family.brother.name\n); // undefined\n\nconsole.log(\n  person.family.brother ? person.family.brother.name : 'none'\n); // 'none'\n```\n\n`family` 객체는 반드시 존재한다는 가정 아래에선 위와 같은 방법으로 처리가 가능하지만 `family`라는 객체마저 없을 수도 있다면 상황이 귀찮아집니다. 이때 필요한게 오늘의 함수 `val`입니다.\n\n\n#### (2) 오늘의 함수\n\n```javascript\nconsole.log(val(person, 'name')); // 'Oliver Queen'\nconsole.log(val(person, 'family.sister.name')); // 'Thea Queen'\nconsole.log(val(person, 'family.brother.name')); // undefined\nconsole.log(val(person, 'family.brother.name') || 'none'); // 'none'\n```\n\n`val`은 객체와 키(문자열)를 받습니다. 이때 키는 점(.) 연산자를 사용할 수 있습니다. `brother.name` 값을 얻으려 할때 `undefined`를 반환한 것으로 보아, 함수 내부에서 에러를 방지하고 있음을 알 수 있습니다. 내부 구현을 살펴보겠습니다.\n\n```javascript\nfunction val(obj, key) {\n  let keys = key.split('.');\n  let i = 0, len = keys.length;\n  let res = obj[keys[i]];\n  \n  while (++i < len) {\n    if (res === undefined) return;\n    res = res[keys[i]];\n  }\n  return res;\n}\n```\n\n`val` 함수는 객체(`obj`)와 키(`key`)를 받습니다. 여기서 문자열인 키는 곧장 `split`에 의해 배열로 쪼개집니다. `res`는 선언되면서 첫번째로 발견한 값을 담습니다. `keys`의 길이만큼 반복문을 수행합니다. 이때 `res`가 없다면 함수를 끝맺습니다. (아무런 값 없이 `return`하면 `undefined`가 반환됩니다.) 그렇지 않은 경우 다음 `res`를 찾습니다. 이를 반복한 뒤 최종 `res`를 반환합니다.\n\n여기서 `obj[keys[i]]`와 같은 형태로 값을 찾기 때문에 배열을 접근하기 위해선 아래와 같이 해야합니다.\n\n```javascript\nconsole.log(val(person, 'occupation.0')); // 'Mayor of Star City'\n```\n","slug":"daily-fp-18","published":1,"updated":"2019-12-05T15:06:08.863Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9g00029dirvwhnv7tbj","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"val\"><a href=\"#val\" class=\"headerlink\" title=\"val\"></a><a href=\"https://marpple.github.io/partial.js/docs/#val\" target=\"_blank\" rel=\"noopener\">val</a></h2><p>오늘은 짧막한 이름을 가진 <code>val</code> 함수를 소개합니다. val이라는 이름은 value의 약자입니다. 여기서 value(값)는 객체에서 프로퍼티의 값을 의미합니다. 오늘 글에서는 ‘값’이라고 표기하겠습니다. 이름이 유사한 함수로는 <code>values</code>가 있는데, 이 함수는 객체에 있는 모든 값을 반환하는 함수입니다. 반면 <code>val</code>은 원하는 값 하나만을 반환합니다.<br>(기능이 유사한 함수로 <a href=\"http://underscorejs.org/#property\" target=\"_blank\" rel=\"noopener\">underscore</a>의 <code>_.property</code>, <a href=\"http://ramdajs.com/docs/#path\" target=\"_blank\" rel=\"noopener\">ramdajs</a>의 <code>R.path</code>가 있지만 사용법이 조금 다릅니다.)</p>\n<p>예제를 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123; </span><br><span class=\"line\">  name: <span class=\"string\">'Oliver Queen'</span>,</span><br><span class=\"line\">  status: <span class=\"string\">'alive'</span>,</span><br><span class=\"line\">  occupation: [<span class=\"string\">'Mayor of Star City'</span>, <span class=\"string\">'Vigilante'</span>],</span><br><span class=\"line\">  family: &#123;</span><br><span class=\"line\">    father: &#123;</span><br><span class=\"line\">      name: <span class=\"string\">'Robert Queen'</span>,</span><br><span class=\"line\">      status: <span class=\"string\">'deceased'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    mother: &#123;</span><br><span class=\"line\">      name: <span class=\"string\">'Moria Queen'</span>,</span><br><span class=\"line\">      status: <span class=\"string\">'deceased'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    sister: &#123;</span><br><span class=\"line\">      name: <span class=\"string\">'Thea Queen'</span>,</span><br><span class=\"line\">      status: <span class=\"string\">'alive'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>여기 <code>person</code>이라는 한 인물의 <a href=\"http://arrow.wikia.com/wiki/Oliver_Queen\" target=\"_blank\" rel=\"noopener\">데이터</a>가 있습니다. 여기서 우리가 원하는 값을 얻는 것은 전혀 어렵지 않습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(person.name); <span class=\"comment\">// 'Oliver Queen'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.occupation[<span class=\"number\">0</span>]); <span class=\"comment\">// 'Mayor of Star City'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.family.sister.name); <span class=\"comment\">// 'Thea Queen'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.family.brother.name); </span><br><span class=\"line\"><span class=\"comment\">// [에러] Uncaught TypeError: Cannot read property 'name' of undefined</span></span><br></pre></td></tr></table></figure>\n\n<p><code>sister.name</code>까지는 쉽게 얻었지만 존재하지 않는 값인 <code>brother.name</code>을 얻으려고 하니 에러가 났습니다. 당연한 결과입니다. 하지만 개발하는 중에 위와 같은 경우는 흔한 경우입니다. 때문에 아래와 같은 코드로 에러를 방지합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  person.family.brother &amp;&amp; person.family.brother.name</span><br><span class=\"line\">); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  person.family.brother ? person.family.brother.name : <span class=\"string\">'none'</span></span><br><span class=\"line\">); <span class=\"comment\">// 'none'</span></span><br></pre></td></tr></table></figure>\n\n<p><code>family</code> 객체는 반드시 존재한다는 가정 아래에선 위와 같은 방법으로 처리가 가능하지만 <code>family</code>라는 객체마저 없을 수도 있다면 상황이 귀찮아집니다. 이때 필요한게 오늘의 함수 <code>val</code>입니다.</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(val(person, <span class=\"string\">'name'</span>)); <span class=\"comment\">// 'Oliver Queen'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(val(person, <span class=\"string\">'family.sister.name'</span>)); <span class=\"comment\">// 'Thea Queen'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(val(person, <span class=\"string\">'family.brother.name'</span>)); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(val(person, <span class=\"string\">'family.brother.name'</span>) || <span class=\"string\">'none'</span>); <span class=\"comment\">// 'none'</span></span><br></pre></td></tr></table></figure>\n\n<p><code>val</code>은 객체와 키(문자열)를 받습니다. 이때 키는 점(.) 연산자를 사용할 수 있습니다. <code>brother.name</code> 값을 얻으려 할때 <code>undefined</code>를 반환한 것으로 보아, 함수 내부에서 에러를 방지하고 있음을 알 수 있습니다. 내부 구현을 살펴보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">val</span>(<span class=\"params\">obj, key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> keys = key.split(<span class=\"string\">'.'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len = keys.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = obj[keys[i]];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">while</span> (++i &lt; len) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res === <span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    res = res[keys[i]];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>val</code> 함수는 객체(<code>obj</code>)와 키(<code>key</code>)를 받습니다. 여기서 문자열인 키는 곧장 <code>split</code>에 의해 배열로 쪼개집니다. <code>res</code>는 선언되면서 첫번째로 발견한 값을 담습니다. <code>keys</code>의 길이만큼 반복문을 수행합니다. 이때 <code>res</code>가 없다면 함수를 끝맺습니다. (아무런 값 없이 <code>return</code>하면 <code>undefined</code>가 반환됩니다.) 그렇지 않은 경우 다음 <code>res</code>를 찾습니다. 이를 반복한 뒤 최종 <code>res</code>를 반환합니다.</p>\n<p>여기서 <code>obj[keys[i]]</code>와 같은 형태로 값을 찾기 때문에 배열을 접근하기 위해선 아래와 같이 해야합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(val(person, <span class=\"string\">'occupation.0'</span>)); <span class=\"comment\">// 'Mayor of Star City'</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"val\"><a href=\"#val\" class=\"headerlink\" title=\"val\"></a><a href=\"https://marpple.github.io/partial.js/docs/#val\" target=\"_blank\" rel=\"noopener\">val</a></h2><p>오늘은 짧막한 이름을 가진 <code>val</code> 함수를 소개합니다. val이라는 이름은 value의 약자입니다. 여기서 value(값)는 객체에서 프로퍼티의 값을 의미합니다. 오늘 글에서는 ‘값’이라고 표기하겠습니다. 이름이 유사한 함수로는 <code>values</code>가 있는데, 이 함수는 객체에 있는 모든 값을 반환하는 함수입니다. 반면 <code>val</code>은 원하는 값 하나만을 반환합니다.<br>(기능이 유사한 함수로 <a href=\"http://underscorejs.org/#property\" target=\"_blank\" rel=\"noopener\">underscore</a>의 <code>_.property</code>, <a href=\"http://ramdajs.com/docs/#path\" target=\"_blank\" rel=\"noopener\">ramdajs</a>의 <code>R.path</code>가 있지만 사용법이 조금 다릅니다.)</p>\n<p>예제를 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> person = &#123; </span><br><span class=\"line\">  name: <span class=\"string\">'Oliver Queen'</span>,</span><br><span class=\"line\">  status: <span class=\"string\">'alive'</span>,</span><br><span class=\"line\">  occupation: [<span class=\"string\">'Mayor of Star City'</span>, <span class=\"string\">'Vigilante'</span>],</span><br><span class=\"line\">  family: &#123;</span><br><span class=\"line\">    father: &#123;</span><br><span class=\"line\">      name: <span class=\"string\">'Robert Queen'</span>,</span><br><span class=\"line\">      status: <span class=\"string\">'deceased'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    mother: &#123;</span><br><span class=\"line\">      name: <span class=\"string\">'Moria Queen'</span>,</span><br><span class=\"line\">      status: <span class=\"string\">'deceased'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    sister: &#123;</span><br><span class=\"line\">      name: <span class=\"string\">'Thea Queen'</span>,</span><br><span class=\"line\">      status: <span class=\"string\">'alive'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>여기 <code>person</code>이라는 한 인물의 <a href=\"http://arrow.wikia.com/wiki/Oliver_Queen\" target=\"_blank\" rel=\"noopener\">데이터</a>가 있습니다. 여기서 우리가 원하는 값을 얻는 것은 전혀 어렵지 않습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(person.name); <span class=\"comment\">// 'Oliver Queen'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.occupation[<span class=\"number\">0</span>]); <span class=\"comment\">// 'Mayor of Star City'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.family.sister.name); <span class=\"comment\">// 'Thea Queen'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.family.brother.name); </span><br><span class=\"line\"><span class=\"comment\">// [에러] Uncaught TypeError: Cannot read property 'name' of undefined</span></span><br></pre></td></tr></table></figure>\n\n<p><code>sister.name</code>까지는 쉽게 얻었지만 존재하지 않는 값인 <code>brother.name</code>을 얻으려고 하니 에러가 났습니다. 당연한 결과입니다. 하지만 개발하는 중에 위와 같은 경우는 흔한 경우입니다. 때문에 아래와 같은 코드로 에러를 방지합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  person.family.brother &amp;&amp; person.family.brother.name</span><br><span class=\"line\">); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  person.family.brother ? person.family.brother.name : <span class=\"string\">'none'</span></span><br><span class=\"line\">); <span class=\"comment\">// 'none'</span></span><br></pre></td></tr></table></figure>\n\n<p><code>family</code> 객체는 반드시 존재한다는 가정 아래에선 위와 같은 방법으로 처리가 가능하지만 <code>family</code>라는 객체마저 없을 수도 있다면 상황이 귀찮아집니다. 이때 필요한게 오늘의 함수 <code>val</code>입니다.</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(val(person, <span class=\"string\">'name'</span>)); <span class=\"comment\">// 'Oliver Queen'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(val(person, <span class=\"string\">'family.sister.name'</span>)); <span class=\"comment\">// 'Thea Queen'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(val(person, <span class=\"string\">'family.brother.name'</span>)); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(val(person, <span class=\"string\">'family.brother.name'</span>) || <span class=\"string\">'none'</span>); <span class=\"comment\">// 'none'</span></span><br></pre></td></tr></table></figure>\n\n<p><code>val</code>은 객체와 키(문자열)를 받습니다. 이때 키는 점(.) 연산자를 사용할 수 있습니다. <code>brother.name</code> 값을 얻으려 할때 <code>undefined</code>를 반환한 것으로 보아, 함수 내부에서 에러를 방지하고 있음을 알 수 있습니다. 내부 구현을 살펴보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">val</span>(<span class=\"params\">obj, key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> keys = key.split(<span class=\"string\">'.'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len = keys.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = obj[keys[i]];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">while</span> (++i &lt; len) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res === <span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    res = res[keys[i]];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>val</code> 함수는 객체(<code>obj</code>)와 키(<code>key</code>)를 받습니다. 여기서 문자열인 키는 곧장 <code>split</code>에 의해 배열로 쪼개집니다. <code>res</code>는 선언되면서 첫번째로 발견한 값을 담습니다. <code>keys</code>의 길이만큼 반복문을 수행합니다. 이때 <code>res</code>가 없다면 함수를 끝맺습니다. (아무런 값 없이 <code>return</code>하면 <code>undefined</code>가 반환됩니다.) 그렇지 않은 경우 다음 <code>res</code>를 찾습니다. 이를 반복한 뒤 최종 <code>res</code>를 반환합니다.</p>\n<p>여기서 <code>obj[keys[i]]</code>와 같은 형태로 값을 찾기 때문에 배열을 접근하기 위해선 아래와 같이 해야합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(val(person, <span class=\"string\">'occupation.0'</span>)); <span class=\"comment\">// 'Mayor of Star City'</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"오늘의 함수 - pipe2","date":"2018-03-29T11:21:56.000Z","description":"pipe는 함수를 합성하는 함수입니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## [pipe](https://marpple.github.io/partial.js/docs/#pipe)\n\n오늘은 `pipe` 함수를 소개하는 두번째 시간입니다. [처음 소개해드린게](/programming/javascript-daily-function-5/) 벌써 1년도 전의 일이네요. 처음 소개해드렸던 것처럼 `pipe`는 함수를 합성하는 함수입니다. 이번 시간에는 멀티 리턴([mr](/programming/javascript-daily-function-14/))을 지원하는 `pipe`의 구현과 사용을 보여드릴까 합니다. 우선 지난 구현을 살펴보시죠.\n\n#### (1) 어제의 함수\n\n```javascript\nfunction pipe() {\n  var funcs = Array.prototype.slice.apply(arguments); \n  // [1] 함수에 들어온 인자(함수)들의 모임인 arguments를 배열로 만들어줍니다. (원래 arguments는 유사 배열입니다.)\n  return function(seed) {\n    return funcs.reduce(function(value, func) { \n      // [2] reduce 함수를 사용해서 함수의 실행 결과를 하나로 합칩니다.\n      return func(value);\n    }, seed);\n  };\n}\n```\n\n처음 소개해드린 `pipe`의 구현을 그대로 가져왔습니다. 이렇게 구현된 함수는 아래와 같이 사용할 수 있습니다.\n\n```javascript\nconst add = a => b => a + b;\nconst adds = pipe(add(5), add(10), add(20));\n\nconsole.log(adds(10)); // 45 (10 + 5 + 10 + 20) \n```\n\n값을 하나씩만 넘겨서 하나의 인자로만 연산하는 함수를 합성하는데는 전혀 문제가 없습니다. 문제가 생기는 상황은 두개의 인자를 전달하는 상황입니다. \n\n```javascript\nconst adds2 = pipe((a, b) => a + b, add(10), add(20));\n\nconsole.log(adds2(10, 20)); // NaN\n```\n\n이때 `NaN`이 나온 이유는 `pipe` 안의 첫번째 함수에서 받은 `a`,`b` 중에서 `b`가 전달되지 않았기 때문입니다. 그래서 `10 + undefined`가 되는거죠. 결과적으로 첫번째 함수의 결과가 `NaN`이 되어 결과값도 `NaN`이 됩니다. 이제 두개의 인자를 전달할 수 있는 `pipe2`를 사용해보겠습니다.\n\n\n#### (2) 오늘의 함수\n\n```javascript\nconst adds3 = pipe2((a, b) => a + b, add(10), add(20));\n\nconsole.log(adds3(10, 20)); // 60 (10 + 20 + 10 + 20)\n```\n\n이번엔 의도한대로 60이 나옵니다. `a`와 `b`에 온전한 값이 들어갔기 때문입니다. 여러개의 인자를 받을 수 있는 상황이 되었다는 뜻인데, 어떻게 구현했는지 살펴보겠습니다.\n\n```javascript\nfunction pipe2() {\n  let funcs = Array.prototype.slice.apply(arguments); \n  return function(seed) {\n    let init = seed;\n    if (arguments.length > 1) { // [1]\n      init = arguments;\n      init.__mr = true; // [2]\n    }\n    return funcs.reduce(function(value, func) { \n      return value.__mr ? func(...value) : func(value); // [3]\n    }, init);\n  };\n}\n```\n\n[1] 함수를 실행하기 전에 초기값으로 들어온 인자들의 수를 파악합니다. 1개 이상이라면 멀티 리턴을 위한 단서를 만들어줘야 합니다.\n[2] 그 단서는 `__mr` 이라는 값(프로퍼티)입니다. 이 값이 참이면 이후에 해당 값을 `apply`나 `...`(전개 연산자)를 이용해서 실행합니다.\n[3] `value`가 멀티 리턴을 해야하는 값이라면, 전개 연산자를 사용해서 함수를 실행합니다.\n\n`pipe2`의 핵심 아이디어는 **`__mr`이라는 단서를 프로퍼티로 붙여준다**는 것. 그리고 **단서가 있으면 값을 전개해서 함수를 실행하도록 한다**는 것입니다. 해당 방식을 보다 적극적으로 활용하기 위해서는 `mr`이나 `to_mr` 같은 함수를 사용해야합니다. 다음 시간에는 그 활용에 대해 이야기 해보겠습니다.\n\n\n#### (3) 미리 보기\n\n```javascript\nconst adds4 = pipe2(\n  (a, b) => mr(a + b, 4), \n  (a, b) => a * b,\n  add(20)\n);\n\nconsole.log(adds4(10, 20)); // 140 ((10 + 20) * 4 + 20)\n```\n\n```javascript\nconst adds5 = pipe2(\n  all(\n    add(5),\n    add(10)\n  ),\n  (a, b) => a * b\n);\n\nconsole.log(adds5(10)); // 300 ((10 + 5) * (10 + 10))\n```","source":"_posts/daily-fp-20.md","raw":"---\ntitle: '오늘의 함수 - pipe2'\ndate: 2018-03-29 20:21:56\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: pipe는 함수를 합성하는 함수입니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## [pipe](https://marpple.github.io/partial.js/docs/#pipe)\n\n오늘은 `pipe` 함수를 소개하는 두번째 시간입니다. [처음 소개해드린게](/programming/javascript-daily-function-5/) 벌써 1년도 전의 일이네요. 처음 소개해드렸던 것처럼 `pipe`는 함수를 합성하는 함수입니다. 이번 시간에는 멀티 리턴([mr](/programming/javascript-daily-function-14/))을 지원하는 `pipe`의 구현과 사용을 보여드릴까 합니다. 우선 지난 구현을 살펴보시죠.\n\n#### (1) 어제의 함수\n\n```javascript\nfunction pipe() {\n  var funcs = Array.prototype.slice.apply(arguments); \n  // [1] 함수에 들어온 인자(함수)들의 모임인 arguments를 배열로 만들어줍니다. (원래 arguments는 유사 배열입니다.)\n  return function(seed) {\n    return funcs.reduce(function(value, func) { \n      // [2] reduce 함수를 사용해서 함수의 실행 결과를 하나로 합칩니다.\n      return func(value);\n    }, seed);\n  };\n}\n```\n\n처음 소개해드린 `pipe`의 구현을 그대로 가져왔습니다. 이렇게 구현된 함수는 아래와 같이 사용할 수 있습니다.\n\n```javascript\nconst add = a => b => a + b;\nconst adds = pipe(add(5), add(10), add(20));\n\nconsole.log(adds(10)); // 45 (10 + 5 + 10 + 20) \n```\n\n값을 하나씩만 넘겨서 하나의 인자로만 연산하는 함수를 합성하는데는 전혀 문제가 없습니다. 문제가 생기는 상황은 두개의 인자를 전달하는 상황입니다. \n\n```javascript\nconst adds2 = pipe((a, b) => a + b, add(10), add(20));\n\nconsole.log(adds2(10, 20)); // NaN\n```\n\n이때 `NaN`이 나온 이유는 `pipe` 안의 첫번째 함수에서 받은 `a`,`b` 중에서 `b`가 전달되지 않았기 때문입니다. 그래서 `10 + undefined`가 되는거죠. 결과적으로 첫번째 함수의 결과가 `NaN`이 되어 결과값도 `NaN`이 됩니다. 이제 두개의 인자를 전달할 수 있는 `pipe2`를 사용해보겠습니다.\n\n\n#### (2) 오늘의 함수\n\n```javascript\nconst adds3 = pipe2((a, b) => a + b, add(10), add(20));\n\nconsole.log(adds3(10, 20)); // 60 (10 + 20 + 10 + 20)\n```\n\n이번엔 의도한대로 60이 나옵니다. `a`와 `b`에 온전한 값이 들어갔기 때문입니다. 여러개의 인자를 받을 수 있는 상황이 되었다는 뜻인데, 어떻게 구현했는지 살펴보겠습니다.\n\n```javascript\nfunction pipe2() {\n  let funcs = Array.prototype.slice.apply(arguments); \n  return function(seed) {\n    let init = seed;\n    if (arguments.length > 1) { // [1]\n      init = arguments;\n      init.__mr = true; // [2]\n    }\n    return funcs.reduce(function(value, func) { \n      return value.__mr ? func(...value) : func(value); // [3]\n    }, init);\n  };\n}\n```\n\n[1] 함수를 실행하기 전에 초기값으로 들어온 인자들의 수를 파악합니다. 1개 이상이라면 멀티 리턴을 위한 단서를 만들어줘야 합니다.\n[2] 그 단서는 `__mr` 이라는 값(프로퍼티)입니다. 이 값이 참이면 이후에 해당 값을 `apply`나 `...`(전개 연산자)를 이용해서 실행합니다.\n[3] `value`가 멀티 리턴을 해야하는 값이라면, 전개 연산자를 사용해서 함수를 실행합니다.\n\n`pipe2`의 핵심 아이디어는 **`__mr`이라는 단서를 프로퍼티로 붙여준다**는 것. 그리고 **단서가 있으면 값을 전개해서 함수를 실행하도록 한다**는 것입니다. 해당 방식을 보다 적극적으로 활용하기 위해서는 `mr`이나 `to_mr` 같은 함수를 사용해야합니다. 다음 시간에는 그 활용에 대해 이야기 해보겠습니다.\n\n\n#### (3) 미리 보기\n\n```javascript\nconst adds4 = pipe2(\n  (a, b) => mr(a + b, 4), \n  (a, b) => a * b,\n  add(20)\n);\n\nconsole.log(adds4(10, 20)); // 140 ((10 + 20) * 4 + 20)\n```\n\n```javascript\nconst adds5 = pipe2(\n  all(\n    add(5),\n    add(10)\n  ),\n  (a, b) => a * b\n);\n\nconsole.log(adds5(10)); // 300 ((10 + 5) * (10 + 10))\n```","slug":"daily-fp-20","published":1,"updated":"2019-12-05T15:06:08.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9g2002cdirvr4xu8ro2","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"pipe\"><a href=\"#pipe\" class=\"headerlink\" title=\"pipe\"></a><a href=\"https://marpple.github.io/partial.js/docs/#pipe\" target=\"_blank\" rel=\"noopener\">pipe</a></h2><p>오늘은 <code>pipe</code> 함수를 소개하는 두번째 시간입니다. <a href=\"/programming/javascript-daily-function-5/\">처음 소개해드린게</a> 벌써 1년도 전의 일이네요. 처음 소개해드렸던 것처럼 <code>pipe</code>는 함수를 합성하는 함수입니다. 이번 시간에는 멀티 리턴(<a href=\"/programming/javascript-daily-function-14/\">mr</a>)을 지원하는 <code>pipe</code>의 구현과 사용을 보여드릴까 합니다. 우선 지난 구현을 살펴보시죠.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pipe</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> funcs = <span class=\"built_in\">Array</span>.prototype.slice.apply(<span class=\"built_in\">arguments</span>); </span><br><span class=\"line\">  <span class=\"comment\">// [1] 함수에 들어온 인자(함수)들의 모임인 arguments를 배열로 만들어줍니다. (원래 arguments는 유사 배열입니다.)</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">seed</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, func</span>) </span>&#123; </span><br><span class=\"line\">      <span class=\"comment\">// [2] reduce 함수를 사용해서 함수의 실행 결과를 하나로 합칩니다.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> func(value);</span><br><span class=\"line\">    &#125;, seed);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>처음 소개해드린 <code>pipe</code>의 구현을 그대로 가져왔습니다. 이렇게 구현된 함수는 아래와 같이 사용할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"function\"><span class=\"params\">b</span> =&gt;</span> a + b;</span><br><span class=\"line\"><span class=\"keyword\">const</span> adds = pipe(add(<span class=\"number\">5</span>), add(<span class=\"number\">10</span>), add(<span class=\"number\">20</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adds(<span class=\"number\">10</span>)); <span class=\"comment\">// 45 (10 + 5 + 10 + 20)</span></span><br></pre></td></tr></table></figure>\n\n<p>값을 하나씩만 넘겨서 하나의 인자로만 연산하는 함수를 합성하는데는 전혀 문제가 없습니다. 문제가 생기는 상황은 두개의 인자를 전달하는 상황입니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> adds2 = pipe(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b, add(<span class=\"number\">10</span>), add(<span class=\"number\">20</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adds2(<span class=\"number\">10</span>, <span class=\"number\">20</span>)); <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>이때 <code>NaN</code>이 나온 이유는 <code>pipe</code> 안의 첫번째 함수에서 받은 <code>a</code>,<code>b</code> 중에서 <code>b</code>가 전달되지 않았기 때문입니다. 그래서 <code>10 + undefined</code>가 되는거죠. 결과적으로 첫번째 함수의 결과가 <code>NaN</code>이 되어 결과값도 <code>NaN</code>이 됩니다. 이제 두개의 인자를 전달할 수 있는 <code>pipe2</code>를 사용해보겠습니다.</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> adds3 = pipe2(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b, add(<span class=\"number\">10</span>), add(<span class=\"number\">20</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adds3(<span class=\"number\">10</span>, <span class=\"number\">20</span>)); <span class=\"comment\">// 60 (10 + 20 + 10 + 20)</span></span><br></pre></td></tr></table></figure>\n\n<p>이번엔 의도한대로 60이 나옵니다. <code>a</code>와 <code>b</code>에 온전한 값이 들어갔기 때문입니다. 여러개의 인자를 받을 수 있는 상황이 되었다는 뜻인데, 어떻게 구현했는지 살펴보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pipe2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> funcs = <span class=\"built_in\">Array</span>.prototype.slice.apply(<span class=\"built_in\">arguments</span>); </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">seed</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> init = seed;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length &gt; <span class=\"number\">1</span>) &#123; <span class=\"comment\">// [1]</span></span><br><span class=\"line\">      init = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">      init.__mr = <span class=\"literal\">true</span>; <span class=\"comment\">// [2]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, func</span>) </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> value.__mr ? func(...value) : func(value); <span class=\"comment\">// [3]</span></span><br><span class=\"line\">    &#125;, init);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>[1] 함수를 실행하기 전에 초기값으로 들어온 인자들의 수를 파악합니다. 1개 이상이라면 멀티 리턴을 위한 단서를 만들어줘야 합니다.<br>[2] 그 단서는 <code>__mr</code> 이라는 값(프로퍼티)입니다. 이 값이 참이면 이후에 해당 값을 <code>apply</code>나 <code>...</code>(전개 연산자)를 이용해서 실행합니다.<br>[3] <code>value</code>가 멀티 리턴을 해야하는 값이라면, 전개 연산자를 사용해서 함수를 실행합니다.</p>\n<p><code>pipe2</code>의 핵심 아이디어는 <strong><code>__mr</code>이라는 단서를 프로퍼티로 붙여준다</strong>는 것. 그리고 <strong>단서가 있으면 값을 전개해서 함수를 실행하도록 한다</strong>는 것입니다. 해당 방식을 보다 적극적으로 활용하기 위해서는 <code>mr</code>이나 <code>to_mr</code> 같은 함수를 사용해야합니다. 다음 시간에는 그 활용에 대해 이야기 해보겠습니다.</p>\n<h4 id=\"3-미리-보기\"><a href=\"#3-미리-보기\" class=\"headerlink\" title=\"(3) 미리 보기\"></a>(3) 미리 보기</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> adds4 = pipe2(</span><br><span class=\"line\">  (a, b) =&gt; mr(a + b, <span class=\"number\">4</span>), </span><br><span class=\"line\">  (a, b) =&gt; a * b,</span><br><span class=\"line\">  add(<span class=\"number\">20</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adds4(<span class=\"number\">10</span>, <span class=\"number\">20</span>)); <span class=\"comment\">// 140 ((10 + 20) * 4 + 20)</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> adds5 = pipe2(</span><br><span class=\"line\">  all(</span><br><span class=\"line\">    add(<span class=\"number\">5</span>),</span><br><span class=\"line\">    add(<span class=\"number\">10</span>)</span><br><span class=\"line\">  ),</span><br><span class=\"line\">  (a, b) =&gt; a * b</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adds5(<span class=\"number\">10</span>)); <span class=\"comment\">// 300 ((10 + 5) * (10 + 10))</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"pipe\"><a href=\"#pipe\" class=\"headerlink\" title=\"pipe\"></a><a href=\"https://marpple.github.io/partial.js/docs/#pipe\" target=\"_blank\" rel=\"noopener\">pipe</a></h2><p>오늘은 <code>pipe</code> 함수를 소개하는 두번째 시간입니다. <a href=\"/programming/javascript-daily-function-5/\">처음 소개해드린게</a> 벌써 1년도 전의 일이네요. 처음 소개해드렸던 것처럼 <code>pipe</code>는 함수를 합성하는 함수입니다. 이번 시간에는 멀티 리턴(<a href=\"/programming/javascript-daily-function-14/\">mr</a>)을 지원하는 <code>pipe</code>의 구현과 사용을 보여드릴까 합니다. 우선 지난 구현을 살펴보시죠.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pipe</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> funcs = <span class=\"built_in\">Array</span>.prototype.slice.apply(<span class=\"built_in\">arguments</span>); </span><br><span class=\"line\">  <span class=\"comment\">// [1] 함수에 들어온 인자(함수)들의 모임인 arguments를 배열로 만들어줍니다. (원래 arguments는 유사 배열입니다.)</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">seed</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, func</span>) </span>&#123; </span><br><span class=\"line\">      <span class=\"comment\">// [2] reduce 함수를 사용해서 함수의 실행 결과를 하나로 합칩니다.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> func(value);</span><br><span class=\"line\">    &#125;, seed);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>처음 소개해드린 <code>pipe</code>의 구현을 그대로 가져왔습니다. 이렇게 구현된 함수는 아래와 같이 사용할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"function\"><span class=\"params\">b</span> =&gt;</span> a + b;</span><br><span class=\"line\"><span class=\"keyword\">const</span> adds = pipe(add(<span class=\"number\">5</span>), add(<span class=\"number\">10</span>), add(<span class=\"number\">20</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adds(<span class=\"number\">10</span>)); <span class=\"comment\">// 45 (10 + 5 + 10 + 20)</span></span><br></pre></td></tr></table></figure>\n\n<p>값을 하나씩만 넘겨서 하나의 인자로만 연산하는 함수를 합성하는데는 전혀 문제가 없습니다. 문제가 생기는 상황은 두개의 인자를 전달하는 상황입니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> adds2 = pipe(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b, add(<span class=\"number\">10</span>), add(<span class=\"number\">20</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adds2(<span class=\"number\">10</span>, <span class=\"number\">20</span>)); <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<p>이때 <code>NaN</code>이 나온 이유는 <code>pipe</code> 안의 첫번째 함수에서 받은 <code>a</code>,<code>b</code> 중에서 <code>b</code>가 전달되지 않았기 때문입니다. 그래서 <code>10 + undefined</code>가 되는거죠. 결과적으로 첫번째 함수의 결과가 <code>NaN</code>이 되어 결과값도 <code>NaN</code>이 됩니다. 이제 두개의 인자를 전달할 수 있는 <code>pipe2</code>를 사용해보겠습니다.</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> adds3 = pipe2(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b, add(<span class=\"number\">10</span>), add(<span class=\"number\">20</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adds3(<span class=\"number\">10</span>, <span class=\"number\">20</span>)); <span class=\"comment\">// 60 (10 + 20 + 10 + 20)</span></span><br></pre></td></tr></table></figure>\n\n<p>이번엔 의도한대로 60이 나옵니다. <code>a</code>와 <code>b</code>에 온전한 값이 들어갔기 때문입니다. 여러개의 인자를 받을 수 있는 상황이 되었다는 뜻인데, 어떻게 구현했는지 살펴보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pipe2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> funcs = <span class=\"built_in\">Array</span>.prototype.slice.apply(<span class=\"built_in\">arguments</span>); </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">seed</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> init = seed;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length &gt; <span class=\"number\">1</span>) &#123; <span class=\"comment\">// [1]</span></span><br><span class=\"line\">      init = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">      init.__mr = <span class=\"literal\">true</span>; <span class=\"comment\">// [2]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, func</span>) </span>&#123; </span><br><span class=\"line\">      <span class=\"keyword\">return</span> value.__mr ? func(...value) : func(value); <span class=\"comment\">// [3]</span></span><br><span class=\"line\">    &#125;, init);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>[1] 함수를 실행하기 전에 초기값으로 들어온 인자들의 수를 파악합니다. 1개 이상이라면 멀티 리턴을 위한 단서를 만들어줘야 합니다.<br>[2] 그 단서는 <code>__mr</code> 이라는 값(프로퍼티)입니다. 이 값이 참이면 이후에 해당 값을 <code>apply</code>나 <code>...</code>(전개 연산자)를 이용해서 실행합니다.<br>[3] <code>value</code>가 멀티 리턴을 해야하는 값이라면, 전개 연산자를 사용해서 함수를 실행합니다.</p>\n<p><code>pipe2</code>의 핵심 아이디어는 <strong><code>__mr</code>이라는 단서를 프로퍼티로 붙여준다</strong>는 것. 그리고 <strong>단서가 있으면 값을 전개해서 함수를 실행하도록 한다</strong>는 것입니다. 해당 방식을 보다 적극적으로 활용하기 위해서는 <code>mr</code>이나 <code>to_mr</code> 같은 함수를 사용해야합니다. 다음 시간에는 그 활용에 대해 이야기 해보겠습니다.</p>\n<h4 id=\"3-미리-보기\"><a href=\"#3-미리-보기\" class=\"headerlink\" title=\"(3) 미리 보기\"></a>(3) 미리 보기</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> adds4 = pipe2(</span><br><span class=\"line\">  (a, b) =&gt; mr(a + b, <span class=\"number\">4</span>), </span><br><span class=\"line\">  (a, b) =&gt; a * b,</span><br><span class=\"line\">  add(<span class=\"number\">20</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adds4(<span class=\"number\">10</span>, <span class=\"number\">20</span>)); <span class=\"comment\">// 140 ((10 + 20) * 4 + 20)</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> adds5 = pipe2(</span><br><span class=\"line\">  all(</span><br><span class=\"line\">    add(<span class=\"number\">5</span>),</span><br><span class=\"line\">    add(<span class=\"number\">10</span>)</span><br><span class=\"line\">  ),</span><br><span class=\"line\">  (a, b) =&gt; a * b</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adds5(<span class=\"number\">10</span>)); <span class=\"comment\">// 300 ((10 + 5) * (10 + 10))</span></span><br></pre></td></tr></table></figure>"},{"title":"오늘의 함수 - pluck","date":"2018-03-05T12:21:56.000Z","description":"pluck는 배열 속 객체에서 원하는 값만 잡아 뜯는(뽑는) 함수입니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## [pluck](https://marpple.github.io/partial.js/docs/#pluck)\n\nPluck는 '뽑다'는 의미를 가지고 있습니다. 풀을 뽑을 때 'pluck grass'라고 합니다. '잡아 뜯다'는 느낌이 강합니다. 오늘 소개할 함수 `pluck`도 배열 속 객체에서 원하는 값만 잡아 뜯는(뽑는) 함수입니다. __배열이라는 땅에 자란 객체라는 풀 중에 뽑아야할 풀(객체)만 뽑아내는 함수__라고 생각하시면 편하겠습니다. 뽑아낸 결과가 다시 땅(배열)이라는게 좀 이상하긴 하네요. \n\n예제를 살펴보겠습니다.\n\n#### (1) 어제의 함수\n\n```javascript\nlet queen_family = [\n  { name: 'Oliver Queen', status: 'alive'}, \n  { name: 'Robert Queen', status: 'deceased' },\n  { name: 'Moria Queen', status: 'deceased' },\n  { name: 'Thea Queen', status: 'alive' }\n];\n```\n\n[지난 시간](/programming/javascript-daily-function-18/)에 다뤘던 데이터에서 일부를 가져왔습니다. 가족 구성원의 정보(객체)가 담긴 배열입니다. 우리가 원하는건 가족 구성원의 이름이라고 가정하겠습니다. 가족 모두의 이름을 찾아 배열로 만드는 일은 간단합니다. `map` 함수를 사용하면 됩니다. \n\n```javascript\nlet names = map(queen_family, person => person.name);\n// queen_family.map(person => person.name)\n\nconsole.log(names); // [\"Oliver Queen\", \"Robert Queen\", \"Moria Queen\", \"Thea Queen\"]\n```\n\n`map`을 사용하니 원하는 값을 쉽게 배열로 만들어주네요. 그런데 여기서 낯익은 구문이 나옵니다. 바로 `person => person.name` 이 함수입니다. [지난 시간](/programming/javascript-daily-function-18/)에 다룬 `val` 함수를 사용할 수 있을 것 같습니다.\n\n```javascript\nlet names = map(queen_family, val('name'));\n\nconsole.log(names); // [\"Oliver Queen\", \"Robert Queen\", \"Moria Queen\", \"Thea Queen\"]\n```\n\n오늘의 함수인 `pluck`는 `map`과 `val`함수가 함께 하는 일을 혼자서 해냅니다.\n\n\n#### (2) 오늘의 함수\n\n```javascript\nlet names = pluck(queen_family, 'name');\n\nconsole.log(names); // [\"Oliver Queen\", \"Robert Queen\", \"Moria Queen\", \"Thea Queen\"]\n```\n\n훨씬 깔끔하네요. 그렇다면 `pluck`는 어떻게 구현할까요?\n\n```javascript\nconst pluck = (arr, key) => map(arr, val(key));\n```\n\n장난인 듯 장난 아닌 멋진 구현입니다. 결국 `pluck`는 두 함수의 조합(합성)으로 만들 수 있는 함수입니다. 근사하지 않나요? ","source":"_posts/daily-fp-19.md","raw":"---\ntitle: '오늘의 함수 - pluck'\ndate: 2018-03-05 21:21:56\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: pluck는 배열 속 객체에서 원하는 값만 잡아 뜯는(뽑는) 함수입니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## [pluck](https://marpple.github.io/partial.js/docs/#pluck)\n\nPluck는 '뽑다'는 의미를 가지고 있습니다. 풀을 뽑을 때 'pluck grass'라고 합니다. '잡아 뜯다'는 느낌이 강합니다. 오늘 소개할 함수 `pluck`도 배열 속 객체에서 원하는 값만 잡아 뜯는(뽑는) 함수입니다. __배열이라는 땅에 자란 객체라는 풀 중에 뽑아야할 풀(객체)만 뽑아내는 함수__라고 생각하시면 편하겠습니다. 뽑아낸 결과가 다시 땅(배열)이라는게 좀 이상하긴 하네요. \n\n예제를 살펴보겠습니다.\n\n#### (1) 어제의 함수\n\n```javascript\nlet queen_family = [\n  { name: 'Oliver Queen', status: 'alive'}, \n  { name: 'Robert Queen', status: 'deceased' },\n  { name: 'Moria Queen', status: 'deceased' },\n  { name: 'Thea Queen', status: 'alive' }\n];\n```\n\n[지난 시간](/programming/javascript-daily-function-18/)에 다뤘던 데이터에서 일부를 가져왔습니다. 가족 구성원의 정보(객체)가 담긴 배열입니다. 우리가 원하는건 가족 구성원의 이름이라고 가정하겠습니다. 가족 모두의 이름을 찾아 배열로 만드는 일은 간단합니다. `map` 함수를 사용하면 됩니다. \n\n```javascript\nlet names = map(queen_family, person => person.name);\n// queen_family.map(person => person.name)\n\nconsole.log(names); // [\"Oliver Queen\", \"Robert Queen\", \"Moria Queen\", \"Thea Queen\"]\n```\n\n`map`을 사용하니 원하는 값을 쉽게 배열로 만들어주네요. 그런데 여기서 낯익은 구문이 나옵니다. 바로 `person => person.name` 이 함수입니다. [지난 시간](/programming/javascript-daily-function-18/)에 다룬 `val` 함수를 사용할 수 있을 것 같습니다.\n\n```javascript\nlet names = map(queen_family, val('name'));\n\nconsole.log(names); // [\"Oliver Queen\", \"Robert Queen\", \"Moria Queen\", \"Thea Queen\"]\n```\n\n오늘의 함수인 `pluck`는 `map`과 `val`함수가 함께 하는 일을 혼자서 해냅니다.\n\n\n#### (2) 오늘의 함수\n\n```javascript\nlet names = pluck(queen_family, 'name');\n\nconsole.log(names); // [\"Oliver Queen\", \"Robert Queen\", \"Moria Queen\", \"Thea Queen\"]\n```\n\n훨씬 깔끔하네요. 그렇다면 `pluck`는 어떻게 구현할까요?\n\n```javascript\nconst pluck = (arr, key) => map(arr, val(key));\n```\n\n장난인 듯 장난 아닌 멋진 구현입니다. 결국 `pluck`는 두 함수의 조합(합성)으로 만들 수 있는 함수입니다. 근사하지 않나요? ","slug":"daily-fp-19","published":1,"updated":"2019-12-05T15:06:08.863Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9g5002gdirvob15wz14","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"pluck\"><a href=\"#pluck\" class=\"headerlink\" title=\"pluck\"></a><a href=\"https://marpple.github.io/partial.js/docs/#pluck\" target=\"_blank\" rel=\"noopener\">pluck</a></h2><p>Pluck는 ‘뽑다’는 의미를 가지고 있습니다. 풀을 뽑을 때 ‘pluck grass’라고 합니다. ‘잡아 뜯다’는 느낌이 강합니다. 오늘 소개할 함수 <code>pluck</code>도 배열 속 객체에서 원하는 값만 잡아 뜯는(뽑는) 함수입니다. <strong>배열이라는 땅에 자란 객체라는 풀 중에 뽑아야할 풀(객체)만 뽑아내는 함수</strong>라고 생각하시면 편하겠습니다. 뽑아낸 결과가 다시 땅(배열)이라는게 좀 이상하긴 하네요. </p>\n<p>예제를 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queen_family = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Oliver Queen'</span>, <span class=\"attr\">status</span>: <span class=\"string\">'alive'</span>&#125;, </span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Robert Queen'</span>, <span class=\"attr\">status</span>: <span class=\"string\">'deceased'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Moria Queen'</span>, <span class=\"attr\">status</span>: <span class=\"string\">'deceased'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Thea Queen'</span>, <span class=\"attr\">status</span>: <span class=\"string\">'alive'</span> &#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"/programming/javascript-daily-function-18/\">지난 시간</a>에 다뤘던 데이터에서 일부를 가져왔습니다. 가족 구성원의 정보(객체)가 담긴 배열입니다. 우리가 원하는건 가족 구성원의 이름이라고 가정하겠습니다. 가족 모두의 이름을 찾아 배열로 만드는 일은 간단합니다. <code>map</code> 함수를 사용하면 됩니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> names = map(queen_family, person =&gt; person.name);</span><br><span class=\"line\"><span class=\"comment\">// queen_family.map(person =&gt; person.name)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(names); <span class=\"comment\">// [\"Oliver Queen\", \"Robert Queen\", \"Moria Queen\", \"Thea Queen\"]</span></span><br></pre></td></tr></table></figure>\n\n<p><code>map</code>을 사용하니 원하는 값을 쉽게 배열로 만들어주네요. 그런데 여기서 낯익은 구문이 나옵니다. 바로 <code>person =&gt; person.name</code> 이 함수입니다. <a href=\"/programming/javascript-daily-function-18/\">지난 시간</a>에 다룬 <code>val</code> 함수를 사용할 수 있을 것 같습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> names = map(queen_family, val(<span class=\"string\">'name'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(names); <span class=\"comment\">// [\"Oliver Queen\", \"Robert Queen\", \"Moria Queen\", \"Thea Queen\"]</span></span><br></pre></td></tr></table></figure>\n\n<p>오늘의 함수인 <code>pluck</code>는 <code>map</code>과 <code>val</code>함수가 함께 하는 일을 혼자서 해냅니다.</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> names = pluck(queen_family, <span class=\"string\">'name'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(names); <span class=\"comment\">// [\"Oliver Queen\", \"Robert Queen\", \"Moria Queen\", \"Thea Queen\"]</span></span><br></pre></td></tr></table></figure>\n\n<p>훨씬 깔끔하네요. 그렇다면 <code>pluck</code>는 어떻게 구현할까요?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pluck = <span class=\"function\">(<span class=\"params\">arr, key</span>) =&gt;</span> map(arr, val(key));</span><br></pre></td></tr></table></figure>\n\n<p>장난인 듯 장난 아닌 멋진 구현입니다. 결국 <code>pluck</code>는 두 함수의 조합(합성)으로 만들 수 있는 함수입니다. 근사하지 않나요? </p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"pluck\"><a href=\"#pluck\" class=\"headerlink\" title=\"pluck\"></a><a href=\"https://marpple.github.io/partial.js/docs/#pluck\" target=\"_blank\" rel=\"noopener\">pluck</a></h2><p>Pluck는 ‘뽑다’는 의미를 가지고 있습니다. 풀을 뽑을 때 ‘pluck grass’라고 합니다. ‘잡아 뜯다’는 느낌이 강합니다. 오늘 소개할 함수 <code>pluck</code>도 배열 속 객체에서 원하는 값만 잡아 뜯는(뽑는) 함수입니다. <strong>배열이라는 땅에 자란 객체라는 풀 중에 뽑아야할 풀(객체)만 뽑아내는 함수</strong>라고 생각하시면 편하겠습니다. 뽑아낸 결과가 다시 땅(배열)이라는게 좀 이상하긴 하네요. </p>\n<p>예제를 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queen_family = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Oliver Queen'</span>, <span class=\"attr\">status</span>: <span class=\"string\">'alive'</span>&#125;, </span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Robert Queen'</span>, <span class=\"attr\">status</span>: <span class=\"string\">'deceased'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Moria Queen'</span>, <span class=\"attr\">status</span>: <span class=\"string\">'deceased'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Thea Queen'</span>, <span class=\"attr\">status</span>: <span class=\"string\">'alive'</span> &#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"/programming/javascript-daily-function-18/\">지난 시간</a>에 다뤘던 데이터에서 일부를 가져왔습니다. 가족 구성원의 정보(객체)가 담긴 배열입니다. 우리가 원하는건 가족 구성원의 이름이라고 가정하겠습니다. 가족 모두의 이름을 찾아 배열로 만드는 일은 간단합니다. <code>map</code> 함수를 사용하면 됩니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> names = map(queen_family, person =&gt; person.name);</span><br><span class=\"line\"><span class=\"comment\">// queen_family.map(person =&gt; person.name)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(names); <span class=\"comment\">// [\"Oliver Queen\", \"Robert Queen\", \"Moria Queen\", \"Thea Queen\"]</span></span><br></pre></td></tr></table></figure>\n\n<p><code>map</code>을 사용하니 원하는 값을 쉽게 배열로 만들어주네요. 그런데 여기서 낯익은 구문이 나옵니다. 바로 <code>person =&gt; person.name</code> 이 함수입니다. <a href=\"/programming/javascript-daily-function-18/\">지난 시간</a>에 다룬 <code>val</code> 함수를 사용할 수 있을 것 같습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> names = map(queen_family, val(<span class=\"string\">'name'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(names); <span class=\"comment\">// [\"Oliver Queen\", \"Robert Queen\", \"Moria Queen\", \"Thea Queen\"]</span></span><br></pre></td></tr></table></figure>\n\n<p>오늘의 함수인 <code>pluck</code>는 <code>map</code>과 <code>val</code>함수가 함께 하는 일을 혼자서 해냅니다.</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> names = pluck(queen_family, <span class=\"string\">'name'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(names); <span class=\"comment\">// [\"Oliver Queen\", \"Robert Queen\", \"Moria Queen\", \"Thea Queen\"]</span></span><br></pre></td></tr></table></figure>\n\n<p>훨씬 깔끔하네요. 그렇다면 <code>pluck</code>는 어떻게 구현할까요?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pluck = <span class=\"function\">(<span class=\"params\">arr, key</span>) =&gt;</span> map(arr, val(key));</span><br></pre></td></tr></table></figure>\n\n<p>장난인 듯 장난 아닌 멋진 구현입니다. 결국 <code>pluck</code>는 두 함수의 조합(합성)으로 만들 수 있는 함수입니다. 근사하지 않나요? </p>\n"},{"title":"오늘의 함수 - identity, always","date":"2017-03-20T14:41:48.000Z","description":"이름부터 심상치 않은 identity와 always 함수 입니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## identity, always 함수 \n\n오늘은 정말 황당한(?) 함수 두개를 소개하겠습니다. 이름부터 심상치 않은 `identity`와 `always` 함수 입니다. 오늘은 어제의 함수를 생략하고 곧장 함수 소개를 하겠습니다.\n\n#### (1) 오늘의 함수 - identity와 always\n```javascript\nfunction identity(value) {\n  return value;\n}\n\nfunction always(value) {\n  return function() {\n    return value;\n  }\n}\n\nconsole.log(identity(10)); // 10\nconsole.log(always(10)()); // 10\n```\n\n정말 황당한 함수입니다. 뭐하자는건가 싶습니다. 넣은 값을 그대로 반환할거면 왜 굳이 함수를 썼어야했나 싶습니다. 하지만 이 함수들은 아주 유용한 함수들입니다. 함수를 값으로 다루는 프로그래밍에서는 이 함수들은 아주 빈번하게 등장합니다. 지난번에 소개해드렸던 `confirm` 함수를 사용해서 예시를 만들어보겠습니다.\n\n#### (2) 오늘의 함수 - confirm 함수와의 콜라보 1\n```javascript\nfunction _confirm(message, yes_fn, no_fn) { // [1] 출력할 메시지와 성공, 실패에 따라 실행할 함수를 받는 confirm 함수입니다.\n  return confirm(message) ? yes_fn() : no_fn(); \n}\n\n$('li').on('click', 'button.delete', function(e) {\n  _confirm('Are you sure?', function() { // [2] '확인'을 눌렀을 때 동작하게될 함수입니다.\n    $(e.delegateTarget).remove();\n  }, always(false)) // [3] '취소'를 눌렀을 때 동작하게될 함수입니다. 이 경우에 항상 'false'를 반환하는 함수입니다.\n})\n```\n\n주목하셔야할 부분은 역시 `always` 함수가 등장한 [3] 지점입니다. 이전에는 해당 코드가 `function() { return false }`로 되어 있었습니다. 오늘 만든 새로운 함수를 써서 보다 간결하게 표현할 수 있게 되었습니다. 그냥 함수를 읽기만 하면 저 코드는 '_항상 false를 반환하는구나_'하고 이해가 됩니다. \n\n사실 이 예제에서 `identity` 함수를 사용하기에는 어려움이 있습니다. `always`와 같이 사용하려면 `_confirm` 함수를 조금 바꿔줘야 합니다.\n\n#### (3) 오늘의 함수 - confirm 함수와의 콜라보 2\n```javascript\nfunction _confirm(message, yes_fn, no_fn) { \n  var res = confirm(message); // [1] confirm 함수의 실행 결과를 아래의 함수에 전달하기 위해 별도로 할당했습니다.\n  return res ? yes_fn(res) : no_fn(res); \n}\n\n$('li').on('click', 'button.delete', function(e) {\n  _confirm('Are you sure?', function() { \n    $(e.delegateTarget).remove();\n  }, identity) // [2] 항상 'false'를 반환하게 됩니다. \n})\n```\n\n`_confirm` 함수를 조금 바꿔서 `identity` 함수가 `always(false)`를 사용한 것과 같은 결과를 만들도록 했습니다. 보다 적절한 예제는 다음 시간에 소개해드릴 `pipe` 함수를 통해서 보여드릴 수 있을 것 같습니다.","source":"_posts/daily-fp-4.md","raw":"---\ntitle: '오늘의 함수 - identity, always'\ndate: 2017-03-20 23:41:48\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: 이름부터 심상치 않은 identity와 always 함수 입니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## identity, always 함수 \n\n오늘은 정말 황당한(?) 함수 두개를 소개하겠습니다. 이름부터 심상치 않은 `identity`와 `always` 함수 입니다. 오늘은 어제의 함수를 생략하고 곧장 함수 소개를 하겠습니다.\n\n#### (1) 오늘의 함수 - identity와 always\n```javascript\nfunction identity(value) {\n  return value;\n}\n\nfunction always(value) {\n  return function() {\n    return value;\n  }\n}\n\nconsole.log(identity(10)); // 10\nconsole.log(always(10)()); // 10\n```\n\n정말 황당한 함수입니다. 뭐하자는건가 싶습니다. 넣은 값을 그대로 반환할거면 왜 굳이 함수를 썼어야했나 싶습니다. 하지만 이 함수들은 아주 유용한 함수들입니다. 함수를 값으로 다루는 프로그래밍에서는 이 함수들은 아주 빈번하게 등장합니다. 지난번에 소개해드렸던 `confirm` 함수를 사용해서 예시를 만들어보겠습니다.\n\n#### (2) 오늘의 함수 - confirm 함수와의 콜라보 1\n```javascript\nfunction _confirm(message, yes_fn, no_fn) { // [1] 출력할 메시지와 성공, 실패에 따라 실행할 함수를 받는 confirm 함수입니다.\n  return confirm(message) ? yes_fn() : no_fn(); \n}\n\n$('li').on('click', 'button.delete', function(e) {\n  _confirm('Are you sure?', function() { // [2] '확인'을 눌렀을 때 동작하게될 함수입니다.\n    $(e.delegateTarget).remove();\n  }, always(false)) // [3] '취소'를 눌렀을 때 동작하게될 함수입니다. 이 경우에 항상 'false'를 반환하는 함수입니다.\n})\n```\n\n주목하셔야할 부분은 역시 `always` 함수가 등장한 [3] 지점입니다. 이전에는 해당 코드가 `function() { return false }`로 되어 있었습니다. 오늘 만든 새로운 함수를 써서 보다 간결하게 표현할 수 있게 되었습니다. 그냥 함수를 읽기만 하면 저 코드는 '_항상 false를 반환하는구나_'하고 이해가 됩니다. \n\n사실 이 예제에서 `identity` 함수를 사용하기에는 어려움이 있습니다. `always`와 같이 사용하려면 `_confirm` 함수를 조금 바꿔줘야 합니다.\n\n#### (3) 오늘의 함수 - confirm 함수와의 콜라보 2\n```javascript\nfunction _confirm(message, yes_fn, no_fn) { \n  var res = confirm(message); // [1] confirm 함수의 실행 결과를 아래의 함수에 전달하기 위해 별도로 할당했습니다.\n  return res ? yes_fn(res) : no_fn(res); \n}\n\n$('li').on('click', 'button.delete', function(e) {\n  _confirm('Are you sure?', function() { \n    $(e.delegateTarget).remove();\n  }, identity) // [2] 항상 'false'를 반환하게 됩니다. \n})\n```\n\n`_confirm` 함수를 조금 바꿔서 `identity` 함수가 `always(false)`를 사용한 것과 같은 결과를 만들도록 했습니다. 보다 적절한 예제는 다음 시간에 소개해드릴 `pipe` 함수를 통해서 보여드릴 수 있을 것 같습니다.","slug":"daily-fp-4","published":1,"updated":"2019-12-05T15:06:08.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9g6002jdirv4pd1ylx9","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"identity-always-함수\"><a href=\"#identity-always-함수\" class=\"headerlink\" title=\"identity, always 함수\"></a>identity, always 함수</h2><p>오늘은 정말 황당한(?) 함수 두개를 소개하겠습니다. 이름부터 심상치 않은 <code>identity</code>와 <code>always</code> 함수 입니다. 오늘은 어제의 함수를 생략하고 곧장 함수 소개를 하겠습니다.</p>\n<h4 id=\"1-오늘의-함수-identity와-always\"><a href=\"#1-오늘의-함수-identity와-always\" class=\"headerlink\" title=\"(1) 오늘의 함수 - identity와 always\"></a>(1) 오늘의 함수 - identity와 always</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">always</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(identity(<span class=\"number\">10</span>)); <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(always(<span class=\"number\">10</span>)()); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<p>정말 황당한 함수입니다. 뭐하자는건가 싶습니다. 넣은 값을 그대로 반환할거면 왜 굳이 함수를 썼어야했나 싶습니다. 하지만 이 함수들은 아주 유용한 함수들입니다. 함수를 값으로 다루는 프로그래밍에서는 이 함수들은 아주 빈번하게 등장합니다. 지난번에 소개해드렸던 <code>confirm</code> 함수를 사용해서 예시를 만들어보겠습니다.</p>\n<h4 id=\"2-오늘의-함수-confirm-함수와의-콜라보-1\"><a href=\"#2-오늘의-함수-confirm-함수와의-콜라보-1\" class=\"headerlink\" title=\"(2) 오늘의 함수 - confirm 함수와의 콜라보 1\"></a>(2) 오늘의 함수 - confirm 함수와의 콜라보 1</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_confirm</span>(<span class=\"params\">message, yes_fn, no_fn</span>) </span>&#123; <span class=\"comment\">// [1] 출력할 메시지와 성공, 실패에 따라 실행할 함수를 받는 confirm 함수입니다.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> confirm(message) ? yes_fn() : no_fn(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">'li'</span>).on(<span class=\"string\">'click'</span>, <span class=\"string\">'button.delete'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  _confirm(<span class=\"string\">'Are you sure?'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// [2] '확인'을 눌렀을 때 동작하게될 함수입니다.</span></span><br><span class=\"line\">    $(e.delegateTarget).remove();</span><br><span class=\"line\">  &#125;, always(<span class=\"literal\">false</span>)) <span class=\"comment\">// [3] '취소'를 눌렀을 때 동작하게될 함수입니다. 이 경우에 항상 'false'를 반환하는 함수입니다.</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>주목하셔야할 부분은 역시 <code>always</code> 함수가 등장한 [3] 지점입니다. 이전에는 해당 코드가 <code>function() { return false }</code>로 되어 있었습니다. 오늘 만든 새로운 함수를 써서 보다 간결하게 표현할 수 있게 되었습니다. 그냥 함수를 읽기만 하면 저 코드는 ‘<em>항상 false를 반환하는구나</em>‘하고 이해가 됩니다. </p>\n<p>사실 이 예제에서 <code>identity</code> 함수를 사용하기에는 어려움이 있습니다. <code>always</code>와 같이 사용하려면 <code>_confirm</code> 함수를 조금 바꿔줘야 합니다.</p>\n<h4 id=\"3-오늘의-함수-confirm-함수와의-콜라보-2\"><a href=\"#3-오늘의-함수-confirm-함수와의-콜라보-2\" class=\"headerlink\" title=\"(3) 오늘의 함수 - confirm 함수와의 콜라보 2\"></a>(3) 오늘의 함수 - confirm 함수와의 콜라보 2</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_confirm</span>(<span class=\"params\">message, yes_fn, no_fn</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> res = confirm(message); <span class=\"comment\">// [1] confirm 함수의 실행 결과를 아래의 함수에 전달하기 위해 별도로 할당했습니다.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res ? yes_fn(res) : no_fn(res); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">'li'</span>).on(<span class=\"string\">'click'</span>, <span class=\"string\">'button.delete'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  _confirm(<span class=\"string\">'Are you sure?'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    $(e.delegateTarget).remove();</span><br><span class=\"line\">  &#125;, identity) <span class=\"comment\">// [2] 항상 'false'를 반환하게 됩니다. </span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>_confirm</code> 함수를 조금 바꿔서 <code>identity</code> 함수가 <code>always(false)</code>를 사용한 것과 같은 결과를 만들도록 했습니다. 보다 적절한 예제는 다음 시간에 소개해드릴 <code>pipe</code> 함수를 통해서 보여드릴 수 있을 것 같습니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"identity-always-함수\"><a href=\"#identity-always-함수\" class=\"headerlink\" title=\"identity, always 함수\"></a>identity, always 함수</h2><p>오늘은 정말 황당한(?) 함수 두개를 소개하겠습니다. 이름부터 심상치 않은 <code>identity</code>와 <code>always</code> 함수 입니다. 오늘은 어제의 함수를 생략하고 곧장 함수 소개를 하겠습니다.</p>\n<h4 id=\"1-오늘의-함수-identity와-always\"><a href=\"#1-오늘의-함수-identity와-always\" class=\"headerlink\" title=\"(1) 오늘의 함수 - identity와 always\"></a>(1) 오늘의 함수 - identity와 always</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">always</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(identity(<span class=\"number\">10</span>)); <span class=\"comment\">// 10</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(always(<span class=\"number\">10</span>)()); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<p>정말 황당한 함수입니다. 뭐하자는건가 싶습니다. 넣은 값을 그대로 반환할거면 왜 굳이 함수를 썼어야했나 싶습니다. 하지만 이 함수들은 아주 유용한 함수들입니다. 함수를 값으로 다루는 프로그래밍에서는 이 함수들은 아주 빈번하게 등장합니다. 지난번에 소개해드렸던 <code>confirm</code> 함수를 사용해서 예시를 만들어보겠습니다.</p>\n<h4 id=\"2-오늘의-함수-confirm-함수와의-콜라보-1\"><a href=\"#2-오늘의-함수-confirm-함수와의-콜라보-1\" class=\"headerlink\" title=\"(2) 오늘의 함수 - confirm 함수와의 콜라보 1\"></a>(2) 오늘의 함수 - confirm 함수와의 콜라보 1</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_confirm</span>(<span class=\"params\">message, yes_fn, no_fn</span>) </span>&#123; <span class=\"comment\">// [1] 출력할 메시지와 성공, 실패에 따라 실행할 함수를 받는 confirm 함수입니다.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> confirm(message) ? yes_fn() : no_fn(); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">'li'</span>).on(<span class=\"string\">'click'</span>, <span class=\"string\">'button.delete'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  _confirm(<span class=\"string\">'Are you sure?'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// [2] '확인'을 눌렀을 때 동작하게될 함수입니다.</span></span><br><span class=\"line\">    $(e.delegateTarget).remove();</span><br><span class=\"line\">  &#125;, always(<span class=\"literal\">false</span>)) <span class=\"comment\">// [3] '취소'를 눌렀을 때 동작하게될 함수입니다. 이 경우에 항상 'false'를 반환하는 함수입니다.</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>주목하셔야할 부분은 역시 <code>always</code> 함수가 등장한 [3] 지점입니다. 이전에는 해당 코드가 <code>function() { return false }</code>로 되어 있었습니다. 오늘 만든 새로운 함수를 써서 보다 간결하게 표현할 수 있게 되었습니다. 그냥 함수를 읽기만 하면 저 코드는 ‘<em>항상 false를 반환하는구나</em>‘하고 이해가 됩니다. </p>\n<p>사실 이 예제에서 <code>identity</code> 함수를 사용하기에는 어려움이 있습니다. <code>always</code>와 같이 사용하려면 <code>_confirm</code> 함수를 조금 바꿔줘야 합니다.</p>\n<h4 id=\"3-오늘의-함수-confirm-함수와의-콜라보-2\"><a href=\"#3-오늘의-함수-confirm-함수와의-콜라보-2\" class=\"headerlink\" title=\"(3) 오늘의 함수 - confirm 함수와의 콜라보 2\"></a>(3) 오늘의 함수 - confirm 함수와의 콜라보 2</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_confirm</span>(<span class=\"params\">message, yes_fn, no_fn</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> res = confirm(message); <span class=\"comment\">// [1] confirm 함수의 실행 결과를 아래의 함수에 전달하기 위해 별도로 할당했습니다.</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res ? yes_fn(res) : no_fn(res); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">'li'</span>).on(<span class=\"string\">'click'</span>, <span class=\"string\">'button.delete'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  _confirm(<span class=\"string\">'Are you sure?'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    $(e.delegateTarget).remove();</span><br><span class=\"line\">  &#125;, identity) <span class=\"comment\">// [2] 항상 'false'를 반환하게 됩니다. </span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>_confirm</code> 함수를 조금 바꿔서 <code>identity</code> 함수가 <code>always(false)</code>를 사용한 것과 같은 결과를 만들도록 했습니다. 보다 적절한 예제는 다음 시간에 소개해드릴 <code>pipe</code> 함수를 통해서 보여드릴 수 있을 것 같습니다.</p>\n"},{"title":"오늘의 함수 - confirm","date":"2017-03-15T14:37:46.000Z","description":"새로운 함수를 만드는 것이 그렇게 화려한 일이 아님을 보여드리고 싶어 간단한 함수를 준비해봤습니다. 바로 confirm 함수 입니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## confirm 함수 \n\n오늘은 정말 단순한 함수입니다. 아이디어가 없어서라기보다 새로운 함수를 만드는 것이 그렇게 화려한 일이 아님을 보여드리고 싶어 간단한 함수를 준비해봤습니다. 바로 `confirm` 함수 입니다. 브라우저 환경에서 기본으로 제공하는 함수이기도 합니다. 기존의 사용법은 아래와 같습니다.\n\n이와 같은 형태의 html 소스 코드가 있다고 가정합니다. 사용자가 삭제 버튼을 누르면 지울 것인지 확인하는 메시지를 보여주고 확인 버튼을 누르면 해당 요소가 삭제되는 예제입니다.\n#### index.html\n```html\n<ul>\n  <li>\n    <span>요소 1번</span>\n    <button class=\"delete\">삭제</button>\n  </li>\n</ul>\n```\n\n#### 1번 - 어제의 함수\n```javascript\n$('li').on('click', 'button.delete', function(e) {\n  if (confirm('Are you sure?')) { // [1] 확인 창을 띄워 유저의 선택을 기다립니다. 그 결과에 따라 다음 코드를 실행합니다.\n    $(e.delegateTarget).remove(); // [2] 클릭했던 버튼의 부모 엘리먼트를 제거합니다.\n  } \n})\n```\n\n`confirm` 함수는 사용자가 어떤 버튼을 누르는가에 따라 `true`, `false` 값을 반환합니다. 보통은 이에 따라 실행되어야할 함수를 조건문으로 분기를 쳐둡니다. 이러한 조건문을 포함한 하나의 `confirm` 함수를 만들어 보았습니다. (구분을 위해 오늘의 함수 앞에 `_`를 붙였습니다.)\n\n#### 2번 - 오늘의 함수\n```javascript\nfunction _confirm(message, yes_fn, no_fn) {\n  return confirm(message) ? yes_fn() : no_fn(); // [1] 분기를 함수 안으로 가져왔습니다.\n}\n\n$('li').on('click', 'button.delete', function(e) {\n  _confirm('Are you sure?', function() { // [2] '확인'을 눌렀을 때 동작하게될 함수입니다.\n    $(e.delegateTarget).remove();\n  }, function() { return false; }) // [3] '취소'를 눌렀을 때 동작하게될 함수입니다.\n})\n```","source":"_posts/daily-fp-3.md","raw":"---\ntitle: '오늘의 함수 - confirm'\ndate: 2017-03-15 23:37:46\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: 새로운 함수를 만드는 것이 그렇게 화려한 일이 아님을 보여드리고 싶어 간단한 함수를 준비해봤습니다. 바로 confirm 함수 입니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## confirm 함수 \n\n오늘은 정말 단순한 함수입니다. 아이디어가 없어서라기보다 새로운 함수를 만드는 것이 그렇게 화려한 일이 아님을 보여드리고 싶어 간단한 함수를 준비해봤습니다. 바로 `confirm` 함수 입니다. 브라우저 환경에서 기본으로 제공하는 함수이기도 합니다. 기존의 사용법은 아래와 같습니다.\n\n이와 같은 형태의 html 소스 코드가 있다고 가정합니다. 사용자가 삭제 버튼을 누르면 지울 것인지 확인하는 메시지를 보여주고 확인 버튼을 누르면 해당 요소가 삭제되는 예제입니다.\n#### index.html\n```html\n<ul>\n  <li>\n    <span>요소 1번</span>\n    <button class=\"delete\">삭제</button>\n  </li>\n</ul>\n```\n\n#### 1번 - 어제의 함수\n```javascript\n$('li').on('click', 'button.delete', function(e) {\n  if (confirm('Are you sure?')) { // [1] 확인 창을 띄워 유저의 선택을 기다립니다. 그 결과에 따라 다음 코드를 실행합니다.\n    $(e.delegateTarget).remove(); // [2] 클릭했던 버튼의 부모 엘리먼트를 제거합니다.\n  } \n})\n```\n\n`confirm` 함수는 사용자가 어떤 버튼을 누르는가에 따라 `true`, `false` 값을 반환합니다. 보통은 이에 따라 실행되어야할 함수를 조건문으로 분기를 쳐둡니다. 이러한 조건문을 포함한 하나의 `confirm` 함수를 만들어 보았습니다. (구분을 위해 오늘의 함수 앞에 `_`를 붙였습니다.)\n\n#### 2번 - 오늘의 함수\n```javascript\nfunction _confirm(message, yes_fn, no_fn) {\n  return confirm(message) ? yes_fn() : no_fn(); // [1] 분기를 함수 안으로 가져왔습니다.\n}\n\n$('li').on('click', 'button.delete', function(e) {\n  _confirm('Are you sure?', function() { // [2] '확인'을 눌렀을 때 동작하게될 함수입니다.\n    $(e.delegateTarget).remove();\n  }, function() { return false; }) // [3] '취소'를 눌렀을 때 동작하게될 함수입니다.\n})\n```","slug":"daily-fp-3","published":1,"updated":"2019-12-05T15:06:08.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9g8002ndirv05zjitum","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"confirm-함수\"><a href=\"#confirm-함수\" class=\"headerlink\" title=\"confirm 함수\"></a>confirm 함수</h2><p>오늘은 정말 단순한 함수입니다. 아이디어가 없어서라기보다 새로운 함수를 만드는 것이 그렇게 화려한 일이 아님을 보여드리고 싶어 간단한 함수를 준비해봤습니다. 바로 <code>confirm</code> 함수 입니다. 브라우저 환경에서 기본으로 제공하는 함수이기도 합니다. 기존의 사용법은 아래와 같습니다.</p>\n<p>이와 같은 형태의 html 소스 코드가 있다고 가정합니다. 사용자가 삭제 버튼을 누르면 지울 것인지 확인하는 메시지를 보여주고 확인 버튼을 누르면 해당 요소가 삭제되는 예제입니다.</p>\n<h4 id=\"index-html\"><a href=\"#index-html\" class=\"headerlink\" title=\"index.html\"></a>index.html</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>요소 1번<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"delete\"</span>&gt;</span>삭제<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1번-어제의-함수\"><a href=\"#1번-어제의-함수\" class=\"headerlink\" title=\"1번 - 어제의 함수\"></a>1번 - 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">'li'</span>).on(<span class=\"string\">'click'</span>, <span class=\"string\">'button.delete'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (confirm(<span class=\"string\">'Are you sure?'</span>)) &#123; <span class=\"comment\">// [1] 확인 창을 띄워 유저의 선택을 기다립니다. 그 결과에 따라 다음 코드를 실행합니다.</span></span><br><span class=\"line\">    $(e.delegateTarget).remove(); <span class=\"comment\">// [2] 클릭했던 버튼의 부모 엘리먼트를 제거합니다.</span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>confirm</code> 함수는 사용자가 어떤 버튼을 누르는가에 따라 <code>true</code>, <code>false</code> 값을 반환합니다. 보통은 이에 따라 실행되어야할 함수를 조건문으로 분기를 쳐둡니다. 이러한 조건문을 포함한 하나의 <code>confirm</code> 함수를 만들어 보았습니다. (구분을 위해 오늘의 함수 앞에 <code>_</code>를 붙였습니다.)</p>\n<h4 id=\"2번-오늘의-함수\"><a href=\"#2번-오늘의-함수\" class=\"headerlink\" title=\"2번 - 오늘의 함수\"></a>2번 - 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_confirm</span>(<span class=\"params\">message, yes_fn, no_fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> confirm(message) ? yes_fn() : no_fn(); <span class=\"comment\">// [1] 분기를 함수 안으로 가져왔습니다.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">'li'</span>).on(<span class=\"string\">'click'</span>, <span class=\"string\">'button.delete'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  _confirm(<span class=\"string\">'Are you sure?'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// [2] '확인'을 눌렀을 때 동작하게될 함수입니다.</span></span><br><span class=\"line\">    $(e.delegateTarget).remove();</span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; &#125;) <span class=\"comment\">// [3] '취소'를 눌렀을 때 동작하게될 함수입니다.</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"confirm-함수\"><a href=\"#confirm-함수\" class=\"headerlink\" title=\"confirm 함수\"></a>confirm 함수</h2><p>오늘은 정말 단순한 함수입니다. 아이디어가 없어서라기보다 새로운 함수를 만드는 것이 그렇게 화려한 일이 아님을 보여드리고 싶어 간단한 함수를 준비해봤습니다. 바로 <code>confirm</code> 함수 입니다. 브라우저 환경에서 기본으로 제공하는 함수이기도 합니다. 기존의 사용법은 아래와 같습니다.</p>\n<p>이와 같은 형태의 html 소스 코드가 있다고 가정합니다. 사용자가 삭제 버튼을 누르면 지울 것인지 확인하는 메시지를 보여주고 확인 버튼을 누르면 해당 요소가 삭제되는 예제입니다.</p>\n<h4 id=\"index-html\"><a href=\"#index-html\" class=\"headerlink\" title=\"index.html\"></a>index.html</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>요소 1번<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">\"delete\"</span>&gt;</span>삭제<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1번-어제의-함수\"><a href=\"#1번-어제의-함수\" class=\"headerlink\" title=\"1번 - 어제의 함수\"></a>1번 - 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">'li'</span>).on(<span class=\"string\">'click'</span>, <span class=\"string\">'button.delete'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (confirm(<span class=\"string\">'Are you sure?'</span>)) &#123; <span class=\"comment\">// [1] 확인 창을 띄워 유저의 선택을 기다립니다. 그 결과에 따라 다음 코드를 실행합니다.</span></span><br><span class=\"line\">    $(e.delegateTarget).remove(); <span class=\"comment\">// [2] 클릭했던 버튼의 부모 엘리먼트를 제거합니다.</span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>confirm</code> 함수는 사용자가 어떤 버튼을 누르는가에 따라 <code>true</code>, <code>false</code> 값을 반환합니다. 보통은 이에 따라 실행되어야할 함수를 조건문으로 분기를 쳐둡니다. 이러한 조건문을 포함한 하나의 <code>confirm</code> 함수를 만들어 보았습니다. (구분을 위해 오늘의 함수 앞에 <code>_</code>를 붙였습니다.)</p>\n<h4 id=\"2번-오늘의-함수\"><a href=\"#2번-오늘의-함수\" class=\"headerlink\" title=\"2번 - 오늘의 함수\"></a>2번 - 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_confirm</span>(<span class=\"params\">message, yes_fn, no_fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> confirm(message) ? yes_fn() : no_fn(); <span class=\"comment\">// [1] 분기를 함수 안으로 가져왔습니다.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">'li'</span>).on(<span class=\"string\">'click'</span>, <span class=\"string\">'button.delete'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  _confirm(<span class=\"string\">'Are you sure?'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// [2] '확인'을 눌렀을 때 동작하게될 함수입니다.</span></span><br><span class=\"line\">    $(e.delegateTarget).remove();</span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; &#125;) <span class=\"comment\">// [3] '취소'를 눌렀을 때 동작하게될 함수입니다.</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>"},{"title":"오늘의 함수 - pipe","date":"2017-03-23T13:48:59.000Z","description":"이 함수는 underscore.js의 compose 함수와 같은 일을 합니다. 복수의 함수를 합쳐 하나의 함수로 만드는 것입니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## pipe 함수\n\n미리 예고드린 것처럼 오늘은 `pipe` 함수를 소개해드리겠습니다. 우선 이 함수는 underscore의 `compose` 함수와 같은 일을 합니다. 복수의 함수를 합쳐 하나의 함수로 만드는 것입니다. 사용법에 있어서 조금 차이가 있는데, 그 부분은 생략하겠습니다. 우선 `pipe` 함수가 필요한 아주 간단한 상황을 살펴보겠습니다.\n\n#### (1) 어제의 함수 - 함수의 연속 실행\n```javascript\nfunction add10(num) {\n  return num + 10;\n}\n\nvar result = add10(add10(add10(5))); // [1] add10 함수를 세번 실행합니다. 첫번째 인자는 5입니다.\nconsole.log(result); // [2] 결과는 35가 나옵니다.\n```\n\n아주 간단한 예제입니다. `add10` 함수는 값이 들어오면 10을 더해서 반환합니다. [1] 에서 함수를 세번 실행하고 있습니다. 5에 10을 세번 더해 35라는 값을 반환합니다. 이 예제의 포인트는 __함수가 값으로 쓰인다는 점__입니다. 가장 좌측에 위치한 `add10` 함수는 인자로 함수 하나를 갖고 있고 인자인 그 함수가 또 함수를 인자로 갖고 있습니다. 이렇듯 인자로 함수를 중첩해서 넘깁니다. 허나 실제로 실행되는 순서, 논리를 읽어나가는 순서는 우측에서부터 시작합니다. 5를 인자로 받은 함수가 먼저 실행되고 그 결과를 자신을 감싸고 있던 함수에 전달하는 식으로 진행됩니다. \n\n이렇게 함수를 값으로 전달함으로써 함수를 연속적으로 실행해서 결과를 얻어낼 수도 있습니다. 이제 오늘의 주인공 `pipe` 함수를 만나보겠습니다.\n\n#### (2) 오늘의 함수 - pipe 함수\n```javascript\nfunction pipe() {\n  var funcs = Array.prototype.slice.apply(arguments); \n  // [1] 함수에 들어온 인자(함수)들의 모임인 arguments를 배열로 만들어줍니다. (원래 arguments는 유사 배열입니다.)\n\n  return function(seed) {\n    return funcs.reduce(function(value, func) { \n      // [2] reduce 함수를 사용해서 함수의 실행 결과를 하나로 합칩니다.\n      return func(value);\n    }, seed);\n  };\n}\n\nvar add30 = pipe(add10, add10, add10); \n// [3] pipe 함수를 이용해 add10 함수를 세번 연속 호출하는 함수를 만듭니다.\n\nvar result1 = add30(5); // [4] 만들어진 함수로 결과를 만듭니다.\nvar result2 = add30(13); // [5] pipe로 만들어진 함수는 재사용 가능합니다.\n\nconsole.log(result1); // 35\nconsole.log(result2); // 43\n```\n","source":"_posts/daily-fp-5.md","raw":"---\ntitle: '오늘의 함수 - pipe'\ndate: 2017-03-23 22:48:59\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: 이 함수는 underscore.js의 compose 함수와 같은 일을 합니다. 복수의 함수를 합쳐 하나의 함수로 만드는 것입니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## pipe 함수\n\n미리 예고드린 것처럼 오늘은 `pipe` 함수를 소개해드리겠습니다. 우선 이 함수는 underscore의 `compose` 함수와 같은 일을 합니다. 복수의 함수를 합쳐 하나의 함수로 만드는 것입니다. 사용법에 있어서 조금 차이가 있는데, 그 부분은 생략하겠습니다. 우선 `pipe` 함수가 필요한 아주 간단한 상황을 살펴보겠습니다.\n\n#### (1) 어제의 함수 - 함수의 연속 실행\n```javascript\nfunction add10(num) {\n  return num + 10;\n}\n\nvar result = add10(add10(add10(5))); // [1] add10 함수를 세번 실행합니다. 첫번째 인자는 5입니다.\nconsole.log(result); // [2] 결과는 35가 나옵니다.\n```\n\n아주 간단한 예제입니다. `add10` 함수는 값이 들어오면 10을 더해서 반환합니다. [1] 에서 함수를 세번 실행하고 있습니다. 5에 10을 세번 더해 35라는 값을 반환합니다. 이 예제의 포인트는 __함수가 값으로 쓰인다는 점__입니다. 가장 좌측에 위치한 `add10` 함수는 인자로 함수 하나를 갖고 있고 인자인 그 함수가 또 함수를 인자로 갖고 있습니다. 이렇듯 인자로 함수를 중첩해서 넘깁니다. 허나 실제로 실행되는 순서, 논리를 읽어나가는 순서는 우측에서부터 시작합니다. 5를 인자로 받은 함수가 먼저 실행되고 그 결과를 자신을 감싸고 있던 함수에 전달하는 식으로 진행됩니다. \n\n이렇게 함수를 값으로 전달함으로써 함수를 연속적으로 실행해서 결과를 얻어낼 수도 있습니다. 이제 오늘의 주인공 `pipe` 함수를 만나보겠습니다.\n\n#### (2) 오늘의 함수 - pipe 함수\n```javascript\nfunction pipe() {\n  var funcs = Array.prototype.slice.apply(arguments); \n  // [1] 함수에 들어온 인자(함수)들의 모임인 arguments를 배열로 만들어줍니다. (원래 arguments는 유사 배열입니다.)\n\n  return function(seed) {\n    return funcs.reduce(function(value, func) { \n      // [2] reduce 함수를 사용해서 함수의 실행 결과를 하나로 합칩니다.\n      return func(value);\n    }, seed);\n  };\n}\n\nvar add30 = pipe(add10, add10, add10); \n// [3] pipe 함수를 이용해 add10 함수를 세번 연속 호출하는 함수를 만듭니다.\n\nvar result1 = add30(5); // [4] 만들어진 함수로 결과를 만듭니다.\nvar result2 = add30(13); // [5] pipe로 만들어진 함수는 재사용 가능합니다.\n\nconsole.log(result1); // 35\nconsole.log(result2); // 43\n```\n","slug":"daily-fp-5","published":1,"updated":"2019-12-05T15:06:08.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9ga002qdirvr6jw0tqb","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"pipe-함수\"><a href=\"#pipe-함수\" class=\"headerlink\" title=\"pipe 함수\"></a>pipe 함수</h2><p>미리 예고드린 것처럼 오늘은 <code>pipe</code> 함수를 소개해드리겠습니다. 우선 이 함수는 underscore의 <code>compose</code> 함수와 같은 일을 합니다. 복수의 함수를 합쳐 하나의 함수로 만드는 것입니다. 사용법에 있어서 조금 차이가 있는데, 그 부분은 생략하겠습니다. 우선 <code>pipe</code> 함수가 필요한 아주 간단한 상황을 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수-함수의-연속-실행\"><a href=\"#1-어제의-함수-함수의-연속-실행\" class=\"headerlink\" title=\"(1) 어제의 함수 - 함수의 연속 실행\"></a>(1) 어제의 함수 - 함수의 연속 실행</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add10</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num + <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = add10(add10(add10(<span class=\"number\">5</span>))); <span class=\"comment\">// [1] add10 함수를 세번 실행합니다. 첫번째 인자는 5입니다.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [2] 결과는 35가 나옵니다.</span></span><br></pre></td></tr></table></figure>\n\n<p>아주 간단한 예제입니다. <code>add10</code> 함수는 값이 들어오면 10을 더해서 반환합니다. [1] 에서 함수를 세번 실행하고 있습니다. 5에 10을 세번 더해 35라는 값을 반환합니다. 이 예제의 포인트는 <strong>함수가 값으로 쓰인다는 점</strong>입니다. 가장 좌측에 위치한 <code>add10</code> 함수는 인자로 함수 하나를 갖고 있고 인자인 그 함수가 또 함수를 인자로 갖고 있습니다. 이렇듯 인자로 함수를 중첩해서 넘깁니다. 허나 실제로 실행되는 순서, 논리를 읽어나가는 순서는 우측에서부터 시작합니다. 5를 인자로 받은 함수가 먼저 실행되고 그 결과를 자신을 감싸고 있던 함수에 전달하는 식으로 진행됩니다. </p>\n<p>이렇게 함수를 값으로 전달함으로써 함수를 연속적으로 실행해서 결과를 얻어낼 수도 있습니다. 이제 오늘의 주인공 <code>pipe</code> 함수를 만나보겠습니다.</p>\n<h4 id=\"2-오늘의-함수-pipe-함수\"><a href=\"#2-오늘의-함수-pipe-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수 - pipe 함수\"></a>(2) 오늘의 함수 - pipe 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pipe</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> funcs = <span class=\"built_in\">Array</span>.prototype.slice.apply(<span class=\"built_in\">arguments</span>); </span><br><span class=\"line\">  <span class=\"comment\">// [1] 함수에 들어온 인자(함수)들의 모임인 arguments를 배열로 만들어줍니다. (원래 arguments는 유사 배열입니다.)</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">seed</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, func</span>) </span>&#123; </span><br><span class=\"line\">      <span class=\"comment\">// [2] reduce 함수를 사용해서 함수의 실행 결과를 하나로 합칩니다.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> func(value);</span><br><span class=\"line\">    &#125;, seed);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> add30 = pipe(add10, add10, add10); </span><br><span class=\"line\"><span class=\"comment\">// [3] pipe 함수를 이용해 add10 함수를 세번 연속 호출하는 함수를 만듭니다.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result1 = add30(<span class=\"number\">5</span>); <span class=\"comment\">// [4] 만들어진 함수로 결과를 만듭니다.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result2 = add30(<span class=\"number\">13</span>); <span class=\"comment\">// [5] pipe로 만들어진 함수는 재사용 가능합니다.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result1); <span class=\"comment\">// 35</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result2); <span class=\"comment\">// 43</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"pipe-함수\"><a href=\"#pipe-함수\" class=\"headerlink\" title=\"pipe 함수\"></a>pipe 함수</h2><p>미리 예고드린 것처럼 오늘은 <code>pipe</code> 함수를 소개해드리겠습니다. 우선 이 함수는 underscore의 <code>compose</code> 함수와 같은 일을 합니다. 복수의 함수를 합쳐 하나의 함수로 만드는 것입니다. 사용법에 있어서 조금 차이가 있는데, 그 부분은 생략하겠습니다. 우선 <code>pipe</code> 함수가 필요한 아주 간단한 상황을 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수-함수의-연속-실행\"><a href=\"#1-어제의-함수-함수의-연속-실행\" class=\"headerlink\" title=\"(1) 어제의 함수 - 함수의 연속 실행\"></a>(1) 어제의 함수 - 함수의 연속 실행</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add10</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num + <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = add10(add10(add10(<span class=\"number\">5</span>))); <span class=\"comment\">// [1] add10 함수를 세번 실행합니다. 첫번째 인자는 5입니다.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [2] 결과는 35가 나옵니다.</span></span><br></pre></td></tr></table></figure>\n\n<p>아주 간단한 예제입니다. <code>add10</code> 함수는 값이 들어오면 10을 더해서 반환합니다. [1] 에서 함수를 세번 실행하고 있습니다. 5에 10을 세번 더해 35라는 값을 반환합니다. 이 예제의 포인트는 <strong>함수가 값으로 쓰인다는 점</strong>입니다. 가장 좌측에 위치한 <code>add10</code> 함수는 인자로 함수 하나를 갖고 있고 인자인 그 함수가 또 함수를 인자로 갖고 있습니다. 이렇듯 인자로 함수를 중첩해서 넘깁니다. 허나 실제로 실행되는 순서, 논리를 읽어나가는 순서는 우측에서부터 시작합니다. 5를 인자로 받은 함수가 먼저 실행되고 그 결과를 자신을 감싸고 있던 함수에 전달하는 식으로 진행됩니다. </p>\n<p>이렇게 함수를 값으로 전달함으로써 함수를 연속적으로 실행해서 결과를 얻어낼 수도 있습니다. 이제 오늘의 주인공 <code>pipe</code> 함수를 만나보겠습니다.</p>\n<h4 id=\"2-오늘의-함수-pipe-함수\"><a href=\"#2-오늘의-함수-pipe-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수 - pipe 함수\"></a>(2) 오늘의 함수 - pipe 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pipe</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> funcs = <span class=\"built_in\">Array</span>.prototype.slice.apply(<span class=\"built_in\">arguments</span>); </span><br><span class=\"line\">  <span class=\"comment\">// [1] 함수에 들어온 인자(함수)들의 모임인 arguments를 배열로 만들어줍니다. (원래 arguments는 유사 배열입니다.)</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">seed</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, func</span>) </span>&#123; </span><br><span class=\"line\">      <span class=\"comment\">// [2] reduce 함수를 사용해서 함수의 실행 결과를 하나로 합칩니다.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> func(value);</span><br><span class=\"line\">    &#125;, seed);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> add30 = pipe(add10, add10, add10); </span><br><span class=\"line\"><span class=\"comment\">// [3] pipe 함수를 이용해 add10 함수를 세번 연속 호출하는 함수를 만듭니다.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result1 = add30(<span class=\"number\">5</span>); <span class=\"comment\">// [4] 만들어진 함수로 결과를 만듭니다.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result2 = add30(<span class=\"number\">13</span>); <span class=\"comment\">// [5] pipe로 만들어진 함수는 재사용 가능합니다.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result1); <span class=\"comment\">// 35</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result2); <span class=\"comment\">// 43</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"오늘의 함수 - nest","date":"2017-03-28T14:07:24.000Z","description":"오늘은 중첩 객체를 만들어주는 함수를 소개드릴까합니다. 바로 nest 함수입니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## nest 함수\n\n[`pick` 함수 편](/programming/javascript-daily-function-1/)에서도 말씀드린 것처럼 자바스크립트에서 객체는 키(key)와 값(value)의 쌍입니다. 때론 값에 또 다시 객체를 담아 내부에 객체가 반복해서 등장하는 형태의 객체를 만들기도 합니다. 이런 객체를 중첩 객체(nested object)라고 부릅니다. 오늘은 이러한 중첩 객체를 만들어주는 함수를 소개드릴까합니다. 바로 `nest` 함수입니다.\n\n#### (1) 어제의 함수\n```javascript\n  var nested_obj = {};\n  nested_obj.first = {};\n  nested_obj.first.second = {};\n  nested_obj.first.second.third = \"I'm nested object.\";\n\n  console.log(nested_obj.first.second.third); // \"I'm nested object.\"\n```\n\n이처럼 중첩된 구조의 객체를 만들기 위해선 일일이 각 순서마다 객체를 생성해줘야하는 번거로운 작업이 수반됩니다. 하지만 `nest` 함수는 이를 한번에 만들어줍니다.\n\n#### (2) 오늘의 함수 - 중첩 객체 만들기\n```javascript\n  var nest = function(key, value) {\n    return key.split('.').reduceRight(valkey, value); // [1] 가장 끝의 인자를 먼저 생성하기 위해 reduceRight를 사용합니다.\n  };\n\n  function valkey(value, key) { // [2] 값과 키를 받아 객체를 만들어주는 함수입니다. (함수 이름은 value_and_key를 줄인 것입니다.)\n    return { [key] : value }; // [3] ES6부터 지원하는 문법입니다. (Computed property names) \n  }\n  \n  var nested_obj = nest('first.second.third', \"I'am nested object.\");\n  console.log(nested_obj.first.second.third); // \"I'm nested object.\"\n```","source":"_posts/daily-fp-6.md","raw":"---\ntitle: '오늘의 함수 - nest'\ndate: 2017-03-28 23:07:24\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: 오늘은 중첩 객체를 만들어주는 함수를 소개드릴까합니다. 바로 nest 함수입니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## nest 함수\n\n[`pick` 함수 편](/programming/javascript-daily-function-1/)에서도 말씀드린 것처럼 자바스크립트에서 객체는 키(key)와 값(value)의 쌍입니다. 때론 값에 또 다시 객체를 담아 내부에 객체가 반복해서 등장하는 형태의 객체를 만들기도 합니다. 이런 객체를 중첩 객체(nested object)라고 부릅니다. 오늘은 이러한 중첩 객체를 만들어주는 함수를 소개드릴까합니다. 바로 `nest` 함수입니다.\n\n#### (1) 어제의 함수\n```javascript\n  var nested_obj = {};\n  nested_obj.first = {};\n  nested_obj.first.second = {};\n  nested_obj.first.second.third = \"I'm nested object.\";\n\n  console.log(nested_obj.first.second.third); // \"I'm nested object.\"\n```\n\n이처럼 중첩된 구조의 객체를 만들기 위해선 일일이 각 순서마다 객체를 생성해줘야하는 번거로운 작업이 수반됩니다. 하지만 `nest` 함수는 이를 한번에 만들어줍니다.\n\n#### (2) 오늘의 함수 - 중첩 객체 만들기\n```javascript\n  var nest = function(key, value) {\n    return key.split('.').reduceRight(valkey, value); // [1] 가장 끝의 인자를 먼저 생성하기 위해 reduceRight를 사용합니다.\n  };\n\n  function valkey(value, key) { // [2] 값과 키를 받아 객체를 만들어주는 함수입니다. (함수 이름은 value_and_key를 줄인 것입니다.)\n    return { [key] : value }; // [3] ES6부터 지원하는 문법입니다. (Computed property names) \n  }\n  \n  var nested_obj = nest('first.second.third', \"I'am nested object.\");\n  console.log(nested_obj.first.second.third); // \"I'm nested object.\"\n```","slug":"daily-fp-6","published":1,"updated":"2019-12-05T15:06:08.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9gc002udirvo8c3qadi","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"nest-함수\"><a href=\"#nest-함수\" class=\"headerlink\" title=\"nest 함수\"></a>nest 함수</h2><p><a href=\"/programming/javascript-daily-function-1/\"><code>pick</code> 함수 편</a>에서도 말씀드린 것처럼 자바스크립트에서 객체는 키(key)와 값(value)의 쌍입니다. 때론 값에 또 다시 객체를 담아 내부에 객체가 반복해서 등장하는 형태의 객체를 만들기도 합니다. 이런 객체를 중첩 객체(nested object)라고 부릅니다. 오늘은 이러한 중첩 객체를 만들어주는 함수를 소개드릴까합니다. 바로 <code>nest</code> 함수입니다.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nested_obj = &#123;&#125;;</span><br><span class=\"line\">nested_obj.first = &#123;&#125;;</span><br><span class=\"line\">nested_obj.first.second = &#123;&#125;;</span><br><span class=\"line\">nested_obj.first.second.third = <span class=\"string\">\"I'm nested object.\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nested_obj.first.second.third); <span class=\"comment\">// \"I'm nested object.\"</span></span><br></pre></td></tr></table></figure>\n\n<p>이처럼 중첩된 구조의 객체를 만들기 위해선 일일이 각 순서마다 객체를 생성해줘야하는 번거로운 작업이 수반됩니다. 하지만 <code>nest</code> 함수는 이를 한번에 만들어줍니다.</p>\n<h4 id=\"2-오늘의-함수-중첩-객체-만들기\"><a href=\"#2-오늘의-함수-중첩-객체-만들기\" class=\"headerlink\" title=\"(2) 오늘의 함수 - 중첩 객체 만들기\"></a>(2) 오늘의 함수 - 중첩 객체 만들기</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nest = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> key.split(<span class=\"string\">'.'</span>).reduceRight(valkey, value); <span class=\"comment\">// [1] 가장 끝의 인자를 먼저 생성하기 위해 reduceRight를 사용합니다.</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">valkey</span>(<span class=\"params\">value, key</span>) </span>&#123; <span class=\"comment\">// [2] 값과 키를 받아 객체를 만들어주는 함수입니다. (함수 이름은 value_and_key를 줄인 것입니다.)</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; [key] : value &#125;; <span class=\"comment\">// [3] ES6부터 지원하는 문법입니다. (Computed property names) </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nested_obj = nest(<span class=\"string\">'first.second.third'</span>, <span class=\"string\">\"I'am nested object.\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nested_obj.first.second.third); <span class=\"comment\">// \"I'm nested object.\"</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"nest-함수\"><a href=\"#nest-함수\" class=\"headerlink\" title=\"nest 함수\"></a>nest 함수</h2><p><a href=\"/programming/javascript-daily-function-1/\"><code>pick</code> 함수 편</a>에서도 말씀드린 것처럼 자바스크립트에서 객체는 키(key)와 값(value)의 쌍입니다. 때론 값에 또 다시 객체를 담아 내부에 객체가 반복해서 등장하는 형태의 객체를 만들기도 합니다. 이런 객체를 중첩 객체(nested object)라고 부릅니다. 오늘은 이러한 중첩 객체를 만들어주는 함수를 소개드릴까합니다. 바로 <code>nest</code> 함수입니다.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nested_obj = &#123;&#125;;</span><br><span class=\"line\">nested_obj.first = &#123;&#125;;</span><br><span class=\"line\">nested_obj.first.second = &#123;&#125;;</span><br><span class=\"line\">nested_obj.first.second.third = <span class=\"string\">\"I'm nested object.\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nested_obj.first.second.third); <span class=\"comment\">// \"I'm nested object.\"</span></span><br></pre></td></tr></table></figure>\n\n<p>이처럼 중첩된 구조의 객체를 만들기 위해선 일일이 각 순서마다 객체를 생성해줘야하는 번거로운 작업이 수반됩니다. 하지만 <code>nest</code> 함수는 이를 한번에 만들어줍니다.</p>\n<h4 id=\"2-오늘의-함수-중첩-객체-만들기\"><a href=\"#2-오늘의-함수-중첩-객체-만들기\" class=\"headerlink\" title=\"(2) 오늘의 함수 - 중첩 객체 만들기\"></a>(2) 오늘의 함수 - 중첩 객체 만들기</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nest = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> key.split(<span class=\"string\">'.'</span>).reduceRight(valkey, value); <span class=\"comment\">// [1] 가장 끝의 인자를 먼저 생성하기 위해 reduceRight를 사용합니다.</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">valkey</span>(<span class=\"params\">value, key</span>) </span>&#123; <span class=\"comment\">// [2] 값과 키를 받아 객체를 만들어주는 함수입니다. (함수 이름은 value_and_key를 줄인 것입니다.)</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; [key] : value &#125;; <span class=\"comment\">// [3] ES6부터 지원하는 문법입니다. (Computed property names) </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nested_obj = nest(<span class=\"string\">'first.second.third'</span>, <span class=\"string\">\"I'am nested object.\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nested_obj.first.second.third); <span class=\"comment\">// \"I'm nested object.\"</span></span><br></pre></td></tr></table></figure>"},{"title":"오늘의 함수 - partial","date":"2017-04-19T14:41:48.000Z","description":"partial은 기존의 함수에 인자를 미리 적용해두는 일을 하는 함수입니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## partial 함수\n\n함수를 만들면서 프로그래밍을 하다보면 `pipe`와 같이 새로운 함수를 만들어주는 함수가 필요한 경우가 있습니다. 오늘 소개해드릴 `partial`도 그런 유형의 함수입니다. 사실 '새로운 함수'를 만들어준다고 보기에는 어려움이 있을 것 같습니다. 이 함수는 __기존의 함수에 인자를 미리 적용해두는 일을 하는 함수__입니다. 내장함수 중에서 `bind`와 같은 일을 합니다. \n\n#### (1) 어제의 함수 - 인자를 미리 적용해두기\n\n```javascript\nvar sum = function(a, b, c) {\n  return a + b + c;\n};\n\nvar sum10 = sum.bind(null, 10); // [1] 첫번째 인자로 넘긴 null은 this 값 입니다.\nvar sum20 = sum.bind(null, 10, 10);\nsum10(1, 2); // 13\nsum20(50); // 70\n```\n\n내장 함수를 사용하는 것도 나쁘지 않아보입니다. 하지만 이 함수에는 아쉬운 점이 있습니다. 반드시 순서대로 인자를 적용해야한다는 점입니다. 중간 인자를 건너뛰고 마지막 인자만 미리 적용해두고 싶을 땐 사용할 수 없다는 점이 아쉽습니다. 그래서 필요한 함수가 `partial`입니다. 우리가 원하는 '건너뛰고 적용하기'까지를 구현하기 위해선 평소보다 긴 함수를 정의해야 합니다. 고로 단계별로 함수를 발전시켜 보겠습니다.\n\n\n#### (2) 오늘의 함수 - 1단계: bind와 같은 수준의 partial\n\n```javascript\nvar partial = function(func, ...args1) { // [1] 인자를 적용해둘 대상이 되는 함수 func를 받고 적용될 인자 rest 파라미터를 이용해 배열로 받습니다. (args1 = 미리 적용된 인자)\n  return function(...args2) { // [2] 인자가 적용된 상태로 추가적인 인자를 받을 준비가 된 함수를 반환합니다. (args2 = 추가될 인자)\n    return func(...[...args1, ...args2]); // [3] 배열로 받은 인자들을 전개해서 함수에 값으로 전달하여 실행합니다. or 'return func.apply([...args1, ...args2])'\n  }\n}\n\nvar sum10 = partial(sum, 10);\nvar sum20 = partial(sum, 10, 10);\nsum10(1, 2); // 13\nsum20(50); // 70\n```\n\nES6에 새롭게 추가된 기능인 [Spread 연산자](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_operator)를 사용했습니다. 덕분에 코드가 간결해졌습니다. 결과적으로 `bind`와 같은 역할을 하는 함수가 만들어졌습니다. 현재 상황에서는 여전히 인자를 순서대로 적용해야만합니다. 다음 단계에서 건너뛰기가 가능하도록 만들어보겠습니다.\n\n\n#### (3) 오늘의 함수 - 2단계: 건너뛰기가 가능한 partial\n\n```javascript\nvar _ = {}; // [1] 건너뛰기의 단서가 될 키워드를 하나 만들어둡니다.\nvar partial = function(func, ...args) {\n  return function(...args2) {\n    var args1 = args.slice(); // [2] 생성된 클로저의 값이 변경되는 것을 막기 위해 배열을 복제합니다.\n\n    for (var i in args1) { \n      if (args1[i] === _) { // [3] 단서인 키워드와 일치하는 값이면 \n        args1[i] = args2.shift(); // [4] 그 자리에 추가될 인자 값을 넣어줍니다.\n      }\n    }\n\n    return func(...[...args1, ...args2]);\n  }\n}\n\nvar sum10 = partial(sum, 10);\nvar sum20 = partial(sum, _, 20);\nsum10(1, 2); // 13\nsum20(50, 50); // 120\n\nvar test = function(a, b, c, d) { // [5] 네개의 인자를 받아 출력하는 테스트 함수입니다.\n  console.log(a, b, c, d);\n}\n\nvar skip = partial(test, 1, _, 3); // [6] 건너뛰기 키워드를 사용해서 인자 b와 d의 값을 지정하지 않은 채로 skip 함수를 생성합니다.\nskip(20, 40); // [7] 인자 b와 d에 값이 적용됩니다. 결과 값은 1, 20, 3, 40\n```\n\n(건너뛰기라는 표현이 와닿지 않을 수도 있을 것 같아 부연설명합니다. 미리 적용될 인자를 나중에 적용하도록 유보시킨다는 관점에서는 '건너뛰기'라고 말할 수 있지만 다음에 들어올 인자의 자리를 비워둔다는 관점으로는 '비워두기'가 더 적절한 표현일 것 같습니다. 비워둔 자리에 두번째로 들어오는 인자 값이 적용된다고 이해하시면 좋을 것 같습니다.)","source":"_posts/daily-fp-7.md","raw":"---\ntitle: '오늘의 함수 - partial'\ndate: 2017-04-19 23:41:48\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: partial은 기존의 함수에 인자를 미리 적용해두는 일을 하는 함수입니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## partial 함수\n\n함수를 만들면서 프로그래밍을 하다보면 `pipe`와 같이 새로운 함수를 만들어주는 함수가 필요한 경우가 있습니다. 오늘 소개해드릴 `partial`도 그런 유형의 함수입니다. 사실 '새로운 함수'를 만들어준다고 보기에는 어려움이 있을 것 같습니다. 이 함수는 __기존의 함수에 인자를 미리 적용해두는 일을 하는 함수__입니다. 내장함수 중에서 `bind`와 같은 일을 합니다. \n\n#### (1) 어제의 함수 - 인자를 미리 적용해두기\n\n```javascript\nvar sum = function(a, b, c) {\n  return a + b + c;\n};\n\nvar sum10 = sum.bind(null, 10); // [1] 첫번째 인자로 넘긴 null은 this 값 입니다.\nvar sum20 = sum.bind(null, 10, 10);\nsum10(1, 2); // 13\nsum20(50); // 70\n```\n\n내장 함수를 사용하는 것도 나쁘지 않아보입니다. 하지만 이 함수에는 아쉬운 점이 있습니다. 반드시 순서대로 인자를 적용해야한다는 점입니다. 중간 인자를 건너뛰고 마지막 인자만 미리 적용해두고 싶을 땐 사용할 수 없다는 점이 아쉽습니다. 그래서 필요한 함수가 `partial`입니다. 우리가 원하는 '건너뛰고 적용하기'까지를 구현하기 위해선 평소보다 긴 함수를 정의해야 합니다. 고로 단계별로 함수를 발전시켜 보겠습니다.\n\n\n#### (2) 오늘의 함수 - 1단계: bind와 같은 수준의 partial\n\n```javascript\nvar partial = function(func, ...args1) { // [1] 인자를 적용해둘 대상이 되는 함수 func를 받고 적용될 인자 rest 파라미터를 이용해 배열로 받습니다. (args1 = 미리 적용된 인자)\n  return function(...args2) { // [2] 인자가 적용된 상태로 추가적인 인자를 받을 준비가 된 함수를 반환합니다. (args2 = 추가될 인자)\n    return func(...[...args1, ...args2]); // [3] 배열로 받은 인자들을 전개해서 함수에 값으로 전달하여 실행합니다. or 'return func.apply([...args1, ...args2])'\n  }\n}\n\nvar sum10 = partial(sum, 10);\nvar sum20 = partial(sum, 10, 10);\nsum10(1, 2); // 13\nsum20(50); // 70\n```\n\nES6에 새롭게 추가된 기능인 [Spread 연산자](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_operator)를 사용했습니다. 덕분에 코드가 간결해졌습니다. 결과적으로 `bind`와 같은 역할을 하는 함수가 만들어졌습니다. 현재 상황에서는 여전히 인자를 순서대로 적용해야만합니다. 다음 단계에서 건너뛰기가 가능하도록 만들어보겠습니다.\n\n\n#### (3) 오늘의 함수 - 2단계: 건너뛰기가 가능한 partial\n\n```javascript\nvar _ = {}; // [1] 건너뛰기의 단서가 될 키워드를 하나 만들어둡니다.\nvar partial = function(func, ...args) {\n  return function(...args2) {\n    var args1 = args.slice(); // [2] 생성된 클로저의 값이 변경되는 것을 막기 위해 배열을 복제합니다.\n\n    for (var i in args1) { \n      if (args1[i] === _) { // [3] 단서인 키워드와 일치하는 값이면 \n        args1[i] = args2.shift(); // [4] 그 자리에 추가될 인자 값을 넣어줍니다.\n      }\n    }\n\n    return func(...[...args1, ...args2]);\n  }\n}\n\nvar sum10 = partial(sum, 10);\nvar sum20 = partial(sum, _, 20);\nsum10(1, 2); // 13\nsum20(50, 50); // 120\n\nvar test = function(a, b, c, d) { // [5] 네개의 인자를 받아 출력하는 테스트 함수입니다.\n  console.log(a, b, c, d);\n}\n\nvar skip = partial(test, 1, _, 3); // [6] 건너뛰기 키워드를 사용해서 인자 b와 d의 값을 지정하지 않은 채로 skip 함수를 생성합니다.\nskip(20, 40); // [7] 인자 b와 d에 값이 적용됩니다. 결과 값은 1, 20, 3, 40\n```\n\n(건너뛰기라는 표현이 와닿지 않을 수도 있을 것 같아 부연설명합니다. 미리 적용될 인자를 나중에 적용하도록 유보시킨다는 관점에서는 '건너뛰기'라고 말할 수 있지만 다음에 들어올 인자의 자리를 비워둔다는 관점으로는 '비워두기'가 더 적절한 표현일 것 같습니다. 비워둔 자리에 두번째로 들어오는 인자 값이 적용된다고 이해하시면 좋을 것 같습니다.)","slug":"daily-fp-7","published":1,"updated":"2019-12-05T15:06:08.857Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9ge002xdirvi33icg5u","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"partial-함수\"><a href=\"#partial-함수\" class=\"headerlink\" title=\"partial 함수\"></a>partial 함수</h2><p>함수를 만들면서 프로그래밍을 하다보면 <code>pipe</code>와 같이 새로운 함수를 만들어주는 함수가 필요한 경우가 있습니다. 오늘 소개해드릴 <code>partial</code>도 그런 유형의 함수입니다. 사실 ‘새로운 함수’를 만들어준다고 보기에는 어려움이 있을 것 같습니다. 이 함수는 <strong>기존의 함수에 인자를 미리 적용해두는 일을 하는 함수</strong>입니다. 내장함수 중에서 <code>bind</code>와 같은 일을 합니다. </p>\n<h4 id=\"1-어제의-함수-인자를-미리-적용해두기\"><a href=\"#1-어제의-함수-인자를-미리-적용해두기\" class=\"headerlink\" title=\"(1) 어제의 함수 - 인자를 미리 적용해두기\"></a>(1) 어제의 함수 - 인자를 미리 적용해두기</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b + c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum10 = sum.bind(<span class=\"literal\">null</span>, <span class=\"number\">10</span>); <span class=\"comment\">// [1] 첫번째 인자로 넘긴 null은 this 값 입니다.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum20 = sum.bind(<span class=\"literal\">null</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">sum10(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 13</span></span><br><span class=\"line\">sum20(<span class=\"number\">50</span>); <span class=\"comment\">// 70</span></span><br></pre></td></tr></table></figure>\n\n<p>내장 함수를 사용하는 것도 나쁘지 않아보입니다. 하지만 이 함수에는 아쉬운 점이 있습니다. 반드시 순서대로 인자를 적용해야한다는 점입니다. 중간 인자를 건너뛰고 마지막 인자만 미리 적용해두고 싶을 땐 사용할 수 없다는 점이 아쉽습니다. 그래서 필요한 함수가 <code>partial</code>입니다. 우리가 원하는 ‘건너뛰고 적용하기’까지를 구현하기 위해선 평소보다 긴 함수를 정의해야 합니다. 고로 단계별로 함수를 발전시켜 보겠습니다.</p>\n<h4 id=\"2-오늘의-함수-1단계-bind와-같은-수준의-partial\"><a href=\"#2-오늘의-함수-1단계-bind와-같은-수준의-partial\" class=\"headerlink\" title=\"(2) 오늘의 함수 - 1단계: bind와 같은 수준의 partial\"></a>(2) 오늘의 함수 - 1단계: bind와 같은 수준의 partial</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> partial = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, ...args1</span>) </span>&#123; <span class=\"comment\">// [1] 인자를 적용해둘 대상이 되는 함수 func를 받고 적용될 인자 rest 파라미터를 이용해 배열로 받습니다. (args1 = 미리 적용된 인자)</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args2</span>) </span>&#123; <span class=\"comment\">// [2] 인자가 적용된 상태로 추가적인 인자를 받을 준비가 된 함수를 반환합니다. (args2 = 추가될 인자)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(...[...args1, ...args2]); <span class=\"comment\">// [3] 배열로 받은 인자들을 전개해서 함수에 값으로 전달하여 실행합니다. or 'return func.apply([...args1, ...args2])'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum10 = partial(sum, <span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum20 = partial(sum, <span class=\"number\">10</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">sum10(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 13</span></span><br><span class=\"line\">sum20(<span class=\"number\">50</span>); <span class=\"comment\">// 70</span></span><br></pre></td></tr></table></figure>\n\n<p>ES6에 새롭게 추가된 기능인 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_operator\" target=\"_blank\" rel=\"noopener\">Spread 연산자</a>를 사용했습니다. 덕분에 코드가 간결해졌습니다. 결과적으로 <code>bind</code>와 같은 역할을 하는 함수가 만들어졌습니다. 현재 상황에서는 여전히 인자를 순서대로 적용해야만합니다. 다음 단계에서 건너뛰기가 가능하도록 만들어보겠습니다.</p>\n<h4 id=\"3-오늘의-함수-2단계-건너뛰기가-가능한-partial\"><a href=\"#3-오늘의-함수-2단계-건너뛰기가-가능한-partial\" class=\"headerlink\" title=\"(3) 오늘의 함수 - 2단계: 건너뛰기가 가능한 partial\"></a>(3) 오늘의 함수 - 2단계: 건너뛰기가 가능한 partial</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _ = &#123;&#125;; <span class=\"comment\">// [1] 건너뛰기의 단서가 될 키워드를 하나 만들어둡니다.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> partial = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args1 = args.slice(); <span class=\"comment\">// [2] 생성된 클로저의 값이 변경되는 것을 막기 위해 배열을 복제합니다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> args1) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (args1[i] === _) &#123; <span class=\"comment\">// [3] 단서인 키워드와 일치하는 값이면 </span></span><br><span class=\"line\">        args1[i] = args2.shift(); <span class=\"comment\">// [4] 그 자리에 추가될 인자 값을 넣어줍니다.</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(...[...args1, ...args2]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum10 = partial(sum, <span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum20 = partial(sum, _, <span class=\"number\">20</span>);</span><br><span class=\"line\">sum10(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 13</span></span><br><span class=\"line\">sum20(<span class=\"number\">50</span>, <span class=\"number\">50</span>); <span class=\"comment\">// 120</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c, d</span>) </span>&#123; <span class=\"comment\">// [5] 네개의 인자를 받아 출력하는 테스트 함수입니다.</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a, b, c, d);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> skip = partial(test, <span class=\"number\">1</span>, _, <span class=\"number\">3</span>); <span class=\"comment\">// [6] 건너뛰기 키워드를 사용해서 인자 b와 d의 값을 지정하지 않은 채로 skip 함수를 생성합니다.</span></span><br><span class=\"line\">skip(<span class=\"number\">20</span>, <span class=\"number\">40</span>); <span class=\"comment\">// [7] 인자 b와 d에 값이 적용됩니다. 결과 값은 1, 20, 3, 40</span></span><br></pre></td></tr></table></figure>\n\n<p>(건너뛰기라는 표현이 와닿지 않을 수도 있을 것 같아 부연설명합니다. 미리 적용될 인자를 나중에 적용하도록 유보시킨다는 관점에서는 ‘건너뛰기’라고 말할 수 있지만 다음에 들어올 인자의 자리를 비워둔다는 관점으로는 ‘비워두기’가 더 적절한 표현일 것 같습니다. 비워둔 자리에 두번째로 들어오는 인자 값이 적용된다고 이해하시면 좋을 것 같습니다.)</p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"partial-함수\"><a href=\"#partial-함수\" class=\"headerlink\" title=\"partial 함수\"></a>partial 함수</h2><p>함수를 만들면서 프로그래밍을 하다보면 <code>pipe</code>와 같이 새로운 함수를 만들어주는 함수가 필요한 경우가 있습니다. 오늘 소개해드릴 <code>partial</code>도 그런 유형의 함수입니다. 사실 ‘새로운 함수’를 만들어준다고 보기에는 어려움이 있을 것 같습니다. 이 함수는 <strong>기존의 함수에 인자를 미리 적용해두는 일을 하는 함수</strong>입니다. 내장함수 중에서 <code>bind</code>와 같은 일을 합니다. </p>\n<h4 id=\"1-어제의-함수-인자를-미리-적용해두기\"><a href=\"#1-어제의-함수-인자를-미리-적용해두기\" class=\"headerlink\" title=\"(1) 어제의 함수 - 인자를 미리 적용해두기\"></a>(1) 어제의 함수 - 인자를 미리 적용해두기</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b + c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum10 = sum.bind(<span class=\"literal\">null</span>, <span class=\"number\">10</span>); <span class=\"comment\">// [1] 첫번째 인자로 넘긴 null은 this 값 입니다.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum20 = sum.bind(<span class=\"literal\">null</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">sum10(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 13</span></span><br><span class=\"line\">sum20(<span class=\"number\">50</span>); <span class=\"comment\">// 70</span></span><br></pre></td></tr></table></figure>\n\n<p>내장 함수를 사용하는 것도 나쁘지 않아보입니다. 하지만 이 함수에는 아쉬운 점이 있습니다. 반드시 순서대로 인자를 적용해야한다는 점입니다. 중간 인자를 건너뛰고 마지막 인자만 미리 적용해두고 싶을 땐 사용할 수 없다는 점이 아쉽습니다. 그래서 필요한 함수가 <code>partial</code>입니다. 우리가 원하는 ‘건너뛰고 적용하기’까지를 구현하기 위해선 평소보다 긴 함수를 정의해야 합니다. 고로 단계별로 함수를 발전시켜 보겠습니다.</p>\n<h4 id=\"2-오늘의-함수-1단계-bind와-같은-수준의-partial\"><a href=\"#2-오늘의-함수-1단계-bind와-같은-수준의-partial\" class=\"headerlink\" title=\"(2) 오늘의 함수 - 1단계: bind와 같은 수준의 partial\"></a>(2) 오늘의 함수 - 1단계: bind와 같은 수준의 partial</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> partial = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, ...args1</span>) </span>&#123; <span class=\"comment\">// [1] 인자를 적용해둘 대상이 되는 함수 func를 받고 적용될 인자 rest 파라미터를 이용해 배열로 받습니다. (args1 = 미리 적용된 인자)</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args2</span>) </span>&#123; <span class=\"comment\">// [2] 인자가 적용된 상태로 추가적인 인자를 받을 준비가 된 함수를 반환합니다. (args2 = 추가될 인자)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(...[...args1, ...args2]); <span class=\"comment\">// [3] 배열로 받은 인자들을 전개해서 함수에 값으로 전달하여 실행합니다. or 'return func.apply([...args1, ...args2])'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum10 = partial(sum, <span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum20 = partial(sum, <span class=\"number\">10</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">sum10(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 13</span></span><br><span class=\"line\">sum20(<span class=\"number\">50</span>); <span class=\"comment\">// 70</span></span><br></pre></td></tr></table></figure>\n\n<p>ES6에 새롭게 추가된 기능인 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_operator\" target=\"_blank\" rel=\"noopener\">Spread 연산자</a>를 사용했습니다. 덕분에 코드가 간결해졌습니다. 결과적으로 <code>bind</code>와 같은 역할을 하는 함수가 만들어졌습니다. 현재 상황에서는 여전히 인자를 순서대로 적용해야만합니다. 다음 단계에서 건너뛰기가 가능하도록 만들어보겠습니다.</p>\n<h4 id=\"3-오늘의-함수-2단계-건너뛰기가-가능한-partial\"><a href=\"#3-오늘의-함수-2단계-건너뛰기가-가능한-partial\" class=\"headerlink\" title=\"(3) 오늘의 함수 - 2단계: 건너뛰기가 가능한 partial\"></a>(3) 오늘의 함수 - 2단계: 건너뛰기가 가능한 partial</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _ = &#123;&#125;; <span class=\"comment\">// [1] 건너뛰기의 단서가 될 키워드를 하나 만들어둡니다.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> partial = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args1 = args.slice(); <span class=\"comment\">// [2] 생성된 클로저의 값이 변경되는 것을 막기 위해 배열을 복제합니다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> args1) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (args1[i] === _) &#123; <span class=\"comment\">// [3] 단서인 키워드와 일치하는 값이면 </span></span><br><span class=\"line\">        args1[i] = args2.shift(); <span class=\"comment\">// [4] 그 자리에 추가될 인자 값을 넣어줍니다.</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(...[...args1, ...args2]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum10 = partial(sum, <span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum20 = partial(sum, _, <span class=\"number\">20</span>);</span><br><span class=\"line\">sum10(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 13</span></span><br><span class=\"line\">sum20(<span class=\"number\">50</span>, <span class=\"number\">50</span>); <span class=\"comment\">// 120</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c, d</span>) </span>&#123; <span class=\"comment\">// [5] 네개의 인자를 받아 출력하는 테스트 함수입니다.</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a, b, c, d);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> skip = partial(test, <span class=\"number\">1</span>, _, <span class=\"number\">3</span>); <span class=\"comment\">// [6] 건너뛰기 키워드를 사용해서 인자 b와 d의 값을 지정하지 않은 채로 skip 함수를 생성합니다.</span></span><br><span class=\"line\">skip(<span class=\"number\">20</span>, <span class=\"number\">40</span>); <span class=\"comment\">// [7] 인자 b와 d에 값이 적용됩니다. 결과 값은 1, 20, 3, 40</span></span><br></pre></td></tr></table></figure>\n\n<p>(건너뛰기라는 표현이 와닿지 않을 수도 있을 것 같아 부연설명합니다. 미리 적용될 인자를 나중에 적용하도록 유보시킨다는 관점에서는 ‘건너뛰기’라고 말할 수 있지만 다음에 들어올 인자의 자리를 비워둔다는 관점으로는 ‘비워두기’가 더 적절한 표현일 것 같습니다. 비워둔 자리에 두번째로 들어오는 인자 값이 적용된다고 이해하시면 좋을 것 같습니다.)</p>\n"},{"title":"오늘의 함수 - partial2","date":"2017-04-26T13:54:34.000Z","description":"지난 시간에 만든 partial 함수보다 향상된 버전의 함수를 준비해보았습니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## partial2 함수\n\n오늘은 지난 시간에 만든 `partial` 함수보다 향상된 버전의 함수를 준비해보았습니다. 지난 함수와 구분 짓기 위해 `partial2`라고 이름 붙였지만 하는 일은 같습니다. 인자가 미리 적용된 함수를 반환하는 함수입니다. 간단히 이전의 함수를 살펴보겠습니다.\n\n#### (1) 어제의 함수 - partial\n\n```javascript\nvar _ = {}; // [1] 건너뛰기의 단서가 될 키워드를 하나 만들어둡니다.\nvar partial = function(func, ...args) {\n  return function(...args2) {\n    var args1 = args.slice(); // [2] 생성된 클로저의 값이 변경되는 것을 막기 위해 배열을 복제합니다.\n\n    for (var i in args1) { \n      if (args1[i] === _) { // [3] 단서인 키워드와 일치하는 값이면 \n        args1[i] = args2.shift(); // [4] 그 자리에 추가될 인자 값을 넣어줍니다.\n      }\n    }\n\n    return func(...[...args1, ...args2]);\n  }\n}\n\nvar sum = function(a, b, c) {\n  return a + b + c;\n};\n\nvar sum10 = partial(sum, 10);\nvar sum20 = partial(sum, _, 20);\nsum10(1, 2); // 13\nsum20(50, 50); // 120\n\nvar log = partial(console.log, 0, _, 0, 0, _, 0);\nlog(1,2,3); // 0 1 0 0 2 0 3\n```\n\n이번에 기존 `partial` 함수에 아쉬운 점은 '유연함'입니다. 인자를 조금 더 유연하게 받을 수 있다면 좋지 않을까요? 건너뛰기를 위한 단서인 `_`는 한번에 한 칸만 건너뜁니다. 몇번을 건너뛸지 알 수 없을 때 두번째로 들어오는 인자에 따라 유연하게 건너뛸 수 있다면 조금 더 편할 것 같습니다. 바로 오늘의 주인공인 `partial2`입니다.\n\n\n#### (2) 오늘의 함수 - partial2\n\n```javascript\nvar partial2 = function(func, ...parts) {\n  var parts1 = [], parts2 = [], ___idx = parts.length;\n\n  for (var i in parts) {\n    if (parts[i] == ___) {\n      ___idx = i; \n    }\n    else if (i < ___idx) {\n      parts1.push(parts[i]);\n    }\n    else {\n      parts2.push(parts[i]);\n    }\n  }\n\n\n  return function(...args) {\n    var args1 = parts1.slice(), \n        args2 = parts2.slice(),\n        rest = args.slice();\n\n    for (var i in args1) {\n      if (args1[i] == _) {\n        args1[i] = rest.shift(); \n      }\n    }     \n      \n    for (var i in args2) {\n      if (args2[i] == _) {\n        args2[i] = rest.pop();\n      }\n    }\n\n    return func(...[...args1, ...rest, ...args2]);\n  }\n}\n\nvar log = partial2(console.log, 0, _, 0, ___, 0, _, 0);\nlog(1,2,3,4,5,6,7,8,9,10); // 0 1 0 2 3 4 5 6 7 8 9 0 10 0\n\nvar greeting = partial2(console.log, 'Hello,', _, ___, 'Nice to meet you.');\ngreeting('Joeun.', 'My name is', 'Momo.', '\\n', 'I\\'m', 27, 'years old.\\n'); \n/* \nHello, Joeun. \n My name is Momo. \n I'm 27 years old. \n Nice to meet you.  \n*/\n```","source":"_posts/daily-fp-8.md","raw":"---\ntitle: '오늘의 함수 - partial2'\ndate: 2017-04-26 22:54:34\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: 지난 시간에 만든 partial 함수보다 향상된 버전의 함수를 준비해보았습니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## partial2 함수\n\n오늘은 지난 시간에 만든 `partial` 함수보다 향상된 버전의 함수를 준비해보았습니다. 지난 함수와 구분 짓기 위해 `partial2`라고 이름 붙였지만 하는 일은 같습니다. 인자가 미리 적용된 함수를 반환하는 함수입니다. 간단히 이전의 함수를 살펴보겠습니다.\n\n#### (1) 어제의 함수 - partial\n\n```javascript\nvar _ = {}; // [1] 건너뛰기의 단서가 될 키워드를 하나 만들어둡니다.\nvar partial = function(func, ...args) {\n  return function(...args2) {\n    var args1 = args.slice(); // [2] 생성된 클로저의 값이 변경되는 것을 막기 위해 배열을 복제합니다.\n\n    for (var i in args1) { \n      if (args1[i] === _) { // [3] 단서인 키워드와 일치하는 값이면 \n        args1[i] = args2.shift(); // [4] 그 자리에 추가될 인자 값을 넣어줍니다.\n      }\n    }\n\n    return func(...[...args1, ...args2]);\n  }\n}\n\nvar sum = function(a, b, c) {\n  return a + b + c;\n};\n\nvar sum10 = partial(sum, 10);\nvar sum20 = partial(sum, _, 20);\nsum10(1, 2); // 13\nsum20(50, 50); // 120\n\nvar log = partial(console.log, 0, _, 0, 0, _, 0);\nlog(1,2,3); // 0 1 0 0 2 0 3\n```\n\n이번에 기존 `partial` 함수에 아쉬운 점은 '유연함'입니다. 인자를 조금 더 유연하게 받을 수 있다면 좋지 않을까요? 건너뛰기를 위한 단서인 `_`는 한번에 한 칸만 건너뜁니다. 몇번을 건너뛸지 알 수 없을 때 두번째로 들어오는 인자에 따라 유연하게 건너뛸 수 있다면 조금 더 편할 것 같습니다. 바로 오늘의 주인공인 `partial2`입니다.\n\n\n#### (2) 오늘의 함수 - partial2\n\n```javascript\nvar partial2 = function(func, ...parts) {\n  var parts1 = [], parts2 = [], ___idx = parts.length;\n\n  for (var i in parts) {\n    if (parts[i] == ___) {\n      ___idx = i; \n    }\n    else if (i < ___idx) {\n      parts1.push(parts[i]);\n    }\n    else {\n      parts2.push(parts[i]);\n    }\n  }\n\n\n  return function(...args) {\n    var args1 = parts1.slice(), \n        args2 = parts2.slice(),\n        rest = args.slice();\n\n    for (var i in args1) {\n      if (args1[i] == _) {\n        args1[i] = rest.shift(); \n      }\n    }     \n      \n    for (var i in args2) {\n      if (args2[i] == _) {\n        args2[i] = rest.pop();\n      }\n    }\n\n    return func(...[...args1, ...rest, ...args2]);\n  }\n}\n\nvar log = partial2(console.log, 0, _, 0, ___, 0, _, 0);\nlog(1,2,3,4,5,6,7,8,9,10); // 0 1 0 2 3 4 5 6 7 8 9 0 10 0\n\nvar greeting = partial2(console.log, 'Hello,', _, ___, 'Nice to meet you.');\ngreeting('Joeun.', 'My name is', 'Momo.', '\\n', 'I\\'m', 27, 'years old.\\n'); \n/* \nHello, Joeun. \n My name is Momo. \n I'm 27 years old. \n Nice to meet you.  \n*/\n```","slug":"daily-fp-8","published":1,"updated":"2019-12-05T15:06:08.857Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9gg0031dirvwqacvjxj","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"partial2-함수\"><a href=\"#partial2-함수\" class=\"headerlink\" title=\"partial2 함수\"></a>partial2 함수</h2><p>오늘은 지난 시간에 만든 <code>partial</code> 함수보다 향상된 버전의 함수를 준비해보았습니다. 지난 함수와 구분 짓기 위해 <code>partial2</code>라고 이름 붙였지만 하는 일은 같습니다. 인자가 미리 적용된 함수를 반환하는 함수입니다. 간단히 이전의 함수를 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수-partial\"><a href=\"#1-어제의-함수-partial\" class=\"headerlink\" title=\"(1) 어제의 함수 - partial\"></a>(1) 어제의 함수 - partial</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _ = &#123;&#125;; <span class=\"comment\">// [1] 건너뛰기의 단서가 될 키워드를 하나 만들어둡니다.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> partial = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args1 = args.slice(); <span class=\"comment\">// [2] 생성된 클로저의 값이 변경되는 것을 막기 위해 배열을 복제합니다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> args1) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (args1[i] === _) &#123; <span class=\"comment\">// [3] 단서인 키워드와 일치하는 값이면 </span></span><br><span class=\"line\">        args1[i] = args2.shift(); <span class=\"comment\">// [4] 그 자리에 추가될 인자 값을 넣어줍니다.</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(...[...args1, ...args2]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b + c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum10 = partial(sum, <span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum20 = partial(sum, _, <span class=\"number\">20</span>);</span><br><span class=\"line\">sum10(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 13</span></span><br><span class=\"line\">sum20(<span class=\"number\">50</span>, <span class=\"number\">50</span>); <span class=\"comment\">// 120</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> log = partial(<span class=\"built_in\">console</span>.log, <span class=\"number\">0</span>, _, <span class=\"number\">0</span>, <span class=\"number\">0</span>, _, <span class=\"number\">0</span>);</span><br><span class=\"line\">log(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>); <span class=\"comment\">// 0 1 0 0 2 0 3</span></span><br></pre></td></tr></table></figure>\n\n<p>이번에 기존 <code>partial</code> 함수에 아쉬운 점은 ‘유연함’입니다. 인자를 조금 더 유연하게 받을 수 있다면 좋지 않을까요? 건너뛰기를 위한 단서인 <code>_</code>는 한번에 한 칸만 건너뜁니다. 몇번을 건너뛸지 알 수 없을 때 두번째로 들어오는 인자에 따라 유연하게 건너뛸 수 있다면 조금 더 편할 것 같습니다. 바로 오늘의 주인공인 <code>partial2</code>입니다.</p>\n<h4 id=\"2-오늘의-함수-partial2\"><a href=\"#2-오늘의-함수-partial2\" class=\"headerlink\" title=\"(2) 오늘의 함수 - partial2\"></a>(2) 오늘의 함수 - partial2</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> partial2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, ...parts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> parts1 = [], parts2 = [], ___idx = parts.length;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> parts) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parts[i] == ___) &#123;</span><br><span class=\"line\">      ___idx = i; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &lt; ___idx) &#123;</span><br><span class=\"line\">      parts1.push(parts[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      parts2.push(parts[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args1 = parts1.slice(), </span><br><span class=\"line\">        args2 = parts2.slice(),</span><br><span class=\"line\">        rest = args.slice();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> args1) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (args1[i] == _) &#123;</span><br><span class=\"line\">        args1[i] = rest.shift(); </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;     </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> args2) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (args2[i] == _) &#123;</span><br><span class=\"line\">        args2[i] = rest.pop();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(...[...args1, ...rest, ...args2]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> log = partial2(<span class=\"built_in\">console</span>.log, <span class=\"number\">0</span>, _, <span class=\"number\">0</span>, ___, <span class=\"number\">0</span>, _, <span class=\"number\">0</span>);</span><br><span class=\"line\">log(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>); <span class=\"comment\">// 0 1 0 2 3 4 5 6 7 8 9 0 10 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> greeting = partial2(<span class=\"built_in\">console</span>.log, <span class=\"string\">'Hello,'</span>, _, ___, <span class=\"string\">'Nice to meet you.'</span>);</span><br><span class=\"line\">greeting(<span class=\"string\">'Joeun.'</span>, <span class=\"string\">'My name is'</span>, <span class=\"string\">'Momo.'</span>, <span class=\"string\">'\\n'</span>, <span class=\"string\">'I\\'m'</span>, <span class=\"number\">27</span>, <span class=\"string\">'years old.\\n'</span>); </span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">Hello, Joeun. </span></span><br><span class=\"line\"><span class=\"comment\"> My name is Momo. </span></span><br><span class=\"line\"><span class=\"comment\"> I'm 27 years old. </span></span><br><span class=\"line\"><span class=\"comment\"> Nice to meet you.  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"partial2-함수\"><a href=\"#partial2-함수\" class=\"headerlink\" title=\"partial2 함수\"></a>partial2 함수</h2><p>오늘은 지난 시간에 만든 <code>partial</code> 함수보다 향상된 버전의 함수를 준비해보았습니다. 지난 함수와 구분 짓기 위해 <code>partial2</code>라고 이름 붙였지만 하는 일은 같습니다. 인자가 미리 적용된 함수를 반환하는 함수입니다. 간단히 이전의 함수를 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수-partial\"><a href=\"#1-어제의-함수-partial\" class=\"headerlink\" title=\"(1) 어제의 함수 - partial\"></a>(1) 어제의 함수 - partial</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _ = &#123;&#125;; <span class=\"comment\">// [1] 건너뛰기의 단서가 될 키워드를 하나 만들어둡니다.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> partial = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args1 = args.slice(); <span class=\"comment\">// [2] 생성된 클로저의 값이 변경되는 것을 막기 위해 배열을 복제합니다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> args1) &#123; </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (args1[i] === _) &#123; <span class=\"comment\">// [3] 단서인 키워드와 일치하는 값이면 </span></span><br><span class=\"line\">        args1[i] = args2.shift(); <span class=\"comment\">// [4] 그 자리에 추가될 인자 값을 넣어줍니다.</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(...[...args1, ...args2]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b + c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum10 = partial(sum, <span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum20 = partial(sum, _, <span class=\"number\">20</span>);</span><br><span class=\"line\">sum10(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 13</span></span><br><span class=\"line\">sum20(<span class=\"number\">50</span>, <span class=\"number\">50</span>); <span class=\"comment\">// 120</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> log = partial(<span class=\"built_in\">console</span>.log, <span class=\"number\">0</span>, _, <span class=\"number\">0</span>, <span class=\"number\">0</span>, _, <span class=\"number\">0</span>);</span><br><span class=\"line\">log(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>); <span class=\"comment\">// 0 1 0 0 2 0 3</span></span><br></pre></td></tr></table></figure>\n\n<p>이번에 기존 <code>partial</code> 함수에 아쉬운 점은 ‘유연함’입니다. 인자를 조금 더 유연하게 받을 수 있다면 좋지 않을까요? 건너뛰기를 위한 단서인 <code>_</code>는 한번에 한 칸만 건너뜁니다. 몇번을 건너뛸지 알 수 없을 때 두번째로 들어오는 인자에 따라 유연하게 건너뛸 수 있다면 조금 더 편할 것 같습니다. 바로 오늘의 주인공인 <code>partial2</code>입니다.</p>\n<h4 id=\"2-오늘의-함수-partial2\"><a href=\"#2-오늘의-함수-partial2\" class=\"headerlink\" title=\"(2) 오늘의 함수 - partial2\"></a>(2) 오늘의 함수 - partial2</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> partial2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">func, ...parts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> parts1 = [], parts2 = [], ___idx = parts.length;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> parts) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parts[i] == ___) &#123;</span><br><span class=\"line\">      ___idx = i; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i &lt; ___idx) &#123;</span><br><span class=\"line\">      parts1.push(parts[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      parts2.push(parts[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args1 = parts1.slice(), </span><br><span class=\"line\">        args2 = parts2.slice(),</span><br><span class=\"line\">        rest = args.slice();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> args1) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (args1[i] == _) &#123;</span><br><span class=\"line\">        args1[i] = rest.shift(); </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;     </span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> args2) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (args2[i] == _) &#123;</span><br><span class=\"line\">        args2[i] = rest.pop();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(...[...args1, ...rest, ...args2]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> log = partial2(<span class=\"built_in\">console</span>.log, <span class=\"number\">0</span>, _, <span class=\"number\">0</span>, ___, <span class=\"number\">0</span>, _, <span class=\"number\">0</span>);</span><br><span class=\"line\">log(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>); <span class=\"comment\">// 0 1 0 2 3 4 5 6 7 8 9 0 10 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> greeting = partial2(<span class=\"built_in\">console</span>.log, <span class=\"string\">'Hello,'</span>, _, ___, <span class=\"string\">'Nice to meet you.'</span>);</span><br><span class=\"line\">greeting(<span class=\"string\">'Joeun.'</span>, <span class=\"string\">'My name is'</span>, <span class=\"string\">'Momo.'</span>, <span class=\"string\">'\\n'</span>, <span class=\"string\">'I\\'m'</span>, <span class=\"number\">27</span>, <span class=\"string\">'years old.\\n'</span>); </span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">Hello, Joeun. </span></span><br><span class=\"line\"><span class=\"comment\"> My name is Momo. </span></span><br><span class=\"line\"><span class=\"comment\"> I'm 27 years old. </span></span><br><span class=\"line\"><span class=\"comment\"> Nice to meet you.  </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>"},{"title":"오늘의 함수 - omit","date":"2017-06-12T11:59:55.000Z","description":"오늘은 pick 함수의 반대 버전인 omit을 소개해드릴까 합니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## omit\n\n오늘은 `pick` 함수의 반대 버전인 `omit`을 소개해드릴까 합니다. 다시 말해 `omit`은 객체에서 키가 일치하는 프로퍼티를 제외한 새로운 객체를 반환하는 함수입니다. \n\n사실 이 함수를 굳이 소개할 필요가 있을까 싶었는데, 사연이 생겨서 올리게 되었습니다. 2주 전쯤 [Codewars](https://www.codewars.com/kumite/)라는 사이트에서 제공하는 'kumite'(일본어로 대련을 의미합니다.) 페이지에 `pick` 함수를 올려두었습니다. 그리고 며칠 뒤 `omit`과 같은 일을 하는 `flick`함수를 대련 코드로 올리셨기에 살펴보다가 블로그에 소개하면 좋겠다고 생각해서 올리게 되었습니다.\n\n우선 [Codewars](https://www.codewars.com/kumite/59421af0c32f438c1a000044?sel=595073a15ceb2bda6d000161)에 올려둔 코드 전체를 보여드리겠습니다.\n\n#### (1) pick 함수와 flick 함수\n```javascript\nvar _ = {};\n\n// [1] 제가 작성한 pick 함수입니다. 기존의 pick과 크게 다르지 않습니다.\n_.pick = (target, ...keys) => {\n  if (typeof keys[0] == 'function') {\n\n    var predicate = keys[0];\n    keys = Object.keys(target);\n    \n    return keys.reduce((obj, key) => {\n      return predicate(target[key], key, target) ? (obj[key] = target[key], obj) : obj;\n    }, {})\n  }\n\n  return keys.reduce((obj, key) => {\n    return obj[key] = target[key], obj;\n  }, {});\n};\n\n// [2] Robert.Cutright이라는 개발자가 작성한 flick 함수입니다. omit 함수와 같은 일을 합니다.\n_.flick = (target, ...keys) => {\n  if (typeof keys[0] == 'function') {\n\n    var predicate = keys[0];\n    keys = Object.keys(target);\n    \n    return keys.reduce((obj, key) => {\n      return predicate(target[key], key, target) ? obj : (obj[key] = target[key], obj);\n    }, {})\n  }\n\n  var obj = Object.assign({}, target);\n  Object.keys(obj).filter(key => keys.includes(key) ? delete obj[key] : obj[key]);\n  return obj;\n};\n```\n\nRobert가 작성한 코드는 정상적으로 동작합니다. 하지만 저는 한가지가 아쉬웠습니다. 바로 `filter`를 사용한 부분입니다. `reduce`를 사용하면 새로운 객체 복사본을 만드는 `var obj = Object.assign({}, target);` 같은 코드를 작성하지 않아도 된다는 점을 놓친 것 같았습니다. 그리고 이렇게 새로운 객체를 생성해서 `delete obj[key]`로 데이터를 제거해나가는 코드는 불필요한 코드라는 생각이 들었습니다. 그래서 아래와 같이 변경했습니다.\n\n```javascript\n_.omit = (target, ...keys) => {\n  if (typeof keys[0] == 'function') {\n\t  var predicate = keys[0];\n    return _.pick(target, (...args) => !predicate(...args)) // [1] pick을 사용하고 predicate를 뒤집었습니다.\n  }\n  \n  return Object.keys(target).reduce((obj, key) => { // [2] reduce를 사용하면서 새로운 객체를 복사한 뒤 요소를 제거하지 않고 바로 생성합니다.\n    return keys.includes(key) ? obj : (obj[key] = target[key], obj);\n  }, {});\n};\n```\n","source":"_posts/daily-fp-9.md","raw":"---\ntitle: '오늘의 함수 - omit'\ndate: 2017-06-12 20:59:55\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: 오늘은 pick 함수의 반대 버전인 omit을 소개해드릴까 합니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## omit\n\n오늘은 `pick` 함수의 반대 버전인 `omit`을 소개해드릴까 합니다. 다시 말해 `omit`은 객체에서 키가 일치하는 프로퍼티를 제외한 새로운 객체를 반환하는 함수입니다. \n\n사실 이 함수를 굳이 소개할 필요가 있을까 싶었는데, 사연이 생겨서 올리게 되었습니다. 2주 전쯤 [Codewars](https://www.codewars.com/kumite/)라는 사이트에서 제공하는 'kumite'(일본어로 대련을 의미합니다.) 페이지에 `pick` 함수를 올려두었습니다. 그리고 며칠 뒤 `omit`과 같은 일을 하는 `flick`함수를 대련 코드로 올리셨기에 살펴보다가 블로그에 소개하면 좋겠다고 생각해서 올리게 되었습니다.\n\n우선 [Codewars](https://www.codewars.com/kumite/59421af0c32f438c1a000044?sel=595073a15ceb2bda6d000161)에 올려둔 코드 전체를 보여드리겠습니다.\n\n#### (1) pick 함수와 flick 함수\n```javascript\nvar _ = {};\n\n// [1] 제가 작성한 pick 함수입니다. 기존의 pick과 크게 다르지 않습니다.\n_.pick = (target, ...keys) => {\n  if (typeof keys[0] == 'function') {\n\n    var predicate = keys[0];\n    keys = Object.keys(target);\n    \n    return keys.reduce((obj, key) => {\n      return predicate(target[key], key, target) ? (obj[key] = target[key], obj) : obj;\n    }, {})\n  }\n\n  return keys.reduce((obj, key) => {\n    return obj[key] = target[key], obj;\n  }, {});\n};\n\n// [2] Robert.Cutright이라는 개발자가 작성한 flick 함수입니다. omit 함수와 같은 일을 합니다.\n_.flick = (target, ...keys) => {\n  if (typeof keys[0] == 'function') {\n\n    var predicate = keys[0];\n    keys = Object.keys(target);\n    \n    return keys.reduce((obj, key) => {\n      return predicate(target[key], key, target) ? obj : (obj[key] = target[key], obj);\n    }, {})\n  }\n\n  var obj = Object.assign({}, target);\n  Object.keys(obj).filter(key => keys.includes(key) ? delete obj[key] : obj[key]);\n  return obj;\n};\n```\n\nRobert가 작성한 코드는 정상적으로 동작합니다. 하지만 저는 한가지가 아쉬웠습니다. 바로 `filter`를 사용한 부분입니다. `reduce`를 사용하면 새로운 객체 복사본을 만드는 `var obj = Object.assign({}, target);` 같은 코드를 작성하지 않아도 된다는 점을 놓친 것 같았습니다. 그리고 이렇게 새로운 객체를 생성해서 `delete obj[key]`로 데이터를 제거해나가는 코드는 불필요한 코드라는 생각이 들었습니다. 그래서 아래와 같이 변경했습니다.\n\n```javascript\n_.omit = (target, ...keys) => {\n  if (typeof keys[0] == 'function') {\n\t  var predicate = keys[0];\n    return _.pick(target, (...args) => !predicate(...args)) // [1] pick을 사용하고 predicate를 뒤집었습니다.\n  }\n  \n  return Object.keys(target).reduce((obj, key) => { // [2] reduce를 사용하면서 새로운 객체를 복사한 뒤 요소를 제거하지 않고 바로 생성합니다.\n    return keys.includes(key) ? obj : (obj[key] = target[key], obj);\n  }, {});\n};\n```\n","slug":"daily-fp-9","published":1,"updated":"2019-12-05T15:06:08.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9gi0034dirvrhjh54yo","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"omit\"><a href=\"#omit\" class=\"headerlink\" title=\"omit\"></a>omit</h2><p>오늘은 <code>pick</code> 함수의 반대 버전인 <code>omit</code>을 소개해드릴까 합니다. 다시 말해 <code>omit</code>은 객체에서 키가 일치하는 프로퍼티를 제외한 새로운 객체를 반환하는 함수입니다. </p>\n<p>사실 이 함수를 굳이 소개할 필요가 있을까 싶었는데, 사연이 생겨서 올리게 되었습니다. 2주 전쯤 <a href=\"https://www.codewars.com/kumite/\" target=\"_blank\" rel=\"noopener\">Codewars</a>라는 사이트에서 제공하는 ‘kumite’(일본어로 대련을 의미합니다.) 페이지에 <code>pick</code> 함수를 올려두었습니다. 그리고 며칠 뒤 <code>omit</code>과 같은 일을 하는 <code>flick</code>함수를 대련 코드로 올리셨기에 살펴보다가 블로그에 소개하면 좋겠다고 생각해서 올리게 되었습니다.</p>\n<p>우선 <a href=\"https://www.codewars.com/kumite/59421af0c32f438c1a000044?sel=595073a15ceb2bda6d000161\" target=\"_blank\" rel=\"noopener\">Codewars</a>에 올려둔 코드 전체를 보여드리겠습니다.</p>\n<h4 id=\"1-pick-함수와-flick-함수\"><a href=\"#1-pick-함수와-flick-함수\" class=\"headerlink\" title=\"(1) pick 함수와 flick 함수\"></a>(1) pick 함수와 flick 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _ = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [1] 제가 작성한 pick 함수입니다. 기존의 pick과 크게 다르지 않습니다.</span></span><br><span class=\"line\">_.pick = <span class=\"function\">(<span class=\"params\">target, ...keys</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> keys[<span class=\"number\">0</span>] == <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> predicate = keys[<span class=\"number\">0</span>];</span><br><span class=\"line\">    keys = <span class=\"built_in\">Object</span>.keys(target);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> keys.reduce(<span class=\"function\">(<span class=\"params\">obj, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> predicate(target[key], key, target) ? (obj[key] = target[key], obj) : obj;</span><br><span class=\"line\">    &#125;, &#123;&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> keys.reduce(<span class=\"function\">(<span class=\"params\">obj, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj[key] = target[key], obj;</span><br><span class=\"line\">  &#125;, &#123;&#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [2] Robert.Cutright이라는 개발자가 작성한 flick 함수입니다. omit 함수와 같은 일을 합니다.</span></span><br><span class=\"line\">_.flick = <span class=\"function\">(<span class=\"params\">target, ...keys</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> keys[<span class=\"number\">0</span>] == <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> predicate = keys[<span class=\"number\">0</span>];</span><br><span class=\"line\">    keys = <span class=\"built_in\">Object</span>.keys(target);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> keys.reduce(<span class=\"function\">(<span class=\"params\">obj, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> predicate(target[key], key, target) ? obj : (obj[key] = target[key], obj);</span><br><span class=\"line\">    &#125;, &#123;&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, target);</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(obj).filter(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> keys.includes(key) ? <span class=\"keyword\">delete</span> obj[key] : obj[key]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Robert가 작성한 코드는 정상적으로 동작합니다. 하지만 저는 한가지가 아쉬웠습니다. 바로 <code>filter</code>를 사용한 부분입니다. <code>reduce</code>를 사용하면 새로운 객체 복사본을 만드는 <code>var obj = Object.assign({}, target);</code> 같은 코드를 작성하지 않아도 된다는 점을 놓친 것 같았습니다. 그리고 이렇게 새로운 객체를 생성해서 <code>delete obj[key]</code>로 데이터를 제거해나가는 코드는 불필요한 코드라는 생각이 들었습니다. 그래서 아래와 같이 변경했습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.omit = <span class=\"function\">(<span class=\"params\">target, ...keys</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> keys[<span class=\"number\">0</span>] == <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">var</span> predicate = keys[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.pick(target, (...args) =&gt; !predicate(...args)) <span class=\"comment\">// [1] pick을 사용하고 predicate를 뒤집었습니다.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(target).reduce(<span class=\"function\">(<span class=\"params\">obj, key</span>) =&gt;</span> &#123; <span class=\"comment\">// [2] reduce를 사용하면서 새로운 객체를 복사한 뒤 요소를 제거하지 않고 바로 생성합니다.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> keys.includes(key) ? obj : (obj[key] = target[key], obj);</span><br><span class=\"line\">  &#125;, &#123;&#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"omit\"><a href=\"#omit\" class=\"headerlink\" title=\"omit\"></a>omit</h2><p>오늘은 <code>pick</code> 함수의 반대 버전인 <code>omit</code>을 소개해드릴까 합니다. 다시 말해 <code>omit</code>은 객체에서 키가 일치하는 프로퍼티를 제외한 새로운 객체를 반환하는 함수입니다. </p>\n<p>사실 이 함수를 굳이 소개할 필요가 있을까 싶었는데, 사연이 생겨서 올리게 되었습니다. 2주 전쯤 <a href=\"https://www.codewars.com/kumite/\" target=\"_blank\" rel=\"noopener\">Codewars</a>라는 사이트에서 제공하는 ‘kumite’(일본어로 대련을 의미합니다.) 페이지에 <code>pick</code> 함수를 올려두었습니다. 그리고 며칠 뒤 <code>omit</code>과 같은 일을 하는 <code>flick</code>함수를 대련 코드로 올리셨기에 살펴보다가 블로그에 소개하면 좋겠다고 생각해서 올리게 되었습니다.</p>\n<p>우선 <a href=\"https://www.codewars.com/kumite/59421af0c32f438c1a000044?sel=595073a15ceb2bda6d000161\" target=\"_blank\" rel=\"noopener\">Codewars</a>에 올려둔 코드 전체를 보여드리겠습니다.</p>\n<h4 id=\"1-pick-함수와-flick-함수\"><a href=\"#1-pick-함수와-flick-함수\" class=\"headerlink\" title=\"(1) pick 함수와 flick 함수\"></a>(1) pick 함수와 flick 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _ = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [1] 제가 작성한 pick 함수입니다. 기존의 pick과 크게 다르지 않습니다.</span></span><br><span class=\"line\">_.pick = <span class=\"function\">(<span class=\"params\">target, ...keys</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> keys[<span class=\"number\">0</span>] == <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> predicate = keys[<span class=\"number\">0</span>];</span><br><span class=\"line\">    keys = <span class=\"built_in\">Object</span>.keys(target);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> keys.reduce(<span class=\"function\">(<span class=\"params\">obj, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> predicate(target[key], key, target) ? (obj[key] = target[key], obj) : obj;</span><br><span class=\"line\">    &#125;, &#123;&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> keys.reduce(<span class=\"function\">(<span class=\"params\">obj, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj[key] = target[key], obj;</span><br><span class=\"line\">  &#125;, &#123;&#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [2] Robert.Cutright이라는 개발자가 작성한 flick 함수입니다. omit 함수와 같은 일을 합니다.</span></span><br><span class=\"line\">_.flick = <span class=\"function\">(<span class=\"params\">target, ...keys</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> keys[<span class=\"number\">0</span>] == <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> predicate = keys[<span class=\"number\">0</span>];</span><br><span class=\"line\">    keys = <span class=\"built_in\">Object</span>.keys(target);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> keys.reduce(<span class=\"function\">(<span class=\"params\">obj, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> predicate(target[key], key, target) ? obj : (obj[key] = target[key], obj);</span><br><span class=\"line\">    &#125;, &#123;&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, target);</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(obj).filter(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span> keys.includes(key) ? <span class=\"keyword\">delete</span> obj[key] : obj[key]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Robert가 작성한 코드는 정상적으로 동작합니다. 하지만 저는 한가지가 아쉬웠습니다. 바로 <code>filter</code>를 사용한 부분입니다. <code>reduce</code>를 사용하면 새로운 객체 복사본을 만드는 <code>var obj = Object.assign({}, target);</code> 같은 코드를 작성하지 않아도 된다는 점을 놓친 것 같았습니다. 그리고 이렇게 새로운 객체를 생성해서 <code>delete obj[key]</code>로 데이터를 제거해나가는 코드는 불필요한 코드라는 생각이 들었습니다. 그래서 아래와 같이 변경했습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.omit = <span class=\"function\">(<span class=\"params\">target, ...keys</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> keys[<span class=\"number\">0</span>] == <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">var</span> predicate = keys[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.pick(target, (...args) =&gt; !predicate(...args)) <span class=\"comment\">// [1] pick을 사용하고 predicate를 뒤집었습니다.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(target).reduce(<span class=\"function\">(<span class=\"params\">obj, key</span>) =&gt;</span> &#123; <span class=\"comment\">// [2] reduce를 사용하면서 새로운 객체를 복사한 뒤 요소를 제거하지 않고 바로 생성합니다.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> keys.includes(key) ? obj : (obj[key] = target[key], obj);</span><br><span class=\"line\">  &#125;, &#123;&#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"[C] fork, execlp, wait 함수","date":"2016-03-25T15:27:03.000Z","author":"rabby","layout":"post","_content":"운영체제를 배우고 있습니다. 이전 글에서 프로그램, 프로세스 그리고 스레드에 대해 다뤘습니다. 오늘은 `fork`, `execlp`, `wait` 함수를 살펴보겠습니다.\n\n이 세 함수는 앞서 살펴본 프로세스와 연관을 맺고 있는 함수입니다. 각각 복사, 대체, 대기를 담당하는 함수들입니다. 오늘은 예시와 함께 살펴보도록 하겠습니다. 예시는 C 언어로 작성되었습니다.\n\n먼저 `fork` 함수 입니다. 이 함수는 프로세스를 복사(duplicate)합니다. 이때 복사가 되어지는 원본을 parent 라고 부르고 복사가 된 복사본을 child 라고 부릅니다. 자식은 부모의 판박이라 복사본인 프로세스는 부모와 동일한 코드를 가집니다. 다만 자식이 부모의 자리를 넘봐선 안되겠죠? 이쪽 세계에도 질서가 있습니다. Process ID(PID)를 부여해서 자식과 부모를 구분짓습니다. 부모의 PID는 다양하게 형성됩니다. 하지만 자식의 경우는 ID가 항상 0 입니다. 구분짓기 쉽죠.\n\n이제 아래의 코드를 보겠습니다.\n\n```c\n#include <stdio.h>\nint main(int argc, char *argv[]) {\n\n   fork();\n   printf(\"Hello, World!\\n\");\n   \n   return 0;\n}\n```\n\n우리에게 너무나 익숙한 'Hello, World!' 를 출력하는 코드입니다. `printf` 앞에 `fork` 함수가 자리하고 있습니다. 이 코드의 결과물은 'Hello, World!' 가 두번 출력되는 것으로 끝입니다. 그 내용은 그리 어렵지 않습니다. `fork` 함수는 자신을 포함한 프로세스 전체를 복사하여 새로운 프로세스를 하나 만듭니다. 두개의 프로세스가 'Hello, World!'를 출력하고 종료됩니다. 그렇다면 메세지를 여덟번 출력하기 위해선 `fork` 함수를 몇번 사용해야 할까요? 정답은 세번입니다.\n\n저는 이걸 이해하는데 은근히 오래걸렸습니다. 어떻게 세번일까요? 이렇게 이해하면 쉽습니다. '1 - 2 - 4 - 8' 하나가 두개가 되고 두개가 네개가 되고... 두배씩 커지는거죠. 이 간단한 원리를, 저는 종이 몇장을 찢어가며 고민했습니다.\n\n이제 `exec` 식구(family)들을 만나볼 시간입니다. `execlp` 함수는 가족이 많습니다. `exec` 가문이죠. 가족 구성원은 `execl`, `execlp`, `execle`, `execv`, `execvp`, `execvpe` 가 있습니다. 이들의 역할은 특정 파일을 실행(execute)하는 것 입니다. 그 파일을 실행하여 현재 프로세스를 대체(replace)해버립니다. 다른 이름을 가지고 있지만 결과적으로 하는 일은 같습니다. 다만 일하는 방식, 사용되는 방식이 각기 이름따라 다릅니다. 저는 `execlp` 만 다루겠습니다. 코드 보시겠습니다.\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char *argv[]) {\n\n   execlp(\"./hello\", \"hello\", NULL);\n   printf(\"This is execlp function test!\\n\");\n\n   return 0;\n} \n```\n\n이 코드도 앞선 `fork` 예제처럼 'Hello, World!' 메세지를 출력하게 됩니다. 갑자기 무슨 소리냐고 하실지 모르지만 결과적으론 그렇습니다. 주인공인 `execlp` 함수를 살펴보기 전에 hello 라는 프로그램을 만들어두었다는 점을 이해하셔야합니다. hello 프로그램은 'Hello, world!' 라는 메세지를 출력하는 프로그램입니다. 결국 저희는 이 프로그램을 다른 프로세스에서 실행시키고자 하는 중입니다. 그럼 이제 그 주체가 되는 execlp 함수를 살펴보겠습니다. 총 세개의 인자를 가지고 있습니다. 첫번째 인자인 \"./hello\" 는 실행시킬 프로세스의 경로를 의미합니다. 그럼 두번째 인자는 뭘까요? 이는 프로그램의 이름을 의미합니다. 이때 적힌 이름은 지금 경로에 위치한 프로그램의 이름이 아니라 호출하는 프로세스에서 부르게될 이름입니다. 그래서 hello가 아니라 bye라고 해도 무방합니다. 세번째는 옵션입니다. 저희는 특별한 옵션을 넣지 않기로 하고 `NULL` 값을 넣어주었습니다. 결과적으로 ./hello 경로에 있는 hello 프로그램이 호출되며 기존의 프로세스를 대체하기 때문에 그 이후에 등장하는 메세지를 출력하지 않습니다.\n\n이제 마지막 `wait` 입니다. 이 함수는 이름처럼 특정 프로세스의 종료를 기다립니다(wait). 코드를 보겠습니다.\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char *argv[]) {\n\n   int child_pid = fork();\n   if(child_pid == 0) {\n      execlp(\"./hello\", \"bye\", NULL);\n   }\n   else {\n      wait();\n      printf(\"This is wait function test!\\n\");\n   }\n   \n   return 0;\n}\n```\n\n결과부터 생각해볼까요? 위의 if문 안에 있는 `execlp`는 같은 프로그램을 호출한 것이라면 'Hello, World!'가 출력될 것입니다. 그리고 다른 출력문인 'This is wait function test!' 구문도 출력됩니다. 어떻게요? 이제 살펴보죠. 우선 첫번째 줄의 child\\_pid라는 변수는 `fork`의 리턴 값을 받습니다. 이때 알아야할 것이 `fork`가 어떤 값을 리턴하는가 하는 것이죠. fork는 프로세스의 ID 값을 리턴합니다. 그러니까 앞서 말씀드린 것 처럼 child인 경우에 0을 돌려보내겠죠. 물론 잊지 말아야할 사실은 `fork`가 호출되면서 이미 프로세스가 복사되었다는 사실입니다. 그래서 두개의 프로세스에서 같은 코드를 진행해갑니다. 다만 다른 것은 child\\_pid 값 뿐이죠. 그로인해 출력되는 값도 달라집니다. 부모는 else 구문에 있는 메세지를 출력하고, 자식은 `execlp`를 통해 hello 프로그램을 자신과 대체시킵니다. 결과적으론 자식을 대체한 hello 프로그램이 먼저 실행되고 부모의 메세지가 등장하게 됩니다. `wait` 함수가 부모 프로세스로 하여금 자식 프로세스가 끝나길 기다리게 만들기 때문입니다. 이해되셨나요?\n\n_위의 모든 코드는 vi로 작성되었고 gcc컴파일러를 통해 컴파일하고 리눅스 환경에서 테스트 되었습니다. 오류 혹은 질문은 댓글 주시면 감사하겠습니다. 감사합니다._","source":"_posts/fork-execlp-wait.md","raw":"---\ntitle: '[C] fork, execlp, wait 함수'\ndate: 2016-03-26T00:27:03+00:00\nauthor: rabby\nlayout: post\ncategories:\n  - rabbylab\ntags:\n  - cs-basic\n---\n운영체제를 배우고 있습니다. 이전 글에서 프로그램, 프로세스 그리고 스레드에 대해 다뤘습니다. 오늘은 `fork`, `execlp`, `wait` 함수를 살펴보겠습니다.\n\n이 세 함수는 앞서 살펴본 프로세스와 연관을 맺고 있는 함수입니다. 각각 복사, 대체, 대기를 담당하는 함수들입니다. 오늘은 예시와 함께 살펴보도록 하겠습니다. 예시는 C 언어로 작성되었습니다.\n\n먼저 `fork` 함수 입니다. 이 함수는 프로세스를 복사(duplicate)합니다. 이때 복사가 되어지는 원본을 parent 라고 부르고 복사가 된 복사본을 child 라고 부릅니다. 자식은 부모의 판박이라 복사본인 프로세스는 부모와 동일한 코드를 가집니다. 다만 자식이 부모의 자리를 넘봐선 안되겠죠? 이쪽 세계에도 질서가 있습니다. Process ID(PID)를 부여해서 자식과 부모를 구분짓습니다. 부모의 PID는 다양하게 형성됩니다. 하지만 자식의 경우는 ID가 항상 0 입니다. 구분짓기 쉽죠.\n\n이제 아래의 코드를 보겠습니다.\n\n```c\n#include <stdio.h>\nint main(int argc, char *argv[]) {\n\n   fork();\n   printf(\"Hello, World!\\n\");\n   \n   return 0;\n}\n```\n\n우리에게 너무나 익숙한 'Hello, World!' 를 출력하는 코드입니다. `printf` 앞에 `fork` 함수가 자리하고 있습니다. 이 코드의 결과물은 'Hello, World!' 가 두번 출력되는 것으로 끝입니다. 그 내용은 그리 어렵지 않습니다. `fork` 함수는 자신을 포함한 프로세스 전체를 복사하여 새로운 프로세스를 하나 만듭니다. 두개의 프로세스가 'Hello, World!'를 출력하고 종료됩니다. 그렇다면 메세지를 여덟번 출력하기 위해선 `fork` 함수를 몇번 사용해야 할까요? 정답은 세번입니다.\n\n저는 이걸 이해하는데 은근히 오래걸렸습니다. 어떻게 세번일까요? 이렇게 이해하면 쉽습니다. '1 - 2 - 4 - 8' 하나가 두개가 되고 두개가 네개가 되고... 두배씩 커지는거죠. 이 간단한 원리를, 저는 종이 몇장을 찢어가며 고민했습니다.\n\n이제 `exec` 식구(family)들을 만나볼 시간입니다. `execlp` 함수는 가족이 많습니다. `exec` 가문이죠. 가족 구성원은 `execl`, `execlp`, `execle`, `execv`, `execvp`, `execvpe` 가 있습니다. 이들의 역할은 특정 파일을 실행(execute)하는 것 입니다. 그 파일을 실행하여 현재 프로세스를 대체(replace)해버립니다. 다른 이름을 가지고 있지만 결과적으로 하는 일은 같습니다. 다만 일하는 방식, 사용되는 방식이 각기 이름따라 다릅니다. 저는 `execlp` 만 다루겠습니다. 코드 보시겠습니다.\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char *argv[]) {\n\n   execlp(\"./hello\", \"hello\", NULL);\n   printf(\"This is execlp function test!\\n\");\n\n   return 0;\n} \n```\n\n이 코드도 앞선 `fork` 예제처럼 'Hello, World!' 메세지를 출력하게 됩니다. 갑자기 무슨 소리냐고 하실지 모르지만 결과적으론 그렇습니다. 주인공인 `execlp` 함수를 살펴보기 전에 hello 라는 프로그램을 만들어두었다는 점을 이해하셔야합니다. hello 프로그램은 'Hello, world!' 라는 메세지를 출력하는 프로그램입니다. 결국 저희는 이 프로그램을 다른 프로세스에서 실행시키고자 하는 중입니다. 그럼 이제 그 주체가 되는 execlp 함수를 살펴보겠습니다. 총 세개의 인자를 가지고 있습니다. 첫번째 인자인 \"./hello\" 는 실행시킬 프로세스의 경로를 의미합니다. 그럼 두번째 인자는 뭘까요? 이는 프로그램의 이름을 의미합니다. 이때 적힌 이름은 지금 경로에 위치한 프로그램의 이름이 아니라 호출하는 프로세스에서 부르게될 이름입니다. 그래서 hello가 아니라 bye라고 해도 무방합니다. 세번째는 옵션입니다. 저희는 특별한 옵션을 넣지 않기로 하고 `NULL` 값을 넣어주었습니다. 결과적으로 ./hello 경로에 있는 hello 프로그램이 호출되며 기존의 프로세스를 대체하기 때문에 그 이후에 등장하는 메세지를 출력하지 않습니다.\n\n이제 마지막 `wait` 입니다. 이 함수는 이름처럼 특정 프로세스의 종료를 기다립니다(wait). 코드를 보겠습니다.\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char *argv[]) {\n\n   int child_pid = fork();\n   if(child_pid == 0) {\n      execlp(\"./hello\", \"bye\", NULL);\n   }\n   else {\n      wait();\n      printf(\"This is wait function test!\\n\");\n   }\n   \n   return 0;\n}\n```\n\n결과부터 생각해볼까요? 위의 if문 안에 있는 `execlp`는 같은 프로그램을 호출한 것이라면 'Hello, World!'가 출력될 것입니다. 그리고 다른 출력문인 'This is wait function test!' 구문도 출력됩니다. 어떻게요? 이제 살펴보죠. 우선 첫번째 줄의 child\\_pid라는 변수는 `fork`의 리턴 값을 받습니다. 이때 알아야할 것이 `fork`가 어떤 값을 리턴하는가 하는 것이죠. fork는 프로세스의 ID 값을 리턴합니다. 그러니까 앞서 말씀드린 것 처럼 child인 경우에 0을 돌려보내겠죠. 물론 잊지 말아야할 사실은 `fork`가 호출되면서 이미 프로세스가 복사되었다는 사실입니다. 그래서 두개의 프로세스에서 같은 코드를 진행해갑니다. 다만 다른 것은 child\\_pid 값 뿐이죠. 그로인해 출력되는 값도 달라집니다. 부모는 else 구문에 있는 메세지를 출력하고, 자식은 `execlp`를 통해 hello 프로그램을 자신과 대체시킵니다. 결과적으론 자식을 대체한 hello 프로그램이 먼저 실행되고 부모의 메세지가 등장하게 됩니다. `wait` 함수가 부모 프로세스로 하여금 자식 프로세스가 끝나길 기다리게 만들기 때문입니다. 이해되셨나요?\n\n_위의 모든 코드는 vi로 작성되었고 gcc컴파일러를 통해 컴파일하고 리눅스 환경에서 테스트 되었습니다. 오류 혹은 질문은 댓글 주시면 감사하겠습니다. 감사합니다._","slug":"fork-execlp-wait","published":1,"updated":"2019-12-05T15:05:29.482Z","comments":1,"photos":[],"link":"","_id":"ck6jcr9gj0038dirvnu4dpdvb","content":"<p>운영체제를 배우고 있습니다. 이전 글에서 프로그램, 프로세스 그리고 스레드에 대해 다뤘습니다. 오늘은 <code>fork</code>, <code>execlp</code>, <code>wait</code> 함수를 살펴보겠습니다.</p>\n<p>이 세 함수는 앞서 살펴본 프로세스와 연관을 맺고 있는 함수입니다. 각각 복사, 대체, 대기를 담당하는 함수들입니다. 오늘은 예시와 함께 살펴보도록 하겠습니다. 예시는 C 언어로 작성되었습니다.</p>\n<p>먼저 <code>fork</code> 함수 입니다. 이 함수는 프로세스를 복사(duplicate)합니다. 이때 복사가 되어지는 원본을 parent 라고 부르고 복사가 된 복사본을 child 라고 부릅니다. 자식은 부모의 판박이라 복사본인 프로세스는 부모와 동일한 코드를 가집니다. 다만 자식이 부모의 자리를 넘봐선 안되겠죠? 이쪽 세계에도 질서가 있습니다. Process ID(PID)를 부여해서 자식과 부모를 구분짓습니다. 부모의 PID는 다양하게 형성됩니다. 하지만 자식의 경우는 ID가 항상 0 입니다. 구분짓기 쉽죠.</p>\n<p>이제 아래의 코드를 보겠습니다.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   fork();</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello, World!\\n\"</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>우리에게 너무나 익숙한 ‘Hello, World!’ 를 출력하는 코드입니다. <code>printf</code> 앞에 <code>fork</code> 함수가 자리하고 있습니다. 이 코드의 결과물은 ‘Hello, World!’ 가 두번 출력되는 것으로 끝입니다. 그 내용은 그리 어렵지 않습니다. <code>fork</code> 함수는 자신을 포함한 프로세스 전체를 복사하여 새로운 프로세스를 하나 만듭니다. 두개의 프로세스가 ‘Hello, World!’를 출력하고 종료됩니다. 그렇다면 메세지를 여덟번 출력하기 위해선 <code>fork</code> 함수를 몇번 사용해야 할까요? 정답은 세번입니다.</p>\n<p>저는 이걸 이해하는데 은근히 오래걸렸습니다. 어떻게 세번일까요? 이렇게 이해하면 쉽습니다. ‘1 - 2 - 4 - 8’ 하나가 두개가 되고 두개가 네개가 되고… 두배씩 커지는거죠. 이 간단한 원리를, 저는 종이 몇장을 찢어가며 고민했습니다.</p>\n<p>이제 <code>exec</code> 식구(family)들을 만나볼 시간입니다. <code>execlp</code> 함수는 가족이 많습니다. <code>exec</code> 가문이죠. 가족 구성원은 <code>execl</code>, <code>execlp</code>, <code>execle</code>, <code>execv</code>, <code>execvp</code>, <code>execvpe</code> 가 있습니다. 이들의 역할은 특정 파일을 실행(execute)하는 것 입니다. 그 파일을 실행하여 현재 프로세스를 대체(replace)해버립니다. 다른 이름을 가지고 있지만 결과적으로 하는 일은 같습니다. 다만 일하는 방식, 사용되는 방식이 각기 이름따라 다릅니다. 저는 <code>execlp</code> 만 다루겠습니다. 코드 보시겠습니다.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   execlp(<span class=\"string\">\"./hello\"</span>, <span class=\"string\">\"hello\"</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"This is execlp function test!\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이 코드도 앞선 <code>fork</code> 예제처럼 ‘Hello, World!’ 메세지를 출력하게 됩니다. 갑자기 무슨 소리냐고 하실지 모르지만 결과적으론 그렇습니다. 주인공인 <code>execlp</code> 함수를 살펴보기 전에 hello 라는 프로그램을 만들어두었다는 점을 이해하셔야합니다. hello 프로그램은 ‘Hello, world!’ 라는 메세지를 출력하는 프로그램입니다. 결국 저희는 이 프로그램을 다른 프로세스에서 실행시키고자 하는 중입니다. 그럼 이제 그 주체가 되는 execlp 함수를 살펴보겠습니다. 총 세개의 인자를 가지고 있습니다. 첫번째 인자인 “./hello” 는 실행시킬 프로세스의 경로를 의미합니다. 그럼 두번째 인자는 뭘까요? 이는 프로그램의 이름을 의미합니다. 이때 적힌 이름은 지금 경로에 위치한 프로그램의 이름이 아니라 호출하는 프로세스에서 부르게될 이름입니다. 그래서 hello가 아니라 bye라고 해도 무방합니다. 세번째는 옵션입니다. 저희는 특별한 옵션을 넣지 않기로 하고 <code>NULL</code> 값을 넣어주었습니다. 결과적으로 ./hello 경로에 있는 hello 프로그램이 호출되며 기존의 프로세스를 대체하기 때문에 그 이후에 등장하는 메세지를 출력하지 않습니다.</p>\n<p>이제 마지막 <code>wait</code> 입니다. 이 함수는 이름처럼 특정 프로세스의 종료를 기다립니다(wait). 코드를 보겠습니다.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">int</span> child_pid = fork();</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(child_pid == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      execlp(<span class=\"string\">\"./hello\"</span>, <span class=\"string\">\"bye\"</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      wait();</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"This is wait function test!\\n\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>결과부터 생각해볼까요? 위의 if문 안에 있는 <code>execlp</code>는 같은 프로그램을 호출한 것이라면 ‘Hello, World!’가 출력될 것입니다. 그리고 다른 출력문인 ‘This is wait function test!’ 구문도 출력됩니다. 어떻게요? 이제 살펴보죠. 우선 첫번째 줄의 child_pid라는 변수는 <code>fork</code>의 리턴 값을 받습니다. 이때 알아야할 것이 <code>fork</code>가 어떤 값을 리턴하는가 하는 것이죠. fork는 프로세스의 ID 값을 리턴합니다. 그러니까 앞서 말씀드린 것 처럼 child인 경우에 0을 돌려보내겠죠. 물론 잊지 말아야할 사실은 <code>fork</code>가 호출되면서 이미 프로세스가 복사되었다는 사실입니다. 그래서 두개의 프로세스에서 같은 코드를 진행해갑니다. 다만 다른 것은 child_pid 값 뿐이죠. 그로인해 출력되는 값도 달라집니다. 부모는 else 구문에 있는 메세지를 출력하고, 자식은 <code>execlp</code>를 통해 hello 프로그램을 자신과 대체시킵니다. 결과적으론 자식을 대체한 hello 프로그램이 먼저 실행되고 부모의 메세지가 등장하게 됩니다. <code>wait</code> 함수가 부모 프로세스로 하여금 자식 프로세스가 끝나길 기다리게 만들기 때문입니다. 이해되셨나요?</p>\n<p><em>위의 모든 코드는 vi로 작성되었고 gcc컴파일러를 통해 컴파일하고 리눅스 환경에서 테스트 되었습니다. 오류 혹은 질문은 댓글 주시면 감사하겠습니다. 감사합니다.</em></p>\n","site":{"data":{}},"excerpt":"","more":"<p>운영체제를 배우고 있습니다. 이전 글에서 프로그램, 프로세스 그리고 스레드에 대해 다뤘습니다. 오늘은 <code>fork</code>, <code>execlp</code>, <code>wait</code> 함수를 살펴보겠습니다.</p>\n<p>이 세 함수는 앞서 살펴본 프로세스와 연관을 맺고 있는 함수입니다. 각각 복사, 대체, 대기를 담당하는 함수들입니다. 오늘은 예시와 함께 살펴보도록 하겠습니다. 예시는 C 언어로 작성되었습니다.</p>\n<p>먼저 <code>fork</code> 함수 입니다. 이 함수는 프로세스를 복사(duplicate)합니다. 이때 복사가 되어지는 원본을 parent 라고 부르고 복사가 된 복사본을 child 라고 부릅니다. 자식은 부모의 판박이라 복사본인 프로세스는 부모와 동일한 코드를 가집니다. 다만 자식이 부모의 자리를 넘봐선 안되겠죠? 이쪽 세계에도 질서가 있습니다. Process ID(PID)를 부여해서 자식과 부모를 구분짓습니다. 부모의 PID는 다양하게 형성됩니다. 하지만 자식의 경우는 ID가 항상 0 입니다. 구분짓기 쉽죠.</p>\n<p>이제 아래의 코드를 보겠습니다.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   fork();</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello, World!\\n\"</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>우리에게 너무나 익숙한 ‘Hello, World!’ 를 출력하는 코드입니다. <code>printf</code> 앞에 <code>fork</code> 함수가 자리하고 있습니다. 이 코드의 결과물은 ‘Hello, World!’ 가 두번 출력되는 것으로 끝입니다. 그 내용은 그리 어렵지 않습니다. <code>fork</code> 함수는 자신을 포함한 프로세스 전체를 복사하여 새로운 프로세스를 하나 만듭니다. 두개의 프로세스가 ‘Hello, World!’를 출력하고 종료됩니다. 그렇다면 메세지를 여덟번 출력하기 위해선 <code>fork</code> 함수를 몇번 사용해야 할까요? 정답은 세번입니다.</p>\n<p>저는 이걸 이해하는데 은근히 오래걸렸습니다. 어떻게 세번일까요? 이렇게 이해하면 쉽습니다. ‘1 - 2 - 4 - 8’ 하나가 두개가 되고 두개가 네개가 되고… 두배씩 커지는거죠. 이 간단한 원리를, 저는 종이 몇장을 찢어가며 고민했습니다.</p>\n<p>이제 <code>exec</code> 식구(family)들을 만나볼 시간입니다. <code>execlp</code> 함수는 가족이 많습니다. <code>exec</code> 가문이죠. 가족 구성원은 <code>execl</code>, <code>execlp</code>, <code>execle</code>, <code>execv</code>, <code>execvp</code>, <code>execvpe</code> 가 있습니다. 이들의 역할은 특정 파일을 실행(execute)하는 것 입니다. 그 파일을 실행하여 현재 프로세스를 대체(replace)해버립니다. 다른 이름을 가지고 있지만 결과적으로 하는 일은 같습니다. 다만 일하는 방식, 사용되는 방식이 각기 이름따라 다릅니다. 저는 <code>execlp</code> 만 다루겠습니다. 코드 보시겠습니다.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   execlp(<span class=\"string\">\"./hello\"</span>, <span class=\"string\">\"hello\"</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"This is execlp function test!\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이 코드도 앞선 <code>fork</code> 예제처럼 ‘Hello, World!’ 메세지를 출력하게 됩니다. 갑자기 무슨 소리냐고 하실지 모르지만 결과적으론 그렇습니다. 주인공인 <code>execlp</code> 함수를 살펴보기 전에 hello 라는 프로그램을 만들어두었다는 점을 이해하셔야합니다. hello 프로그램은 ‘Hello, world!’ 라는 메세지를 출력하는 프로그램입니다. 결국 저희는 이 프로그램을 다른 프로세스에서 실행시키고자 하는 중입니다. 그럼 이제 그 주체가 되는 execlp 함수를 살펴보겠습니다. 총 세개의 인자를 가지고 있습니다. 첫번째 인자인 “./hello” 는 실행시킬 프로세스의 경로를 의미합니다. 그럼 두번째 인자는 뭘까요? 이는 프로그램의 이름을 의미합니다. 이때 적힌 이름은 지금 경로에 위치한 프로그램의 이름이 아니라 호출하는 프로세스에서 부르게될 이름입니다. 그래서 hello가 아니라 bye라고 해도 무방합니다. 세번째는 옵션입니다. 저희는 특별한 옵션을 넣지 않기로 하고 <code>NULL</code> 값을 넣어주었습니다. 결과적으로 ./hello 경로에 있는 hello 프로그램이 호출되며 기존의 프로세스를 대체하기 때문에 그 이후에 등장하는 메세지를 출력하지 않습니다.</p>\n<p>이제 마지막 <code>wait</code> 입니다. 이 함수는 이름처럼 특정 프로세스의 종료를 기다립니다(wait). 코드를 보겠습니다.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">int</span> child_pid = fork();</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(child_pid == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      execlp(<span class=\"string\">\"./hello\"</span>, <span class=\"string\">\"bye\"</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      wait();</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"This is wait function test!\\n\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>결과부터 생각해볼까요? 위의 if문 안에 있는 <code>execlp</code>는 같은 프로그램을 호출한 것이라면 ‘Hello, World!’가 출력될 것입니다. 그리고 다른 출력문인 ‘This is wait function test!’ 구문도 출력됩니다. 어떻게요? 이제 살펴보죠. 우선 첫번째 줄의 child_pid라는 변수는 <code>fork</code>의 리턴 값을 받습니다. 이때 알아야할 것이 <code>fork</code>가 어떤 값을 리턴하는가 하는 것이죠. fork는 프로세스의 ID 값을 리턴합니다. 그러니까 앞서 말씀드린 것 처럼 child인 경우에 0을 돌려보내겠죠. 물론 잊지 말아야할 사실은 <code>fork</code>가 호출되면서 이미 프로세스가 복사되었다는 사실입니다. 그래서 두개의 프로세스에서 같은 코드를 진행해갑니다. 다만 다른 것은 child_pid 값 뿐이죠. 그로인해 출력되는 값도 달라집니다. 부모는 else 구문에 있는 메세지를 출력하고, 자식은 <code>execlp</code>를 통해 hello 프로그램을 자신과 대체시킵니다. 결과적으론 자식을 대체한 hello 프로그램이 먼저 실행되고 부모의 메세지가 등장하게 됩니다. <code>wait</code> 함수가 부모 프로세스로 하여금 자식 프로세스가 끝나길 기다리게 만들기 때문입니다. 이해되셨나요?</p>\n<p><em>위의 모든 코드는 vi로 작성되었고 gcc컴파일러를 통해 컴파일하고 리눅스 환경에서 테스트 되었습니다. 오류 혹은 질문은 댓글 주시면 감사하겠습니다. 감사합니다.</em></p>\n"},{"id":"25","title":"[RABBY LAB] 블로그 및 운영자 소개","date":"2015-07-17T11:19:54.000Z","author":"rabby","layout":"post","guid":"https://rabbylab.wordpress.com/?p=25","geo_public":[0],"_content":"<h5 style=\"text-align: center;\">\n  ![](/images/profile-1.png)\n</h5>\n\n<h5 style=\"text-align: center;\">\n  RABBY LAB에 오신 걸 환영합니다.\n</h5>\n\n<p style=\"text-align: center;\">\n  RABBY LAB은 대학생인 제가 개발자로 성장해나가는 과정을 담고 있습니다.\n</p>\n\n<p style=\"text-align: center;\">\n  앞으로 본 블로그에는 저의 학업적, 직업적 성장과정이 담길 것입니다.<br /> 이를 통해 제 자신은 정리하는 습관과 성장이 배가되는 효과를<br /> 독자분들은 소소한 재미와 위로를 얻어가실 수 있길 기대해봅니다.\n</p>\n\n<p style=\"text-align: center;\">\n  부족한 점에 대한 조언은 언제나 환영합니다.<br /> 아래의 메일로 연락주시기 바랍니다.<br /> imjoeunha@gmail.com\n</p>","source":"_posts/introduction-to-blog.md","raw":"---\nid: 25\ntitle: '[RABBY LAB] 블로그 및 운영자 소개'\ndate: 2015-07-17T20:19:54+00:00\nauthor: rabby\nlayout: post\nguid: https://rabbylab.wordpress.com/?p=25\ngeo_public:\n  - 0\ncategories:\n  - rabbylab\ntags:\n  - introduction\n---\n<h5 style=\"text-align: center;\">\n  ![](/images/profile-1.png)\n</h5>\n\n<h5 style=\"text-align: center;\">\n  RABBY LAB에 오신 걸 환영합니다.\n</h5>\n\n<p style=\"text-align: center;\">\n  RABBY LAB은 대학생인 제가 개발자로 성장해나가는 과정을 담고 있습니다.\n</p>\n\n<p style=\"text-align: center;\">\n  앞으로 본 블로그에는 저의 학업적, 직업적 성장과정이 담길 것입니다.<br /> 이를 통해 제 자신은 정리하는 습관과 성장이 배가되는 효과를<br /> 독자분들은 소소한 재미와 위로를 얻어가실 수 있길 기대해봅니다.\n</p>\n\n<p style=\"text-align: center;\">\n  부족한 점에 대한 조언은 언제나 환영합니다.<br /> 아래의 메일로 연락주시기 바랍니다.<br /> imjoeunha@gmail.com\n</p>","slug":"introduction-to-blog","published":1,"updated":"2019-12-05T15:05:29.483Z","comments":1,"photos":[],"link":"","_id":"ck6jcr9gl003bdirvvzryczu4","content":"<h5 style=\"text-align: center;\">\n  ![](/images/profile-1.png)\n</h5>\n\n<h5 style=\"text-align: center;\">\n  RABBY LAB에 오신 걸 환영합니다.\n</h5>\n\n<p style=\"text-align: center;\">\n  RABBY LAB은 대학생인 제가 개발자로 성장해나가는 과정을 담고 있습니다.\n</p>\n\n<p style=\"text-align: center;\">\n  앞으로 본 블로그에는 저의 학업적, 직업적 성장과정이 담길 것입니다.<br> 이를 통해 제 자신은 정리하는 습관과 성장이 배가되는 효과를<br> 독자분들은 소소한 재미와 위로를 얻어가실 수 있길 기대해봅니다.\n</p>\n\n<p style=\"text-align: center;\">\n  부족한 점에 대한 조언은 언제나 환영합니다.<br> 아래의 메일로 연락주시기 바랍니다.<br> imjoeunha@gmail.com\n</p>","site":{"data":{}},"excerpt":"","more":"<h5 style=\"text-align: center;\">\n  ![](/images/profile-1.png)\n</h5>\n\n<h5 style=\"text-align: center;\">\n  RABBY LAB에 오신 걸 환영합니다.\n</h5>\n\n<p style=\"text-align: center;\">\n  RABBY LAB은 대학생인 제가 개발자로 성장해나가는 과정을 담고 있습니다.\n</p>\n\n<p style=\"text-align: center;\">\n  앞으로 본 블로그에는 저의 학업적, 직업적 성장과정이 담길 것입니다.<br> 이를 통해 제 자신은 정리하는 습관과 성장이 배가되는 효과를<br> 독자분들은 소소한 재미와 위로를 얻어가실 수 있길 기대해봅니다.\n</p>\n\n<p style=\"text-align: center;\">\n  부족한 점에 대한 조언은 언제나 환영합니다.<br> 아래의 메일로 연락주시기 바랍니다.<br> imjoeunha@gmail.com\n</p>"},{"id":"15","title":"[JavaScript] 자바스크립트를 선택한 이유","date":"2015-07-17T12:10:11.000Z","author":"rabby","layout":"post","guid":"https://rabbylab.wordpress.com/?p=15","geo_public":[0],"_content":"<p style=\"text-align:left;\">\n  세상에는 수 많은 프로그래밍 언어가 존재하고 그 언어들은 제 각기 배움의 가치가 있습니다. 때문에 제 각기 배움의 이유가 존재합니다. 다수의 프로그래밍 언어 서적들은 &#8216;왜 많은 언어 중에 이 언어를 배워야하는가?&#8217; 하는 질문을 답하며 책을 시작합니다. 그렇다면 저는 왜 자바스크립트를 선택했을까요?\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>프로그래밍 경험</strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  대다수의 컴퓨터공학 전공자들이 그러하듯 저 역시 C언어로 프로그래밍에 입문했습니다. &#8216;hello world&#8217;를 출력하고 기본적인 연산 프로그램을 만들며 별거 아닌데? 라는 생각이 들때쯤 배열과 포인터의 늪을 허덕였습니다. 이후 다양한 응용 과제와 씨름하며 밤새워 한번 앉아서 8시간씩 코딩을 하면서도 문제를 해결했을 때의 그 쾌감 때문에 프로그래밍에 빠져들게 되었습니다. 이어서 자바, C++등을 배웠습니다. 이후 배운 것을 근간으로 프로젝트를 수행하기도 했습니다. 자바를 이용한 안드로이드 앱 개발이 대표적이죠. 제가 배운 언어를 사용할 일이 있을 때 그 언어는 빛을 발하고 정말 재밌다는 것을 느낄 수 있었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  아쉬운 것은 스마트 디바이스의 출현으로 실질적으로 와닿는 프로그램을 만들기 위해서는 C나 자바가 다소 어렵게 느껴지는 경우가 많다는 것이었습니다. 물론 오랜 시간을 투자해서 네이티브 앱을 만들어내려고 한다면 자바는 충분히 가치가 있습니다. 허나 학회활동이나 수업에서 사용되고 만들어야 하는 수준의 프로그램은 실제 배포판이 아닌 어느정도 구색을 갖춘 프로토 타입 수준의 어플리케이션이면 되는 것이었습니다. 조금 간편하게 만들고 운영체제에 무관하게 사용해볼 수 있는 프로그램이 필요했던 것입니다.\n</p>\n\n<p style=\"text-align:left;\">\n  웹앱(web app)이 이에 적합한 형태의 프로그램이었습니다. 방학 중 Do it! 시리즈 중 한권인 &#8216;<a href=\"http://www.easyspub.co.kr/20_Menu/BookView/B001/90\" target=\"_blank\">쉽게 배우는 웹앱&하이브리드앱</a>&#8216;을 잡고 공부를 했습니다. <a href=\"https://opentutorials.org/course/668\" target=\"_blank\">생활코딩 &#8211; 클라이언트</a> 강의와 함께 HTML, CSS, jQuery의 기초를 공부하면서 웹앱의 기초를 익혔습니다. 허나 책을 다봤는데도 실제 어플리케이션을 만들 수준이 되지 않음을 깨달았습니다. 이에 <a href=\"https://opentutorials.org/course/1688\" target=\"_blank\">생활코딩 &#8211; 웹 애플리케이션 만들기</a> 강의를 보며 php, mysql, javascript 에 대해 배웠습니다. 이를 배우는 과정에서 간단하게 만들어 본 1차 결과물이 <a href=\"https://github.com/joeunha/taleline\" target=\"_blank\">taleline</a> 입니다. 지금은 정말 아무것도 아닌 상태로 남아있는 이 웹앱을 제대로 만들어보고 싶은 마음이 생긴 것이 발단이었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  어떻게하면 이 앱을 제대로 만들어 볼 수 있을까 하는 고민을 하기 시작했습니다. 현재 제가 처한 여러가지 상황을 놓고 고민했을때 저에게는 두가지 선택지가 있음을 깨달았습니다. 첫째, 지금처럼 얇고 넓게 조금씩 배우며 혼자 개발한다. 둘째, 한가지 언어를 깊게 파서 내공을 쌓은 뒤 누군가와 협력해서 개발한다. 주위의 선배들과 커뮤니티의 선배님들의 조언을 살펴 저는 한가지 언어를 깊게 파는 것을 선택했습니다.\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>왜 자바스크립트를 선택했나? </strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  사실 딱히 어떤 이유로 자바스크립트를 배워야겠다고 생각한 것은 아닙니다. 매력에 이끌렸다고 할까요? 특히 자바스크립트가 가지는 자유로움에 끌렸습니다. 운영체제를 가리지 않는 자유로움, 변수 타입에 제한을 두지 않는 자유로움, 또 웹이 확장되어가고 탈웹의 흐름에 따라 더 많은 곳에서 사용될 가능성이 저를 매료시켰습니다. 생활코딩 강의를 들으면서도 jQuery 같은 강력한 라이브러리가 자바스크립트에 기반을 두고 있다는 사실이 이 언어를 매력적으로 보이게 만들었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  앞선 자바스크립트의 매력 요소가 분명 이 언어를 선택함에 어느정도 영향을 준 것이 분명합니다. 하지만 자바스크립트가 저에게 필요하지 않았더라면 아무리 매력적이라고 해도 이 언어를 선택하지 않았을 것입니다. 그 필요는 연습삼아 만들어본 taleline 이라는 앱을 완성시키고 싶은 마음에서 출발합니다. 이 앱을 완성하기 위해 C나 자바를 배우는 것은 무의미합니다. 필요한 서비스를 구현하기 위해 필요한 언어를 배우기로 한 것이죠. 또한 지대한 영향을 끼쳤던 것은 제가 사용하는 스마트워치 &#8216;Pebble Time&#8217;의 개발 언어가 자바스크립트를 기반으로 한 <a href=\"http://developer.getpebble.com/getting-started/pebble-js-tutorial/part1/\" target=\"_blank\">pepple.js</a>(originally <a href=\"http://simplyjs.io/\" target=\"_blank\">simply.js</a>)였기 때문입니다. 가까이 두고 사용하고 있는 기기인만큼 새로운 앱에 대한 아이디어가 종종 떠올랐는데 이를 직접 만들어보고 싶었기 때문입니다.\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>필요해서 배운다!<br /> </strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  결국 필요에 의해 자바스크립트를 선택했다라고 말할 수 있겠습니다. 결론은 너무 당연한 것을 이야기하는 것 같습니다. 결국 모든 언어를 배우는 이유는 해당 언어가 자신이 만들고자 하는 서비스에 꼭 필요한 기능을 가졌거나 그 언어로 작업했을 때 발생하는 효용이 있기 때문이라는 겁니다.\n</p>","source":"_posts/javascript-intro-1.md","raw":"---\nid: 15\ntitle: '[JavaScript] 자바스크립트를 선택한 이유'\ndate: 2015-07-17T21:10:11+00:00\nauthor: rabby\nlayout: post\nguid: https://rabbylab.wordpress.com/?p=15\npermalink: /javascript-intro-1/\ngeo_public:\n  - 0\ncategories:\n  - rabbylab\ntags:\n  - javascript\n---\n<p style=\"text-align:left;\">\n  세상에는 수 많은 프로그래밍 언어가 존재하고 그 언어들은 제 각기 배움의 가치가 있습니다. 때문에 제 각기 배움의 이유가 존재합니다. 다수의 프로그래밍 언어 서적들은 &#8216;왜 많은 언어 중에 이 언어를 배워야하는가?&#8217; 하는 질문을 답하며 책을 시작합니다. 그렇다면 저는 왜 자바스크립트를 선택했을까요?\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>프로그래밍 경험</strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  대다수의 컴퓨터공학 전공자들이 그러하듯 저 역시 C언어로 프로그래밍에 입문했습니다. &#8216;hello world&#8217;를 출력하고 기본적인 연산 프로그램을 만들며 별거 아닌데? 라는 생각이 들때쯤 배열과 포인터의 늪을 허덕였습니다. 이후 다양한 응용 과제와 씨름하며 밤새워 한번 앉아서 8시간씩 코딩을 하면서도 문제를 해결했을 때의 그 쾌감 때문에 프로그래밍에 빠져들게 되었습니다. 이어서 자바, C++등을 배웠습니다. 이후 배운 것을 근간으로 프로젝트를 수행하기도 했습니다. 자바를 이용한 안드로이드 앱 개발이 대표적이죠. 제가 배운 언어를 사용할 일이 있을 때 그 언어는 빛을 발하고 정말 재밌다는 것을 느낄 수 있었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  아쉬운 것은 스마트 디바이스의 출현으로 실질적으로 와닿는 프로그램을 만들기 위해서는 C나 자바가 다소 어렵게 느껴지는 경우가 많다는 것이었습니다. 물론 오랜 시간을 투자해서 네이티브 앱을 만들어내려고 한다면 자바는 충분히 가치가 있습니다. 허나 학회활동이나 수업에서 사용되고 만들어야 하는 수준의 프로그램은 실제 배포판이 아닌 어느정도 구색을 갖춘 프로토 타입 수준의 어플리케이션이면 되는 것이었습니다. 조금 간편하게 만들고 운영체제에 무관하게 사용해볼 수 있는 프로그램이 필요했던 것입니다.\n</p>\n\n<p style=\"text-align:left;\">\n  웹앱(web app)이 이에 적합한 형태의 프로그램이었습니다. 방학 중 Do it! 시리즈 중 한권인 &#8216;<a href=\"http://www.easyspub.co.kr/20_Menu/BookView/B001/90\" target=\"_blank\">쉽게 배우는 웹앱&하이브리드앱</a>&#8216;을 잡고 공부를 했습니다. <a href=\"https://opentutorials.org/course/668\" target=\"_blank\">생활코딩 &#8211; 클라이언트</a> 강의와 함께 HTML, CSS, jQuery의 기초를 공부하면서 웹앱의 기초를 익혔습니다. 허나 책을 다봤는데도 실제 어플리케이션을 만들 수준이 되지 않음을 깨달았습니다. 이에 <a href=\"https://opentutorials.org/course/1688\" target=\"_blank\">생활코딩 &#8211; 웹 애플리케이션 만들기</a> 강의를 보며 php, mysql, javascript 에 대해 배웠습니다. 이를 배우는 과정에서 간단하게 만들어 본 1차 결과물이 <a href=\"https://github.com/joeunha/taleline\" target=\"_blank\">taleline</a> 입니다. 지금은 정말 아무것도 아닌 상태로 남아있는 이 웹앱을 제대로 만들어보고 싶은 마음이 생긴 것이 발단이었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  어떻게하면 이 앱을 제대로 만들어 볼 수 있을까 하는 고민을 하기 시작했습니다. 현재 제가 처한 여러가지 상황을 놓고 고민했을때 저에게는 두가지 선택지가 있음을 깨달았습니다. 첫째, 지금처럼 얇고 넓게 조금씩 배우며 혼자 개발한다. 둘째, 한가지 언어를 깊게 파서 내공을 쌓은 뒤 누군가와 협력해서 개발한다. 주위의 선배들과 커뮤니티의 선배님들의 조언을 살펴 저는 한가지 언어를 깊게 파는 것을 선택했습니다.\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>왜 자바스크립트를 선택했나? </strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  사실 딱히 어떤 이유로 자바스크립트를 배워야겠다고 생각한 것은 아닙니다. 매력에 이끌렸다고 할까요? 특히 자바스크립트가 가지는 자유로움에 끌렸습니다. 운영체제를 가리지 않는 자유로움, 변수 타입에 제한을 두지 않는 자유로움, 또 웹이 확장되어가고 탈웹의 흐름에 따라 더 많은 곳에서 사용될 가능성이 저를 매료시켰습니다. 생활코딩 강의를 들으면서도 jQuery 같은 강력한 라이브러리가 자바스크립트에 기반을 두고 있다는 사실이 이 언어를 매력적으로 보이게 만들었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  앞선 자바스크립트의 매력 요소가 분명 이 언어를 선택함에 어느정도 영향을 준 것이 분명합니다. 하지만 자바스크립트가 저에게 필요하지 않았더라면 아무리 매력적이라고 해도 이 언어를 선택하지 않았을 것입니다. 그 필요는 연습삼아 만들어본 taleline 이라는 앱을 완성시키고 싶은 마음에서 출발합니다. 이 앱을 완성하기 위해 C나 자바를 배우는 것은 무의미합니다. 필요한 서비스를 구현하기 위해 필요한 언어를 배우기로 한 것이죠. 또한 지대한 영향을 끼쳤던 것은 제가 사용하는 스마트워치 &#8216;Pebble Time&#8217;의 개발 언어가 자바스크립트를 기반으로 한 <a href=\"http://developer.getpebble.com/getting-started/pebble-js-tutorial/part1/\" target=\"_blank\">pepple.js</a>(originally <a href=\"http://simplyjs.io/\" target=\"_blank\">simply.js</a>)였기 때문입니다. 가까이 두고 사용하고 있는 기기인만큼 새로운 앱에 대한 아이디어가 종종 떠올랐는데 이를 직접 만들어보고 싶었기 때문입니다.\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>필요해서 배운다!<br /> </strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  결국 필요에 의해 자바스크립트를 선택했다라고 말할 수 있겠습니다. 결론은 너무 당연한 것을 이야기하는 것 같습니다. 결국 모든 언어를 배우는 이유는 해당 언어가 자신이 만들고자 하는 서비스에 꼭 필요한 기능을 가졌거나 그 언어로 작업했을 때 발생하는 효용이 있기 때문이라는 겁니다.\n</p>","slug":"/javascript-intro-1/","published":1,"updated":"2019-12-05T15:05:29.490Z","comments":1,"photos":[],"link":"","_id":"ck6jcr9gn003fdirv1f1ic7hk","content":"<p style=\"text-align:left;\">\n  세상에는 수 많은 프로그래밍 언어가 존재하고 그 언어들은 제 각기 배움의 가치가 있습니다. 때문에 제 각기 배움의 이유가 존재합니다. 다수의 프로그래밍 언어 서적들은 &#8216;왜 많은 언어 중에 이 언어를 배워야하는가?&#8217; 하는 질문을 답하며 책을 시작합니다. 그렇다면 저는 왜 자바스크립트를 선택했을까요?\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>프로그래밍 경험</strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  대다수의 컴퓨터공학 전공자들이 그러하듯 저 역시 C언어로 프로그래밍에 입문했습니다. &#8216;hello world&#8217;를 출력하고 기본적인 연산 프로그램을 만들며 별거 아닌데? 라는 생각이 들때쯤 배열과 포인터의 늪을 허덕였습니다. 이후 다양한 응용 과제와 씨름하며 밤새워 한번 앉아서 8시간씩 코딩을 하면서도 문제를 해결했을 때의 그 쾌감 때문에 프로그래밍에 빠져들게 되었습니다. 이어서 자바, C++등을 배웠습니다. 이후 배운 것을 근간으로 프로젝트를 수행하기도 했습니다. 자바를 이용한 안드로이드 앱 개발이 대표적이죠. 제가 배운 언어를 사용할 일이 있을 때 그 언어는 빛을 발하고 정말 재밌다는 것을 느낄 수 있었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  아쉬운 것은 스마트 디바이스의 출현으로 실질적으로 와닿는 프로그램을 만들기 위해서는 C나 자바가 다소 어렵게 느껴지는 경우가 많다는 것이었습니다. 물론 오랜 시간을 투자해서 네이티브 앱을 만들어내려고 한다면 자바는 충분히 가치가 있습니다. 허나 학회활동이나 수업에서 사용되고 만들어야 하는 수준의 프로그램은 실제 배포판이 아닌 어느정도 구색을 갖춘 프로토 타입 수준의 어플리케이션이면 되는 것이었습니다. 조금 간편하게 만들고 운영체제에 무관하게 사용해볼 수 있는 프로그램이 필요했던 것입니다.\n</p>\n\n<p style=\"text-align:left;\">\n  웹앱(web app)이 이에 적합한 형태의 프로그램이었습니다. 방학 중 Do it! 시리즈 중 한권인 &#8216;<a href=\"http://www.easyspub.co.kr/20_Menu/BookView/B001/90\" target=\"_blank\">쉽게 배우는 웹앱&하이브리드앱</a>&#8216;을 잡고 공부를 했습니다. <a href=\"https://opentutorials.org/course/668\" target=\"_blank\">생활코딩 &#8211; 클라이언트</a> 강의와 함께 HTML, CSS, jQuery의 기초를 공부하면서 웹앱의 기초를 익혔습니다. 허나 책을 다봤는데도 실제 어플리케이션을 만들 수준이 되지 않음을 깨달았습니다. 이에 <a href=\"https://opentutorials.org/course/1688\" target=\"_blank\">생활코딩 &#8211; 웹 애플리케이션 만들기</a> 강의를 보며 php, mysql, javascript 에 대해 배웠습니다. 이를 배우는 과정에서 간단하게 만들어 본 1차 결과물이 <a href=\"https://github.com/joeunha/taleline\" target=\"_blank\">taleline</a> 입니다. 지금은 정말 아무것도 아닌 상태로 남아있는 이 웹앱을 제대로 만들어보고 싶은 마음이 생긴 것이 발단이었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  어떻게하면 이 앱을 제대로 만들어 볼 수 있을까 하는 고민을 하기 시작했습니다. 현재 제가 처한 여러가지 상황을 놓고 고민했을때 저에게는 두가지 선택지가 있음을 깨달았습니다. 첫째, 지금처럼 얇고 넓게 조금씩 배우며 혼자 개발한다. 둘째, 한가지 언어를 깊게 파서 내공을 쌓은 뒤 누군가와 협력해서 개발한다. 주위의 선배들과 커뮤니티의 선배님들의 조언을 살펴 저는 한가지 언어를 깊게 파는 것을 선택했습니다.\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>왜 자바스크립트를 선택했나? </strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  사실 딱히 어떤 이유로 자바스크립트를 배워야겠다고 생각한 것은 아닙니다. 매력에 이끌렸다고 할까요? 특히 자바스크립트가 가지는 자유로움에 끌렸습니다. 운영체제를 가리지 않는 자유로움, 변수 타입에 제한을 두지 않는 자유로움, 또 웹이 확장되어가고 탈웹의 흐름에 따라 더 많은 곳에서 사용될 가능성이 저를 매료시켰습니다. 생활코딩 강의를 들으면서도 jQuery 같은 강력한 라이브러리가 자바스크립트에 기반을 두고 있다는 사실이 이 언어를 매력적으로 보이게 만들었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  앞선 자바스크립트의 매력 요소가 분명 이 언어를 선택함에 어느정도 영향을 준 것이 분명합니다. 하지만 자바스크립트가 저에게 필요하지 않았더라면 아무리 매력적이라고 해도 이 언어를 선택하지 않았을 것입니다. 그 필요는 연습삼아 만들어본 taleline 이라는 앱을 완성시키고 싶은 마음에서 출발합니다. 이 앱을 완성하기 위해 C나 자바를 배우는 것은 무의미합니다. 필요한 서비스를 구현하기 위해 필요한 언어를 배우기로 한 것이죠. 또한 지대한 영향을 끼쳤던 것은 제가 사용하는 스마트워치 &#8216;Pebble Time&#8217;의 개발 언어가 자바스크립트를 기반으로 한 <a href=\"http://developer.getpebble.com/getting-started/pebble-js-tutorial/part1/\" target=\"_blank\">pepple.js</a>(originally <a href=\"http://simplyjs.io/\" target=\"_blank\">simply.js</a>)였기 때문입니다. 가까이 두고 사용하고 있는 기기인만큼 새로운 앱에 대한 아이디어가 종종 떠올랐는데 이를 직접 만들어보고 싶었기 때문입니다.\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>필요해서 배운다!<br> </strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  결국 필요에 의해 자바스크립트를 선택했다라고 말할 수 있겠습니다. 결론은 너무 당연한 것을 이야기하는 것 같습니다. 결국 모든 언어를 배우는 이유는 해당 언어가 자신이 만들고자 하는 서비스에 꼭 필요한 기능을 가졌거나 그 언어로 작업했을 때 발생하는 효용이 있기 때문이라는 겁니다.\n</p>","site":{"data":{}},"excerpt":"","more":"<p style=\"text-align:left;\">\n  세상에는 수 많은 프로그래밍 언어가 존재하고 그 언어들은 제 각기 배움의 가치가 있습니다. 때문에 제 각기 배움의 이유가 존재합니다. 다수의 프로그래밍 언어 서적들은 &#8216;왜 많은 언어 중에 이 언어를 배워야하는가?&#8217; 하는 질문을 답하며 책을 시작합니다. 그렇다면 저는 왜 자바스크립트를 선택했을까요?\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>프로그래밍 경험</strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  대다수의 컴퓨터공학 전공자들이 그러하듯 저 역시 C언어로 프로그래밍에 입문했습니다. &#8216;hello world&#8217;를 출력하고 기본적인 연산 프로그램을 만들며 별거 아닌데? 라는 생각이 들때쯤 배열과 포인터의 늪을 허덕였습니다. 이후 다양한 응용 과제와 씨름하며 밤새워 한번 앉아서 8시간씩 코딩을 하면서도 문제를 해결했을 때의 그 쾌감 때문에 프로그래밍에 빠져들게 되었습니다. 이어서 자바, C++등을 배웠습니다. 이후 배운 것을 근간으로 프로젝트를 수행하기도 했습니다. 자바를 이용한 안드로이드 앱 개발이 대표적이죠. 제가 배운 언어를 사용할 일이 있을 때 그 언어는 빛을 발하고 정말 재밌다는 것을 느낄 수 있었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  아쉬운 것은 스마트 디바이스의 출현으로 실질적으로 와닿는 프로그램을 만들기 위해서는 C나 자바가 다소 어렵게 느껴지는 경우가 많다는 것이었습니다. 물론 오랜 시간을 투자해서 네이티브 앱을 만들어내려고 한다면 자바는 충분히 가치가 있습니다. 허나 학회활동이나 수업에서 사용되고 만들어야 하는 수준의 프로그램은 실제 배포판이 아닌 어느정도 구색을 갖춘 프로토 타입 수준의 어플리케이션이면 되는 것이었습니다. 조금 간편하게 만들고 운영체제에 무관하게 사용해볼 수 있는 프로그램이 필요했던 것입니다.\n</p>\n\n<p style=\"text-align:left;\">\n  웹앱(web app)이 이에 적합한 형태의 프로그램이었습니다. 방학 중 Do it! 시리즈 중 한권인 &#8216;<a href=\"http://www.easyspub.co.kr/20_Menu/BookView/B001/90\" target=\"_blank\">쉽게 배우는 웹앱&하이브리드앱</a>&#8216;을 잡고 공부를 했습니다. <a href=\"https://opentutorials.org/course/668\" target=\"_blank\">생활코딩 &#8211; 클라이언트</a> 강의와 함께 HTML, CSS, jQuery의 기초를 공부하면서 웹앱의 기초를 익혔습니다. 허나 책을 다봤는데도 실제 어플리케이션을 만들 수준이 되지 않음을 깨달았습니다. 이에 <a href=\"https://opentutorials.org/course/1688\" target=\"_blank\">생활코딩 &#8211; 웹 애플리케이션 만들기</a> 강의를 보며 php, mysql, javascript 에 대해 배웠습니다. 이를 배우는 과정에서 간단하게 만들어 본 1차 결과물이 <a href=\"https://github.com/joeunha/taleline\" target=\"_blank\">taleline</a> 입니다. 지금은 정말 아무것도 아닌 상태로 남아있는 이 웹앱을 제대로 만들어보고 싶은 마음이 생긴 것이 발단이었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  어떻게하면 이 앱을 제대로 만들어 볼 수 있을까 하는 고민을 하기 시작했습니다. 현재 제가 처한 여러가지 상황을 놓고 고민했을때 저에게는 두가지 선택지가 있음을 깨달았습니다. 첫째, 지금처럼 얇고 넓게 조금씩 배우며 혼자 개발한다. 둘째, 한가지 언어를 깊게 파서 내공을 쌓은 뒤 누군가와 협력해서 개발한다. 주위의 선배들과 커뮤니티의 선배님들의 조언을 살펴 저는 한가지 언어를 깊게 파는 것을 선택했습니다.\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>왜 자바스크립트를 선택했나? </strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  사실 딱히 어떤 이유로 자바스크립트를 배워야겠다고 생각한 것은 아닙니다. 매력에 이끌렸다고 할까요? 특히 자바스크립트가 가지는 자유로움에 끌렸습니다. 운영체제를 가리지 않는 자유로움, 변수 타입에 제한을 두지 않는 자유로움, 또 웹이 확장되어가고 탈웹의 흐름에 따라 더 많은 곳에서 사용될 가능성이 저를 매료시켰습니다. 생활코딩 강의를 들으면서도 jQuery 같은 강력한 라이브러리가 자바스크립트에 기반을 두고 있다는 사실이 이 언어를 매력적으로 보이게 만들었습니다.\n</p>\n\n<p style=\"text-align:left;\">\n  앞선 자바스크립트의 매력 요소가 분명 이 언어를 선택함에 어느정도 영향을 준 것이 분명합니다. 하지만 자바스크립트가 저에게 필요하지 않았더라면 아무리 매력적이라고 해도 이 언어를 선택하지 않았을 것입니다. 그 필요는 연습삼아 만들어본 taleline 이라는 앱을 완성시키고 싶은 마음에서 출발합니다. 이 앱을 완성하기 위해 C나 자바를 배우는 것은 무의미합니다. 필요한 서비스를 구현하기 위해 필요한 언어를 배우기로 한 것이죠. 또한 지대한 영향을 끼쳤던 것은 제가 사용하는 스마트워치 &#8216;Pebble Time&#8217;의 개발 언어가 자바스크립트를 기반으로 한 <a href=\"http://developer.getpebble.com/getting-started/pebble-js-tutorial/part1/\" target=\"_blank\">pepple.js</a>(originally <a href=\"http://simplyjs.io/\" target=\"_blank\">simply.js</a>)였기 때문입니다. 가까이 두고 사용하고 있는 기기인만큼 새로운 앱에 대한 아이디어가 종종 떠올랐는데 이를 직접 만들어보고 싶었기 때문입니다.\n</p>\n\n<h4 style=\"text-align:left;\">\n  <strong>필요해서 배운다!<br> </strong>\n</h4>\n\n<p style=\"text-align:left;\">\n  결국 필요에 의해 자바스크립트를 선택했다라고 말할 수 있겠습니다. 결론은 너무 당연한 것을 이야기하는 것 같습니다. 결국 모든 언어를 배우는 이유는 해당 언어가 자신이 만들고자 하는 서비스에 꼭 필요한 기능을 가졌거나 그 언어로 작업했을 때 발생하는 효용이 있기 때문이라는 겁니다.\n</p>"},{"id":"47","title":"[JavaScript] 자바스크립트, 어떻게 공부하지?","date":"2015-07-21T13:39:27.000Z","author":"rabby","layout":"post","guid":"https://rabbylab.wordpress.com/?p=47","geo_public":[0],"_content":"어떤 일의 전문가를 찾아가야 그 일의 전문가가 될 수 있습니다. 배움을 위해 스승을 찾는 것은 너무나 당연한 일이지요. 저는 자바스크립트를 공부하기로 결심하고 이를 가르쳐줄 훌륭한 스승을 찾아야겠다고 생각했습니다.\n\n#### **훌륭한 스승을 찾아서**\n\n훌륭한 스승을 찾겠다는 목적으로 정보의 바다를 뒤지기 시작했습니다. (주위를 둘러볼 수 있었으나 당시에는 여유가 없었습니다.) 역시나 저를 실망시키지 않은 곳은 <a href=\"https://opentutorials.org/course/743\" target=\"_blank\">생활코딩 &#8211; JavaScript </a>강의와 <a href=\"https://www.codecademy.com/en/tracks/javascript\" target=\"_blank\">Codecademy &#8211; JavaScript </a>강의였습니다. 이고잉님을 스승님 삼아 동영상 강의를 듣고 Codecademy의 커리큘럼을 따라 착실히 공부를 1주일쯤 했습니다. 저는 알 수 없는 허전함을 느꼈습니다. 뭔가 배우고 있다는 느낌보다 그냥 강의와 과제를 해치운다는 느낌이었습니다. 온전히 제것이 되지 않는다는 느낌이 들었죠. 이때 저는 인터넷 강의가 가지는 한계가 존재한다는 사실을 깨달았습니다. 곧장 다른 방법을 찾기 시작했습니다.\n\n정보의 바다를 헤매이다 마침내 주옥 같은 글을 발견했습니다. &#8220;<a href=\"http://nolboo.kim/blog/2014/03/13/how-to-learn-javascript-properly/\" target=\"_blank\">자바스크립트 제대로 배우기</a>&#8220;라는 nolbookim님의 글이었습니다. 이 글은 &#8220;<a href=\"http://javascriptissexy.com/how-to-learn-javascript-properly/\" target=\"_blank\">How to Learn JavaScript Properly</a>&#8220;라는 글의 번역글인데 영어가 부족한 저에게 있어서 정말 단비같은 글이었습니다. 글을 보면 아시겠지만 약 6~8주가 걸리는 커리큘럼입니다. 원문 저자에 따르면 주당 20~25시간을 투자해야한다고 합니다. 20시간으로 계산해도 하루에 3시간은 공부해야하는 분량입니다. 마침 일도 관두고 집에서 쉬고 있던 저에게 적절한 커리큘럼이었습니다.\n\n해당 커리큘럼에선 두권의 책을 권장하고 있습니다. 저는 약간의 프로그래밍 경험을 가진 이들을 위한 책인 <a href=\"http://www.insightbook.co.kr/post/5765\" target=\"_blank\">프론트엔드 개발자를 위한 자바스크립트 프로그래밍</a>을 저의 책으로 선정했습니다. 그리고 책이 무척 두껍다는 이야기를 들은터라 휴대하기 좋은 책을 한권 더 구매했습니다. (실제로 받아보니 1130페이지의 엄청난 두께였습니다.) 바로 <a href=\"http://www.hanbit.co.kr/book/look.html?isbn=978-89-7914-598-4\" target=\"_blank\">더글라스 크락포드의 자바스크립트 핵심 가이드</a>입니다. 휴대하고 이동하는 길에 읽기 위해 구매했습니다. 이로써 저에게 두명의 스승이 생긴 것입니다.\n\n책에 관한 평가와 살짝 살펴본 제 견해로는 첫번째 스승인 니콜라스 자카스(Nicholas C. Zakas)는 친절한 선배 같은 스승입니다. 자바스크립트에 관해 해주고 싶은 말이 많아 자바스크립트의 전반적인 이야기를 지루하지 않게 들려줍니다. 두번째 스승인 더글라스 크락포드(Douglas Crockford)는 달인의 경지에 이른 교수님의 포스가 흘러넘칩니다. 그의 책은 두께는 얇지만 깊이가 있다고 알려져있습니다. 생활코딩의 이고잉님은 &#8216;보면 볼수록 씹는 맛이 나는 책&#8217;이라고 평했습니다.<figure id=\"attachment_55\" style=\"width: 264px\" class=\"wp-caption alignleft\">\n\n<div>\n![](/images/nicholas-zakas.jpg)\n<figcaption class=\"wp-caption-text\">Nicholas C. Zakas</figcaption>\n</div> \n<div>\n![](/images/douglas-crockford.jpg)\n<figcaption class=\"wp-caption-text\">Doublas Crockford</figcaption>\n</div>\n\n#### **이제 훌륭한 제자가 되자!**\n\n위의 블로그에서 소개드린 커리큘럼은 책을 읽으며 병행하는 도구로 Codecademy를 추천하고 있습니다. 저는 이미 해당 과정을 절반정도 수료한 상태임으로 커리큘럼보다 빠른 속도로 공부를 진행할 계획입니다. 하루에 3시간씩 꾸준함을 무기로 야금야금 자바스크립트를 배워나가겠습니다. 분명한 사실은 저는 이번 도전을 통해 자신감을 얻고 훌륭한 제자가 될 것입니다. 그리고 언젠가는 청출어람할 날도 오겠지요. 하지만 오늘은 아닌 것 같습니다. 오늘은 오늘의 공부에 최선을 다하겠습니다.","source":"_posts/javascript-intro-2.md","raw":"---\nid: 47\ntitle: '[JavaScript] 자바스크립트, 어떻게 공부하지?'\ndate: 2015-07-21T22:39:27+00:00\nauthor: rabby\nlayout: post\nguid: https://rabbylab.wordpress.com/?p=47\npermalink: /javasrcipt-intro-2/\ngeo_public:\n  - 0\ncategories:\n  - rabbylab\ntags:\n  - javascript\n---\n어떤 일의 전문가를 찾아가야 그 일의 전문가가 될 수 있습니다. 배움을 위해 스승을 찾는 것은 너무나 당연한 일이지요. 저는 자바스크립트를 공부하기로 결심하고 이를 가르쳐줄 훌륭한 스승을 찾아야겠다고 생각했습니다.\n\n#### **훌륭한 스승을 찾아서**\n\n훌륭한 스승을 찾겠다는 목적으로 정보의 바다를 뒤지기 시작했습니다. (주위를 둘러볼 수 있었으나 당시에는 여유가 없었습니다.) 역시나 저를 실망시키지 않은 곳은 <a href=\"https://opentutorials.org/course/743\" target=\"_blank\">생활코딩 &#8211; JavaScript </a>강의와 <a href=\"https://www.codecademy.com/en/tracks/javascript\" target=\"_blank\">Codecademy &#8211; JavaScript </a>강의였습니다. 이고잉님을 스승님 삼아 동영상 강의를 듣고 Codecademy의 커리큘럼을 따라 착실히 공부를 1주일쯤 했습니다. 저는 알 수 없는 허전함을 느꼈습니다. 뭔가 배우고 있다는 느낌보다 그냥 강의와 과제를 해치운다는 느낌이었습니다. 온전히 제것이 되지 않는다는 느낌이 들었죠. 이때 저는 인터넷 강의가 가지는 한계가 존재한다는 사실을 깨달았습니다. 곧장 다른 방법을 찾기 시작했습니다.\n\n정보의 바다를 헤매이다 마침내 주옥 같은 글을 발견했습니다. &#8220;<a href=\"http://nolboo.kim/blog/2014/03/13/how-to-learn-javascript-properly/\" target=\"_blank\">자바스크립트 제대로 배우기</a>&#8220;라는 nolbookim님의 글이었습니다. 이 글은 &#8220;<a href=\"http://javascriptissexy.com/how-to-learn-javascript-properly/\" target=\"_blank\">How to Learn JavaScript Properly</a>&#8220;라는 글의 번역글인데 영어가 부족한 저에게 있어서 정말 단비같은 글이었습니다. 글을 보면 아시겠지만 약 6~8주가 걸리는 커리큘럼입니다. 원문 저자에 따르면 주당 20~25시간을 투자해야한다고 합니다. 20시간으로 계산해도 하루에 3시간은 공부해야하는 분량입니다. 마침 일도 관두고 집에서 쉬고 있던 저에게 적절한 커리큘럼이었습니다.\n\n해당 커리큘럼에선 두권의 책을 권장하고 있습니다. 저는 약간의 프로그래밍 경험을 가진 이들을 위한 책인 <a href=\"http://www.insightbook.co.kr/post/5765\" target=\"_blank\">프론트엔드 개발자를 위한 자바스크립트 프로그래밍</a>을 저의 책으로 선정했습니다. 그리고 책이 무척 두껍다는 이야기를 들은터라 휴대하기 좋은 책을 한권 더 구매했습니다. (실제로 받아보니 1130페이지의 엄청난 두께였습니다.) 바로 <a href=\"http://www.hanbit.co.kr/book/look.html?isbn=978-89-7914-598-4\" target=\"_blank\">더글라스 크락포드의 자바스크립트 핵심 가이드</a>입니다. 휴대하고 이동하는 길에 읽기 위해 구매했습니다. 이로써 저에게 두명의 스승이 생긴 것입니다.\n\n책에 관한 평가와 살짝 살펴본 제 견해로는 첫번째 스승인 니콜라스 자카스(Nicholas C. Zakas)는 친절한 선배 같은 스승입니다. 자바스크립트에 관해 해주고 싶은 말이 많아 자바스크립트의 전반적인 이야기를 지루하지 않게 들려줍니다. 두번째 스승인 더글라스 크락포드(Douglas Crockford)는 달인의 경지에 이른 교수님의 포스가 흘러넘칩니다. 그의 책은 두께는 얇지만 깊이가 있다고 알려져있습니다. 생활코딩의 이고잉님은 &#8216;보면 볼수록 씹는 맛이 나는 책&#8217;이라고 평했습니다.<figure id=\"attachment_55\" style=\"width: 264px\" class=\"wp-caption alignleft\">\n\n<div>\n![](/images/nicholas-zakas.jpg)\n<figcaption class=\"wp-caption-text\">Nicholas C. Zakas</figcaption>\n</div> \n<div>\n![](/images/douglas-crockford.jpg)\n<figcaption class=\"wp-caption-text\">Doublas Crockford</figcaption>\n</div>\n\n#### **이제 훌륭한 제자가 되자!**\n\n위의 블로그에서 소개드린 커리큘럼은 책을 읽으며 병행하는 도구로 Codecademy를 추천하고 있습니다. 저는 이미 해당 과정을 절반정도 수료한 상태임으로 커리큘럼보다 빠른 속도로 공부를 진행할 계획입니다. 하루에 3시간씩 꾸준함을 무기로 야금야금 자바스크립트를 배워나가겠습니다. 분명한 사실은 저는 이번 도전을 통해 자신감을 얻고 훌륭한 제자가 될 것입니다. 그리고 언젠가는 청출어람할 날도 오겠지요. 하지만 오늘은 아닌 것 같습니다. 오늘은 오늘의 공부에 최선을 다하겠습니다.","slug":"/javasrcipt-intro-2/","published":1,"updated":"2020-01-13T13:40:46.651Z","comments":1,"photos":[],"link":"","_id":"ck6jcr9go003idirvfwzf9ka7","content":"<p>어떤 일의 전문가를 찾아가야 그 일의 전문가가 될 수 있습니다. 배움을 위해 스승을 찾는 것은 너무나 당연한 일이지요. 저는 자바스크립트를 공부하기로 결심하고 이를 가르쳐줄 훌륭한 스승을 찾아야겠다고 생각했습니다.</p>\n<h4 id=\"훌륭한-스승을-찾아서\"><a href=\"#훌륭한-스승을-찾아서\" class=\"headerlink\" title=\"훌륭한 스승을 찾아서\"></a><strong>훌륭한 스승을 찾아서</strong></h4><p>훌륭한 스승을 찾겠다는 목적으로 정보의 바다를 뒤지기 시작했습니다. (주위를 둘러볼 수 있었으나 당시에는 여유가 없었습니다.) 역시나 저를 실망시키지 않은 곳은 <a href=\"https://opentutorials.org/course/743\" target=\"_blank\">생활코딩 &#8211; JavaScript </a>강의와 <a href=\"https://www.codecademy.com/en/tracks/javascript\" target=\"_blank\">Codecademy &#8211; JavaScript </a>강의였습니다. 이고잉님을 스승님 삼아 동영상 강의를 듣고 Codecademy의 커리큘럼을 따라 착실히 공부를 1주일쯤 했습니다. 저는 알 수 없는 허전함을 느꼈습니다. 뭔가 배우고 있다는 느낌보다 그냥 강의와 과제를 해치운다는 느낌이었습니다. 온전히 제것이 되지 않는다는 느낌이 들었죠. 이때 저는 인터넷 강의가 가지는 한계가 존재한다는 사실을 깨달았습니다. 곧장 다른 방법을 찾기 시작했습니다.</p>\n<p>정보의 바다를 헤매이다 마침내 주옥 같은 글을 발견했습니다. &#8220;<a href=\"http://nolboo.kim/blog/2014/03/13/how-to-learn-javascript-properly/\" target=\"_blank\">자바스크립트 제대로 배우기</a>&#8220;라는 nolbookim님의 글이었습니다. 이 글은 &#8220;<a href=\"http://javascriptissexy.com/how-to-learn-javascript-properly/\" target=\"_blank\">How to Learn JavaScript Properly</a>&#8220;라는 글의 번역글인데 영어가 부족한 저에게 있어서 정말 단비같은 글이었습니다. 글을 보면 아시겠지만 약 6<del>8주가 걸리는 커리큘럼입니다. 원문 저자에 따르면 주당 20</del>25시간을 투자해야한다고 합니다. 20시간으로 계산해도 하루에 3시간은 공부해야하는 분량입니다. 마침 일도 관두고 집에서 쉬고 있던 저에게 적절한 커리큘럼이었습니다.</p>\n<p>해당 커리큘럼에선 두권의 책을 권장하고 있습니다. 저는 약간의 프로그래밍 경험을 가진 이들을 위한 책인 <a href=\"http://www.insightbook.co.kr/post/5765\" target=\"_blank\">프론트엔드 개발자를 위한 자바스크립트 프로그래밍</a>을 저의 책으로 선정했습니다. 그리고 책이 무척 두껍다는 이야기를 들은터라 휴대하기 좋은 책을 한권 더 구매했습니다. (실제로 받아보니 1130페이지의 엄청난 두께였습니다.) 바로 <a href=\"http://www.hanbit.co.kr/book/look.html?isbn=978-89-7914-598-4\" target=\"_blank\">더글라스 크락포드의 자바스크립트 핵심 가이드</a>입니다. 휴대하고 이동하는 길에 읽기 위해 구매했습니다. 이로써 저에게 두명의 스승이 생긴 것입니다.</p>\n<p>책에 관한 평가와 살짝 살펴본 제 견해로는 첫번째 스승인 니콜라스 자카스(Nicholas C. Zakas)는 친절한 선배 같은 스승입니다. 자바스크립트에 관해 해주고 싶은 말이 많아 자바스크립트의 전반적인 이야기를 지루하지 않게 들려줍니다. 두번째 스승인 더글라스 크락포드(Douglas Crockford)는 달인의 경지에 이른 교수님의 포스가 흘러넘칩니다. 그의 책은 두께는 얇지만 깊이가 있다고 알려져있습니다. 생활코딩의 이고잉님은 &#8216;보면 볼수록 씹는 맛이 나는 책&#8217;이라고 평했습니다.<figure id=\"attachment_55\" style=\"width: 264px\" class=\"wp-caption alignleft\"></figure></p>\n<div>\n![](/images/nicholas-zakas.jpg)\n<figcaption class=\"wp-caption-text\">Nicholas C. Zakas</figcaption>\n</div> \n<div>\n![](/images/douglas-crockford.jpg)\n<figcaption class=\"wp-caption-text\">Doublas Crockford</figcaption>\n</div>\n\n<h4 id=\"이제-훌륭한-제자가-되자\"><a href=\"#이제-훌륭한-제자가-되자\" class=\"headerlink\" title=\"이제 훌륭한 제자가 되자!\"></a><strong>이제 훌륭한 제자가 되자!</strong></h4><p>위의 블로그에서 소개드린 커리큘럼은 책을 읽으며 병행하는 도구로 Codecademy를 추천하고 있습니다. 저는 이미 해당 과정을 절반정도 수료한 상태임으로 커리큘럼보다 빠른 속도로 공부를 진행할 계획입니다. 하루에 3시간씩 꾸준함을 무기로 야금야금 자바스크립트를 배워나가겠습니다. 분명한 사실은 저는 이번 도전을 통해 자신감을 얻고 훌륭한 제자가 될 것입니다. 그리고 언젠가는 청출어람할 날도 오겠지요. 하지만 오늘은 아닌 것 같습니다. 오늘은 오늘의 공부에 최선을 다하겠습니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>어떤 일의 전문가를 찾아가야 그 일의 전문가가 될 수 있습니다. 배움을 위해 스승을 찾는 것은 너무나 당연한 일이지요. 저는 자바스크립트를 공부하기로 결심하고 이를 가르쳐줄 훌륭한 스승을 찾아야겠다고 생각했습니다.</p>\n<h4 id=\"훌륭한-스승을-찾아서\"><a href=\"#훌륭한-스승을-찾아서\" class=\"headerlink\" title=\"훌륭한 스승을 찾아서\"></a><strong>훌륭한 스승을 찾아서</strong></h4><p>훌륭한 스승을 찾겠다는 목적으로 정보의 바다를 뒤지기 시작했습니다. (주위를 둘러볼 수 있었으나 당시에는 여유가 없었습니다.) 역시나 저를 실망시키지 않은 곳은 <a href=\"https://opentutorials.org/course/743\" target=\"_blank\">생활코딩 &#8211; JavaScript </a>강의와 <a href=\"https://www.codecademy.com/en/tracks/javascript\" target=\"_blank\">Codecademy &#8211; JavaScript </a>강의였습니다. 이고잉님을 스승님 삼아 동영상 강의를 듣고 Codecademy의 커리큘럼을 따라 착실히 공부를 1주일쯤 했습니다. 저는 알 수 없는 허전함을 느꼈습니다. 뭔가 배우고 있다는 느낌보다 그냥 강의와 과제를 해치운다는 느낌이었습니다. 온전히 제것이 되지 않는다는 느낌이 들었죠. 이때 저는 인터넷 강의가 가지는 한계가 존재한다는 사실을 깨달았습니다. 곧장 다른 방법을 찾기 시작했습니다.</p>\n<p>정보의 바다를 헤매이다 마침내 주옥 같은 글을 발견했습니다. &#8220;<a href=\"http://nolboo.kim/blog/2014/03/13/how-to-learn-javascript-properly/\" target=\"_blank\">자바스크립트 제대로 배우기</a>&#8220;라는 nolbookim님의 글이었습니다. 이 글은 &#8220;<a href=\"http://javascriptissexy.com/how-to-learn-javascript-properly/\" target=\"_blank\">How to Learn JavaScript Properly</a>&#8220;라는 글의 번역글인데 영어가 부족한 저에게 있어서 정말 단비같은 글이었습니다. 글을 보면 아시겠지만 약 6<del>8주가 걸리는 커리큘럼입니다. 원문 저자에 따르면 주당 20</del>25시간을 투자해야한다고 합니다. 20시간으로 계산해도 하루에 3시간은 공부해야하는 분량입니다. 마침 일도 관두고 집에서 쉬고 있던 저에게 적절한 커리큘럼이었습니다.</p>\n<p>해당 커리큘럼에선 두권의 책을 권장하고 있습니다. 저는 약간의 프로그래밍 경험을 가진 이들을 위한 책인 <a href=\"http://www.insightbook.co.kr/post/5765\" target=\"_blank\">프론트엔드 개발자를 위한 자바스크립트 프로그래밍</a>을 저의 책으로 선정했습니다. 그리고 책이 무척 두껍다는 이야기를 들은터라 휴대하기 좋은 책을 한권 더 구매했습니다. (실제로 받아보니 1130페이지의 엄청난 두께였습니다.) 바로 <a href=\"http://www.hanbit.co.kr/book/look.html?isbn=978-89-7914-598-4\" target=\"_blank\">더글라스 크락포드의 자바스크립트 핵심 가이드</a>입니다. 휴대하고 이동하는 길에 읽기 위해 구매했습니다. 이로써 저에게 두명의 스승이 생긴 것입니다.</p>\n<p>책에 관한 평가와 살짝 살펴본 제 견해로는 첫번째 스승인 니콜라스 자카스(Nicholas C. Zakas)는 친절한 선배 같은 스승입니다. 자바스크립트에 관해 해주고 싶은 말이 많아 자바스크립트의 전반적인 이야기를 지루하지 않게 들려줍니다. 두번째 스승인 더글라스 크락포드(Douglas Crockford)는 달인의 경지에 이른 교수님의 포스가 흘러넘칩니다. 그의 책은 두께는 얇지만 깊이가 있다고 알려져있습니다. 생활코딩의 이고잉님은 &#8216;보면 볼수록 씹는 맛이 나는 책&#8217;이라고 평했습니다.<figure id=\"attachment_55\" style=\"width: 264px\" class=\"wp-caption alignleft\"></figure></p>\n<div>\n![](/images/nicholas-zakas.jpg)\n<figcaption class=\"wp-caption-text\">Nicholas C. Zakas</figcaption>\n</div> \n<div>\n![](/images/douglas-crockford.jpg)\n<figcaption class=\"wp-caption-text\">Doublas Crockford</figcaption>\n</div>\n\n<h4 id=\"이제-훌륭한-제자가-되자\"><a href=\"#이제-훌륭한-제자가-되자\" class=\"headerlink\" title=\"이제 훌륭한 제자가 되자!\"></a><strong>이제 훌륭한 제자가 되자!</strong></h4><p>위의 블로그에서 소개드린 커리큘럼은 책을 읽으며 병행하는 도구로 Codecademy를 추천하고 있습니다. 저는 이미 해당 과정을 절반정도 수료한 상태임으로 커리큘럼보다 빠른 속도로 공부를 진행할 계획입니다. 하루에 3시간씩 꾸준함을 무기로 야금야금 자바스크립트를 배워나가겠습니다. 분명한 사실은 저는 이번 도전을 통해 자신감을 얻고 훌륭한 제자가 될 것입니다. 그리고 언젠가는 청출어람할 날도 오겠지요. 하지만 오늘은 아닌 것 같습니다. 오늘은 오늘의 공부에 최선을 다하겠습니다.</p>\n"},{"id":"87","title":"[JavaScript] 자바스크립트의 예약어","date":"2015-08-31T22:30:00.000Z","author":"rabby","layout":"post","guid":"https://rabbylab.wordpress.com/?p=87","_content":"다른 언어들과 마찬가지로 자바스크립트 역시 문장, 변수, 매개변수, 연산자, 라벨 등에 사용하는 이름을 정하는데 있어서 문자, 숫자, _(under bar)만을 사용하도록 허용하고 있습니다.\n\n모든 것이 가능하지만 특별히 사용할 수 없는  &#8216;예약어&#8217;가 존재합니다. 예약어는 말 그대로 예약된 단어입니다. 다른 용도로 사용되거나 사용될 여지가 있는 단어를 의미합니다. 그 목록은 아래와 같습니다.\n\n<p style=\"padding-left:30px;\">\n  A &#8211; abstract\n</p>\n\n<p style=\"padding-left:30px;\">\n  B &#8211; boolean, break, byte\n</p>\n\n<p style=\"padding-left:30px;\">\n  C &#8211; case, catch, char, class, const, continue\n</p>\n\n<p style=\"padding-left:30px;\">\n  D &#8211; debugger, default, delete, do, double\n</p>\n\n<p style=\"padding-left:30px;\">\n  E &#8211; else, enum, export, extends\n</p>\n\n<p style=\"padding-left:30px;\">\n  F &#8211; false, final, finally, float, for, function\n</p>\n\n<p style=\"padding-left:30px;\">\n  G &#8211; goto\n</p>\n\n<p style=\"padding-left:30px;\">\n  I &#8211; if, implements, import, in, instanceof, int, interface\n</p>\n\n<p style=\"padding-left:30px;\">\n  L &#8211; long\n</p>\n\n<p style=\"padding-left:30px;\">\n  N &#8211; native, new, null\n</p>\n\n<p style=\"padding-left:30px;\">\n  P &#8211; package, private, protected, public\n</p>\n\n<p style=\"padding-left:30px;\">\n  R &#8211; return\n</p>\n\n<p style=\"padding-left:30px;\">\n  S &#8211; short, static, super, switch, synchronized\n</p>\n\n<p style=\"padding-left:30px;\">\n  T &#8211; this, throw, throws, transient, true, try, typeof\n</p>\n\n<p style=\"padding-left:30px;\">\n  V &#8211; var, volatile, void\n</p>\n\n<p style=\"padding-left:30px;\">\n  W &#8211; while, with\n</p>\n\n이상 55개의 예약어가 있습니다. 예약어는 변수 이름이나 매겨변수 이름으로 사용할 수 없습니다.","source":"_posts/javascript-keywords.md","raw":"---\nid: 87\ntitle: '[JavaScript] 자바스크립트의 예약어'\ndate: 2015-09-01T07:30:00+00:00\nauthor: rabby\nlayout: post\nguid: https://rabbylab.wordpress.com/?p=87\npermalink: /javascript-keyword/\ncategories:\n  - rabbylab\ntags:\n  - javascript\n---\n다른 언어들과 마찬가지로 자바스크립트 역시 문장, 변수, 매개변수, 연산자, 라벨 등에 사용하는 이름을 정하는데 있어서 문자, 숫자, _(under bar)만을 사용하도록 허용하고 있습니다.\n\n모든 것이 가능하지만 특별히 사용할 수 없는  &#8216;예약어&#8217;가 존재합니다. 예약어는 말 그대로 예약된 단어입니다. 다른 용도로 사용되거나 사용될 여지가 있는 단어를 의미합니다. 그 목록은 아래와 같습니다.\n\n<p style=\"padding-left:30px;\">\n  A &#8211; abstract\n</p>\n\n<p style=\"padding-left:30px;\">\n  B &#8211; boolean, break, byte\n</p>\n\n<p style=\"padding-left:30px;\">\n  C &#8211; case, catch, char, class, const, continue\n</p>\n\n<p style=\"padding-left:30px;\">\n  D &#8211; debugger, default, delete, do, double\n</p>\n\n<p style=\"padding-left:30px;\">\n  E &#8211; else, enum, export, extends\n</p>\n\n<p style=\"padding-left:30px;\">\n  F &#8211; false, final, finally, float, for, function\n</p>\n\n<p style=\"padding-left:30px;\">\n  G &#8211; goto\n</p>\n\n<p style=\"padding-left:30px;\">\n  I &#8211; if, implements, import, in, instanceof, int, interface\n</p>\n\n<p style=\"padding-left:30px;\">\n  L &#8211; long\n</p>\n\n<p style=\"padding-left:30px;\">\n  N &#8211; native, new, null\n</p>\n\n<p style=\"padding-left:30px;\">\n  P &#8211; package, private, protected, public\n</p>\n\n<p style=\"padding-left:30px;\">\n  R &#8211; return\n</p>\n\n<p style=\"padding-left:30px;\">\n  S &#8211; short, static, super, switch, synchronized\n</p>\n\n<p style=\"padding-left:30px;\">\n  T &#8211; this, throw, throws, transient, true, try, typeof\n</p>\n\n<p style=\"padding-left:30px;\">\n  V &#8211; var, volatile, void\n</p>\n\n<p style=\"padding-left:30px;\">\n  W &#8211; while, with\n</p>\n\n이상 55개의 예약어가 있습니다. 예약어는 변수 이름이나 매겨변수 이름으로 사용할 수 없습니다.","slug":"/javascript-keyword/","published":1,"updated":"2019-12-05T15:05:29.490Z","comments":1,"photos":[],"link":"","_id":"ck6jcr9gq003mdirv6o6kb53h","content":"<p>다른 언어들과 마찬가지로 자바스크립트 역시 문장, 변수, 매개변수, 연산자, 라벨 등에 사용하는 이름을 정하는데 있어서 문자, 숫자, _(under bar)만을 사용하도록 허용하고 있습니다.</p>\n<p>모든 것이 가능하지만 특별히 사용할 수 없는  &#8216;예약어&#8217;가 존재합니다. 예약어는 말 그대로 예약된 단어입니다. 다른 용도로 사용되거나 사용될 여지가 있는 단어를 의미합니다. 그 목록은 아래와 같습니다.</p>\n<p style=\"padding-left:30px;\">\n  A &#8211; abstract\n</p>\n\n<p style=\"padding-left:30px;\">\n  B &#8211; boolean, break, byte\n</p>\n\n<p style=\"padding-left:30px;\">\n  C &#8211; case, catch, char, class, const, continue\n</p>\n\n<p style=\"padding-left:30px;\">\n  D &#8211; debugger, default, delete, do, double\n</p>\n\n<p style=\"padding-left:30px;\">\n  E &#8211; else, enum, export, extends\n</p>\n\n<p style=\"padding-left:30px;\">\n  F &#8211; false, final, finally, float, for, function\n</p>\n\n<p style=\"padding-left:30px;\">\n  G &#8211; goto\n</p>\n\n<p style=\"padding-left:30px;\">\n  I &#8211; if, implements, import, in, instanceof, int, interface\n</p>\n\n<p style=\"padding-left:30px;\">\n  L &#8211; long\n</p>\n\n<p style=\"padding-left:30px;\">\n  N &#8211; native, new, null\n</p>\n\n<p style=\"padding-left:30px;\">\n  P &#8211; package, private, protected, public\n</p>\n\n<p style=\"padding-left:30px;\">\n  R &#8211; return\n</p>\n\n<p style=\"padding-left:30px;\">\n  S &#8211; short, static, super, switch, synchronized\n</p>\n\n<p style=\"padding-left:30px;\">\n  T &#8211; this, throw, throws, transient, true, try, typeof\n</p>\n\n<p style=\"padding-left:30px;\">\n  V &#8211; var, volatile, void\n</p>\n\n<p style=\"padding-left:30px;\">\n  W &#8211; while, with\n</p>\n\n<p>이상 55개의 예약어가 있습니다. 예약어는 변수 이름이나 매겨변수 이름으로 사용할 수 없습니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>다른 언어들과 마찬가지로 자바스크립트 역시 문장, 변수, 매개변수, 연산자, 라벨 등에 사용하는 이름을 정하는데 있어서 문자, 숫자, _(under bar)만을 사용하도록 허용하고 있습니다.</p>\n<p>모든 것이 가능하지만 특별히 사용할 수 없는  &#8216;예약어&#8217;가 존재합니다. 예약어는 말 그대로 예약된 단어입니다. 다른 용도로 사용되거나 사용될 여지가 있는 단어를 의미합니다. 그 목록은 아래와 같습니다.</p>\n<p style=\"padding-left:30px;\">\n  A &#8211; abstract\n</p>\n\n<p style=\"padding-left:30px;\">\n  B &#8211; boolean, break, byte\n</p>\n\n<p style=\"padding-left:30px;\">\n  C &#8211; case, catch, char, class, const, continue\n</p>\n\n<p style=\"padding-left:30px;\">\n  D &#8211; debugger, default, delete, do, double\n</p>\n\n<p style=\"padding-left:30px;\">\n  E &#8211; else, enum, export, extends\n</p>\n\n<p style=\"padding-left:30px;\">\n  F &#8211; false, final, finally, float, for, function\n</p>\n\n<p style=\"padding-left:30px;\">\n  G &#8211; goto\n</p>\n\n<p style=\"padding-left:30px;\">\n  I &#8211; if, implements, import, in, instanceof, int, interface\n</p>\n\n<p style=\"padding-left:30px;\">\n  L &#8211; long\n</p>\n\n<p style=\"padding-left:30px;\">\n  N &#8211; native, new, null\n</p>\n\n<p style=\"padding-left:30px;\">\n  P &#8211; package, private, protected, public\n</p>\n\n<p style=\"padding-left:30px;\">\n  R &#8211; return\n</p>\n\n<p style=\"padding-left:30px;\">\n  S &#8211; short, static, super, switch, synchronized\n</p>\n\n<p style=\"padding-left:30px;\">\n  T &#8211; this, throw, throws, transient, true, try, typeof\n</p>\n\n<p style=\"padding-left:30px;\">\n  V &#8211; var, volatile, void\n</p>\n\n<p style=\"padding-left:30px;\">\n  W &#8211; while, with\n</p>\n\n<p>이상 55개의 예약어가 있습니다. 예약어는 변수 이름이나 매겨변수 이름으로 사용할 수 없습니다.</p>\n"},{"id":"402","title":"[JavaScript] Learn about MEAN stack","date":"2016-02-25T06:42:11.000Z","author":"rabby","layout":"post","guid":"https://rabbylab.wordpress.com/?p=402","_content":"자바스크립트 공부로 시작한 블로그인데 자바스크립트 관련 글을 너무 오랫동안 쓰지 않았습니다. 오랜만에 다시 글을 씁니다. 그동안 인턴이다 영어공부다 해서 블로그 관리에 소홀했습니다. 그렇다고 공부를 소홀히 하진 않았습니다. 제목처럼 한동안 <a href=\"http://mean.io/\" target=\"_blank\">MEAN stack</a> 을 공부하고 있었습니다. 아시다시피 MEAN stack 은 MongoDB, Express, Angular, Node 의미합니다. 모두 자바스크립트로 코딩할 수 있습니다. MEAN stack 을 활용하면 저같은 초보 개발자도 풀스택 개발을 할 수 있다기에 시작했습니다. 인턴으로 일하면서 혼자서는 제대로된 서비스를 만들지 못해 늘 아쉬웠던 탓에 풀스택 개발에 대한 욕구가 있었습니다.\n\n책을 사는 것으로 공부를 시작했습니다. 책은 한빛미디어에서 나온 <a href=\"http://www.hanbit.co.kr/book/look.html?isbn=978-89-6848-218-2\" target=\"_blank\"><풀스택 개발자를 위한 MEAN 스택 입문></a>이라는 책입니다. 한권을 독파하면 Human Resource Management Application을 구현할 수 있습니다. 1월말부터 조금씩 공부해서 오늘까지 총 23장 중 21장을 공부했습니다. 나름대로 열심히 했는데 아직은 책 없이 구현할 수 있는 정도는 아닙니다. 이번주 중으로 23장까지 마무리 짓고 다음달부터는 제가 자체적으로 기획한 앱을 구현해 볼 생각입니다. (적용이 없으면 제대로된 학습이 되질 않죠.)\n\n지금까지 MEAN stack 을 공부하면서 코딩한 내용을 Github 에 올려뒀습니다. 아직까지는 예제 소스를 막 써보느라 난잡한 감이 있습니다. 차츰 정리해나가도록 하겠습니다. 주소는 아래와 같습니다.\n\n<a href=\"https://github.com/joeunha/learn-about-meanstack\" target=\"_blank\">https://github.com/joeunha/learn-about-meanstack</a>\n\n&nbsp;\n\n다음주부터 개강이라 바쁠것 같습니다. 그래도 조금 느리더라도 github 뿐만 아니라 블로그에도 꾸준히 배우는 내용 올리도록 하겠습니다. 지켜봐주세요.","source":"_posts/learn-about-mean-stack.md","raw":"---\nid: 402\ntitle: '[JavaScript] Learn about MEAN stack'\ndate: 2016-02-25T15:42:11+00:00\nauthor: rabby\nlayout: post\nguid: https://rabbylab.wordpress.com/?p=402\npermalink: /learn-about-mean-stack/\ncategories:\n  - rabbylab\ntags:\n  - javascript\n---\n자바스크립트 공부로 시작한 블로그인데 자바스크립트 관련 글을 너무 오랫동안 쓰지 않았습니다. 오랜만에 다시 글을 씁니다. 그동안 인턴이다 영어공부다 해서 블로그 관리에 소홀했습니다. 그렇다고 공부를 소홀히 하진 않았습니다. 제목처럼 한동안 <a href=\"http://mean.io/\" target=\"_blank\">MEAN stack</a> 을 공부하고 있었습니다. 아시다시피 MEAN stack 은 MongoDB, Express, Angular, Node 의미합니다. 모두 자바스크립트로 코딩할 수 있습니다. MEAN stack 을 활용하면 저같은 초보 개발자도 풀스택 개발을 할 수 있다기에 시작했습니다. 인턴으로 일하면서 혼자서는 제대로된 서비스를 만들지 못해 늘 아쉬웠던 탓에 풀스택 개발에 대한 욕구가 있었습니다.\n\n책을 사는 것으로 공부를 시작했습니다. 책은 한빛미디어에서 나온 <a href=\"http://www.hanbit.co.kr/book/look.html?isbn=978-89-6848-218-2\" target=\"_blank\"><풀스택 개발자를 위한 MEAN 스택 입문></a>이라는 책입니다. 한권을 독파하면 Human Resource Management Application을 구현할 수 있습니다. 1월말부터 조금씩 공부해서 오늘까지 총 23장 중 21장을 공부했습니다. 나름대로 열심히 했는데 아직은 책 없이 구현할 수 있는 정도는 아닙니다. 이번주 중으로 23장까지 마무리 짓고 다음달부터는 제가 자체적으로 기획한 앱을 구현해 볼 생각입니다. (적용이 없으면 제대로된 학습이 되질 않죠.)\n\n지금까지 MEAN stack 을 공부하면서 코딩한 내용을 Github 에 올려뒀습니다. 아직까지는 예제 소스를 막 써보느라 난잡한 감이 있습니다. 차츰 정리해나가도록 하겠습니다. 주소는 아래와 같습니다.\n\n<a href=\"https://github.com/joeunha/learn-about-meanstack\" target=\"_blank\">https://github.com/joeunha/learn-about-meanstack</a>\n\n&nbsp;\n\n다음주부터 개강이라 바쁠것 같습니다. 그래도 조금 느리더라도 github 뿐만 아니라 블로그에도 꾸준히 배우는 내용 올리도록 하겠습니다. 지켜봐주세요.","slug":"/learn-about-mean-stack/","published":1,"updated":"2019-12-05T15:05:29.490Z","comments":1,"photos":[],"link":"","_id":"ck6jcr9gr003pdirv6v8sqen2","content":"<p>자바스크립트 공부로 시작한 블로그인데 자바스크립트 관련 글을 너무 오랫동안 쓰지 않았습니다. 오랜만에 다시 글을 씁니다. 그동안 인턴이다 영어공부다 해서 블로그 관리에 소홀했습니다. 그렇다고 공부를 소홀히 하진 않았습니다. 제목처럼 한동안 <a href=\"http://mean.io/\" target=\"_blank\">MEAN stack</a> 을 공부하고 있었습니다. 아시다시피 MEAN stack 은 MongoDB, Express, Angular, Node 의미합니다. 모두 자바스크립트로 코딩할 수 있습니다. MEAN stack 을 활용하면 저같은 초보 개발자도 풀스택 개발을 할 수 있다기에 시작했습니다. 인턴으로 일하면서 혼자서는 제대로된 서비스를 만들지 못해 늘 아쉬웠던 탓에 풀스택 개발에 대한 욕구가 있었습니다.</p>\n<p>책을 사는 것으로 공부를 시작했습니다. 책은 한빛미디어에서 나온 <a href=\"http://www.hanbit.co.kr/book/look.html?isbn=978-89-6848-218-2\" target=\"_blank\">&lt;풀스택 개발자를 위한 MEAN 스택 입문&gt;</a>이라는 책입니다. 한권을 독파하면 Human Resource Management Application을 구현할 수 있습니다. 1월말부터 조금씩 공부해서 오늘까지 총 23장 중 21장을 공부했습니다. 나름대로 열심히 했는데 아직은 책 없이 구현할 수 있는 정도는 아닙니다. 이번주 중으로 23장까지 마무리 짓고 다음달부터는 제가 자체적으로 기획한 앱을 구현해 볼 생각입니다. (적용이 없으면 제대로된 학습이 되질 않죠.)</p>\n<p>지금까지 MEAN stack 을 공부하면서 코딩한 내용을 Github 에 올려뒀습니다. 아직까지는 예제 소스를 막 써보느라 난잡한 감이 있습니다. 차츰 정리해나가도록 하겠습니다. 주소는 아래와 같습니다.</p>\n<p><a href=\"https://github.com/joeunha/learn-about-meanstack\" target=\"_blank\">https://github.com/joeunha/learn-about-meanstack</a></p>\n<p>&nbsp;</p>\n<p>다음주부터 개강이라 바쁠것 같습니다. 그래도 조금 느리더라도 github 뿐만 아니라 블로그에도 꾸준히 배우는 내용 올리도록 하겠습니다. 지켜봐주세요.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>자바스크립트 공부로 시작한 블로그인데 자바스크립트 관련 글을 너무 오랫동안 쓰지 않았습니다. 오랜만에 다시 글을 씁니다. 그동안 인턴이다 영어공부다 해서 블로그 관리에 소홀했습니다. 그렇다고 공부를 소홀히 하진 않았습니다. 제목처럼 한동안 <a href=\"http://mean.io/\" target=\"_blank\">MEAN stack</a> 을 공부하고 있었습니다. 아시다시피 MEAN stack 은 MongoDB, Express, Angular, Node 의미합니다. 모두 자바스크립트로 코딩할 수 있습니다. MEAN stack 을 활용하면 저같은 초보 개발자도 풀스택 개발을 할 수 있다기에 시작했습니다. 인턴으로 일하면서 혼자서는 제대로된 서비스를 만들지 못해 늘 아쉬웠던 탓에 풀스택 개발에 대한 욕구가 있었습니다.</p>\n<p>책을 사는 것으로 공부를 시작했습니다. 책은 한빛미디어에서 나온 <a href=\"http://www.hanbit.co.kr/book/look.html?isbn=978-89-6848-218-2\" target=\"_blank\">&lt;풀스택 개발자를 위한 MEAN 스택 입문&gt;</a>이라는 책입니다. 한권을 독파하면 Human Resource Management Application을 구현할 수 있습니다. 1월말부터 조금씩 공부해서 오늘까지 총 23장 중 21장을 공부했습니다. 나름대로 열심히 했는데 아직은 책 없이 구현할 수 있는 정도는 아닙니다. 이번주 중으로 23장까지 마무리 짓고 다음달부터는 제가 자체적으로 기획한 앱을 구현해 볼 생각입니다. (적용이 없으면 제대로된 학습이 되질 않죠.)</p>\n<p>지금까지 MEAN stack 을 공부하면서 코딩한 내용을 Github 에 올려뒀습니다. 아직까지는 예제 소스를 막 써보느라 난잡한 감이 있습니다. 차츰 정리해나가도록 하겠습니다. 주소는 아래와 같습니다.</p>\n<p><a href=\"https://github.com/joeunha/learn-about-meanstack\" target=\"_blank\">https://github.com/joeunha/learn-about-meanstack</a></p>\n<p>&nbsp;</p>\n<p>다음주부터 개강이라 바쁠것 같습니다. 그래도 조금 느리더라도 github 뿐만 아니라 블로그에도 꾸준히 배우는 내용 올리도록 하겠습니다. 지켜봐주세요.</p>\n"},{"id":"484","title":"[JavaScript] 프로토타입","date":"2016-03-29T15:26:18.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=484","_content":"오늘은 &#8216;**prototype(프로토타입)**&#8216;에 대해 먼저 이야기해보겠습니다. 프로토타입은 사전에서 &#8220;(후대 사물의) 원조&#8221;라고 정의하고 있습니다. 다른 말로 &#8220;원형&#8221;이라고도 정의합니다. 코드 먼저 보시겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function GrandFa(){};\nGrandFa.prototype.name = \"Joeun\";\n\nfunction Father(){};\nFather.prototype = new GrandFa();\n\nfunction Sun(){};\nSun.prototype = new Father();\n\nvar o = new Sun();\n\nconsole.log(o.name);\n</pre>\n\n위 코드는 &#8220;Joeun&#8221;을 출력하는 코드입니다. 자세히 살펴보면 첫째줄에서 GrandFa가 선언됩니다. (할아버지가 제일 먼저 계셨죠.) 그리고 두번째 줄에서 그 GrandFa의 이름은 Joeun이라고 GrandFa.prototype.name으로 정의합니다. 이때 프로토타입은 자바스크립트가 객체에 기본적으로 제공하는 프로퍼티입니다. 특정 객체의 원형을 정의하기 위해 사용된다고 생각하면 쉽습니다. 그 후에는 Father가 선언되고 GrandFa의 원형(특징,성질)을 물려받습니다. 상속이죠. 마찬가지로 Sun도 Father의 원형을 물려받습니다. 아들 객체가 마지막으로 o를 생성하고 o가 그 이름을 출력하면 결과물은 Joeun이 됩니다. 무슨 일이 일어난걸까요? \n\n이 상황을 설명하기 위해 Prototype Chain이라는 개념을 이해해야합니다. 가장 아래에 있는 o.name부터 보겠습니다. 자바스크립트는 o.name을 출력하기 위해 내용물을 들여다봅니다. 그런데 그 안에 아무것도 없는걸 발견하죠. 실제로 저희는 o.name에 아무것도 정의하지 않았으니까요. 그럼 이제 자바스크립트는 o의 원형인 Sun을 찾아갑니다. sun.name을 확인합니다. 역시 비어있습니다. 위로 올라갑니다. Father를 살펴보니 또 없군요. 결국 GrandFa까지 가서 보니 이 가족의 이름은 &#8220;Joeun&#8221;입니다. 그래서 o.name에 해당 내용을 출력합니다. 어떤가요? name을 Family name이라고 했으면 더 쉬웠을지도 모르겠다는 생각이 듭니다. 결국 Prototype Chain은 원형이 이어져있는 겁니다. 하위 항목에 없으면 상위 항목으로 찾으러 올라가는거죠. 너 성이 뭐니? 라고 물어봐서 아들이 모르면 아빠가 알테고 아빠가 모르면 할아버지가 알겠죠? 위로 올라가면서 묻는겁니다.\n\n그럼 이런 경우는 어떨까요?\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function GrandFa(){};\nGrandFa.prototype.name = \"Joeun\";\n\nfunction Father(){};\nFather.prototype = new GrandFa();\nFather.prototype.name = \"Rabby\"\n\nfunction Sun(){};\nSun.prototype = new Father();\n\nvar o = new Sun();\n\nconsole.log(o.name);\n</pre>\n\n딱 한줄이 추가됐습니다. Father가 생성되고 중간에 이름을 변경합니다. 이때 출력되는 값은 &#8220;Rabby&#8221;입니다. 체인을 타고 올라가다가보니 중간쯤에 값이 있는데 그게 &#8220;Rabby&#8221;였기 때문입니다. (아빠가 성을 바꾸면 아들도 그 성을 따라가겠죠.)\n\n이때 주의하셔야할 부분이 하나 있습니다. 객체를 생성할 때 `var o = Sun.prototype`라고 하면 안됩니다. 그렇게 되면 o가 변경되면 Sun.prototype 값이 영향을 받습니다. 왜 그럴까요?\n\n&#8220;_객체는 결코 복사되지 않는다. 다만 참조된다._&#8221; 바로 이 문장 때문입니다.\n  \n그렇습니다. 객체는 복사되지 않습니다. 객체는 참조됩니다. 코드를 보시면 알 수 있습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function Dev(){};\nDev.prototype.name = \"Joeun\";\n\nvar a = b = c = Dev.prototype;\n\nconsole.log(a.name);\nconsole.log(b.name);\nconsole.log(c.name);\n\nDev.prototype.name = \"Rabby\";\n\nconsole.log(a.name);\nconsole.log(b.name);\nconsole.log(c.name);\n</pre>\n\n이 코드의 결과는 &#8220;Joeun&#8221;이 세번 반복되고 이어서 &#8220;Rabby&#8221;가 세번 반복됩니다. a,b,c를 정의할 때 저희는 Dev.prototype을 참조하게 했습니다. 만약에 복사되었다면 중간에 Dev.prototype.name 값이 바뀐다고 해서 이후 값이 바뀌지 않았겠죠. 하지만 객체는 &#8216;참조&#8217;된다는 특성 때문에 이와 같은 결과가 나온 것입니다. 때문에 객체를 복사하듯 사용하기 위해선 &#8220;new&#8221;를 이용해 생성자로 사용해주셔야 합니다.","source":"_posts/javascript-prototype.md","raw":"---\nid: 484\ntitle: '[JavaScript] 프로토타입'\ndate: 2016-03-30T00:26:18+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=484\npermalink: /javascript-prototype/\ncategories:\n  - rabbylab\ntags:\n  - javascript\n---\n오늘은 &#8216;**prototype(프로토타입)**&#8216;에 대해 먼저 이야기해보겠습니다. 프로토타입은 사전에서 &#8220;(후대 사물의) 원조&#8221;라고 정의하고 있습니다. 다른 말로 &#8220;원형&#8221;이라고도 정의합니다. 코드 먼저 보시겠습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function GrandFa(){};\nGrandFa.prototype.name = \"Joeun\";\n\nfunction Father(){};\nFather.prototype = new GrandFa();\n\nfunction Sun(){};\nSun.prototype = new Father();\n\nvar o = new Sun();\n\nconsole.log(o.name);\n</pre>\n\n위 코드는 &#8220;Joeun&#8221;을 출력하는 코드입니다. 자세히 살펴보면 첫째줄에서 GrandFa가 선언됩니다. (할아버지가 제일 먼저 계셨죠.) 그리고 두번째 줄에서 그 GrandFa의 이름은 Joeun이라고 GrandFa.prototype.name으로 정의합니다. 이때 프로토타입은 자바스크립트가 객체에 기본적으로 제공하는 프로퍼티입니다. 특정 객체의 원형을 정의하기 위해 사용된다고 생각하면 쉽습니다. 그 후에는 Father가 선언되고 GrandFa의 원형(특징,성질)을 물려받습니다. 상속이죠. 마찬가지로 Sun도 Father의 원형을 물려받습니다. 아들 객체가 마지막으로 o를 생성하고 o가 그 이름을 출력하면 결과물은 Joeun이 됩니다. 무슨 일이 일어난걸까요? \n\n이 상황을 설명하기 위해 Prototype Chain이라는 개념을 이해해야합니다. 가장 아래에 있는 o.name부터 보겠습니다. 자바스크립트는 o.name을 출력하기 위해 내용물을 들여다봅니다. 그런데 그 안에 아무것도 없는걸 발견하죠. 실제로 저희는 o.name에 아무것도 정의하지 않았으니까요. 그럼 이제 자바스크립트는 o의 원형인 Sun을 찾아갑니다. sun.name을 확인합니다. 역시 비어있습니다. 위로 올라갑니다. Father를 살펴보니 또 없군요. 결국 GrandFa까지 가서 보니 이 가족의 이름은 &#8220;Joeun&#8221;입니다. 그래서 o.name에 해당 내용을 출력합니다. 어떤가요? name을 Family name이라고 했으면 더 쉬웠을지도 모르겠다는 생각이 듭니다. 결국 Prototype Chain은 원형이 이어져있는 겁니다. 하위 항목에 없으면 상위 항목으로 찾으러 올라가는거죠. 너 성이 뭐니? 라고 물어봐서 아들이 모르면 아빠가 알테고 아빠가 모르면 할아버지가 알겠죠? 위로 올라가면서 묻는겁니다.\n\n그럼 이런 경우는 어떨까요?\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function GrandFa(){};\nGrandFa.prototype.name = \"Joeun\";\n\nfunction Father(){};\nFather.prototype = new GrandFa();\nFather.prototype.name = \"Rabby\"\n\nfunction Sun(){};\nSun.prototype = new Father();\n\nvar o = new Sun();\n\nconsole.log(o.name);\n</pre>\n\n딱 한줄이 추가됐습니다. Father가 생성되고 중간에 이름을 변경합니다. 이때 출력되는 값은 &#8220;Rabby&#8221;입니다. 체인을 타고 올라가다가보니 중간쯤에 값이 있는데 그게 &#8220;Rabby&#8221;였기 때문입니다. (아빠가 성을 바꾸면 아들도 그 성을 따라가겠죠.)\n\n이때 주의하셔야할 부분이 하나 있습니다. 객체를 생성할 때 `var o = Sun.prototype`라고 하면 안됩니다. 그렇게 되면 o가 변경되면 Sun.prototype 값이 영향을 받습니다. 왜 그럴까요?\n\n&#8220;_객체는 결코 복사되지 않는다. 다만 참조된다._&#8221; 바로 이 문장 때문입니다.\n  \n그렇습니다. 객체는 복사되지 않습니다. 객체는 참조됩니다. 코드를 보시면 알 수 있습니다.\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">function Dev(){};\nDev.prototype.name = \"Joeun\";\n\nvar a = b = c = Dev.prototype;\n\nconsole.log(a.name);\nconsole.log(b.name);\nconsole.log(c.name);\n\nDev.prototype.name = \"Rabby\";\n\nconsole.log(a.name);\nconsole.log(b.name);\nconsole.log(c.name);\n</pre>\n\n이 코드의 결과는 &#8220;Joeun&#8221;이 세번 반복되고 이어서 &#8220;Rabby&#8221;가 세번 반복됩니다. a,b,c를 정의할 때 저희는 Dev.prototype을 참조하게 했습니다. 만약에 복사되었다면 중간에 Dev.prototype.name 값이 바뀐다고 해서 이후 값이 바뀌지 않았겠죠. 하지만 객체는 &#8216;참조&#8217;된다는 특성 때문에 이와 같은 결과가 나온 것입니다. 때문에 객체를 복사하듯 사용하기 위해선 &#8220;new&#8221;를 이용해 생성자로 사용해주셔야 합니다.","slug":"/javascript-prototype/","published":1,"updated":"2019-12-05T15:05:29.490Z","comments":1,"photos":[],"link":"","_id":"ck6jcr9gs003tdirv1jykudsz","content":"<p>오늘은 &#8216;<strong>prototype(프로토타입)</strong>&#8216;에 대해 먼저 이야기해보겠습니다. 프로토타입은 사전에서 &#8220;(후대 사물의) 원조&#8221;라고 정의하고 있습니다. 다른 말로 &#8220;원형&#8221;이라고도 정의합니다. 코드 먼저 보시겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title>function GrandFa(){};\nGrandFa.prototype.name = \"Joeun\";\n\nfunction Father(){};\nFather.prototype = new GrandFa();\n\nfunction Sun(){};\nSun.prototype = new Father();\n\nvar o = new Sun();\n\nconsole.log(o.name);\n</pre>\n\n<p>위 코드는 &#8220;Joeun&#8221;을 출력하는 코드입니다. 자세히 살펴보면 첫째줄에서 GrandFa가 선언됩니다. (할아버지가 제일 먼저 계셨죠.) 그리고 두번째 줄에서 그 GrandFa의 이름은 Joeun이라고 GrandFa.prototype.name으로 정의합니다. 이때 프로토타입은 자바스크립트가 객체에 기본적으로 제공하는 프로퍼티입니다. 특정 객체의 원형을 정의하기 위해 사용된다고 생각하면 쉽습니다. 그 후에는 Father가 선언되고 GrandFa의 원형(특징,성질)을 물려받습니다. 상속이죠. 마찬가지로 Sun도 Father의 원형을 물려받습니다. 아들 객체가 마지막으로 o를 생성하고 o가 그 이름을 출력하면 결과물은 Joeun이 됩니다. 무슨 일이 일어난걸까요? </p>\n<p>이 상황을 설명하기 위해 Prototype Chain이라는 개념을 이해해야합니다. 가장 아래에 있는 o.name부터 보겠습니다. 자바스크립트는 o.name을 출력하기 위해 내용물을 들여다봅니다. 그런데 그 안에 아무것도 없는걸 발견하죠. 실제로 저희는 o.name에 아무것도 정의하지 않았으니까요. 그럼 이제 자바스크립트는 o의 원형인 Sun을 찾아갑니다. sun.name을 확인합니다. 역시 비어있습니다. 위로 올라갑니다. Father를 살펴보니 또 없군요. 결국 GrandFa까지 가서 보니 이 가족의 이름은 &#8220;Joeun&#8221;입니다. 그래서 o.name에 해당 내용을 출력합니다. 어떤가요? name을 Family name이라고 했으면 더 쉬웠을지도 모르겠다는 생각이 듭니다. 결국 Prototype Chain은 원형이 이어져있는 겁니다. 하위 항목에 없으면 상위 항목으로 찾으러 올라가는거죠. 너 성이 뭐니? 라고 물어봐서 아들이 모르면 아빠가 알테고 아빠가 모르면 할아버지가 알겠죠? 위로 올라가면서 묻는겁니다.</p>\n<p>그럼 이런 경우는 어떨까요?</p>\n<pre class=\"brush: plain; title: ; notranslate\" title>function GrandFa(){};\nGrandFa.prototype.name = \"Joeun\";\n\nfunction Father(){};\nFather.prototype = new GrandFa();\nFather.prototype.name = \"Rabby\"\n\nfunction Sun(){};\nSun.prototype = new Father();\n\nvar o = new Sun();\n\nconsole.log(o.name);\n</pre>\n\n<p>딱 한줄이 추가됐습니다. Father가 생성되고 중간에 이름을 변경합니다. 이때 출력되는 값은 &#8220;Rabby&#8221;입니다. 체인을 타고 올라가다가보니 중간쯤에 값이 있는데 그게 &#8220;Rabby&#8221;였기 때문입니다. (아빠가 성을 바꾸면 아들도 그 성을 따라가겠죠.)</p>\n<p>이때 주의하셔야할 부분이 하나 있습니다. 객체를 생성할 때 <code>var o = Sun.prototype</code>라고 하면 안됩니다. 그렇게 되면 o가 변경되면 Sun.prototype 값이 영향을 받습니다. 왜 그럴까요?</p>\n<p>&#8220;<em>객체는 결코 복사되지 않는다. 다만 참조된다.</em>&#8221; 바로 이 문장 때문입니다.</p>\n<p>그렇습니다. 객체는 복사되지 않습니다. 객체는 참조됩니다. 코드를 보시면 알 수 있습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title>function Dev(){};\nDev.prototype.name = \"Joeun\";\n\nvar a = b = c = Dev.prototype;\n\nconsole.log(a.name);\nconsole.log(b.name);\nconsole.log(c.name);\n\nDev.prototype.name = \"Rabby\";\n\nconsole.log(a.name);\nconsole.log(b.name);\nconsole.log(c.name);\n</pre>\n\n<p>이 코드의 결과는 &#8220;Joeun&#8221;이 세번 반복되고 이어서 &#8220;Rabby&#8221;가 세번 반복됩니다. a,b,c를 정의할 때 저희는 Dev.prototype을 참조하게 했습니다. 만약에 복사되었다면 중간에 Dev.prototype.name 값이 바뀐다고 해서 이후 값이 바뀌지 않았겠죠. 하지만 객체는 &#8216;참조&#8217;된다는 특성 때문에 이와 같은 결과가 나온 것입니다. 때문에 객체를 복사하듯 사용하기 위해선 &#8220;new&#8221;를 이용해 생성자로 사용해주셔야 합니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>오늘은 &#8216;<strong>prototype(프로토타입)</strong>&#8216;에 대해 먼저 이야기해보겠습니다. 프로토타입은 사전에서 &#8220;(후대 사물의) 원조&#8221;라고 정의하고 있습니다. 다른 말로 &#8220;원형&#8221;이라고도 정의합니다. 코드 먼저 보시겠습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title>function GrandFa(){};\nGrandFa.prototype.name = \"Joeun\";\n\nfunction Father(){};\nFather.prototype = new GrandFa();\n\nfunction Sun(){};\nSun.prototype = new Father();\n\nvar o = new Sun();\n\nconsole.log(o.name);\n</pre>\n\n<p>위 코드는 &#8220;Joeun&#8221;을 출력하는 코드입니다. 자세히 살펴보면 첫째줄에서 GrandFa가 선언됩니다. (할아버지가 제일 먼저 계셨죠.) 그리고 두번째 줄에서 그 GrandFa의 이름은 Joeun이라고 GrandFa.prototype.name으로 정의합니다. 이때 프로토타입은 자바스크립트가 객체에 기본적으로 제공하는 프로퍼티입니다. 특정 객체의 원형을 정의하기 위해 사용된다고 생각하면 쉽습니다. 그 후에는 Father가 선언되고 GrandFa의 원형(특징,성질)을 물려받습니다. 상속이죠. 마찬가지로 Sun도 Father의 원형을 물려받습니다. 아들 객체가 마지막으로 o를 생성하고 o가 그 이름을 출력하면 결과물은 Joeun이 됩니다. 무슨 일이 일어난걸까요? </p>\n<p>이 상황을 설명하기 위해 Prototype Chain이라는 개념을 이해해야합니다. 가장 아래에 있는 o.name부터 보겠습니다. 자바스크립트는 o.name을 출력하기 위해 내용물을 들여다봅니다. 그런데 그 안에 아무것도 없는걸 발견하죠. 실제로 저희는 o.name에 아무것도 정의하지 않았으니까요. 그럼 이제 자바스크립트는 o의 원형인 Sun을 찾아갑니다. sun.name을 확인합니다. 역시 비어있습니다. 위로 올라갑니다. Father를 살펴보니 또 없군요. 결국 GrandFa까지 가서 보니 이 가족의 이름은 &#8220;Joeun&#8221;입니다. 그래서 o.name에 해당 내용을 출력합니다. 어떤가요? name을 Family name이라고 했으면 더 쉬웠을지도 모르겠다는 생각이 듭니다. 결국 Prototype Chain은 원형이 이어져있는 겁니다. 하위 항목에 없으면 상위 항목으로 찾으러 올라가는거죠. 너 성이 뭐니? 라고 물어봐서 아들이 모르면 아빠가 알테고 아빠가 모르면 할아버지가 알겠죠? 위로 올라가면서 묻는겁니다.</p>\n<p>그럼 이런 경우는 어떨까요?</p>\n<pre class=\"brush: plain; title: ; notranslate\" title>function GrandFa(){};\nGrandFa.prototype.name = \"Joeun\";\n\nfunction Father(){};\nFather.prototype = new GrandFa();\nFather.prototype.name = \"Rabby\"\n\nfunction Sun(){};\nSun.prototype = new Father();\n\nvar o = new Sun();\n\nconsole.log(o.name);\n</pre>\n\n<p>딱 한줄이 추가됐습니다. Father가 생성되고 중간에 이름을 변경합니다. 이때 출력되는 값은 &#8220;Rabby&#8221;입니다. 체인을 타고 올라가다가보니 중간쯤에 값이 있는데 그게 &#8220;Rabby&#8221;였기 때문입니다. (아빠가 성을 바꾸면 아들도 그 성을 따라가겠죠.)</p>\n<p>이때 주의하셔야할 부분이 하나 있습니다. 객체를 생성할 때 <code>var o = Sun.prototype</code>라고 하면 안됩니다. 그렇게 되면 o가 변경되면 Sun.prototype 값이 영향을 받습니다. 왜 그럴까요?</p>\n<p>&#8220;<em>객체는 결코 복사되지 않는다. 다만 참조된다.</em>&#8221; 바로 이 문장 때문입니다.</p>\n<p>그렇습니다. 객체는 복사되지 않습니다. 객체는 참조됩니다. 코드를 보시면 알 수 있습니다.</p>\n<pre class=\"brush: plain; title: ; notranslate\" title>function Dev(){};\nDev.prototype.name = \"Joeun\";\n\nvar a = b = c = Dev.prototype;\n\nconsole.log(a.name);\nconsole.log(b.name);\nconsole.log(c.name);\n\nDev.prototype.name = \"Rabby\";\n\nconsole.log(a.name);\nconsole.log(b.name);\nconsole.log(c.name);\n</pre>\n\n<p>이 코드의 결과는 &#8220;Joeun&#8221;이 세번 반복되고 이어서 &#8220;Rabby&#8221;가 세번 반복됩니다. a,b,c를 정의할 때 저희는 Dev.prototype을 참조하게 했습니다. 만약에 복사되었다면 중간에 Dev.prototype.name 값이 바뀐다고 해서 이후 값이 바뀌지 않았겠죠. 하지만 객체는 &#8216;참조&#8217;된다는 특성 때문에 이와 같은 결과가 나온 것입니다. 때문에 객체를 복사하듯 사용하기 위해선 &#8220;new&#8221;를 이용해 생성자로 사용해주셔야 합니다.</p>\n"},{"title":"미니게임 - BINGO(1)","date":"2017-07-12T14:56:13.000Z","_content":"_미니 게임을 만들어보자!_\n\n## BINGO[1] - Plan\n\n_옆집 사는 개 이름 빙고라지요~ B.I.N.G.O. B.I.N.G.O. 빙고 개 이름_ \n어린 시절 가족과 이웃 사촌들과 함께 여행을 가면 [주제가](http://jr.naver.com/s/play_song/view?sort=update&contentsNo=48312)를 부르며 즐겨하던 빙고 게임을 만들어볼까 합니다.\n\n\n#### 기본 룰\n- 1부터 75까지의 숫자가 임의로 배정된 보드에서 게임이 진행된다.\n  - 각 숫자는 B, I, N, G, O 라고 이름 붙여진 행에 속하게 된다.\n  - 각 행은 15개 숫자 중 5개의 숫자를 임의로 부여 받는다. (임의 지정 범위 => B: 1~15, I: 16~30, N: 31~45, G: 46~60, O: 61~75 )\n- 참가자는 진행자에 의해(혹은 임의의 방식에 의해) 선택된 숫자를 보드에서 체크해나간다.\n- 체크된 숫자가 가로, 세로, 대각선으로 한줄이 모두 체크가 되면 빙고다.\n- 이때 사전에 정의된 빙고 갯수를 먼저 도달한 사람이 게임에서 승리한다.\n\n#### 결과물과 구현 방식\n우선 완성된 게임을 먼저 확인하겠습니다. 미리 만들어 둔 [게임](/bingo)를 통해 확인하시면 됩니다.\n\n구현에는 [오늘의 함수 시리즈](/tags/오늘의-함수/)와 [daily.js](/source/daily.js)의 모태가 되는 함수형 자바스크립트 라이브러리 [partial.js](https://github.com/marpple/partial.js)를 사용하겠습니다. DOM을 다루는 don.js도 사용합니다. (don.js는 함수형 프로그래밍에 최적화된 DOM 핸들링 라이브러리입니다.)\n\n\n##### [다음 글](/programming/make-bingo-game-1/)을 통해 만들기 과정을 확인하실 수 있습니다.","source":"_posts/make-bingo-game-0.md","raw":"---\ntitle: '미니게임 - BINGO(1)'\ndate: 2017-07-12 23:56:13\ncategories:\n  - programming\ntags:\n  - javascript\n  - 미니게임\n  - 만들기\n  - 빙고\n  - bingo\n---\n_미니 게임을 만들어보자!_\n\n## BINGO[1] - Plan\n\n_옆집 사는 개 이름 빙고라지요~ B.I.N.G.O. B.I.N.G.O. 빙고 개 이름_ \n어린 시절 가족과 이웃 사촌들과 함께 여행을 가면 [주제가](http://jr.naver.com/s/play_song/view?sort=update&contentsNo=48312)를 부르며 즐겨하던 빙고 게임을 만들어볼까 합니다.\n\n\n#### 기본 룰\n- 1부터 75까지의 숫자가 임의로 배정된 보드에서 게임이 진행된다.\n  - 각 숫자는 B, I, N, G, O 라고 이름 붙여진 행에 속하게 된다.\n  - 각 행은 15개 숫자 중 5개의 숫자를 임의로 부여 받는다. (임의 지정 범위 => B: 1~15, I: 16~30, N: 31~45, G: 46~60, O: 61~75 )\n- 참가자는 진행자에 의해(혹은 임의의 방식에 의해) 선택된 숫자를 보드에서 체크해나간다.\n- 체크된 숫자가 가로, 세로, 대각선으로 한줄이 모두 체크가 되면 빙고다.\n- 이때 사전에 정의된 빙고 갯수를 먼저 도달한 사람이 게임에서 승리한다.\n\n#### 결과물과 구현 방식\n우선 완성된 게임을 먼저 확인하겠습니다. 미리 만들어 둔 [게임](/bingo)를 통해 확인하시면 됩니다.\n\n구현에는 [오늘의 함수 시리즈](/tags/오늘의-함수/)와 [daily.js](/source/daily.js)의 모태가 되는 함수형 자바스크립트 라이브러리 [partial.js](https://github.com/marpple/partial.js)를 사용하겠습니다. DOM을 다루는 don.js도 사용합니다. (don.js는 함수형 프로그래밍에 최적화된 DOM 핸들링 라이브러리입니다.)\n\n\n##### [다음 글](/programming/make-bingo-game-1/)을 통해 만들기 과정을 확인하실 수 있습니다.","slug":"make-bingo-game-0","published":1,"updated":"2019-12-17T11:46:39.386Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9gt003wdirvyy3h6f97","content":"<p><em>미니 게임을 만들어보자!</em></p>\n<h2 id=\"BINGO-1-Plan\"><a href=\"#BINGO-1-Plan\" class=\"headerlink\" title=\"BINGO[1] - Plan\"></a>BINGO[1] - Plan</h2><p><em>옆집 사는 개 이름 빙고라지요~ B.I.N.G.O. B.I.N.G.O. 빙고 개 이름</em><br>어린 시절 가족과 이웃 사촌들과 함께 여행을 가면 <a href=\"http://jr.naver.com/s/play_song/view?sort=update&contentsNo=48312\" target=\"_blank\" rel=\"noopener\">주제가</a>를 부르며 즐겨하던 빙고 게임을 만들어볼까 합니다.</p>\n<h4 id=\"기본-룰\"><a href=\"#기본-룰\" class=\"headerlink\" title=\"기본 룰\"></a>기본 룰</h4><ul>\n<li>1부터 75까지의 숫자가 임의로 배정된 보드에서 게임이 진행된다.<ul>\n<li>각 숫자는 B, I, N, G, O 라고 이름 붙여진 행에 속하게 된다.</li>\n<li>각 행은 15개 숫자 중 5개의 숫자를 임의로 부여 받는다. (임의 지정 범위 =&gt; B: 1<del>15, I: 16</del>30, N: 31<del>45, G: 46</del>60, O: 61~75 )</li>\n</ul>\n</li>\n<li>참가자는 진행자에 의해(혹은 임의의 방식에 의해) 선택된 숫자를 보드에서 체크해나간다.</li>\n<li>체크된 숫자가 가로, 세로, 대각선으로 한줄이 모두 체크가 되면 빙고다.</li>\n<li>이때 사전에 정의된 빙고 갯수를 먼저 도달한 사람이 게임에서 승리한다.</li>\n</ul>\n<h4 id=\"결과물과-구현-방식\"><a href=\"#결과물과-구현-방식\" class=\"headerlink\" title=\"결과물과 구현 방식\"></a>결과물과 구현 방식</h4><p>우선 완성된 게임을 먼저 확인하겠습니다. 미리 만들어 둔 <a href=\"/bingo\">게임</a>를 통해 확인하시면 됩니다.</p>\n<p>구현에는 <a href=\"/tags/오늘의-함수/\">오늘의 함수 시리즈</a>와 <a href=\"/source/daily.js\">daily.js</a>의 모태가 되는 함수형 자바스크립트 라이브러리 <a href=\"https://github.com/marpple/partial.js\" target=\"_blank\" rel=\"noopener\">partial.js</a>를 사용하겠습니다. DOM을 다루는 don.js도 사용합니다. (don.js는 함수형 프로그래밍에 최적화된 DOM 핸들링 라이브러리입니다.)</p>\n<h5 id=\"다음-글을-통해-만들기-과정을-확인하실-수-있습니다\"><a href=\"#다음-글을-통해-만들기-과정을-확인하실-수-있습니다\" class=\"headerlink\" title=\"다음 글을 통해 만들기 과정을 확인하실 수 있습니다.\"></a><a href=\"/programming/make-bingo-game-1/\">다음 글</a>을 통해 만들기 과정을 확인하실 수 있습니다.</h5>","site":{"data":{}},"excerpt":"","more":"<p><em>미니 게임을 만들어보자!</em></p>\n<h2 id=\"BINGO-1-Plan\"><a href=\"#BINGO-1-Plan\" class=\"headerlink\" title=\"BINGO[1] - Plan\"></a>BINGO[1] - Plan</h2><p><em>옆집 사는 개 이름 빙고라지요~ B.I.N.G.O. B.I.N.G.O. 빙고 개 이름</em><br>어린 시절 가족과 이웃 사촌들과 함께 여행을 가면 <a href=\"http://jr.naver.com/s/play_song/view?sort=update&contentsNo=48312\" target=\"_blank\" rel=\"noopener\">주제가</a>를 부르며 즐겨하던 빙고 게임을 만들어볼까 합니다.</p>\n<h4 id=\"기본-룰\"><a href=\"#기본-룰\" class=\"headerlink\" title=\"기본 룰\"></a>기본 룰</h4><ul>\n<li>1부터 75까지의 숫자가 임의로 배정된 보드에서 게임이 진행된다.<ul>\n<li>각 숫자는 B, I, N, G, O 라고 이름 붙여진 행에 속하게 된다.</li>\n<li>각 행은 15개 숫자 중 5개의 숫자를 임의로 부여 받는다. (임의 지정 범위 =&gt; B: 1<del>15, I: 16</del>30, N: 31<del>45, G: 46</del>60, O: 61~75 )</li>\n</ul>\n</li>\n<li>참가자는 진행자에 의해(혹은 임의의 방식에 의해) 선택된 숫자를 보드에서 체크해나간다.</li>\n<li>체크된 숫자가 가로, 세로, 대각선으로 한줄이 모두 체크가 되면 빙고다.</li>\n<li>이때 사전에 정의된 빙고 갯수를 먼저 도달한 사람이 게임에서 승리한다.</li>\n</ul>\n<h4 id=\"결과물과-구현-방식\"><a href=\"#결과물과-구현-방식\" class=\"headerlink\" title=\"결과물과 구현 방식\"></a>결과물과 구현 방식</h4><p>우선 완성된 게임을 먼저 확인하겠습니다. 미리 만들어 둔 <a href=\"/bingo\">게임</a>를 통해 확인하시면 됩니다.</p>\n<p>구현에는 <a href=\"/tags/오늘의-함수/\">오늘의 함수 시리즈</a>와 <a href=\"/source/daily.js\">daily.js</a>의 모태가 되는 함수형 자바스크립트 라이브러리 <a href=\"https://github.com/marpple/partial.js\" target=\"_blank\" rel=\"noopener\">partial.js</a>를 사용하겠습니다. DOM을 다루는 don.js도 사용합니다. (don.js는 함수형 프로그래밍에 최적화된 DOM 핸들링 라이브러리입니다.)</p>\n<h5 id=\"다음-글을-통해-만들기-과정을-확인하실-수-있습니다\"><a href=\"#다음-글을-통해-만들기-과정을-확인하실-수-있습니다\" class=\"headerlink\" title=\"다음 글을 통해 만들기 과정을 확인하실 수 있습니다.\"></a><a href=\"/programming/make-bingo-game-1/\">다음 글</a>을 통해 만들기 과정을 확인하실 수 있습니다.</h5>"},{"title":"[Practice] 동물 쉼터(Animal Shelter)를 구현하라!","date":"2016-04-01T15:16:46.000Z","author":"rabby","layout":"post","_content":"<span style=\"color: #999999;\">Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 <코딩인터뷰 완전분석> 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.</span>\n\n* * *\n\n**코딩인터뷰 완전분석 – 연습문제 3.7**\n\n**“먼저 들어온 동물이 먼저 나가는 동물 쉼터(animal shelter)가 있다고 하자. 이 쉼터는 개와 고양이만 수용할 수 있다. 사람들은 쉼터의 동물들 가운데 들어온 지 가장 오래된 동물부터 입양할 수 있는데, 개와 고양이 중 어떤 동물을 데려갈지 선택할 수도 있다. 특정한 동물을 지정해 데려가는 것은 금지되어 있다. 이 시스템을 자료구조로 구현하라. 해당 자료구조는 enqueue, dequeueAny, dequeueDog, dequeueCat의 연산들을 제공해야 한다. 언어에 기본 탑재되어 있는 LinkedList (Java) 자료구조를 이용해도 좋다.”**\n\n이번부터는 자바로 구현하겠습니다. [이전 글](/rabbylab-wordpress/practice-1/)에서 C로 코딩을 했는데, COIN에서 사용하는 공용 언어로 자바를 선정함에 따라 자바로 코딩하겠습니다.\n\n코드를 보시기에 앞서 문제를 먼저 해부(?)하겠습니다. 동물 쉼터는 '먼저 들어온 동물이 먼저 나가는' 곳 입니다. First In First Out(FIFO)라는거죠. 큐를 의미합니다. 그리고 문제의 끝에서 'LinkedList'를 사용해도 좋다고 합니다. 결국 LikedList로 표현된 Queue를 구현하라는 것입니다. 그리고 그 큐는 몇가지 제약조건을 가지고 있습니다. 들어온 지 가장 오래된 동물부터 입양하되, 개나 고양이 중에서 선택은 할 수 있도록 해줘라는 것입니다. 그래서 dequeueDog, dequeueCat 연산을 제공합니다. 대충 그림나옵니다. 그럼 시작할까요?\n\n```java\nprivate Node head;\nprivate Node tail;\nprivate int size = 0;\nprivate class Node {\n\tprivate String name;\n\tprivate int id;\n\tprivate Node next;\n\tpublic Node(String animal, int num){\n\t\tthis.name = animal;\n\t\tthis.id = num;\n\t\tthis.next = null;\n\t}\n}\n```\n\n링크드리스트를 구현해야하기 때문에 노드를 만들어줍니다. head와 tail은 큐에서 front(앞)와 rear(뒤)를 맡게됩니다. 일단은 4번째 줄 이후를 집중해서 보겠습니다. 이 노드는 동물의 이름 값(name), 개와 고양이를 분류하기 위한 값(id) 그리고 다음 노드를 가르키는 값(next)을 가지고 있습니다. 사실 저는 이 '가르키는 값'이 참 익숙하지 않습니다. C에서는 이걸 포인터로 구현하는데 Java에서는 그냥 값을 참조하면 되는데, 그게 은근히 낯섭니다. 포인터의 그 특징이 더 뇌리에 깊게 박힌 것 같습니다. 여하튼 노드는 이렇게 구성되어 있습니다. 이제 본격적인 연산들을 살펴보겠습니다.\n\n```java\npublic void enqueue(String animal, int num){\n\tNode newNode = new Node(animal, num);\n\tif (size == 0) {\n\t\ttail = head = newNode;\n\t} else {\n\t\thead.next = newNode;\n\t\thead = newNode;\n\t}\n\tsize++;\n}\n```\n\n이 코드는 노드를 추가(enqueue)하는 과정을 보여줍니다. 이 메소드는 인자로 동물의 이름(animal)과 개와 고양이를 구분하는 숫자(num)을 받습니다. 그리고 새로운 노드를 생성합니다. 이때 생성된 노드가 첫번째 노드라면(queue의 size가 0이라면) head와 tail이 동시에 이 노드를 가르킵니다. 만약 그렇지 않다면 head의 다음(next)에 새로운 노드가 붙습니다. 그리고 head는 새로운 노드를 가르킵니다. 그러니까 새로운 노드가 추가되면 tail로 붙는게 아니라 head가 이동합니다. tail은 움직이지 않습니다. 앞에다가 추가하는 방식인거죠. 추가가 끝나면 size를 증가시켜줍니다. 이로써 tail에는 가장 오래된 동물이 주인을 기다리게 됩니다.\n\n```java\npublic void dequeueAny(){\n\tSystem.out.println(tail.name);\n\ttail = tail.next;\n\tsize--;\n\treturn;\n}\n```\n\n새로운 주인을 만난 동물을 보내주는 메소드입니다. 가장 먼저 들어온 동물을 보내주겠습니다. 보내주는 걸 확인하기 위해 메세지를 출력합니다. 출력 이후에는 tail을 한칸 뒤로 이동합니다. 다음 차례를 가르키는거죠. 그리곤 size를 감소시켜줍니다.\n\n```java\npublic void dequeueDog(){\n\tNode chaser_1 = tail;\n\tNode chaser_2 = tail;\n\twhile(chaser_1.id != 0 && chaser_1.next != null){\n\t\tchaser_2 = chaser_1;\n\t\tchaser_1 = chaser_2.next;\n\t}\n  \n\tif (chaser_1 == tail) { //개가 첫번째 노드에 있었던 경우\n\t\tdequeueAny();\n\t} else if (chaser_1.id == 0) { //개를 발견한 경우\n\t\tSystem.out.println(chaser_1.name + \", Bye!\\n\");\n\t\tchaser_2.next = chaser_1.next;\n  } else { //개가 없는 경우\n\t\tSystem.out.println(\"No Dog...\");\n\t\treturn;\n\t}\n\tsize--;\n\treturn;\n}\n```\n\n이제 새로운 주인이 원하는 동물을 골라서 주겠습니다. 개/고양이 중에서 선택이 가능해야겠죠. 위의 코드는 개를 내보내는 코드입니다. id가 0일 때, 개/ 1일 때, 고양이라고 간주했습니다. 이번 코드에서 중요한건 역시 chaser\\_1,chaser\\_2 입니다. 이들의 역할은 원하는 동물을 찾아오는 것입니다. 처음에는 tail부터 시작합니다. 가장 오래된 동물부터 확인하는 것이죠.\n  \nwhile문을 보겠습니다. 본격적인 추적(chase)가 시작됩니다. id가 0이 아닐 경우 계속 반복됩니다. 다시말해, 0이 아니라는 말은 개가 아니라는 것이니까 고양이라는 의미겠죠? 그리고 만약에 더 이상 개가 남아 있지 않을 경우도 있겠죠? 그런 경우에 무한루프를 방지하기 위해서 next값이 null이면 탈출할 수 있도록 조건을 만들어둡니다. 이제 chaser의 이동을 살펴보겠습니다. 5번 줄에서 chaser\\_2가 chaser\\_1의 위치로 갑니다. 그리고 다음 줄에서 chaser\\_1은 다음 노드로 이동합니다. 이렇게 chaser\\_1이 앞으로 한 노드씩 움직이며 개를 찾습니다. 결국 개가 발견되거나 개가 없으면 루프를 벗어납니다.\n  \n만약에 개가 첫번째 노드에 있었다면 그냥 dequeueAny 메소드를 호출해줍니다. 그리고 만약에 개가 맞다면 개에게 작별을 고하고 보내줍니다. chaser\\_2의 다음 노드였던 chaser\\_1의 노드를 없애주기 위해 chaser\\_1 다음의 노드와 chaser\\_2를 이어줍니다. 그렇게 노드를 정리합니다. 만약에 개가 없었다면 더 이상 개가 없다고 메세지를 출력해줍니다.\n\ndequeueCat의 경우는 id 값만 바꿔주면 됩니다. 고로 생략하겠습니다.\n\n```java\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tLinkedList animals = new LinkedList();\n\t\t\n\t\tanimals.enqueue(\"귀욤\",1);\n\t\tanimals.enqueue(\"개똥\",0);\n\t\tanimals.enqueue(\"황묘\",1);\n\t\tanimals.enqueue(\"백구\",0);\n\t\t\n\t\tSystem.out.println(animals);\n\t\t\n\t\tanimals.dequeueDog();\n\t\n\t\tSystem.out.println(animals);\n\t}\n\n}\n```\n\n예제 확인을 위한 코드입니다. 개똥이를 보내고 빈자리를 확인하는 것으로 코드가 끝납니다. 아래는 출력결과 입니다.\n  \n![](/images/aniqueue-result.jpg)\n\n_전체 코드는 <a href=\"https://github.com/joeunha/rabbylab-csbasic/blob/master/src/rabbylab/csbasic/coin/animalshelter/LinkedList.java\" target=\"_blank\">이곳</a>에서 확인하실 수 있습니다. 감사합니다._","source":"_posts/practice-animal-shelter.md","raw":"---\ntitle: '[Practice] 동물 쉼터(Animal Shelter)를 구현하라!'\ndate: 2016-04-02T00:16:46+00:00\nauthor: rabby\nlayout: post\ncategories:\n  - rabbylab\ntags:\n  - practice\n---\n<span style=\"color: #999999;\">Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 <코딩인터뷰 완전분석> 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.</span>\n\n* * *\n\n**코딩인터뷰 완전분석 – 연습문제 3.7**\n\n**“먼저 들어온 동물이 먼저 나가는 동물 쉼터(animal shelter)가 있다고 하자. 이 쉼터는 개와 고양이만 수용할 수 있다. 사람들은 쉼터의 동물들 가운데 들어온 지 가장 오래된 동물부터 입양할 수 있는데, 개와 고양이 중 어떤 동물을 데려갈지 선택할 수도 있다. 특정한 동물을 지정해 데려가는 것은 금지되어 있다. 이 시스템을 자료구조로 구현하라. 해당 자료구조는 enqueue, dequeueAny, dequeueDog, dequeueCat의 연산들을 제공해야 한다. 언어에 기본 탑재되어 있는 LinkedList (Java) 자료구조를 이용해도 좋다.”**\n\n이번부터는 자바로 구현하겠습니다. [이전 글](/rabbylab-wordpress/practice-1/)에서 C로 코딩을 했는데, COIN에서 사용하는 공용 언어로 자바를 선정함에 따라 자바로 코딩하겠습니다.\n\n코드를 보시기에 앞서 문제를 먼저 해부(?)하겠습니다. 동물 쉼터는 '먼저 들어온 동물이 먼저 나가는' 곳 입니다. First In First Out(FIFO)라는거죠. 큐를 의미합니다. 그리고 문제의 끝에서 'LinkedList'를 사용해도 좋다고 합니다. 결국 LikedList로 표현된 Queue를 구현하라는 것입니다. 그리고 그 큐는 몇가지 제약조건을 가지고 있습니다. 들어온 지 가장 오래된 동물부터 입양하되, 개나 고양이 중에서 선택은 할 수 있도록 해줘라는 것입니다. 그래서 dequeueDog, dequeueCat 연산을 제공합니다. 대충 그림나옵니다. 그럼 시작할까요?\n\n```java\nprivate Node head;\nprivate Node tail;\nprivate int size = 0;\nprivate class Node {\n\tprivate String name;\n\tprivate int id;\n\tprivate Node next;\n\tpublic Node(String animal, int num){\n\t\tthis.name = animal;\n\t\tthis.id = num;\n\t\tthis.next = null;\n\t}\n}\n```\n\n링크드리스트를 구현해야하기 때문에 노드를 만들어줍니다. head와 tail은 큐에서 front(앞)와 rear(뒤)를 맡게됩니다. 일단은 4번째 줄 이후를 집중해서 보겠습니다. 이 노드는 동물의 이름 값(name), 개와 고양이를 분류하기 위한 값(id) 그리고 다음 노드를 가르키는 값(next)을 가지고 있습니다. 사실 저는 이 '가르키는 값'이 참 익숙하지 않습니다. C에서는 이걸 포인터로 구현하는데 Java에서는 그냥 값을 참조하면 되는데, 그게 은근히 낯섭니다. 포인터의 그 특징이 더 뇌리에 깊게 박힌 것 같습니다. 여하튼 노드는 이렇게 구성되어 있습니다. 이제 본격적인 연산들을 살펴보겠습니다.\n\n```java\npublic void enqueue(String animal, int num){\n\tNode newNode = new Node(animal, num);\n\tif (size == 0) {\n\t\ttail = head = newNode;\n\t} else {\n\t\thead.next = newNode;\n\t\thead = newNode;\n\t}\n\tsize++;\n}\n```\n\n이 코드는 노드를 추가(enqueue)하는 과정을 보여줍니다. 이 메소드는 인자로 동물의 이름(animal)과 개와 고양이를 구분하는 숫자(num)을 받습니다. 그리고 새로운 노드를 생성합니다. 이때 생성된 노드가 첫번째 노드라면(queue의 size가 0이라면) head와 tail이 동시에 이 노드를 가르킵니다. 만약 그렇지 않다면 head의 다음(next)에 새로운 노드가 붙습니다. 그리고 head는 새로운 노드를 가르킵니다. 그러니까 새로운 노드가 추가되면 tail로 붙는게 아니라 head가 이동합니다. tail은 움직이지 않습니다. 앞에다가 추가하는 방식인거죠. 추가가 끝나면 size를 증가시켜줍니다. 이로써 tail에는 가장 오래된 동물이 주인을 기다리게 됩니다.\n\n```java\npublic void dequeueAny(){\n\tSystem.out.println(tail.name);\n\ttail = tail.next;\n\tsize--;\n\treturn;\n}\n```\n\n새로운 주인을 만난 동물을 보내주는 메소드입니다. 가장 먼저 들어온 동물을 보내주겠습니다. 보내주는 걸 확인하기 위해 메세지를 출력합니다. 출력 이후에는 tail을 한칸 뒤로 이동합니다. 다음 차례를 가르키는거죠. 그리곤 size를 감소시켜줍니다.\n\n```java\npublic void dequeueDog(){\n\tNode chaser_1 = tail;\n\tNode chaser_2 = tail;\n\twhile(chaser_1.id != 0 && chaser_1.next != null){\n\t\tchaser_2 = chaser_1;\n\t\tchaser_1 = chaser_2.next;\n\t}\n  \n\tif (chaser_1 == tail) { //개가 첫번째 노드에 있었던 경우\n\t\tdequeueAny();\n\t} else if (chaser_1.id == 0) { //개를 발견한 경우\n\t\tSystem.out.println(chaser_1.name + \", Bye!\\n\");\n\t\tchaser_2.next = chaser_1.next;\n  } else { //개가 없는 경우\n\t\tSystem.out.println(\"No Dog...\");\n\t\treturn;\n\t}\n\tsize--;\n\treturn;\n}\n```\n\n이제 새로운 주인이 원하는 동물을 골라서 주겠습니다. 개/고양이 중에서 선택이 가능해야겠죠. 위의 코드는 개를 내보내는 코드입니다. id가 0일 때, 개/ 1일 때, 고양이라고 간주했습니다. 이번 코드에서 중요한건 역시 chaser\\_1,chaser\\_2 입니다. 이들의 역할은 원하는 동물을 찾아오는 것입니다. 처음에는 tail부터 시작합니다. 가장 오래된 동물부터 확인하는 것이죠.\n  \nwhile문을 보겠습니다. 본격적인 추적(chase)가 시작됩니다. id가 0이 아닐 경우 계속 반복됩니다. 다시말해, 0이 아니라는 말은 개가 아니라는 것이니까 고양이라는 의미겠죠? 그리고 만약에 더 이상 개가 남아 있지 않을 경우도 있겠죠? 그런 경우에 무한루프를 방지하기 위해서 next값이 null이면 탈출할 수 있도록 조건을 만들어둡니다. 이제 chaser의 이동을 살펴보겠습니다. 5번 줄에서 chaser\\_2가 chaser\\_1의 위치로 갑니다. 그리고 다음 줄에서 chaser\\_1은 다음 노드로 이동합니다. 이렇게 chaser\\_1이 앞으로 한 노드씩 움직이며 개를 찾습니다. 결국 개가 발견되거나 개가 없으면 루프를 벗어납니다.\n  \n만약에 개가 첫번째 노드에 있었다면 그냥 dequeueAny 메소드를 호출해줍니다. 그리고 만약에 개가 맞다면 개에게 작별을 고하고 보내줍니다. chaser\\_2의 다음 노드였던 chaser\\_1의 노드를 없애주기 위해 chaser\\_1 다음의 노드와 chaser\\_2를 이어줍니다. 그렇게 노드를 정리합니다. 만약에 개가 없었다면 더 이상 개가 없다고 메세지를 출력해줍니다.\n\ndequeueCat의 경우는 id 값만 바꿔주면 됩니다. 고로 생략하겠습니다.\n\n```java\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tLinkedList animals = new LinkedList();\n\t\t\n\t\tanimals.enqueue(\"귀욤\",1);\n\t\tanimals.enqueue(\"개똥\",0);\n\t\tanimals.enqueue(\"황묘\",1);\n\t\tanimals.enqueue(\"백구\",0);\n\t\t\n\t\tSystem.out.println(animals);\n\t\t\n\t\tanimals.dequeueDog();\n\t\n\t\tSystem.out.println(animals);\n\t}\n\n}\n```\n\n예제 확인을 위한 코드입니다. 개똥이를 보내고 빈자리를 확인하는 것으로 코드가 끝납니다. 아래는 출력결과 입니다.\n  \n![](/images/aniqueue-result.jpg)\n\n_전체 코드는 <a href=\"https://github.com/joeunha/rabbylab-csbasic/blob/master/src/rabbylab/csbasic/coin/animalshelter/LinkedList.java\" target=\"_blank\">이곳</a>에서 확인하실 수 있습니다. 감사합니다._","slug":"practice-animal-shelter","published":1,"updated":"2019-12-05T15:05:29.491Z","comments":1,"photos":[],"link":"","_id":"ck6jcr9gu0040dirvo12x17qp","content":"<p><span style=\"color: #999999;\">Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 &lt;코딩인터뷰 완전분석&gt; 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.</span></p>\n<hr>\n<p><strong>코딩인터뷰 완전분석 – 연습문제 3.7</strong></p>\n<p><strong>“먼저 들어온 동물이 먼저 나가는 동물 쉼터(animal shelter)가 있다고 하자. 이 쉼터는 개와 고양이만 수용할 수 있다. 사람들은 쉼터의 동물들 가운데 들어온 지 가장 오래된 동물부터 입양할 수 있는데, 개와 고양이 중 어떤 동물을 데려갈지 선택할 수도 있다. 특정한 동물을 지정해 데려가는 것은 금지되어 있다. 이 시스템을 자료구조로 구현하라. 해당 자료구조는 enqueue, dequeueAny, dequeueDog, dequeueCat의 연산들을 제공해야 한다. 언어에 기본 탑재되어 있는 LinkedList (Java) 자료구조를 이용해도 좋다.”</strong></p>\n<p>이번부터는 자바로 구현하겠습니다. <a href=\"/rabbylab-wordpress/practice-1/\">이전 글</a>에서 C로 코딩을 했는데, COIN에서 사용하는 공용 언어로 자바를 선정함에 따라 자바로 코딩하겠습니다.</p>\n<p>코드를 보시기에 앞서 문제를 먼저 해부(?)하겠습니다. 동물 쉼터는 ‘먼저 들어온 동물이 먼저 나가는’ 곳 입니다. First In First Out(FIFO)라는거죠. 큐를 의미합니다. 그리고 문제의 끝에서 ‘LinkedList’를 사용해도 좋다고 합니다. 결국 LikedList로 표현된 Queue를 구현하라는 것입니다. 그리고 그 큐는 몇가지 제약조건을 가지고 있습니다. 들어온 지 가장 오래된 동물부터 입양하되, 개나 고양이 중에서 선택은 할 수 있도록 해줘라는 것입니다. 그래서 dequeueDog, dequeueCat 연산을 제공합니다. 대충 그림나옵니다. 그럼 시작할까요?</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Node head;</span><br><span class=\"line\"><span class=\"keyword\">private</span> Node tail;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Node next;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(String animal, <span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = animal;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.id = num;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>링크드리스트를 구현해야하기 때문에 노드를 만들어줍니다. head와 tail은 큐에서 front(앞)와 rear(뒤)를 맡게됩니다. 일단은 4번째 줄 이후를 집중해서 보겠습니다. 이 노드는 동물의 이름 값(name), 개와 고양이를 분류하기 위한 값(id) 그리고 다음 노드를 가르키는 값(next)을 가지고 있습니다. 사실 저는 이 ‘가르키는 값’이 참 익숙하지 않습니다. C에서는 이걸 포인터로 구현하는데 Java에서는 그냥 값을 참조하면 되는데, 그게 은근히 낯섭니다. 포인터의 그 특징이 더 뇌리에 깊게 박힌 것 같습니다. 여하튼 노드는 이렇게 구성되어 있습니다. 이제 본격적인 연산들을 살펴보겠습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(String animal, <span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">\tNode newNode = <span class=\"keyword\">new</span> Node(animal, num);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\ttail = head = newNode;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\thead.next = newNode;</span><br><span class=\"line\">\t\thead = newNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsize++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이 코드는 노드를 추가(enqueue)하는 과정을 보여줍니다. 이 메소드는 인자로 동물의 이름(animal)과 개와 고양이를 구분하는 숫자(num)을 받습니다. 그리고 새로운 노드를 생성합니다. 이때 생성된 노드가 첫번째 노드라면(queue의 size가 0이라면) head와 tail이 동시에 이 노드를 가르킵니다. 만약 그렇지 않다면 head의 다음(next)에 새로운 노드가 붙습니다. 그리고 head는 새로운 노드를 가르킵니다. 그러니까 새로운 노드가 추가되면 tail로 붙는게 아니라 head가 이동합니다. tail은 움직이지 않습니다. 앞에다가 추가하는 방식인거죠. 추가가 끝나면 size를 증가시켜줍니다. 이로써 tail에는 가장 오래된 동물이 주인을 기다리게 됩니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dequeueAny</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tSystem.out.println(tail.name);</span><br><span class=\"line\">\ttail = tail.next;</span><br><span class=\"line\">\tsize--;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>새로운 주인을 만난 동물을 보내주는 메소드입니다. 가장 먼저 들어온 동물을 보내주겠습니다. 보내주는 걸 확인하기 위해 메세지를 출력합니다. 출력 이후에는 tail을 한칸 뒤로 이동합니다. 다음 차례를 가르키는거죠. 그리곤 size를 감소시켜줍니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dequeueDog</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tNode chaser_1 = tail;</span><br><span class=\"line\">\tNode chaser_2 = tail;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(chaser_1.id != <span class=\"number\">0</span> &amp;&amp; chaser_1.next != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\tchaser_2 = chaser_1;</span><br><span class=\"line\">\t\tchaser_1 = chaser_2.next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (chaser_1 == tail) &#123; <span class=\"comment\">//개가 첫번째 노드에 있었던 경우</span></span><br><span class=\"line\">\t\tdequeueAny();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (chaser_1.id == <span class=\"number\">0</span>) &#123; <span class=\"comment\">//개를 발견한 경우</span></span><br><span class=\"line\">\t\tSystem.out.println(chaser_1.name + <span class=\"string\">\", Bye!\\n\"</span>);</span><br><span class=\"line\">\t\tchaser_2.next = chaser_1.next;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//개가 없는 경우</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"No Dog...\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsize--;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이제 새로운 주인이 원하는 동물을 골라서 주겠습니다. 개/고양이 중에서 선택이 가능해야겠죠. 위의 코드는 개를 내보내는 코드입니다. id가 0일 때, 개/ 1일 때, 고양이라고 간주했습니다. 이번 코드에서 중요한건 역시 chaser_1,chaser_2 입니다. 이들의 역할은 원하는 동물을 찾아오는 것입니다. 처음에는 tail부터 시작합니다. 가장 오래된 동물부터 확인하는 것이죠.</p>\n<p>while문을 보겠습니다. 본격적인 추적(chase)가 시작됩니다. id가 0이 아닐 경우 계속 반복됩니다. 다시말해, 0이 아니라는 말은 개가 아니라는 것이니까 고양이라는 의미겠죠? 그리고 만약에 더 이상 개가 남아 있지 않을 경우도 있겠죠? 그런 경우에 무한루프를 방지하기 위해서 next값이 null이면 탈출할 수 있도록 조건을 만들어둡니다. 이제 chaser의 이동을 살펴보겠습니다. 5번 줄에서 chaser_2가 chaser_1의 위치로 갑니다. 그리고 다음 줄에서 chaser_1은 다음 노드로 이동합니다. 이렇게 chaser_1이 앞으로 한 노드씩 움직이며 개를 찾습니다. 결국 개가 발견되거나 개가 없으면 루프를 벗어납니다.</p>\n<p>만약에 개가 첫번째 노드에 있었다면 그냥 dequeueAny 메소드를 호출해줍니다. 그리고 만약에 개가 맞다면 개에게 작별을 고하고 보내줍니다. chaser_2의 다음 노드였던 chaser_1의 노드를 없애주기 위해 chaser_1 다음의 노드와 chaser_2를 이어줍니다. 그렇게 노드를 정리합니다. 만약에 개가 없었다면 더 이상 개가 없다고 메세지를 출력해줍니다.</p>\n<p>dequeueCat의 경우는 id 값만 바꿔주면 됩니다. 고로 생략하겠습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tLinkedList animals = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tanimals.enqueue(<span class=\"string\">\"귀욤\"</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tanimals.enqueue(<span class=\"string\">\"개똥\"</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tanimals.enqueue(<span class=\"string\">\"황묘\"</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tanimals.enqueue(<span class=\"string\">\"백구\"</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSystem.out.println(animals);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tanimals.dequeueDog();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\tSystem.out.println(animals);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>예제 확인을 위한 코드입니다. 개똥이를 보내고 빈자리를 확인하는 것으로 코드가 끝납니다. 아래는 출력결과 입니다.</p>\n<p><img src=\"/images/aniqueue-result.jpg\" alt></p>\n<p><em>전체 코드는 <a href=\"https://github.com/joeunha/rabbylab-csbasic/blob/master/src/rabbylab/csbasic/coin/animalshelter/LinkedList.java\" target=\"_blank\">이곳</a>에서 확인하실 수 있습니다. 감사합니다.</em></p>\n","site":{"data":{}},"excerpt":"","more":"<p><span style=\"color: #999999;\">Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 &lt;코딩인터뷰 완전분석&gt; 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.</span></p>\n<hr>\n<p><strong>코딩인터뷰 완전분석 – 연습문제 3.7</strong></p>\n<p><strong>“먼저 들어온 동물이 먼저 나가는 동물 쉼터(animal shelter)가 있다고 하자. 이 쉼터는 개와 고양이만 수용할 수 있다. 사람들은 쉼터의 동물들 가운데 들어온 지 가장 오래된 동물부터 입양할 수 있는데, 개와 고양이 중 어떤 동물을 데려갈지 선택할 수도 있다. 특정한 동물을 지정해 데려가는 것은 금지되어 있다. 이 시스템을 자료구조로 구현하라. 해당 자료구조는 enqueue, dequeueAny, dequeueDog, dequeueCat의 연산들을 제공해야 한다. 언어에 기본 탑재되어 있는 LinkedList (Java) 자료구조를 이용해도 좋다.”</strong></p>\n<p>이번부터는 자바로 구현하겠습니다. <a href=\"/rabbylab-wordpress/practice-1/\">이전 글</a>에서 C로 코딩을 했는데, COIN에서 사용하는 공용 언어로 자바를 선정함에 따라 자바로 코딩하겠습니다.</p>\n<p>코드를 보시기에 앞서 문제를 먼저 해부(?)하겠습니다. 동물 쉼터는 ‘먼저 들어온 동물이 먼저 나가는’ 곳 입니다. First In First Out(FIFO)라는거죠. 큐를 의미합니다. 그리고 문제의 끝에서 ‘LinkedList’를 사용해도 좋다고 합니다. 결국 LikedList로 표현된 Queue를 구현하라는 것입니다. 그리고 그 큐는 몇가지 제약조건을 가지고 있습니다. 들어온 지 가장 오래된 동물부터 입양하되, 개나 고양이 중에서 선택은 할 수 있도록 해줘라는 것입니다. 그래서 dequeueDog, dequeueCat 연산을 제공합니다. 대충 그림나옵니다. 그럼 시작할까요?</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Node head;</span><br><span class=\"line\"><span class=\"keyword\">private</span> Node tail;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Node next;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Node</span><span class=\"params\">(String animal, <span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = animal;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.id = num;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>링크드리스트를 구현해야하기 때문에 노드를 만들어줍니다. head와 tail은 큐에서 front(앞)와 rear(뒤)를 맡게됩니다. 일단은 4번째 줄 이후를 집중해서 보겠습니다. 이 노드는 동물의 이름 값(name), 개와 고양이를 분류하기 위한 값(id) 그리고 다음 노드를 가르키는 값(next)을 가지고 있습니다. 사실 저는 이 ‘가르키는 값’이 참 익숙하지 않습니다. C에서는 이걸 포인터로 구현하는데 Java에서는 그냥 값을 참조하면 되는데, 그게 은근히 낯섭니다. 포인터의 그 특징이 더 뇌리에 깊게 박힌 것 같습니다. 여하튼 노드는 이렇게 구성되어 있습니다. 이제 본격적인 연산들을 살펴보겠습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(String animal, <span class=\"keyword\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">\tNode newNode = <span class=\"keyword\">new</span> Node(animal, num);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\ttail = head = newNode;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\thead.next = newNode;</span><br><span class=\"line\">\t\thead = newNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsize++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이 코드는 노드를 추가(enqueue)하는 과정을 보여줍니다. 이 메소드는 인자로 동물의 이름(animal)과 개와 고양이를 구분하는 숫자(num)을 받습니다. 그리고 새로운 노드를 생성합니다. 이때 생성된 노드가 첫번째 노드라면(queue의 size가 0이라면) head와 tail이 동시에 이 노드를 가르킵니다. 만약 그렇지 않다면 head의 다음(next)에 새로운 노드가 붙습니다. 그리고 head는 새로운 노드를 가르킵니다. 그러니까 새로운 노드가 추가되면 tail로 붙는게 아니라 head가 이동합니다. tail은 움직이지 않습니다. 앞에다가 추가하는 방식인거죠. 추가가 끝나면 size를 증가시켜줍니다. 이로써 tail에는 가장 오래된 동물이 주인을 기다리게 됩니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dequeueAny</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tSystem.out.println(tail.name);</span><br><span class=\"line\">\ttail = tail.next;</span><br><span class=\"line\">\tsize--;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>새로운 주인을 만난 동물을 보내주는 메소드입니다. 가장 먼저 들어온 동물을 보내주겠습니다. 보내주는 걸 확인하기 위해 메세지를 출력합니다. 출력 이후에는 tail을 한칸 뒤로 이동합니다. 다음 차례를 가르키는거죠. 그리곤 size를 감소시켜줍니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dequeueDog</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tNode chaser_1 = tail;</span><br><span class=\"line\">\tNode chaser_2 = tail;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(chaser_1.id != <span class=\"number\">0</span> &amp;&amp; chaser_1.next != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">\t\tchaser_2 = chaser_1;</span><br><span class=\"line\">\t\tchaser_1 = chaser_2.next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (chaser_1 == tail) &#123; <span class=\"comment\">//개가 첫번째 노드에 있었던 경우</span></span><br><span class=\"line\">\t\tdequeueAny();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (chaser_1.id == <span class=\"number\">0</span>) &#123; <span class=\"comment\">//개를 발견한 경우</span></span><br><span class=\"line\">\t\tSystem.out.println(chaser_1.name + <span class=\"string\">\", Bye!\\n\"</span>);</span><br><span class=\"line\">\t\tchaser_2.next = chaser_1.next;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//개가 없는 경우</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"No Dog...\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsize--;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>이제 새로운 주인이 원하는 동물을 골라서 주겠습니다. 개/고양이 중에서 선택이 가능해야겠죠. 위의 코드는 개를 내보내는 코드입니다. id가 0일 때, 개/ 1일 때, 고양이라고 간주했습니다. 이번 코드에서 중요한건 역시 chaser_1,chaser_2 입니다. 이들의 역할은 원하는 동물을 찾아오는 것입니다. 처음에는 tail부터 시작합니다. 가장 오래된 동물부터 확인하는 것이죠.</p>\n<p>while문을 보겠습니다. 본격적인 추적(chase)가 시작됩니다. id가 0이 아닐 경우 계속 반복됩니다. 다시말해, 0이 아니라는 말은 개가 아니라는 것이니까 고양이라는 의미겠죠? 그리고 만약에 더 이상 개가 남아 있지 않을 경우도 있겠죠? 그런 경우에 무한루프를 방지하기 위해서 next값이 null이면 탈출할 수 있도록 조건을 만들어둡니다. 이제 chaser의 이동을 살펴보겠습니다. 5번 줄에서 chaser_2가 chaser_1의 위치로 갑니다. 그리고 다음 줄에서 chaser_1은 다음 노드로 이동합니다. 이렇게 chaser_1이 앞으로 한 노드씩 움직이며 개를 찾습니다. 결국 개가 발견되거나 개가 없으면 루프를 벗어납니다.</p>\n<p>만약에 개가 첫번째 노드에 있었다면 그냥 dequeueAny 메소드를 호출해줍니다. 그리고 만약에 개가 맞다면 개에게 작별을 고하고 보내줍니다. chaser_2의 다음 노드였던 chaser_1의 노드를 없애주기 위해 chaser_1 다음의 노드와 chaser_2를 이어줍니다. 그렇게 노드를 정리합니다. 만약에 개가 없었다면 더 이상 개가 없다고 메세지를 출력해줍니다.</p>\n<p>dequeueCat의 경우는 id 값만 바꿔주면 됩니다. 고로 생략하겠습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tLinkedList animals = <span class=\"keyword\">new</span> LinkedList();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tanimals.enqueue(<span class=\"string\">\"귀욤\"</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tanimals.enqueue(<span class=\"string\">\"개똥\"</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tanimals.enqueue(<span class=\"string\">\"황묘\"</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tanimals.enqueue(<span class=\"string\">\"백구\"</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSystem.out.println(animals);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tanimals.dequeueDog();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\tSystem.out.println(animals);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>예제 확인을 위한 코드입니다. 개똥이를 보내고 빈자리를 확인하는 것으로 코드가 끝납니다. 아래는 출력결과 입니다.</p>\n<p><img src=\"/images/aniqueue-result.jpg\" alt></p>\n<p><em>전체 코드는 <a href=\"https://github.com/joeunha/rabbylab-csbasic/blob/master/src/rabbylab/csbasic/coin/animalshelter/LinkedList.java\" target=\"_blank\">이곳</a>에서 확인하실 수 있습니다. 감사합니다.</em></p>\n"},{"title":"[Practice] min연산을 갖춘 stack을 구현하라!","date":"2016-03-26T10:29:50.000Z","author":"rabby","layout":"post","_content":"<span style=\"color: #999999;\">Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 <코딩인터뷰 완전분석> 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.</span>\n\n* * *\n\n**코딩인터뷰 완전분석 - 연습문제 3.2**\n\n**\"push와 pop의 두 가지 연산뿐 아니라, 최솟값을 갖는 원소를 반환하는 min연산을 갖춘 stack은 어떻게 구현할 수 있겠는가? push, pop, 그리고 min은 공히 O(1) 시간에 처리되어야 한다.\"**\n\n이 문제의 포인트는 'min연산', 'O(1)'에 있습니다. min연산은 어떻게 검색을 통해 해낸다고 해도 O(1) 시간에 처리해야하는 문제로 인해 반복문을 사용할 수가 없게되죠. 결국 min연산부터 다시 생각해야합니다. 이 문제를 해결하는 아이디어를 낸 친구가 이렇게 말했습니다. '그냥 stack을 하나 더 만들면 안돼?'라고 말입니다. 이때부터 함께 이것저것 아이디어를 덧붙여가며 이야기를 나눠보니 '옳다쿠나' 정답이었습니다.\n\n구현은 그리 어렵지 않습니다. 차근차근 해보겠습니다.\n\n```c\n#include <stdio.h>\n\nint main_stack[10];\nint min_chaser[10];\nint main_top = 0, chaser_top = 0;\nint cur_min;\n```\n\n우선 배열을 두개를 선언해줍니다. 하나는 기본 스택을 위한 배열, 다른 하나는 최소값을 추적하는 배열입니다. 그리고 각 스택별로 가장 마지막에 들어온 숫자를 체크하는 top 변수를 스택마다 하나씩 선언하고 0으로 초기화시킵니다. 마지막으로 현재의 최소값을 기억하고 있는 변수를 하나 선언합니다.\n\n```c\n//chaser_push function\nvoid chaser_push(num) {\n   if(chaser_top >= 10) {\n      printf(\"Stack is overflow!\\n\");\n   } else {\n      min_chaser[chaser_top] = num;\n      chaser_top++;\n   }\n}\n\n//chaser_pop function\nvoid chaser_pop() {\n   chaser_top--;\n   printf(\"I am number %d. I was a min number!\\n\", min_chaser[chaser_top]);\n   min_chaser[chaser_top] = 0;\n   cur_min = min_chaser[chaser_top - 1];\n}\n```\n\n다음은 함수를 만들어줄 차례입니다. 우선 chaser와 관련된 함수를 먼저 만들겠습니다. 왜냐하면 뒤이어 나오는 기본 스택 함수들이 이 함수들을 사용해야하기 때문입니다. chaser\\_push는 인자로 num값을 받습니다. 만약에 chaser\\_top값이 스택의 범주(10)를 넘어선다면 이는 오버플로우가 발생한 것이라고 경고하는 메세지를 출력합니다. 만약 오버플로우가 아니라면 chaser에 인자로 받은 값을 넣습니다. 그리고 chaser_top 값을 증가시켜줍니다. 기본적인 push구현 방식입니다.\n  \n이어사 등장하는 chaser\\_pop도 일반적인 pop과 같습니다. 우선 chaser\\_top을 감소시켜줍니다. 그리고 min\\_chaser에서 가장 위에 있는 값을 꺼내줍니다. 출력문을 통해 최소값이었다는 것을 밝힙니다. 원래 최소값이 들어있던 자리를 비워주고 cur\\_min값을 바꿔줍니다.\n\n_<span style=\"color: #999999;\">*저는 이 부분에서 chaser가 제일 작은 놈을 가두는 경찰소라는 추상적인 관념을 가지고 작업했습니다. 각 숫자들에 인격을 부여하고 함수 역시 어떤 역할을 감당하는 객체(?)라는 느낌을 가지고 작업하다보니 \"I am number 5. I was a min number!\" 같은 메세지가 나왔습니다.</span>_\n\n```c\n//main_stack push function\nvoid push(int num) {\n   if(main_top >= 10) {\n      printf(\"Stack is overflow.\\n\");\n   } else if (main_top == 0) {\n      main_stack[main_top] = num;\n      cur_num = num;\n      chaser_push(cur_num);\n      main_top++;\n  } else {\n      main_stack[main_top] = num;\n      main_top++;\n      if(num < cur_num) {\n          cur_num = num;\n          chaser_push(cur_num);\n      }\n   }  \n}\n\n//main_stack pop function\nvoid pop() {\n   if(main_top == 0) {\n      printf(\"Stack is empty.\\n\");\n   } else {\n      main_top--;\n      \n      if(main_stack[main_top] == cur_num) {\n         chaser_pop();\n      } else {\n          printf(\"I am number %d.\\n\", main_stack[main_top]);\n      }\n        main_stack[main_top] = 0;\n   }\n}\n```\n\n기본적인 push&pop 함수를 크게 벗어나지 않습니다. 특이점만 살펴보겠습니다. 우선 main\\_stack에 처음으로 push를 하는 경우가 나옵니다. main\\_top가 0인 경우죠. 이 경우에는 홀로 존재하기 때문에 곧장 최소값이 됩니다. 때문에 cur\\_num에 num을 넣어주고 chaser에도 push를 합니다. 그리고 top을 증가시키구요. 그 이후로는 cur\\_num값과 비교해서 더 작은 경우에만 chaser\\_push를 호출합니다. pop을 살펴보면 비어있는 경우를 메세지로 알려줍니다. 그렇지 않은 경우 중에서 빼내려고 하는 값과 cur\\_num가 같을 경우, main\\_stack의 pop이 아니라 chaser\\_pop으로 넘어갑니다. 거기서 \"I was a min number!\"라는 메세지를 출력한 뒤에 다시 돌아와 빠진 자리를 비워줍니다. 일반적인 경우에는 main_stack에서 메세지를 출력하고 함수가 끝납니다.\n\n이제 테스트해보겠습니다.\n\n```c\nint main() {\n\n   push(20);\n   push(16);\n   push(3);\n   push(26);\n   push(19);\n   push(21);\n\n   pop();\n   pop();\n   pop();\n   pop();\n   pop();\n   pop();\n\n   return 0;\n}\n```\n\n결과 값은 아래와 같습니다. (20과 16은 각기 들어갔을 때 당시에 최소값이었습니다.)\n![](/images/practice-1-result.png)\n\n\n[Practice 1] \"min연산을 갖춘 stack을 구현하라!\" 끝.\n\n_질문 혹은 문제 제기 환영합니다. 댓글 남겨주세요._","source":"_posts/practice-min-stack.md","raw":"---\ntitle: '[Practice] min연산을 갖춘 stack을 구현하라!'\ndate: 2016-03-26T19:29:50+00:00\nauthor: rabby\nlayout: post\ncategories:\n  - rabbylab\ntags:\n  - practice\n---\n<span style=\"color: #999999;\">Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 <코딩인터뷰 완전분석> 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.</span>\n\n* * *\n\n**코딩인터뷰 완전분석 - 연습문제 3.2**\n\n**\"push와 pop의 두 가지 연산뿐 아니라, 최솟값을 갖는 원소를 반환하는 min연산을 갖춘 stack은 어떻게 구현할 수 있겠는가? push, pop, 그리고 min은 공히 O(1) 시간에 처리되어야 한다.\"**\n\n이 문제의 포인트는 'min연산', 'O(1)'에 있습니다. min연산은 어떻게 검색을 통해 해낸다고 해도 O(1) 시간에 처리해야하는 문제로 인해 반복문을 사용할 수가 없게되죠. 결국 min연산부터 다시 생각해야합니다. 이 문제를 해결하는 아이디어를 낸 친구가 이렇게 말했습니다. '그냥 stack을 하나 더 만들면 안돼?'라고 말입니다. 이때부터 함께 이것저것 아이디어를 덧붙여가며 이야기를 나눠보니 '옳다쿠나' 정답이었습니다.\n\n구현은 그리 어렵지 않습니다. 차근차근 해보겠습니다.\n\n```c\n#include <stdio.h>\n\nint main_stack[10];\nint min_chaser[10];\nint main_top = 0, chaser_top = 0;\nint cur_min;\n```\n\n우선 배열을 두개를 선언해줍니다. 하나는 기본 스택을 위한 배열, 다른 하나는 최소값을 추적하는 배열입니다. 그리고 각 스택별로 가장 마지막에 들어온 숫자를 체크하는 top 변수를 스택마다 하나씩 선언하고 0으로 초기화시킵니다. 마지막으로 현재의 최소값을 기억하고 있는 변수를 하나 선언합니다.\n\n```c\n//chaser_push function\nvoid chaser_push(num) {\n   if(chaser_top >= 10) {\n      printf(\"Stack is overflow!\\n\");\n   } else {\n      min_chaser[chaser_top] = num;\n      chaser_top++;\n   }\n}\n\n//chaser_pop function\nvoid chaser_pop() {\n   chaser_top--;\n   printf(\"I am number %d. I was a min number!\\n\", min_chaser[chaser_top]);\n   min_chaser[chaser_top] = 0;\n   cur_min = min_chaser[chaser_top - 1];\n}\n```\n\n다음은 함수를 만들어줄 차례입니다. 우선 chaser와 관련된 함수를 먼저 만들겠습니다. 왜냐하면 뒤이어 나오는 기본 스택 함수들이 이 함수들을 사용해야하기 때문입니다. chaser\\_push는 인자로 num값을 받습니다. 만약에 chaser\\_top값이 스택의 범주(10)를 넘어선다면 이는 오버플로우가 발생한 것이라고 경고하는 메세지를 출력합니다. 만약 오버플로우가 아니라면 chaser에 인자로 받은 값을 넣습니다. 그리고 chaser_top 값을 증가시켜줍니다. 기본적인 push구현 방식입니다.\n  \n이어사 등장하는 chaser\\_pop도 일반적인 pop과 같습니다. 우선 chaser\\_top을 감소시켜줍니다. 그리고 min\\_chaser에서 가장 위에 있는 값을 꺼내줍니다. 출력문을 통해 최소값이었다는 것을 밝힙니다. 원래 최소값이 들어있던 자리를 비워주고 cur\\_min값을 바꿔줍니다.\n\n_<span style=\"color: #999999;\">*저는 이 부분에서 chaser가 제일 작은 놈을 가두는 경찰소라는 추상적인 관념을 가지고 작업했습니다. 각 숫자들에 인격을 부여하고 함수 역시 어떤 역할을 감당하는 객체(?)라는 느낌을 가지고 작업하다보니 \"I am number 5. I was a min number!\" 같은 메세지가 나왔습니다.</span>_\n\n```c\n//main_stack push function\nvoid push(int num) {\n   if(main_top >= 10) {\n      printf(\"Stack is overflow.\\n\");\n   } else if (main_top == 0) {\n      main_stack[main_top] = num;\n      cur_num = num;\n      chaser_push(cur_num);\n      main_top++;\n  } else {\n      main_stack[main_top] = num;\n      main_top++;\n      if(num < cur_num) {\n          cur_num = num;\n          chaser_push(cur_num);\n      }\n   }  \n}\n\n//main_stack pop function\nvoid pop() {\n   if(main_top == 0) {\n      printf(\"Stack is empty.\\n\");\n   } else {\n      main_top--;\n      \n      if(main_stack[main_top] == cur_num) {\n         chaser_pop();\n      } else {\n          printf(\"I am number %d.\\n\", main_stack[main_top]);\n      }\n        main_stack[main_top] = 0;\n   }\n}\n```\n\n기본적인 push&pop 함수를 크게 벗어나지 않습니다. 특이점만 살펴보겠습니다. 우선 main\\_stack에 처음으로 push를 하는 경우가 나옵니다. main\\_top가 0인 경우죠. 이 경우에는 홀로 존재하기 때문에 곧장 최소값이 됩니다. 때문에 cur\\_num에 num을 넣어주고 chaser에도 push를 합니다. 그리고 top을 증가시키구요. 그 이후로는 cur\\_num값과 비교해서 더 작은 경우에만 chaser\\_push를 호출합니다. pop을 살펴보면 비어있는 경우를 메세지로 알려줍니다. 그렇지 않은 경우 중에서 빼내려고 하는 값과 cur\\_num가 같을 경우, main\\_stack의 pop이 아니라 chaser\\_pop으로 넘어갑니다. 거기서 \"I was a min number!\"라는 메세지를 출력한 뒤에 다시 돌아와 빠진 자리를 비워줍니다. 일반적인 경우에는 main_stack에서 메세지를 출력하고 함수가 끝납니다.\n\n이제 테스트해보겠습니다.\n\n```c\nint main() {\n\n   push(20);\n   push(16);\n   push(3);\n   push(26);\n   push(19);\n   push(21);\n\n   pop();\n   pop();\n   pop();\n   pop();\n   pop();\n   pop();\n\n   return 0;\n}\n```\n\n결과 값은 아래와 같습니다. (20과 16은 각기 들어갔을 때 당시에 최소값이었습니다.)\n![](/images/practice-1-result.png)\n\n\n[Practice 1] \"min연산을 갖춘 stack을 구현하라!\" 끝.\n\n_질문 혹은 문제 제기 환영합니다. 댓글 남겨주세요._","slug":"practice-min-stack","published":1,"updated":"2019-12-05T15:05:29.492Z","comments":1,"photos":[],"link":"","_id":"ck6jcr9gv0043dirvyc7zny3e","content":"<p><span style=\"color: #999999;\">Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 &lt;코딩인터뷰 완전분석&gt; 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.</span></p>\n<hr>\n<p><strong>코딩인터뷰 완전분석 - 연습문제 3.2</strong></p>\n<p><strong>“push와 pop의 두 가지 연산뿐 아니라, 최솟값을 갖는 원소를 반환하는 min연산을 갖춘 stack은 어떻게 구현할 수 있겠는가? push, pop, 그리고 min은 공히 O(1) 시간에 처리되어야 한다.”</strong></p>\n<p>이 문제의 포인트는 ‘min연산’, ‘O(1)’에 있습니다. min연산은 어떻게 검색을 통해 해낸다고 해도 O(1) 시간에 처리해야하는 문제로 인해 반복문을 사용할 수가 없게되죠. 결국 min연산부터 다시 생각해야합니다. 이 문제를 해결하는 아이디어를 낸 친구가 이렇게 말했습니다. ‘그냥 stack을 하나 더 만들면 안돼?’라고 말입니다. 이때부터 함께 이것저것 아이디어를 덧붙여가며 이야기를 나눠보니 ‘옳다쿠나’ 정답이었습니다.</p>\n<p>구현은 그리 어렵지 않습니다. 차근차근 해보겠습니다.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main_stack[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> min_chaser[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> main_top = <span class=\"number\">0</span>, chaser_top = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> cur_min;</span><br></pre></td></tr></table></figure>\n\n<p>우선 배열을 두개를 선언해줍니다. 하나는 기본 스택을 위한 배열, 다른 하나는 최소값을 추적하는 배열입니다. 그리고 각 스택별로 가장 마지막에 들어온 숫자를 체크하는 top 변수를 스택마다 하나씩 선언하고 0으로 초기화시킵니다. 마지막으로 현재의 최소값을 기억하고 있는 변수를 하나 선언합니다.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//chaser_push function</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">chaser_push</span><span class=\"params\">(num)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(chaser_top &gt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"Stack is overflow!\\n\"</span>);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      min_chaser[chaser_top] = num;</span><br><span class=\"line\">      chaser_top++;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//chaser_pop function</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">chaser_pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   chaser_top--;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"I am number %d. I was a min number!\\n\"</span>, min_chaser[chaser_top]);</span><br><span class=\"line\">   min_chaser[chaser_top] = <span class=\"number\">0</span>;</span><br><span class=\"line\">   cur_min = min_chaser[chaser_top - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>다음은 함수를 만들어줄 차례입니다. 우선 chaser와 관련된 함수를 먼저 만들겠습니다. 왜냐하면 뒤이어 나오는 기본 스택 함수들이 이 함수들을 사용해야하기 때문입니다. chaser_push는 인자로 num값을 받습니다. 만약에 chaser_top값이 스택의 범주(10)를 넘어선다면 이는 오버플로우가 발생한 것이라고 경고하는 메세지를 출력합니다. 만약 오버플로우가 아니라면 chaser에 인자로 받은 값을 넣습니다. 그리고 chaser_top 값을 증가시켜줍니다. 기본적인 push구현 방식입니다.</p>\n<p>이어사 등장하는 chaser_pop도 일반적인 pop과 같습니다. 우선 chaser_top을 감소시켜줍니다. 그리고 min_chaser에서 가장 위에 있는 값을 꺼내줍니다. 출력문을 통해 최소값이었다는 것을 밝힙니다. 원래 최소값이 들어있던 자리를 비워주고 cur_min값을 바꿔줍니다.</p>\n<p>_<span style=\"color: #999999;\">*저는 이 부분에서 chaser가 제일 작은 놈을 가두는 경찰소라는 추상적인 관념을 가지고 작업했습니다. 각 숫자들에 인격을 부여하고 함수 역시 어떤 역할을 감당하는 객체(?)라는 느낌을 가지고 작업하다보니 “I am number 5. I was a min number!” 같은 메세지가 나왔습니다.</span>_</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main_stack push function</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(main_top &gt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"Stack is overflow.\\n\"</span>);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (main_top == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      main_stack[main_top] = num;</span><br><span class=\"line\">      cur_num = num;</span><br><span class=\"line\">      chaser_push(cur_num);</span><br><span class=\"line\">      main_top++;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      main_stack[main_top] = num;</span><br><span class=\"line\">      main_top++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(num &lt; cur_num) &#123;</span><br><span class=\"line\">          cur_num = num;</span><br><span class=\"line\">          chaser_push(cur_num);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//main_stack pop function</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(main_top == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"Stack is empty.\\n\"</span>);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      main_top--;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span>(main_stack[main_top] == cur_num) &#123;</span><br><span class=\"line\">         chaser_pop();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">\"I am number %d.\\n\"</span>, main_stack[main_top]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">        main_stack[main_top] = <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>기본적인 push&amp;pop 함수를 크게 벗어나지 않습니다. 특이점만 살펴보겠습니다. 우선 main_stack에 처음으로 push를 하는 경우가 나옵니다. main_top가 0인 경우죠. 이 경우에는 홀로 존재하기 때문에 곧장 최소값이 됩니다. 때문에 cur_num에 num을 넣어주고 chaser에도 push를 합니다. 그리고 top을 증가시키구요. 그 이후로는 cur_num값과 비교해서 더 작은 경우에만 chaser_push를 호출합니다. pop을 살펴보면 비어있는 경우를 메세지로 알려줍니다. 그렇지 않은 경우 중에서 빼내려고 하는 값과 cur_num가 같을 경우, main_stack의 pop이 아니라 chaser_pop으로 넘어갑니다. 거기서 “I was a min number!”라는 메세지를 출력한 뒤에 다시 돌아와 빠진 자리를 비워줍니다. 일반적인 경우에는 main_stack에서 메세지를 출력하고 함수가 끝납니다.</p>\n<p>이제 테스트해보겠습니다.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   push(<span class=\"number\">20</span>);</span><br><span class=\"line\">   push(<span class=\"number\">16</span>);</span><br><span class=\"line\">   push(<span class=\"number\">3</span>);</span><br><span class=\"line\">   push(<span class=\"number\">26</span>);</span><br><span class=\"line\">   push(<span class=\"number\">19</span>);</span><br><span class=\"line\">   push(<span class=\"number\">21</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   pop();</span><br><span class=\"line\">   pop();</span><br><span class=\"line\">   pop();</span><br><span class=\"line\">   pop();</span><br><span class=\"line\">   pop();</span><br><span class=\"line\">   pop();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>결과 값은 아래와 같습니다. (20과 16은 각기 들어갔을 때 당시에 최소값이었습니다.)<br><img src=\"/images/practice-1-result.png\" alt></p>\n<p>[Practice 1] “min연산을 갖춘 stack을 구현하라!” 끝.</p>\n<p><em>질문 혹은 문제 제기 환영합니다. 댓글 남겨주세요.</em></p>\n","site":{"data":{}},"excerpt":"","more":"<p><span style=\"color: #999999;\">Practice 시리즈를 연재합니다. 지난 3월 3일부터 COIN(코딩인터뷰 준비하는 모임)이라는 이름으로 함께 취업스터디를 진행하고 있는 5명의 친구들과 함께 교재 &lt;코딩인터뷰 완전분석&gt; 이라는 책을 가지고 공부를 시작했습니다. Practice 시리즈는 이 과정에서 함께 고민하며 풀었던 문제에 대해 이야기하는 시리즈입니다.</span></p>\n<hr>\n<p><strong>코딩인터뷰 완전분석 - 연습문제 3.2</strong></p>\n<p><strong>“push와 pop의 두 가지 연산뿐 아니라, 최솟값을 갖는 원소를 반환하는 min연산을 갖춘 stack은 어떻게 구현할 수 있겠는가? push, pop, 그리고 min은 공히 O(1) 시간에 처리되어야 한다.”</strong></p>\n<p>이 문제의 포인트는 ‘min연산’, ‘O(1)’에 있습니다. min연산은 어떻게 검색을 통해 해낸다고 해도 O(1) 시간에 처리해야하는 문제로 인해 반복문을 사용할 수가 없게되죠. 결국 min연산부터 다시 생각해야합니다. 이 문제를 해결하는 아이디어를 낸 친구가 이렇게 말했습니다. ‘그냥 stack을 하나 더 만들면 안돼?’라고 말입니다. 이때부터 함께 이것저것 아이디어를 덧붙여가며 이야기를 나눠보니 ‘옳다쿠나’ 정답이었습니다.</p>\n<p>구현은 그리 어렵지 않습니다. 차근차근 해보겠습니다.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main_stack[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> min_chaser[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> main_top = <span class=\"number\">0</span>, chaser_top = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> cur_min;</span><br></pre></td></tr></table></figure>\n\n<p>우선 배열을 두개를 선언해줍니다. 하나는 기본 스택을 위한 배열, 다른 하나는 최소값을 추적하는 배열입니다. 그리고 각 스택별로 가장 마지막에 들어온 숫자를 체크하는 top 변수를 스택마다 하나씩 선언하고 0으로 초기화시킵니다. 마지막으로 현재의 최소값을 기억하고 있는 변수를 하나 선언합니다.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//chaser_push function</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">chaser_push</span><span class=\"params\">(num)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(chaser_top &gt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"Stack is overflow!\\n\"</span>);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      min_chaser[chaser_top] = num;</span><br><span class=\"line\">      chaser_top++;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//chaser_pop function</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">chaser_pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   chaser_top--;</span><br><span class=\"line\">   <span class=\"built_in\">printf</span>(<span class=\"string\">\"I am number %d. I was a min number!\\n\"</span>, min_chaser[chaser_top]);</span><br><span class=\"line\">   min_chaser[chaser_top] = <span class=\"number\">0</span>;</span><br><span class=\"line\">   cur_min = min_chaser[chaser_top - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>다음은 함수를 만들어줄 차례입니다. 우선 chaser와 관련된 함수를 먼저 만들겠습니다. 왜냐하면 뒤이어 나오는 기본 스택 함수들이 이 함수들을 사용해야하기 때문입니다. chaser_push는 인자로 num값을 받습니다. 만약에 chaser_top값이 스택의 범주(10)를 넘어선다면 이는 오버플로우가 발생한 것이라고 경고하는 메세지를 출력합니다. 만약 오버플로우가 아니라면 chaser에 인자로 받은 값을 넣습니다. 그리고 chaser_top 값을 증가시켜줍니다. 기본적인 push구현 방식입니다.</p>\n<p>이어사 등장하는 chaser_pop도 일반적인 pop과 같습니다. 우선 chaser_top을 감소시켜줍니다. 그리고 min_chaser에서 가장 위에 있는 값을 꺼내줍니다. 출력문을 통해 최소값이었다는 것을 밝힙니다. 원래 최소값이 들어있던 자리를 비워주고 cur_min값을 바꿔줍니다.</p>\n<p>_<span style=\"color: #999999;\">*저는 이 부분에서 chaser가 제일 작은 놈을 가두는 경찰소라는 추상적인 관념을 가지고 작업했습니다. 각 숫자들에 인격을 부여하고 함수 역시 어떤 역할을 감당하는 객체(?)라는 느낌을 가지고 작업하다보니 “I am number 5. I was a min number!” 같은 메세지가 나왔습니다.</span>_</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main_stack push function</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(main_top &gt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"Stack is overflow.\\n\"</span>);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (main_top == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      main_stack[main_top] = num;</span><br><span class=\"line\">      cur_num = num;</span><br><span class=\"line\">      chaser_push(cur_num);</span><br><span class=\"line\">      main_top++;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      main_stack[main_top] = num;</span><br><span class=\"line\">      main_top++;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(num &lt; cur_num) &#123;</span><br><span class=\"line\">          cur_num = num;</span><br><span class=\"line\">          chaser_push(cur_num);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//main_stack pop function</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(main_top == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"Stack is empty.\\n\"</span>);</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      main_top--;</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span>(main_stack[main_top] == cur_num) &#123;</span><br><span class=\"line\">         chaser_pop();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">\"I am number %d.\\n\"</span>, main_stack[main_top]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">        main_stack[main_top] = <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>기본적인 push&amp;pop 함수를 크게 벗어나지 않습니다. 특이점만 살펴보겠습니다. 우선 main_stack에 처음으로 push를 하는 경우가 나옵니다. main_top가 0인 경우죠. 이 경우에는 홀로 존재하기 때문에 곧장 최소값이 됩니다. 때문에 cur_num에 num을 넣어주고 chaser에도 push를 합니다. 그리고 top을 증가시키구요. 그 이후로는 cur_num값과 비교해서 더 작은 경우에만 chaser_push를 호출합니다. pop을 살펴보면 비어있는 경우를 메세지로 알려줍니다. 그렇지 않은 경우 중에서 빼내려고 하는 값과 cur_num가 같을 경우, main_stack의 pop이 아니라 chaser_pop으로 넘어갑니다. 거기서 “I was a min number!”라는 메세지를 출력한 뒤에 다시 돌아와 빠진 자리를 비워줍니다. 일반적인 경우에는 main_stack에서 메세지를 출력하고 함수가 끝납니다.</p>\n<p>이제 테스트해보겠습니다.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   push(<span class=\"number\">20</span>);</span><br><span class=\"line\">   push(<span class=\"number\">16</span>);</span><br><span class=\"line\">   push(<span class=\"number\">3</span>);</span><br><span class=\"line\">   push(<span class=\"number\">26</span>);</span><br><span class=\"line\">   push(<span class=\"number\">19</span>);</span><br><span class=\"line\">   push(<span class=\"number\">21</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   pop();</span><br><span class=\"line\">   pop();</span><br><span class=\"line\">   pop();</span><br><span class=\"line\">   pop();</span><br><span class=\"line\">   pop();</span><br><span class=\"line\">   pop();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>결과 값은 아래와 같습니다. (20과 16은 각기 들어갔을 때 당시에 최소값이었습니다.)<br><img src=\"/images/practice-1-result.png\" alt></p>\n<p>[Practice 1] “min연산을 갖춘 stack을 구현하라!” 끝.</p>\n<p><em>질문 혹은 문제 제기 환영합니다. 댓글 남겨주세요.</em></p>\n"},{"id":"518","title":"[Project] PRATO 개발기(2)","date":"2016-05-23T00:05:29.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=518","_content":"페이지 구조를 잡아보기로 했습니다. 기획 부분이라고 보시면 될 것 같습니다. 기존에 PPT 파일로 만들어둔 목업을 조금 더 세련된 형태로 다듬어 보여 드리는 것으로 자질구레한 설명을 대체하겠습니다. 목업은 [이곳](https://goo.gl/OMW0rb)에서 보실 수 있습니다. 도구는 [페이지 구조를 잡아보기로 했습니다. 기획 부분이라고 보시면 될 것 같습니다. 기존에 PPT 파일로 만들어둔 목업을 조금 더 세련된 형태로 다듬어 보여 드리는 것으로 자질구레한 설명을 대체하겠습니다. 목업은 [이곳](https://goo.gl/OMW0rb)에서 보실 수 있습니다. 도구는 ](https://ovenapp.io/) 를 활용했습니다.\n\n분홍 툴팁을 따라가면 대략적인 플로우를 이해하실 수 있습니다. 더 많은 이들이 이해하기 쉽도록 만들어야하는 기획 프로토타입이지만 저만 이해할 수준으로 만들어서 부끄럽습니다. 시간 나는대로 디테일을 더할 생각입니다. 계속 지켜봐주세요.\n\n* * *\n\n(16&#8217;07.05 업데이트) ovenapp 을 대신해 codepen 에 프로토타입을 만들었습니다. 학교 수업에서 발표를 위해 이전의 프로토타입보다 조금 더 발전한 수준으로 만들었습니다. 발전이라고 했으나, 플로우를 이해할 수 있는 정도입니다. 해당 목업은 [이곳](http://codepen.io/rabbylab/full/jrWKPR/)에서 보실 수 있습니다.","source":"_posts/prato-2.md","raw":"---\nid: 518\ntitle: '[Project] PRATO 개발기(2)'\ndate: 2016-05-23T09:05:29+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=518\npermalink: /prato-2/\ncategories:\n  - rabbylab\ntags:\n  - toy-project\n---\n페이지 구조를 잡아보기로 했습니다. 기획 부분이라고 보시면 될 것 같습니다. 기존에 PPT 파일로 만들어둔 목업을 조금 더 세련된 형태로 다듬어 보여 드리는 것으로 자질구레한 설명을 대체하겠습니다. 목업은 [이곳](https://goo.gl/OMW0rb)에서 보실 수 있습니다. 도구는 [페이지 구조를 잡아보기로 했습니다. 기획 부분이라고 보시면 될 것 같습니다. 기존에 PPT 파일로 만들어둔 목업을 조금 더 세련된 형태로 다듬어 보여 드리는 것으로 자질구레한 설명을 대체하겠습니다. 목업은 [이곳](https://goo.gl/OMW0rb)에서 보실 수 있습니다. 도구는 ](https://ovenapp.io/) 를 활용했습니다.\n\n분홍 툴팁을 따라가면 대략적인 플로우를 이해하실 수 있습니다. 더 많은 이들이 이해하기 쉽도록 만들어야하는 기획 프로토타입이지만 저만 이해할 수준으로 만들어서 부끄럽습니다. 시간 나는대로 디테일을 더할 생각입니다. 계속 지켜봐주세요.\n\n* * *\n\n(16&#8217;07.05 업데이트) ovenapp 을 대신해 codepen 에 프로토타입을 만들었습니다. 학교 수업에서 발표를 위해 이전의 프로토타입보다 조금 더 발전한 수준으로 만들었습니다. 발전이라고 했으나, 플로우를 이해할 수 있는 정도입니다. 해당 목업은 [이곳](http://codepen.io/rabbylab/full/jrWKPR/)에서 보실 수 있습니다.","slug":"/prato-2/","published":1,"updated":"2019-12-05T15:05:29.492Z","comments":1,"photos":[],"link":"","_id":"ck6jcr9gx0047dirv8ayviu67","content":"<p>페이지 구조를 잡아보기로 했습니다. 기획 부분이라고 보시면 될 것 같습니다. 기존에 PPT 파일로 만들어둔 목업을 조금 더 세련된 형태로 다듬어 보여 드리는 것으로 자질구레한 설명을 대체하겠습니다. 목업은 <a href=\"https://goo.gl/OMW0rb\" target=\"_blank\" rel=\"noopener\">이곳</a>에서 보실 수 있습니다. 도구는 <a href=\"https://ovenapp.io/\" target=\"_blank\" rel=\"noopener\">페이지 구조를 잡아보기로 했습니다. 기획 부분이라고 보시면 될 것 같습니다. 기존에 PPT 파일로 만들어둔 목업을 조금 더 세련된 형태로 다듬어 보여 드리는 것으로 자질구레한 설명을 대체하겠습니다. 목업은 <a href=\"https://goo.gl/OMW0rb\" target=\"_blank\" rel=\"noopener\">이곳</a>에서 보실 수 있습니다. 도구는 </a> 를 활용했습니다.</p>\n<p>분홍 툴팁을 따라가면 대략적인 플로우를 이해하실 수 있습니다. 더 많은 이들이 이해하기 쉽도록 만들어야하는 기획 프로토타입이지만 저만 이해할 수준으로 만들어서 부끄럽습니다. 시간 나는대로 디테일을 더할 생각입니다. 계속 지켜봐주세요.</p>\n<hr>\n<p>(16&#8217;07.05 업데이트) ovenapp 을 대신해 codepen 에 프로토타입을 만들었습니다. 학교 수업에서 발표를 위해 이전의 프로토타입보다 조금 더 발전한 수준으로 만들었습니다. 발전이라고 했으나, 플로우를 이해할 수 있는 정도입니다. 해당 목업은 <a href=\"http://codepen.io/rabbylab/full/jrWKPR/\" target=\"_blank\" rel=\"noopener\">이곳</a>에서 보실 수 있습니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>페이지 구조를 잡아보기로 했습니다. 기획 부분이라고 보시면 될 것 같습니다. 기존에 PPT 파일로 만들어둔 목업을 조금 더 세련된 형태로 다듬어 보여 드리는 것으로 자질구레한 설명을 대체하겠습니다. 목업은 <a href=\"https://goo.gl/OMW0rb\" target=\"_blank\" rel=\"noopener\">이곳</a>에서 보실 수 있습니다. 도구는 <a href=\"https://ovenapp.io/\" target=\"_blank\" rel=\"noopener\">페이지 구조를 잡아보기로 했습니다. 기획 부분이라고 보시면 될 것 같습니다. 기존에 PPT 파일로 만들어둔 목업을 조금 더 세련된 형태로 다듬어 보여 드리는 것으로 자질구레한 설명을 대체하겠습니다. 목업은 <a href=\"https://goo.gl/OMW0rb\" target=\"_blank\" rel=\"noopener\">이곳</a>에서 보실 수 있습니다. 도구는 </a> 를 활용했습니다.</p>\n<p>분홍 툴팁을 따라가면 대략적인 플로우를 이해하실 수 있습니다. 더 많은 이들이 이해하기 쉽도록 만들어야하는 기획 프로토타입이지만 저만 이해할 수준으로 만들어서 부끄럽습니다. 시간 나는대로 디테일을 더할 생각입니다. 계속 지켜봐주세요.</p>\n<hr>\n<p>(16&#8217;07.05 업데이트) ovenapp 을 대신해 codepen 에 프로토타입을 만들었습니다. 학교 수업에서 발표를 위해 이전의 프로토타입보다 조금 더 발전한 수준으로 만들었습니다. 발전이라고 했으나, 플로우를 이해할 수 있는 정도입니다. 해당 목업은 <a href=\"http://codepen.io/rabbylab/full/jrWKPR/\" target=\"_blank\" rel=\"noopener\">이곳</a>에서 보실 수 있습니다.</p>\n"},{"id":"516","title":"[Project] PRATO 개발기(1)","date":"2016-04-28T06:14:17.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=516","_content":"### 소개\n\nPRATO는 PraiseTogether의 약자입니다. 함께 찬양하고 노래하기 위해 필요한 콘티(곡의 순서)를 제작하는 과정에 필요한 모든 과정을 제공하는 웹 서비스입니다.\n\n해당 서비스는 기존에 콘티 제작 과정이 웹 검색-문서 편집-출력의 과정에서 웹 브라우저와 문서 편집 도구를 별도로 이용해야만 했던 불편함을 해소하고자 시작되었습니다. 불필요한 다운로드 과정을 생략하고 하나의 웹 페이지에서 모든 과정을 수행할 수 있는 서비스입니다.\n\n주요 기능은 &#8216;**악보 검색**&#8216;, &#8216;**콘티 편집**&#8216;, &#8216;**콘티 출력**&#8216; 입니다.\n\n개발 과정 및 코드는 [Github](https://github.com/joeunha/praisetogether)을 통해 확인하실 수 있습니다.\n\n&nbsp;\n\n### 개발 환경 만들기\n\n그나마 경험이 많은 AngularJS로 프론트엔드를 꾸릴까 합니다. 서버단을 구현할 능력이 있을지 모르나, 시간과 능력이 허락한다면 MEAN Stack으로 전체를 구현해볼 생각입니다. 개발 환경 세팅에 소요되는 시간을 최소화하기 위해 스캐폴딩 도구인 [Yeoman](http://yeoman.io/)을 이용했습니다.\n\n개발 툴은 SourceTree / Atom / Chrome을 사용합니다. 상황에 따라 Windows 10 / OS X를 혼용하고 있습니다. Windows 10의 경우 bash 툴을 지원하지 않지만 SourceTree에서 제공하는 터미널 기능을 이용하여 개발을 진행하고 있습니다.\n\nnode (npm)을 설치한 뒤, yeoman 을 설치하면 yeoman을 사용할 준비가 끝이 납니다. 터미널에서 yo라고 입력하면 generator를 설치할 수 있는 installer가 보입니다. 저는 Grunt / Bower / css 를 선택했습니다. 스캐폴딩이 끝나고 grunt test, grunt build, grunt serve를 순서대로 입력하면 바로 작업 가능한 웹 페이지를 만나보실 수 있습니다. 이로써 개발 환경을 설정 했습니다.\n\n다음 시간에는 페이지 구조를 잡아보겠습니다.","source":"_posts/prato-1.md","raw":"---\nid: 516\ntitle: '[Project] PRATO 개발기(1)'\ndate: 2016-04-28T15:14:17+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=516\npermalink: /prato-1/\ncategories:\n  - rabbylab\ntags:\n  - toy-project\n---\n### 소개\n\nPRATO는 PraiseTogether의 약자입니다. 함께 찬양하고 노래하기 위해 필요한 콘티(곡의 순서)를 제작하는 과정에 필요한 모든 과정을 제공하는 웹 서비스입니다.\n\n해당 서비스는 기존에 콘티 제작 과정이 웹 검색-문서 편집-출력의 과정에서 웹 브라우저와 문서 편집 도구를 별도로 이용해야만 했던 불편함을 해소하고자 시작되었습니다. 불필요한 다운로드 과정을 생략하고 하나의 웹 페이지에서 모든 과정을 수행할 수 있는 서비스입니다.\n\n주요 기능은 &#8216;**악보 검색**&#8216;, &#8216;**콘티 편집**&#8216;, &#8216;**콘티 출력**&#8216; 입니다.\n\n개발 과정 및 코드는 [Github](https://github.com/joeunha/praisetogether)을 통해 확인하실 수 있습니다.\n\n&nbsp;\n\n### 개발 환경 만들기\n\n그나마 경험이 많은 AngularJS로 프론트엔드를 꾸릴까 합니다. 서버단을 구현할 능력이 있을지 모르나, 시간과 능력이 허락한다면 MEAN Stack으로 전체를 구현해볼 생각입니다. 개발 환경 세팅에 소요되는 시간을 최소화하기 위해 스캐폴딩 도구인 [Yeoman](http://yeoman.io/)을 이용했습니다.\n\n개발 툴은 SourceTree / Atom / Chrome을 사용합니다. 상황에 따라 Windows 10 / OS X를 혼용하고 있습니다. Windows 10의 경우 bash 툴을 지원하지 않지만 SourceTree에서 제공하는 터미널 기능을 이용하여 개발을 진행하고 있습니다.\n\nnode (npm)을 설치한 뒤, yeoman 을 설치하면 yeoman을 사용할 준비가 끝이 납니다. 터미널에서 yo라고 입력하면 generator를 설치할 수 있는 installer가 보입니다. 저는 Grunt / Bower / css 를 선택했습니다. 스캐폴딩이 끝나고 grunt test, grunt build, grunt serve를 순서대로 입력하면 바로 작업 가능한 웹 페이지를 만나보실 수 있습니다. 이로써 개발 환경을 설정 했습니다.\n\n다음 시간에는 페이지 구조를 잡아보겠습니다.","slug":"/prato-1/","published":1,"updated":"2019-12-05T15:05:29.492Z","comments":1,"photos":[],"link":"","_id":"ck6jcr9gy004adirvhh6gqcj1","content":"<h3 id=\"소개\"><a href=\"#소개\" class=\"headerlink\" title=\"소개\"></a>소개</h3><p>PRATO는 PraiseTogether의 약자입니다. 함께 찬양하고 노래하기 위해 필요한 콘티(곡의 순서)를 제작하는 과정에 필요한 모든 과정을 제공하는 웹 서비스입니다.</p>\n<p>해당 서비스는 기존에 콘티 제작 과정이 웹 검색-문서 편집-출력의 과정에서 웹 브라우저와 문서 편집 도구를 별도로 이용해야만 했던 불편함을 해소하고자 시작되었습니다. 불필요한 다운로드 과정을 생략하고 하나의 웹 페이지에서 모든 과정을 수행할 수 있는 서비스입니다.</p>\n<p>주요 기능은 &#8216;<strong>악보 검색</strong>&#8216;, &#8216;<strong>콘티 편집</strong>&#8216;, &#8216;<strong>콘티 출력</strong>&#8216; 입니다.</p>\n<p>개발 과정 및 코드는 <a href=\"https://github.com/joeunha/praisetogether\" target=\"_blank\" rel=\"noopener\">Github</a>을 통해 확인하실 수 있습니다.</p>\n<p>&nbsp;</p>\n<h3 id=\"개발-환경-만들기\"><a href=\"#개발-환경-만들기\" class=\"headerlink\" title=\"개발 환경 만들기\"></a>개발 환경 만들기</h3><p>그나마 경험이 많은 AngularJS로 프론트엔드를 꾸릴까 합니다. 서버단을 구현할 능력이 있을지 모르나, 시간과 능력이 허락한다면 MEAN Stack으로 전체를 구현해볼 생각입니다. 개발 환경 세팅에 소요되는 시간을 최소화하기 위해 스캐폴딩 도구인 <a href=\"http://yeoman.io/\" target=\"_blank\" rel=\"noopener\">Yeoman</a>을 이용했습니다.</p>\n<p>개발 툴은 SourceTree / Atom / Chrome을 사용합니다. 상황에 따라 Windows 10 / OS X를 혼용하고 있습니다. Windows 10의 경우 bash 툴을 지원하지 않지만 SourceTree에서 제공하는 터미널 기능을 이용하여 개발을 진행하고 있습니다.</p>\n<p>node (npm)을 설치한 뒤, yeoman 을 설치하면 yeoman을 사용할 준비가 끝이 납니다. 터미널에서 yo라고 입력하면 generator를 설치할 수 있는 installer가 보입니다. 저는 Grunt / Bower / css 를 선택했습니다. 스캐폴딩이 끝나고 grunt test, grunt build, grunt serve를 순서대로 입력하면 바로 작업 가능한 웹 페이지를 만나보실 수 있습니다. 이로써 개발 환경을 설정 했습니다.</p>\n<p>다음 시간에는 페이지 구조를 잡아보겠습니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"소개\"><a href=\"#소개\" class=\"headerlink\" title=\"소개\"></a>소개</h3><p>PRATO는 PraiseTogether의 약자입니다. 함께 찬양하고 노래하기 위해 필요한 콘티(곡의 순서)를 제작하는 과정에 필요한 모든 과정을 제공하는 웹 서비스입니다.</p>\n<p>해당 서비스는 기존에 콘티 제작 과정이 웹 검색-문서 편집-출력의 과정에서 웹 브라우저와 문서 편집 도구를 별도로 이용해야만 했던 불편함을 해소하고자 시작되었습니다. 불필요한 다운로드 과정을 생략하고 하나의 웹 페이지에서 모든 과정을 수행할 수 있는 서비스입니다.</p>\n<p>주요 기능은 &#8216;<strong>악보 검색</strong>&#8216;, &#8216;<strong>콘티 편집</strong>&#8216;, &#8216;<strong>콘티 출력</strong>&#8216; 입니다.</p>\n<p>개발 과정 및 코드는 <a href=\"https://github.com/joeunha/praisetogether\" target=\"_blank\" rel=\"noopener\">Github</a>을 통해 확인하실 수 있습니다.</p>\n<p>&nbsp;</p>\n<h3 id=\"개발-환경-만들기\"><a href=\"#개발-환경-만들기\" class=\"headerlink\" title=\"개발 환경 만들기\"></a>개발 환경 만들기</h3><p>그나마 경험이 많은 AngularJS로 프론트엔드를 꾸릴까 합니다. 서버단을 구현할 능력이 있을지 모르나, 시간과 능력이 허락한다면 MEAN Stack으로 전체를 구현해볼 생각입니다. 개발 환경 세팅에 소요되는 시간을 최소화하기 위해 스캐폴딩 도구인 <a href=\"http://yeoman.io/\" target=\"_blank\" rel=\"noopener\">Yeoman</a>을 이용했습니다.</p>\n<p>개발 툴은 SourceTree / Atom / Chrome을 사용합니다. 상황에 따라 Windows 10 / OS X를 혼용하고 있습니다. Windows 10의 경우 bash 툴을 지원하지 않지만 SourceTree에서 제공하는 터미널 기능을 이용하여 개발을 진행하고 있습니다.</p>\n<p>node (npm)을 설치한 뒤, yeoman 을 설치하면 yeoman을 사용할 준비가 끝이 납니다. 터미널에서 yo라고 입력하면 generator를 설치할 수 있는 installer가 보입니다. 저는 Grunt / Bower / css 를 선택했습니다. 스캐폴딩이 끝나고 grunt test, grunt build, grunt serve를 순서대로 입력하면 바로 작업 가능한 웹 페이지를 만나보실 수 있습니다. 이로써 개발 환경을 설정 했습니다.</p>\n<p>다음 시간에는 페이지 구조를 잡아보겠습니다.</p>\n"},{"id":"540","title":"[Challenge] Tribute Page 만들기","date":"2016-05-26T08:51:04.000Z","author":"rabby","layout":"post","guid":"http://rabbylab.xyz/?p=540","_content":"[FreeCodeCamp](https://www.freecodecamp.com/)를 시작한지 3주가 되어갑니다. 지금까지 [13시간 분량의 공부를 진행했네요.](https://www.freecodecamp.com/joeunha) Challenge 부분에서는 HTML, Bootstrap, jQuery 를 이수했습니다. 그리고 이제는 Project를 하게 되었는데요. 이런 실전적인 과제를 내어준다는 점에서 다른 코딩 학습 서비스와 차별점이 있는 것 같습니다. (중간 중간에 계속 커뮤니티와 소통할 수 있는 미션을 주는 것도 FCC가 가진 장점 중에 하납니다.)\n\n첫번째 과제는 Tribute Page를 만드는 건데요. Tribute는 공헌, 봉헌, 헌사 등의 이미를 갖는데 죽은 이를 기리는 페이지입니다. [예시](https://codepen.io/FreeCodeCamp/full/NNvBQW/)를 주고 코드를 보지 않고 이와 유사한 형태의 페이지를 만들라는 것이 주요 내용입니다.\n\n과제를 위해 [CodePen](https://codepen.io/)이라는 서비스를 사용하는데요. 일전에 인턴으로 일하면서 프론트엔드에 필요한 효과의 코드를 얻기 위해 사용했었는데 이렇게 개인 프로젝트로도 사용이 가능하군요.\n\n저는 존경하는 Steve Jobs를 기리는 페이지를 만들어보았습니다. 특별할 건 없구요. 예시를 최대한 따라하면서 Challenge를 통해 배운 기술들을 활용했습니다. [이곳](https://codepen.io/rabbylab/pen/mEbVNJ)에서 확인하실 수 있습니다. 조금 엉성한 구조로 만든 탓인지 자료 조사를 포함해서 40분 정도 소요되었습니다. (제 기준에서는 제법 금방 한 것 같습니다.)\n\n다음 프로젝트는 개인 포트폴리오를 만드는 겁니다. 늘 포트폴리오 하나 만들어야겠다고 생각해왔었는데 이참에 하나 만들어야겠습니다. FCC, 이거 은근히 중독됩니다. 공부도 되고 재미도 있는 참 좋은 서비스인 것 같습니다.","source":"_posts/project-tribute-page.md","raw":"---\nid: 540\ntitle: '[Challenge] Tribute Page 만들기'\ndate: 2016-05-26T17:51:04+00:00\nauthor: rabby\nlayout: post\nguid: http://rabbylab.xyz/?p=540\npermalink: /project-tribute-page/\ncategories:\n  - rabbylab\ntags:\n  - freecodecamp\n---\n[FreeCodeCamp](https://www.freecodecamp.com/)를 시작한지 3주가 되어갑니다. 지금까지 [13시간 분량의 공부를 진행했네요.](https://www.freecodecamp.com/joeunha) Challenge 부분에서는 HTML, Bootstrap, jQuery 를 이수했습니다. 그리고 이제는 Project를 하게 되었는데요. 이런 실전적인 과제를 내어준다는 점에서 다른 코딩 학습 서비스와 차별점이 있는 것 같습니다. (중간 중간에 계속 커뮤니티와 소통할 수 있는 미션을 주는 것도 FCC가 가진 장점 중에 하납니다.)\n\n첫번째 과제는 Tribute Page를 만드는 건데요. Tribute는 공헌, 봉헌, 헌사 등의 이미를 갖는데 죽은 이를 기리는 페이지입니다. [예시](https://codepen.io/FreeCodeCamp/full/NNvBQW/)를 주고 코드를 보지 않고 이와 유사한 형태의 페이지를 만들라는 것이 주요 내용입니다.\n\n과제를 위해 [CodePen](https://codepen.io/)이라는 서비스를 사용하는데요. 일전에 인턴으로 일하면서 프론트엔드에 필요한 효과의 코드를 얻기 위해 사용했었는데 이렇게 개인 프로젝트로도 사용이 가능하군요.\n\n저는 존경하는 Steve Jobs를 기리는 페이지를 만들어보았습니다. 특별할 건 없구요. 예시를 최대한 따라하면서 Challenge를 통해 배운 기술들을 활용했습니다. [이곳](https://codepen.io/rabbylab/pen/mEbVNJ)에서 확인하실 수 있습니다. 조금 엉성한 구조로 만든 탓인지 자료 조사를 포함해서 40분 정도 소요되었습니다. (제 기준에서는 제법 금방 한 것 같습니다.)\n\n다음 프로젝트는 개인 포트폴리오를 만드는 겁니다. 늘 포트폴리오 하나 만들어야겠다고 생각해왔었는데 이참에 하나 만들어야겠습니다. FCC, 이거 은근히 중독됩니다. 공부도 되고 재미도 있는 참 좋은 서비스인 것 같습니다.","slug":"/project-tribute-page/","published":1,"updated":"2019-12-05T15:05:29.492Z","comments":1,"photos":[],"link":"","_id":"ck6jcr9gz004edirv0zo16el3","content":"<p><a href=\"https://www.freecodecamp.com/\" target=\"_blank\" rel=\"noopener\">FreeCodeCamp</a>를 시작한지 3주가 되어갑니다. 지금까지 <a href=\"https://www.freecodecamp.com/joeunha\" target=\"_blank\" rel=\"noopener\">13시간 분량의 공부를 진행했네요.</a> Challenge 부분에서는 HTML, Bootstrap, jQuery 를 이수했습니다. 그리고 이제는 Project를 하게 되었는데요. 이런 실전적인 과제를 내어준다는 점에서 다른 코딩 학습 서비스와 차별점이 있는 것 같습니다. (중간 중간에 계속 커뮤니티와 소통할 수 있는 미션을 주는 것도 FCC가 가진 장점 중에 하납니다.)</p>\n<p>첫번째 과제는 Tribute Page를 만드는 건데요. Tribute는 공헌, 봉헌, 헌사 등의 이미를 갖는데 죽은 이를 기리는 페이지입니다. <a href=\"https://codepen.io/FreeCodeCamp/full/NNvBQW/\" target=\"_blank\" rel=\"noopener\">예시</a>를 주고 코드를 보지 않고 이와 유사한 형태의 페이지를 만들라는 것이 주요 내용입니다.</p>\n<p>과제를 위해 <a href=\"https://codepen.io/\" target=\"_blank\" rel=\"noopener\">CodePen</a>이라는 서비스를 사용하는데요. 일전에 인턴으로 일하면서 프론트엔드에 필요한 효과의 코드를 얻기 위해 사용했었는데 이렇게 개인 프로젝트로도 사용이 가능하군요.</p>\n<p>저는 존경하는 Steve Jobs를 기리는 페이지를 만들어보았습니다. 특별할 건 없구요. 예시를 최대한 따라하면서 Challenge를 통해 배운 기술들을 활용했습니다. <a href=\"https://codepen.io/rabbylab/pen/mEbVNJ\" target=\"_blank\" rel=\"noopener\">이곳</a>에서 확인하실 수 있습니다. 조금 엉성한 구조로 만든 탓인지 자료 조사를 포함해서 40분 정도 소요되었습니다. (제 기준에서는 제법 금방 한 것 같습니다.)</p>\n<p>다음 프로젝트는 개인 포트폴리오를 만드는 겁니다. 늘 포트폴리오 하나 만들어야겠다고 생각해왔었는데 이참에 하나 만들어야겠습니다. FCC, 이거 은근히 중독됩니다. 공부도 되고 재미도 있는 참 좋은 서비스인 것 같습니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.freecodecamp.com/\" target=\"_blank\" rel=\"noopener\">FreeCodeCamp</a>를 시작한지 3주가 되어갑니다. 지금까지 <a href=\"https://www.freecodecamp.com/joeunha\" target=\"_blank\" rel=\"noopener\">13시간 분량의 공부를 진행했네요.</a> Challenge 부분에서는 HTML, Bootstrap, jQuery 를 이수했습니다. 그리고 이제는 Project를 하게 되었는데요. 이런 실전적인 과제를 내어준다는 점에서 다른 코딩 학습 서비스와 차별점이 있는 것 같습니다. (중간 중간에 계속 커뮤니티와 소통할 수 있는 미션을 주는 것도 FCC가 가진 장점 중에 하납니다.)</p>\n<p>첫번째 과제는 Tribute Page를 만드는 건데요. Tribute는 공헌, 봉헌, 헌사 등의 이미를 갖는데 죽은 이를 기리는 페이지입니다. <a href=\"https://codepen.io/FreeCodeCamp/full/NNvBQW/\" target=\"_blank\" rel=\"noopener\">예시</a>를 주고 코드를 보지 않고 이와 유사한 형태의 페이지를 만들라는 것이 주요 내용입니다.</p>\n<p>과제를 위해 <a href=\"https://codepen.io/\" target=\"_blank\" rel=\"noopener\">CodePen</a>이라는 서비스를 사용하는데요. 일전에 인턴으로 일하면서 프론트엔드에 필요한 효과의 코드를 얻기 위해 사용했었는데 이렇게 개인 프로젝트로도 사용이 가능하군요.</p>\n<p>저는 존경하는 Steve Jobs를 기리는 페이지를 만들어보았습니다. 특별할 건 없구요. 예시를 최대한 따라하면서 Challenge를 통해 배운 기술들을 활용했습니다. <a href=\"https://codepen.io/rabbylab/pen/mEbVNJ\" target=\"_blank\" rel=\"noopener\">이곳</a>에서 확인하실 수 있습니다. 조금 엉성한 구조로 만든 탓인지 자료 조사를 포함해서 40분 정도 소요되었습니다. (제 기준에서는 제법 금방 한 것 같습니다.)</p>\n<p>다음 프로젝트는 개인 포트폴리오를 만드는 겁니다. 늘 포트폴리오 하나 만들어야겠다고 생각해왔었는데 이참에 하나 만들어야겠습니다. FCC, 이거 은근히 중독됩니다. 공부도 되고 재미도 있는 참 좋은 서비스인 것 같습니다.</p>\n"},{"title":"회고 - 숫자로 보는 2018","date":"2018-12-31T08:00:00.000Z","description":"2018년, 새해를 야심 차게 시작했음이 틀림없다.","image":"typewriter.jpg","_content":"\n## 18\n\n#### 열여덟권의 책\n\n새해를 야심 차게 시작했음이 틀림없다. 1월 2일에 **2018년 도서 목록**이라는 노트를 만들어 둔 걸 보면. 처음엔 열다섯권 정도였다. 중간에 읽고 싶은 책을 추가해서 지금은 마흔두권이 됐다. 그중 열여덟권을 읽었다. 읽은 시기도 기록해뒀는데 연초와 연말에 대부분의 책이 몰려있다.\n\n여덟권은 경영, 비즈니스, 스타트업에 관한 책이다. 이 중에 한권을 고르라면 **<아마존, 세상의 모든 것을 팝니다>**를 고르겠다. 여러 가지로 많은 영감을 얻었다. 그 외에 인문, 프로그래밍 관련 서적을 읽었다. 관심 없는 분야의 책도 꾸준히 읽을 수 있었던 건 독서 모임 덕분이다. 이름을 정하지 못해서 지금까지 **이름 없는 독서 모임**으로 불리는 이 모임을 통해 **<생각의 탄생>**, **<혼자가 편한 사람들의 사랑법>**이라는 굵직하고 깊이 있는 책을 읽을 수 있었다. 혼자였다면 도무지 이해하지 못했을 책을 함께라서 즐겁게 읽을 수 있었다.\n\n## 9\n\n#### 아홉번의 스터디와 클래스\n\n주로 프로그래밍 관련 스터디가 주를 이뤘다. **함수형 프로그래밍, Github** 등의 주제를 다뤘다. 강의의 형식을 빌려 진행했다. 전자는 실무자를, 후자는 학생들을 대상으로 했다. 횟수가 많은 까닭은 여러번 반복했기 때문이다. 그 과정에서 [콘텐츠](https://github.com/joeunha/functional-js-study2)를 계속 발전 시킬 수 있었다. 좋은 네트워킹의 기회도 되었다.\n\n클래스는 드로잉, 사진이 주제였다. 드로잉 클래스는 그림을 배우고 싶어서 직접 강사를 섭외했다. 여행 중에 그림을 그려보고 싶었다. 강사분과 함께 콘텐츠를 기획하고 건물, 풍경, 음식을 그릴 수 있는 커리큘럼을 짰다. 수업을 듣는 동안에는 제법 그림 그리기에 심취했었다. 인스타도 그림으로 도배됐었다. 새로운 취미가 생기는가 했는데 지금까지 꾸준하지 않은 걸 보니 취미라고 부르긴 글렀나보다.\n\n## 7\n\n#### 일곱번의 강의\n\n**'배워서 남주자'**는 생각을 늘 가지고 있다. 강의는 그 생각의 발현이다. 강의 활동을 칭찬해주는 분들에게 종종 하는 말이 있는데, 내가 잘나서 강의하는 게 아니라는 것이다. 다만 경험을 통해 조금 먼저 알게 된 정보나 사실을 다른 사람들에게 나누는 것일 뿐이라고. 강의를 통해 오히려 많이 배운다고 말한다. 뜬금없이 이 말을 꺼낸 이유는 많은 분이 강의에 도전했으면 하는 마음 때문이다. **스스로 보기에 사소한 지식도 누군가에겐 정말 귀한 지식이 되곤 한다.**\n\n첫 강의는 4월에 있었다. 모교인 한동대학교에서 오픈소스의 중요성을 가르치고 있고 실무자의 경험을 듣길 원한다는 연락을 받고 강의를 하게 됐다. 처음엔 무슨 이야기를 해야 하나 막막했다. 몇 주째 아무런 준비를 못 하고 있었다. 그러다 실제 서비스 개발에 무심코 사용하던 소스 코드 목록(`package.json`)을 확인하게 됐다. 목록엔 오픈소스가 가득했고 이 소스들이 서비스에 얼마나 큰 영향을 미치는지 이야기 하는 것으로 갈래를 잡았다. 제목은 **<일상에 스며든 오픈소스>**였다.\n\n이후 [리드미](http://campus.leadme.today/)를 통해 지난 경험을 토대로 [문과 출신 개발자의 이야기](/view-of-value/like-me-2/)를 몇 차례 전했다. 정보통신산업진흥원(nipa)에서 진행하는 **소프트웨어 일일 교사**에도 [참여](https://youtu.be/SLU-IZJxxgw)했다. 한동대학교에서 <떠먹여주는 웹 프로그래밍>이라는 제목으로 웹 프로그래밍 기초를 다루기도 했다. 이 콘텐츠들은 실무자들이 보기엔 민망할 정도로 사소한 지식이다. 하지만 조금만 다듬어서 쉽게 풀어내면 누군가에겐 정말 귀한 정보가 된다는 생각으로 지금까지 강의를 이어오고 있다.\n\n## 4\n\n#### 네번의 결혼식, 소개팅, 집들이\n\n네번이라는 공통된 숫자가 나와 재밌어서 기록했다. 극히 개인적인 경험이라 자세한 스토리를 기술하진 않겠지만 이 숫자의 변화가 **생애 주기의 변화를 의미한다고 생각하니 흥미롭다.**\n\n## 1\n\n#### 첫번째 이직\n\n지난 [회고](/view-of-value/1-year-anniversary/)를 통해 밝힌 것처럼 마플은 정말 훌륭한 경험을 안겨준 회사였다. 개발자로서 그리고 인격체로서 어떻게 성장해야 할지 방향성을 알려주었다. 개발팀은 끊임없이 도전했고 성장했다. 함께 성장하며 즐거웠다. **다만 새로운 환경이 필요했다.** 극단적으로 해외로의 이직을 생각한 걸 보면 그 갈망이 얼마나 컸는지 알 수 있다. 하지만 일상의 관성도 만만치 않았다.\n\n관성을 극복할 수 있었던 건 주변의 조언 덕분이다. 새로운 환경으로 도전할 수 있도록 꾸준히 자극을 줬다. 몇번의 크고 작은 자극을 받고 링크드인(LinkedIn)을 시작했다. 10월엔 헤드헌터를 만났고 채용 시장에 뛰어들었다. 일곱 회사의 문을 두드렸다. 서류 전형을 통과한 뒤론 자투리 시간을 활용해 면접 볼 회사의 도메인 지식을 습득했다. 주말엔 코딩 테스트를 봤다. 면접을 거듭할수록 계속 성장함을 느꼈다. 면접에도 기술이 있었다.\n\n면접을 거듭 진행하는 중에 세 차례 강의도 있었다. 너무 무리한 탓에 입과 귀에 염증이 생겼다. 제대로 먹지도 못하고 이어폰으로 노래를 들을 수도 없었다. 덕분에 고생 끝에 낙이 온다는 사실을 몸소 체험할 수 있었다. 감사하게도 네곳에 합격했다.\n\n최종적으로 [레이니스트](https://rainist.com/)를 선택했다. 핀테크에 대한 관심, 좋은 사내 문화도 분명 중요한 이유였다. 하지만 무엇보다 고객에게 감동을 주는 서비스를 운영한다는 게 결정적이었다.\n\n레이니스트가 서비스하는 [뱅크샐러드](https://banksalad.com/)는 가족이 감동한 서비스였다. 사내에서 있었던 자기소개 시간에 밝힌 친동생이 뱅크샐러드를 사용하며 느낀 감동. 그 감동을 대한민국으로 확장하고 싶었다. **정보의 비대칭성을 해결해 더 나은 의사결정을 돕는다**는 이들의 미션을 **함께** 이뤄보고 싶었다. 늘 꿈꿔오던 헤븐(Heaven) 조선을 함께 만들어가고 싶어 레이니스트로 이직했다.\n\n## 30\n\n#### 서른을 앞둔 나이\n\n2018년은 이십대로서 마지막 해였다. 비록 **진정한 가치는 숫자로 측정되지 않는다**고 하지만 서른이라는 숫자 앞에서 막연하게 불안한 감정을 느끼는 게 사실이다. 갓 대학생이 됐을 땐 서른이 되면 정말 많은 것을 이뤘을 것이라 기대했다. 엄청 어른이 되어 있을 것 같았다. 사실 지금의 나는 새내기 시절 나와 크게 다르지 않다. 가끔 나이를 착각할 정도다. 다만 그때는 몰랐던 사실을 깨달았다. 너무 반복돼서 익숙하게 지나치는 오늘이 정말 중요한 **꿈꾸던 그 날**이라는 사실. 아직 오지 않은 **미래가 아니라 오늘이 중요하다**는 사실. 그리고 이 마음으로 살아가면 행복할 거라는 사실.\n","source":"_posts/retrospection-2018.md","raw":"---\ntitle: '회고 - 숫자로 보는 2018'\ndate: 2018-12-31 17:00:00\ncategories:\n  - view of value\ntags:\n  - retrospection\n  - 회고록\ndescription: '2018년, 새해를 야심 차게 시작했음이 틀림없다.'\nimage: 'typewriter.jpg'\n---\n\n## 18\n\n#### 열여덟권의 책\n\n새해를 야심 차게 시작했음이 틀림없다. 1월 2일에 **2018년 도서 목록**이라는 노트를 만들어 둔 걸 보면. 처음엔 열다섯권 정도였다. 중간에 읽고 싶은 책을 추가해서 지금은 마흔두권이 됐다. 그중 열여덟권을 읽었다. 읽은 시기도 기록해뒀는데 연초와 연말에 대부분의 책이 몰려있다.\n\n여덟권은 경영, 비즈니스, 스타트업에 관한 책이다. 이 중에 한권을 고르라면 **<아마존, 세상의 모든 것을 팝니다>**를 고르겠다. 여러 가지로 많은 영감을 얻었다. 그 외에 인문, 프로그래밍 관련 서적을 읽었다. 관심 없는 분야의 책도 꾸준히 읽을 수 있었던 건 독서 모임 덕분이다. 이름을 정하지 못해서 지금까지 **이름 없는 독서 모임**으로 불리는 이 모임을 통해 **<생각의 탄생>**, **<혼자가 편한 사람들의 사랑법>**이라는 굵직하고 깊이 있는 책을 읽을 수 있었다. 혼자였다면 도무지 이해하지 못했을 책을 함께라서 즐겁게 읽을 수 있었다.\n\n## 9\n\n#### 아홉번의 스터디와 클래스\n\n주로 프로그래밍 관련 스터디가 주를 이뤘다. **함수형 프로그래밍, Github** 등의 주제를 다뤘다. 강의의 형식을 빌려 진행했다. 전자는 실무자를, 후자는 학생들을 대상으로 했다. 횟수가 많은 까닭은 여러번 반복했기 때문이다. 그 과정에서 [콘텐츠](https://github.com/joeunha/functional-js-study2)를 계속 발전 시킬 수 있었다. 좋은 네트워킹의 기회도 되었다.\n\n클래스는 드로잉, 사진이 주제였다. 드로잉 클래스는 그림을 배우고 싶어서 직접 강사를 섭외했다. 여행 중에 그림을 그려보고 싶었다. 강사분과 함께 콘텐츠를 기획하고 건물, 풍경, 음식을 그릴 수 있는 커리큘럼을 짰다. 수업을 듣는 동안에는 제법 그림 그리기에 심취했었다. 인스타도 그림으로 도배됐었다. 새로운 취미가 생기는가 했는데 지금까지 꾸준하지 않은 걸 보니 취미라고 부르긴 글렀나보다.\n\n## 7\n\n#### 일곱번의 강의\n\n**'배워서 남주자'**는 생각을 늘 가지고 있다. 강의는 그 생각의 발현이다. 강의 활동을 칭찬해주는 분들에게 종종 하는 말이 있는데, 내가 잘나서 강의하는 게 아니라는 것이다. 다만 경험을 통해 조금 먼저 알게 된 정보나 사실을 다른 사람들에게 나누는 것일 뿐이라고. 강의를 통해 오히려 많이 배운다고 말한다. 뜬금없이 이 말을 꺼낸 이유는 많은 분이 강의에 도전했으면 하는 마음 때문이다. **스스로 보기에 사소한 지식도 누군가에겐 정말 귀한 지식이 되곤 한다.**\n\n첫 강의는 4월에 있었다. 모교인 한동대학교에서 오픈소스의 중요성을 가르치고 있고 실무자의 경험을 듣길 원한다는 연락을 받고 강의를 하게 됐다. 처음엔 무슨 이야기를 해야 하나 막막했다. 몇 주째 아무런 준비를 못 하고 있었다. 그러다 실제 서비스 개발에 무심코 사용하던 소스 코드 목록(`package.json`)을 확인하게 됐다. 목록엔 오픈소스가 가득했고 이 소스들이 서비스에 얼마나 큰 영향을 미치는지 이야기 하는 것으로 갈래를 잡았다. 제목은 **<일상에 스며든 오픈소스>**였다.\n\n이후 [리드미](http://campus.leadme.today/)를 통해 지난 경험을 토대로 [문과 출신 개발자의 이야기](/view-of-value/like-me-2/)를 몇 차례 전했다. 정보통신산업진흥원(nipa)에서 진행하는 **소프트웨어 일일 교사**에도 [참여](https://youtu.be/SLU-IZJxxgw)했다. 한동대학교에서 <떠먹여주는 웹 프로그래밍>이라는 제목으로 웹 프로그래밍 기초를 다루기도 했다. 이 콘텐츠들은 실무자들이 보기엔 민망할 정도로 사소한 지식이다. 하지만 조금만 다듬어서 쉽게 풀어내면 누군가에겐 정말 귀한 정보가 된다는 생각으로 지금까지 강의를 이어오고 있다.\n\n## 4\n\n#### 네번의 결혼식, 소개팅, 집들이\n\n네번이라는 공통된 숫자가 나와 재밌어서 기록했다. 극히 개인적인 경험이라 자세한 스토리를 기술하진 않겠지만 이 숫자의 변화가 **생애 주기의 변화를 의미한다고 생각하니 흥미롭다.**\n\n## 1\n\n#### 첫번째 이직\n\n지난 [회고](/view-of-value/1-year-anniversary/)를 통해 밝힌 것처럼 마플은 정말 훌륭한 경험을 안겨준 회사였다. 개발자로서 그리고 인격체로서 어떻게 성장해야 할지 방향성을 알려주었다. 개발팀은 끊임없이 도전했고 성장했다. 함께 성장하며 즐거웠다. **다만 새로운 환경이 필요했다.** 극단적으로 해외로의 이직을 생각한 걸 보면 그 갈망이 얼마나 컸는지 알 수 있다. 하지만 일상의 관성도 만만치 않았다.\n\n관성을 극복할 수 있었던 건 주변의 조언 덕분이다. 새로운 환경으로 도전할 수 있도록 꾸준히 자극을 줬다. 몇번의 크고 작은 자극을 받고 링크드인(LinkedIn)을 시작했다. 10월엔 헤드헌터를 만났고 채용 시장에 뛰어들었다. 일곱 회사의 문을 두드렸다. 서류 전형을 통과한 뒤론 자투리 시간을 활용해 면접 볼 회사의 도메인 지식을 습득했다. 주말엔 코딩 테스트를 봤다. 면접을 거듭할수록 계속 성장함을 느꼈다. 면접에도 기술이 있었다.\n\n면접을 거듭 진행하는 중에 세 차례 강의도 있었다. 너무 무리한 탓에 입과 귀에 염증이 생겼다. 제대로 먹지도 못하고 이어폰으로 노래를 들을 수도 없었다. 덕분에 고생 끝에 낙이 온다는 사실을 몸소 체험할 수 있었다. 감사하게도 네곳에 합격했다.\n\n최종적으로 [레이니스트](https://rainist.com/)를 선택했다. 핀테크에 대한 관심, 좋은 사내 문화도 분명 중요한 이유였다. 하지만 무엇보다 고객에게 감동을 주는 서비스를 운영한다는 게 결정적이었다.\n\n레이니스트가 서비스하는 [뱅크샐러드](https://banksalad.com/)는 가족이 감동한 서비스였다. 사내에서 있었던 자기소개 시간에 밝힌 친동생이 뱅크샐러드를 사용하며 느낀 감동. 그 감동을 대한민국으로 확장하고 싶었다. **정보의 비대칭성을 해결해 더 나은 의사결정을 돕는다**는 이들의 미션을 **함께** 이뤄보고 싶었다. 늘 꿈꿔오던 헤븐(Heaven) 조선을 함께 만들어가고 싶어 레이니스트로 이직했다.\n\n## 30\n\n#### 서른을 앞둔 나이\n\n2018년은 이십대로서 마지막 해였다. 비록 **진정한 가치는 숫자로 측정되지 않는다**고 하지만 서른이라는 숫자 앞에서 막연하게 불안한 감정을 느끼는 게 사실이다. 갓 대학생이 됐을 땐 서른이 되면 정말 많은 것을 이뤘을 것이라 기대했다. 엄청 어른이 되어 있을 것 같았다. 사실 지금의 나는 새내기 시절 나와 크게 다르지 않다. 가끔 나이를 착각할 정도다. 다만 그때는 몰랐던 사실을 깨달았다. 너무 반복돼서 익숙하게 지나치는 오늘이 정말 중요한 **꿈꾸던 그 날**이라는 사실. 아직 오지 않은 **미래가 아니라 오늘이 중요하다**는 사실. 그리고 이 마음으로 살아가면 행복할 거라는 사실.\n","slug":"retrospection-2018","published":1,"updated":"2020-02-09T14:20:01.167Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9gz004hdirv6sgqjmlp","content":"<h2 id=\"18\"><a href=\"#18\" class=\"headerlink\" title=\"18\"></a>18</h2><h4 id=\"열여덟권의-책\"><a href=\"#열여덟권의-책\" class=\"headerlink\" title=\"열여덟권의 책\"></a>열여덟권의 책</h4><p>새해를 야심 차게 시작했음이 틀림없다. 1월 2일에 <strong>2018년 도서 목록</strong>이라는 노트를 만들어 둔 걸 보면. 처음엔 열다섯권 정도였다. 중간에 읽고 싶은 책을 추가해서 지금은 마흔두권이 됐다. 그중 열여덟권을 읽었다. 읽은 시기도 기록해뒀는데 연초와 연말에 대부분의 책이 몰려있다.</p>\n<p>여덟권은 경영, 비즈니스, 스타트업에 관한 책이다. 이 중에 한권을 고르라면 <strong>&lt;아마존, 세상의 모든 것을 팝니다&gt;</strong>를 고르겠다. 여러 가지로 많은 영감을 얻었다. 그 외에 인문, 프로그래밍 관련 서적을 읽었다. 관심 없는 분야의 책도 꾸준히 읽을 수 있었던 건 독서 모임 덕분이다. 이름을 정하지 못해서 지금까지 <strong>이름 없는 독서 모임</strong>으로 불리는 이 모임을 통해 <strong>&lt;생각의 탄생&gt;</strong>, <strong>&lt;혼자가 편한 사람들의 사랑법&gt;</strong>이라는 굵직하고 깊이 있는 책을 읽을 수 있었다. 혼자였다면 도무지 이해하지 못했을 책을 함께라서 즐겁게 읽을 수 있었다.</p>\n<h2 id=\"9\"><a href=\"#9\" class=\"headerlink\" title=\"9\"></a>9</h2><h4 id=\"아홉번의-스터디와-클래스\"><a href=\"#아홉번의-스터디와-클래스\" class=\"headerlink\" title=\"아홉번의 스터디와 클래스\"></a>아홉번의 스터디와 클래스</h4><p>주로 프로그래밍 관련 스터디가 주를 이뤘다. <strong>함수형 프로그래밍, Github</strong> 등의 주제를 다뤘다. 강의의 형식을 빌려 진행했다. 전자는 실무자를, 후자는 학생들을 대상으로 했다. 횟수가 많은 까닭은 여러번 반복했기 때문이다. 그 과정에서 <a href=\"https://github.com/joeunha/functional-js-study2\" target=\"_blank\" rel=\"noopener\">콘텐츠</a>를 계속 발전 시킬 수 있었다. 좋은 네트워킹의 기회도 되었다.</p>\n<p>클래스는 드로잉, 사진이 주제였다. 드로잉 클래스는 그림을 배우고 싶어서 직접 강사를 섭외했다. 여행 중에 그림을 그려보고 싶었다. 강사분과 함께 콘텐츠를 기획하고 건물, 풍경, 음식을 그릴 수 있는 커리큘럼을 짰다. 수업을 듣는 동안에는 제법 그림 그리기에 심취했었다. 인스타도 그림으로 도배됐었다. 새로운 취미가 생기는가 했는데 지금까지 꾸준하지 않은 걸 보니 취미라고 부르긴 글렀나보다.</p>\n<h2 id=\"7\"><a href=\"#7\" class=\"headerlink\" title=\"7\"></a>7</h2><h4 id=\"일곱번의-강의\"><a href=\"#일곱번의-강의\" class=\"headerlink\" title=\"일곱번의 강의\"></a>일곱번의 강의</h4><p><strong>‘배워서 남주자’</strong>는 생각을 늘 가지고 있다. 강의는 그 생각의 발현이다. 강의 활동을 칭찬해주는 분들에게 종종 하는 말이 있는데, 내가 잘나서 강의하는 게 아니라는 것이다. 다만 경험을 통해 조금 먼저 알게 된 정보나 사실을 다른 사람들에게 나누는 것일 뿐이라고. 강의를 통해 오히려 많이 배운다고 말한다. 뜬금없이 이 말을 꺼낸 이유는 많은 분이 강의에 도전했으면 하는 마음 때문이다. <strong>스스로 보기에 사소한 지식도 누군가에겐 정말 귀한 지식이 되곤 한다.</strong></p>\n<p>첫 강의는 4월에 있었다. 모교인 한동대학교에서 오픈소스의 중요성을 가르치고 있고 실무자의 경험을 듣길 원한다는 연락을 받고 강의를 하게 됐다. 처음엔 무슨 이야기를 해야 하나 막막했다. 몇 주째 아무런 준비를 못 하고 있었다. 그러다 실제 서비스 개발에 무심코 사용하던 소스 코드 목록(<code>package.json</code>)을 확인하게 됐다. 목록엔 오픈소스가 가득했고 이 소스들이 서비스에 얼마나 큰 영향을 미치는지 이야기 하는 것으로 갈래를 잡았다. 제목은 <strong>&lt;일상에 스며든 오픈소스&gt;</strong>였다.</p>\n<p>이후 <a href=\"http://campus.leadme.today/\" target=\"_blank\" rel=\"noopener\">리드미</a>를 통해 지난 경험을 토대로 <a href=\"/view-of-value/like-me-2/\">문과 출신 개발자의 이야기</a>를 몇 차례 전했다. 정보통신산업진흥원(nipa)에서 진행하는 <strong>소프트웨어 일일 교사</strong>에도 <a href=\"https://youtu.be/SLU-IZJxxgw\" target=\"_blank\" rel=\"noopener\">참여</a>했다. 한동대학교에서 &lt;떠먹여주는 웹 프로그래밍&gt;이라는 제목으로 웹 프로그래밍 기초를 다루기도 했다. 이 콘텐츠들은 실무자들이 보기엔 민망할 정도로 사소한 지식이다. 하지만 조금만 다듬어서 쉽게 풀어내면 누군가에겐 정말 귀한 정보가 된다는 생각으로 지금까지 강의를 이어오고 있다.</p>\n<h2 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4\"></a>4</h2><h4 id=\"네번의-결혼식-소개팅-집들이\"><a href=\"#네번의-결혼식-소개팅-집들이\" class=\"headerlink\" title=\"네번의 결혼식, 소개팅, 집들이\"></a>네번의 결혼식, 소개팅, 집들이</h4><p>네번이라는 공통된 숫자가 나와 재밌어서 기록했다. 극히 개인적인 경험이라 자세한 스토리를 기술하진 않겠지만 이 숫자의 변화가 <strong>생애 주기의 변화를 의미한다고 생각하니 흥미롭다.</strong></p>\n<h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h2><h4 id=\"첫번째-이직\"><a href=\"#첫번째-이직\" class=\"headerlink\" title=\"첫번째 이직\"></a>첫번째 이직</h4><p>지난 <a href=\"/view-of-value/1-year-anniversary/\">회고</a>를 통해 밝힌 것처럼 마플은 정말 훌륭한 경험을 안겨준 회사였다. 개발자로서 그리고 인격체로서 어떻게 성장해야 할지 방향성을 알려주었다. 개발팀은 끊임없이 도전했고 성장했다. 함께 성장하며 즐거웠다. <strong>다만 새로운 환경이 필요했다.</strong> 극단적으로 해외로의 이직을 생각한 걸 보면 그 갈망이 얼마나 컸는지 알 수 있다. 하지만 일상의 관성도 만만치 않았다.</p>\n<p>관성을 극복할 수 있었던 건 주변의 조언 덕분이다. 새로운 환경으로 도전할 수 있도록 꾸준히 자극을 줬다. 몇번의 크고 작은 자극을 받고 링크드인(LinkedIn)을 시작했다. 10월엔 헤드헌터를 만났고 채용 시장에 뛰어들었다. 일곱 회사의 문을 두드렸다. 서류 전형을 통과한 뒤론 자투리 시간을 활용해 면접 볼 회사의 도메인 지식을 습득했다. 주말엔 코딩 테스트를 봤다. 면접을 거듭할수록 계속 성장함을 느꼈다. 면접에도 기술이 있었다.</p>\n<p>면접을 거듭 진행하는 중에 세 차례 강의도 있었다. 너무 무리한 탓에 입과 귀에 염증이 생겼다. 제대로 먹지도 못하고 이어폰으로 노래를 들을 수도 없었다. 덕분에 고생 끝에 낙이 온다는 사실을 몸소 체험할 수 있었다. 감사하게도 네곳에 합격했다.</p>\n<p>최종적으로 <a href=\"https://rainist.com/\" target=\"_blank\" rel=\"noopener\">레이니스트</a>를 선택했다. 핀테크에 대한 관심, 좋은 사내 문화도 분명 중요한 이유였다. 하지만 무엇보다 고객에게 감동을 주는 서비스를 운영한다는 게 결정적이었다.</p>\n<p>레이니스트가 서비스하는 <a href=\"https://banksalad.com/\" target=\"_blank\" rel=\"noopener\">뱅크샐러드</a>는 가족이 감동한 서비스였다. 사내에서 있었던 자기소개 시간에 밝힌 친동생이 뱅크샐러드를 사용하며 느낀 감동. 그 감동을 대한민국으로 확장하고 싶었다. <strong>정보의 비대칭성을 해결해 더 나은 의사결정을 돕는다</strong>는 이들의 미션을 <strong>함께</strong> 이뤄보고 싶었다. 늘 꿈꿔오던 헤븐(Heaven) 조선을 함께 만들어가고 싶어 레이니스트로 이직했다.</p>\n<h2 id=\"30\"><a href=\"#30\" class=\"headerlink\" title=\"30\"></a>30</h2><h4 id=\"서른을-앞둔-나이\"><a href=\"#서른을-앞둔-나이\" class=\"headerlink\" title=\"서른을 앞둔 나이\"></a>서른을 앞둔 나이</h4><p>2018년은 이십대로서 마지막 해였다. 비록 <strong>진정한 가치는 숫자로 측정되지 않는다</strong>고 하지만 서른이라는 숫자 앞에서 막연하게 불안한 감정을 느끼는 게 사실이다. 갓 대학생이 됐을 땐 서른이 되면 정말 많은 것을 이뤘을 것이라 기대했다. 엄청 어른이 되어 있을 것 같았다. 사실 지금의 나는 새내기 시절 나와 크게 다르지 않다. 가끔 나이를 착각할 정도다. 다만 그때는 몰랐던 사실을 깨달았다. 너무 반복돼서 익숙하게 지나치는 오늘이 정말 중요한 <strong>꿈꾸던 그 날</strong>이라는 사실. 아직 오지 않은 <strong>미래가 아니라 오늘이 중요하다</strong>는 사실. 그리고 이 마음으로 살아가면 행복할 거라는 사실.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"18\"><a href=\"#18\" class=\"headerlink\" title=\"18\"></a>18</h2><h4 id=\"열여덟권의-책\"><a href=\"#열여덟권의-책\" class=\"headerlink\" title=\"열여덟권의 책\"></a>열여덟권의 책</h4><p>새해를 야심 차게 시작했음이 틀림없다. 1월 2일에 <strong>2018년 도서 목록</strong>이라는 노트를 만들어 둔 걸 보면. 처음엔 열다섯권 정도였다. 중간에 읽고 싶은 책을 추가해서 지금은 마흔두권이 됐다. 그중 열여덟권을 읽었다. 읽은 시기도 기록해뒀는데 연초와 연말에 대부분의 책이 몰려있다.</p>\n<p>여덟권은 경영, 비즈니스, 스타트업에 관한 책이다. 이 중에 한권을 고르라면 <strong>&lt;아마존, 세상의 모든 것을 팝니다&gt;</strong>를 고르겠다. 여러 가지로 많은 영감을 얻었다. 그 외에 인문, 프로그래밍 관련 서적을 읽었다. 관심 없는 분야의 책도 꾸준히 읽을 수 있었던 건 독서 모임 덕분이다. 이름을 정하지 못해서 지금까지 <strong>이름 없는 독서 모임</strong>으로 불리는 이 모임을 통해 <strong>&lt;생각의 탄생&gt;</strong>, <strong>&lt;혼자가 편한 사람들의 사랑법&gt;</strong>이라는 굵직하고 깊이 있는 책을 읽을 수 있었다. 혼자였다면 도무지 이해하지 못했을 책을 함께라서 즐겁게 읽을 수 있었다.</p>\n<h2 id=\"9\"><a href=\"#9\" class=\"headerlink\" title=\"9\"></a>9</h2><h4 id=\"아홉번의-스터디와-클래스\"><a href=\"#아홉번의-스터디와-클래스\" class=\"headerlink\" title=\"아홉번의 스터디와 클래스\"></a>아홉번의 스터디와 클래스</h4><p>주로 프로그래밍 관련 스터디가 주를 이뤘다. <strong>함수형 프로그래밍, Github</strong> 등의 주제를 다뤘다. 강의의 형식을 빌려 진행했다. 전자는 실무자를, 후자는 학생들을 대상으로 했다. 횟수가 많은 까닭은 여러번 반복했기 때문이다. 그 과정에서 <a href=\"https://github.com/joeunha/functional-js-study2\" target=\"_blank\" rel=\"noopener\">콘텐츠</a>를 계속 발전 시킬 수 있었다. 좋은 네트워킹의 기회도 되었다.</p>\n<p>클래스는 드로잉, 사진이 주제였다. 드로잉 클래스는 그림을 배우고 싶어서 직접 강사를 섭외했다. 여행 중에 그림을 그려보고 싶었다. 강사분과 함께 콘텐츠를 기획하고 건물, 풍경, 음식을 그릴 수 있는 커리큘럼을 짰다. 수업을 듣는 동안에는 제법 그림 그리기에 심취했었다. 인스타도 그림으로 도배됐었다. 새로운 취미가 생기는가 했는데 지금까지 꾸준하지 않은 걸 보니 취미라고 부르긴 글렀나보다.</p>\n<h2 id=\"7\"><a href=\"#7\" class=\"headerlink\" title=\"7\"></a>7</h2><h4 id=\"일곱번의-강의\"><a href=\"#일곱번의-강의\" class=\"headerlink\" title=\"일곱번의 강의\"></a>일곱번의 강의</h4><p><strong>‘배워서 남주자’</strong>는 생각을 늘 가지고 있다. 강의는 그 생각의 발현이다. 강의 활동을 칭찬해주는 분들에게 종종 하는 말이 있는데, 내가 잘나서 강의하는 게 아니라는 것이다. 다만 경험을 통해 조금 먼저 알게 된 정보나 사실을 다른 사람들에게 나누는 것일 뿐이라고. 강의를 통해 오히려 많이 배운다고 말한다. 뜬금없이 이 말을 꺼낸 이유는 많은 분이 강의에 도전했으면 하는 마음 때문이다. <strong>스스로 보기에 사소한 지식도 누군가에겐 정말 귀한 지식이 되곤 한다.</strong></p>\n<p>첫 강의는 4월에 있었다. 모교인 한동대학교에서 오픈소스의 중요성을 가르치고 있고 실무자의 경험을 듣길 원한다는 연락을 받고 강의를 하게 됐다. 처음엔 무슨 이야기를 해야 하나 막막했다. 몇 주째 아무런 준비를 못 하고 있었다. 그러다 실제 서비스 개발에 무심코 사용하던 소스 코드 목록(<code>package.json</code>)을 확인하게 됐다. 목록엔 오픈소스가 가득했고 이 소스들이 서비스에 얼마나 큰 영향을 미치는지 이야기 하는 것으로 갈래를 잡았다. 제목은 <strong>&lt;일상에 스며든 오픈소스&gt;</strong>였다.</p>\n<p>이후 <a href=\"http://campus.leadme.today/\" target=\"_blank\" rel=\"noopener\">리드미</a>를 통해 지난 경험을 토대로 <a href=\"/view-of-value/like-me-2/\">문과 출신 개발자의 이야기</a>를 몇 차례 전했다. 정보통신산업진흥원(nipa)에서 진행하는 <strong>소프트웨어 일일 교사</strong>에도 <a href=\"https://youtu.be/SLU-IZJxxgw\" target=\"_blank\" rel=\"noopener\">참여</a>했다. 한동대학교에서 &lt;떠먹여주는 웹 프로그래밍&gt;이라는 제목으로 웹 프로그래밍 기초를 다루기도 했다. 이 콘텐츠들은 실무자들이 보기엔 민망할 정도로 사소한 지식이다. 하지만 조금만 다듬어서 쉽게 풀어내면 누군가에겐 정말 귀한 정보가 된다는 생각으로 지금까지 강의를 이어오고 있다.</p>\n<h2 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4\"></a>4</h2><h4 id=\"네번의-결혼식-소개팅-집들이\"><a href=\"#네번의-결혼식-소개팅-집들이\" class=\"headerlink\" title=\"네번의 결혼식, 소개팅, 집들이\"></a>네번의 결혼식, 소개팅, 집들이</h4><p>네번이라는 공통된 숫자가 나와 재밌어서 기록했다. 극히 개인적인 경험이라 자세한 스토리를 기술하진 않겠지만 이 숫자의 변화가 <strong>생애 주기의 변화를 의미한다고 생각하니 흥미롭다.</strong></p>\n<h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h2><h4 id=\"첫번째-이직\"><a href=\"#첫번째-이직\" class=\"headerlink\" title=\"첫번째 이직\"></a>첫번째 이직</h4><p>지난 <a href=\"/view-of-value/1-year-anniversary/\">회고</a>를 통해 밝힌 것처럼 마플은 정말 훌륭한 경험을 안겨준 회사였다. 개발자로서 그리고 인격체로서 어떻게 성장해야 할지 방향성을 알려주었다. 개발팀은 끊임없이 도전했고 성장했다. 함께 성장하며 즐거웠다. <strong>다만 새로운 환경이 필요했다.</strong> 극단적으로 해외로의 이직을 생각한 걸 보면 그 갈망이 얼마나 컸는지 알 수 있다. 하지만 일상의 관성도 만만치 않았다.</p>\n<p>관성을 극복할 수 있었던 건 주변의 조언 덕분이다. 새로운 환경으로 도전할 수 있도록 꾸준히 자극을 줬다. 몇번의 크고 작은 자극을 받고 링크드인(LinkedIn)을 시작했다. 10월엔 헤드헌터를 만났고 채용 시장에 뛰어들었다. 일곱 회사의 문을 두드렸다. 서류 전형을 통과한 뒤론 자투리 시간을 활용해 면접 볼 회사의 도메인 지식을 습득했다. 주말엔 코딩 테스트를 봤다. 면접을 거듭할수록 계속 성장함을 느꼈다. 면접에도 기술이 있었다.</p>\n<p>면접을 거듭 진행하는 중에 세 차례 강의도 있었다. 너무 무리한 탓에 입과 귀에 염증이 생겼다. 제대로 먹지도 못하고 이어폰으로 노래를 들을 수도 없었다. 덕분에 고생 끝에 낙이 온다는 사실을 몸소 체험할 수 있었다. 감사하게도 네곳에 합격했다.</p>\n<p>최종적으로 <a href=\"https://rainist.com/\" target=\"_blank\" rel=\"noopener\">레이니스트</a>를 선택했다. 핀테크에 대한 관심, 좋은 사내 문화도 분명 중요한 이유였다. 하지만 무엇보다 고객에게 감동을 주는 서비스를 운영한다는 게 결정적이었다.</p>\n<p>레이니스트가 서비스하는 <a href=\"https://banksalad.com/\" target=\"_blank\" rel=\"noopener\">뱅크샐러드</a>는 가족이 감동한 서비스였다. 사내에서 있었던 자기소개 시간에 밝힌 친동생이 뱅크샐러드를 사용하며 느낀 감동. 그 감동을 대한민국으로 확장하고 싶었다. <strong>정보의 비대칭성을 해결해 더 나은 의사결정을 돕는다</strong>는 이들의 미션을 <strong>함께</strong> 이뤄보고 싶었다. 늘 꿈꿔오던 헤븐(Heaven) 조선을 함께 만들어가고 싶어 레이니스트로 이직했다.</p>\n<h2 id=\"30\"><a href=\"#30\" class=\"headerlink\" title=\"30\"></a>30</h2><h4 id=\"서른을-앞둔-나이\"><a href=\"#서른을-앞둔-나이\" class=\"headerlink\" title=\"서른을 앞둔 나이\"></a>서른을 앞둔 나이</h4><p>2018년은 이십대로서 마지막 해였다. 비록 <strong>진정한 가치는 숫자로 측정되지 않는다</strong>고 하지만 서른이라는 숫자 앞에서 막연하게 불안한 감정을 느끼는 게 사실이다. 갓 대학생이 됐을 땐 서른이 되면 정말 많은 것을 이뤘을 것이라 기대했다. 엄청 어른이 되어 있을 것 같았다. 사실 지금의 나는 새내기 시절 나와 크게 다르지 않다. 가끔 나이를 착각할 정도다. 다만 그때는 몰랐던 사실을 깨달았다. 너무 반복돼서 익숙하게 지나치는 오늘이 정말 중요한 <strong>꿈꾸던 그 날</strong>이라는 사실. 아직 오지 않은 <strong>미래가 아니라 오늘이 중요하다</strong>는 사실. 그리고 이 마음으로 살아가면 행복할 거라는 사실.</p>\n"},{"title":"든든한 우리 형, 함수형 - 역할의 차이","date":"2020-01-07T11:00:00.000Z","description":"우리 형은 역할의 차이를 중요하게 생각합니다","_content":"**개발할 때 늘 도움을 주는 우리 형, 함수형을 소개합니다**\n\n## 역할의 차이\n형은 대체로 순수해서 대하기 편하지만, 가끔 까다로운 경우가 있었습니다. 제가 함수의 역할을 잘못 판단하는 경우죠. 개발 할 때 `forEach`와 `map`을 종종 헷갈리곤 했습니다. 배열을 순서대로 돌면서 어떤 행동을 할지 정의하는 함수라 크게 다르지 않다고 생각했거든요. 이런 저의 생각을 우리 형은 늘 못마땅해했습니다. 두 함수의 역할이 분명히 다르다는 겁니다. 이름이 다르니까 분명 뭐가 다르겠지 싶었지만, 뭐가 다른지 이해하기 어려웠습니다. 사용해보면 크게 다르지 않거든요. 형은 어리둥절하는 저를 보곤 이렇게 말했습니다. \"리턴 값을 한번 봐.\"\n\n## 리턴 값의 차이\n```js\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\nconst result1 = arr.forEach(n => n);\nconst result2 = arr.map(n => n);\n\nconsole.log(reuslt1); // undefined\nconsole.log(result2); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n두 함수의 리턴 값은 분명 달랐습니다. `forEach`는 `undefined`를 반환했고 `map`은 배열을 반환했죠. 가만 보니 `map`은 이름대로 결괏값을 매핑하는 함수인 것 같았습니다. 심지어 `forEach`가 하는 일(순회)도 할 수 있었습니다. 이제는 `forEach` 대신 `map`만 쓰면 되겠구나 싶었습니다. 형은 반만 맞았다고 말했습니다. 단순히 순차적으로 조회할 땐 `forEach`를 써야 한다고 했습니다. 역할에 맞는 순간에 사용해야 한다는 것이었죠. 왜 굳이 두 개를 따로 써야 하는지 저는 여전히 의문이었습니다. \n\n## 속도의 차이\n```js\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst limit = 1000000;\n\nconsole.time('forEach');\nlet i = 0;\nwhile (i++ < limit) arr.forEach(n => n);\nconsole.timeEnd('forEach'); // forEach: 36.455078125ms\n\nconsole.time('map');\nlet j = 0;\nwhile (j++ < limit) arr.map(n => n);\nconsole.timeEnd('map'); // map: 69.7138671875ms\n```\n\n극단적인 상황이지만 속도가 두배 가까이 차이가 났습니다. 생각해보니 이유는 분명했습니다. `map`이 하는 일이 더 많았기 때문이죠. 정말 결괏값을 이용하기 위해, 매핑하기 위해 사용하는게 아니라면 `forEach`를 사용하는게 맞다는 확신이 생겼습니다. 성능적으로 손해를 보기 싫다면 말이죠. 미비한 차이지만 이렇게 역할의 차이를 분명히 알고 필요에 맞게 골라 쓰는게 함수형, 우리형의 매력이라는 생각이 드네요.","source":"_posts/my-bro-fp-1.md","raw":"---\ntitle: '든든한 우리 형, 함수형 - 역할의 차이'\ndate: 2020-01-07 20:00:00\ncategories:\n  - paradigm\ntags:\n  - javascript\n  - 함수형 프로그래밍\n  - 든든한 우리 형\n  - forEach\n  - map\ndescription: 우리 형은 역할의 차이를 중요하게 생각합니다\n---\n**개발할 때 늘 도움을 주는 우리 형, 함수형을 소개합니다**\n\n## 역할의 차이\n형은 대체로 순수해서 대하기 편하지만, 가끔 까다로운 경우가 있었습니다. 제가 함수의 역할을 잘못 판단하는 경우죠. 개발 할 때 `forEach`와 `map`을 종종 헷갈리곤 했습니다. 배열을 순서대로 돌면서 어떤 행동을 할지 정의하는 함수라 크게 다르지 않다고 생각했거든요. 이런 저의 생각을 우리 형은 늘 못마땅해했습니다. 두 함수의 역할이 분명히 다르다는 겁니다. 이름이 다르니까 분명 뭐가 다르겠지 싶었지만, 뭐가 다른지 이해하기 어려웠습니다. 사용해보면 크게 다르지 않거든요. 형은 어리둥절하는 저를 보곤 이렇게 말했습니다. \"리턴 값을 한번 봐.\"\n\n## 리턴 값의 차이\n```js\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\nconst result1 = arr.forEach(n => n);\nconst result2 = arr.map(n => n);\n\nconsole.log(reuslt1); // undefined\nconsole.log(result2); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n\n두 함수의 리턴 값은 분명 달랐습니다. `forEach`는 `undefined`를 반환했고 `map`은 배열을 반환했죠. 가만 보니 `map`은 이름대로 결괏값을 매핑하는 함수인 것 같았습니다. 심지어 `forEach`가 하는 일(순회)도 할 수 있었습니다. 이제는 `forEach` 대신 `map`만 쓰면 되겠구나 싶었습니다. 형은 반만 맞았다고 말했습니다. 단순히 순차적으로 조회할 땐 `forEach`를 써야 한다고 했습니다. 역할에 맞는 순간에 사용해야 한다는 것이었죠. 왜 굳이 두 개를 따로 써야 하는지 저는 여전히 의문이었습니다. \n\n## 속도의 차이\n```js\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst limit = 1000000;\n\nconsole.time('forEach');\nlet i = 0;\nwhile (i++ < limit) arr.forEach(n => n);\nconsole.timeEnd('forEach'); // forEach: 36.455078125ms\n\nconsole.time('map');\nlet j = 0;\nwhile (j++ < limit) arr.map(n => n);\nconsole.timeEnd('map'); // map: 69.7138671875ms\n```\n\n극단적인 상황이지만 속도가 두배 가까이 차이가 났습니다. 생각해보니 이유는 분명했습니다. `map`이 하는 일이 더 많았기 때문이죠. 정말 결괏값을 이용하기 위해, 매핑하기 위해 사용하는게 아니라면 `forEach`를 사용하는게 맞다는 확신이 생겼습니다. 성능적으로 손해를 보기 싫다면 말이죠. 미비한 차이지만 이렇게 역할의 차이를 분명히 알고 필요에 맞게 골라 쓰는게 함수형, 우리형의 매력이라는 생각이 드네요.","slug":"my-bro-fp-1","published":1,"updated":"2020-01-07T12:01:16.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9h1004ldirvsc2pc2sy","content":"<p><strong>개발할 때 늘 도움을 주는 우리 형, 함수형을 소개합니다</strong></p>\n<h2 id=\"역할의-차이\"><a href=\"#역할의-차이\" class=\"headerlink\" title=\"역할의 차이\"></a>역할의 차이</h2><p>형은 대체로 순수해서 대하기 편하지만, 가끔 까다로운 경우가 있었습니다. 제가 함수의 역할을 잘못 판단하는 경우죠. 개발 할 때 <code>forEach</code>와 <code>map</code>을 종종 헷갈리곤 했습니다. 배열을 순서대로 돌면서 어떤 행동을 할지 정의하는 함수라 크게 다르지 않다고 생각했거든요. 이런 저의 생각을 우리 형은 늘 못마땅해했습니다. 두 함수의 역할이 분명히 다르다는 겁니다. 이름이 다르니까 분명 뭐가 다르겠지 싶었지만, 뭐가 다른지 이해하기 어려웠습니다. 사용해보면 크게 다르지 않거든요. 형은 어리둥절하는 저를 보곤 이렇게 말했습니다. “리턴 값을 한번 봐.”</p>\n<h2 id=\"리턴-값의-차이\"><a href=\"#리턴-값의-차이\" class=\"headerlink\" title=\"리턴 값의 차이\"></a>리턴 값의 차이</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> result1 = arr.forEach(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n);</span><br><span class=\"line\"><span class=\"keyword\">const</span> result2 = arr.map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reuslt1); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result2); <span class=\"comment\">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>\n\n<p>두 함수의 리턴 값은 분명 달랐습니다. <code>forEach</code>는 <code>undefined</code>를 반환했고 <code>map</code>은 배열을 반환했죠. 가만 보니 <code>map</code>은 이름대로 결괏값을 매핑하는 함수인 것 같았습니다. 심지어 <code>forEach</code>가 하는 일(순회)도 할 수 있었습니다. 이제는 <code>forEach</code> 대신 <code>map</code>만 쓰면 되겠구나 싶었습니다. 형은 반만 맞았다고 말했습니다. 단순히 순차적으로 조회할 땐 <code>forEach</code>를 써야 한다고 했습니다. 역할에 맞는 순간에 사용해야 한다는 것이었죠. 왜 굳이 두 개를 따로 써야 하는지 저는 여전히 의문이었습니다. </p>\n<h2 id=\"속도의-차이\"><a href=\"#속도의-차이\" class=\"headerlink\" title=\"속도의 차이\"></a>속도의 차이</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> limit = <span class=\"number\">1000000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'forEach'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (i++ <span class=\"xml\"><span class=\"tag\">&lt; <span class=\"attr\">limit</span>) <span class=\"attr\">arr.forEach</span>(<span class=\"attr\">n</span> =&gt;</span> n);</span></span><br><span class=\"line\"><span class=\"xml\">console.timeEnd('forEach'); // forEach: 36.455078125ms</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\">console.time('map');</span></span><br><span class=\"line\"><span class=\"xml\">let j = 0;</span></span><br><span class=\"line\"><span class=\"xml\">while (j++ <span class=\"tag\">&lt; <span class=\"attr\">limit</span>) <span class=\"attr\">arr.map</span>(<span class=\"attr\">n</span> =&gt;</span> n);</span></span><br><span class=\"line\"><span class=\"xml\">console.timeEnd('map'); // map: 69.7138671875ms</span></span><br></pre></td></tr></table></figure>\n\n<p>극단적인 상황이지만 속도가 두배 가까이 차이가 났습니다. 생각해보니 이유는 분명했습니다. <code>map</code>이 하는 일이 더 많았기 때문이죠. 정말 결괏값을 이용하기 위해, 매핑하기 위해 사용하는게 아니라면 <code>forEach</code>를 사용하는게 맞다는 확신이 생겼습니다. 성능적으로 손해를 보기 싫다면 말이죠. 미비한 차이지만 이렇게 역할의 차이를 분명히 알고 필요에 맞게 골라 쓰는게 함수형, 우리형의 매력이라는 생각이 드네요.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>개발할 때 늘 도움을 주는 우리 형, 함수형을 소개합니다</strong></p>\n<h2 id=\"역할의-차이\"><a href=\"#역할의-차이\" class=\"headerlink\" title=\"역할의 차이\"></a>역할의 차이</h2><p>형은 대체로 순수해서 대하기 편하지만, 가끔 까다로운 경우가 있었습니다. 제가 함수의 역할을 잘못 판단하는 경우죠. 개발 할 때 <code>forEach</code>와 <code>map</code>을 종종 헷갈리곤 했습니다. 배열을 순서대로 돌면서 어떤 행동을 할지 정의하는 함수라 크게 다르지 않다고 생각했거든요. 이런 저의 생각을 우리 형은 늘 못마땅해했습니다. 두 함수의 역할이 분명히 다르다는 겁니다. 이름이 다르니까 분명 뭐가 다르겠지 싶었지만, 뭐가 다른지 이해하기 어려웠습니다. 사용해보면 크게 다르지 않거든요. 형은 어리둥절하는 저를 보곤 이렇게 말했습니다. “리턴 값을 한번 봐.”</p>\n<h2 id=\"리턴-값의-차이\"><a href=\"#리턴-값의-차이\" class=\"headerlink\" title=\"리턴 값의 차이\"></a>리턴 값의 차이</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> result1 = arr.forEach(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n);</span><br><span class=\"line\"><span class=\"keyword\">const</span> result2 = arr.map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reuslt1); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result2); <span class=\"comment\">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure>\n\n<p>두 함수의 리턴 값은 분명 달랐습니다. <code>forEach</code>는 <code>undefined</code>를 반환했고 <code>map</code>은 배열을 반환했죠. 가만 보니 <code>map</code>은 이름대로 결괏값을 매핑하는 함수인 것 같았습니다. 심지어 <code>forEach</code>가 하는 일(순회)도 할 수 있었습니다. 이제는 <code>forEach</code> 대신 <code>map</code>만 쓰면 되겠구나 싶었습니다. 형은 반만 맞았다고 말했습니다. 단순히 순차적으로 조회할 땐 <code>forEach</code>를 써야 한다고 했습니다. 역할에 맞는 순간에 사용해야 한다는 것이었죠. 왜 굳이 두 개를 따로 써야 하는지 저는 여전히 의문이었습니다. </p>\n<h2 id=\"속도의-차이\"><a href=\"#속도의-차이\" class=\"headerlink\" title=\"속도의 차이\"></a>속도의 차이</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> limit = <span class=\"number\">1000000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'forEach'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (i++ <span class=\"xml\"><span class=\"tag\">&lt; <span class=\"attr\">limit</span>) <span class=\"attr\">arr.forEach</span>(<span class=\"attr\">n</span> =&gt;</span> n);</span></span><br><span class=\"line\"><span class=\"xml\">console.timeEnd('forEach'); // forEach: 36.455078125ms</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\">console.time('map');</span></span><br><span class=\"line\"><span class=\"xml\">let j = 0;</span></span><br><span class=\"line\"><span class=\"xml\">while (j++ <span class=\"tag\">&lt; <span class=\"attr\">limit</span>) <span class=\"attr\">arr.map</span>(<span class=\"attr\">n</span> =&gt;</span> n);</span></span><br><span class=\"line\"><span class=\"xml\">console.timeEnd('map'); // map: 69.7138671875ms</span></span><br></pre></td></tr></table></figure>\n\n<p>극단적인 상황이지만 속도가 두배 가까이 차이가 났습니다. 생각해보니 이유는 분명했습니다. <code>map</code>이 하는 일이 더 많았기 때문이죠. 정말 결괏값을 이용하기 위해, 매핑하기 위해 사용하는게 아니라면 <code>forEach</code>를 사용하는게 맞다는 확신이 생겼습니다. 성능적으로 손해를 보기 싫다면 말이죠. 미비한 차이지만 이렇게 역할의 차이를 분명히 알고 필요에 맞게 골라 쓰는게 함수형, 우리형의 매력이라는 생각이 드네요.</p>\n"},{"title":"Go로 sum을 만드는 네가지 방법","date":"2020-02-12T13:00:00.000Z","description":"for, range and variadic function","image":"thumbs/go-thumb.jpeg","_content":"\n## 하나씩 더하기\n\n우선 인자를 하나씩 전달 받아서 직접 더해줄 수 있습니다.\n\n```go\nfunc sum(a int, b int, c int) int {\n  return a + b + c\n}\n\nfmt.Println(sum(1, 2, 3)) // 6\n```\n\n## 배열과 반복문 활용하기\n\n하나씩 더해주는게 번거로우니 `for`를 사용할 수 있도록 배열을 사용할 수 있습니다. 배열의 길이를 확인하기 위해 `len` 함수도 사용해야 합니다. 배열은 Array라고 부르는 고정 배열과 Slice라고 부르는 동적 배열이 있습니다. 여기서는 고정 배열을 사용합니다.\n\n```go\nfunc sum(numbers [3]int) (total int) {\n  number := 0\n  for i := 0; i < len(numbers); i++ {\n    number = numbers[i]\n    total += number\n  }\n  return total\n}\n\nfmt.Println([3]int{1, 2, 3}) // 6\n```\n\n## 가변 인자 함수(variadic function) 활용하기\n\n아무래도 더 많은 수를 더하려면 배열보다 좋은 방법이 필요합니다. [가변 인자 함수](https://gobyexample.com/variadic-functions)를 활용할 수 있습니다. 자바스크립트에서 [Rest Parameter](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/rest_parameters)와 같은 역할을 합니다.\n\n```go\nfunc sum(numbers ...int) (total int) {\n  number := 0\n  for i := 0; i < len(numbers); i++ {\n    number = numbers[i]\n    total += number\n  }\n  return total\n}\n\nfmt.Println(1, 2, 3, 4, 5) // 15\n```\n\n## range 활용하기\n\n[`range`](https://gobyexample.com/range)는 Array, Slice, Map과 같은 돌림직한 타입(iterable type)은 물론 문자열도(유니코드로 변환) 순회할 수 있게 해줍니다. 자바스크립트에서 [`for ...of`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for...of)와 유사한 역할을 합니다.\n\n```go\nfunc sum(numbers ...int) (total int) {\n  for i := range numbers {\n    total += numbers[i]\n  }\n  return total\n}\n\nfmt.Println(1, 2, 3, 4, 5) // 15\n```\n\nindex와 value를 동시에 반환해주기 때문에 아래와 같이 쓸 수도 있습니다. (재미있는건 [사용하지 않을 값을 반드시 언더스코어로 정의해주어야 한다](https://golang.org/doc/effective_go.html?h=underscore#blank)는 점인데, 이건 다른 구문에서도 마찬가지입니다. 보통 다른 언어에서 컨벤션으로 여겨지는게 언어에서 강제한다는 점이 신선합니다.)\n\n```go\nfunc sum(numbers ...int) (total int) {\n  for _, number := range numbers {\n    total += numbers[i]\n  }\n  return total\n}\n\nfmt.Println(1, 2, 3, 4, 5) // 15\n```\n","source":"_posts/write-it-go-1.md","raw":"---\ntitle: Go로 sum을 만드는 네가지 방법\ncategories:\n  - joeun.dev\ntags:\n  - Go\n  - Golang\n  - for\n  - range\n  - array\n  - variadic function\ndate: 2020-02-12 22:00:00\ndescription: for, range and variadic function\nimage: thumbs/go-thumb.jpeg\n---\n\n## 하나씩 더하기\n\n우선 인자를 하나씩 전달 받아서 직접 더해줄 수 있습니다.\n\n```go\nfunc sum(a int, b int, c int) int {\n  return a + b + c\n}\n\nfmt.Println(sum(1, 2, 3)) // 6\n```\n\n## 배열과 반복문 활용하기\n\n하나씩 더해주는게 번거로우니 `for`를 사용할 수 있도록 배열을 사용할 수 있습니다. 배열의 길이를 확인하기 위해 `len` 함수도 사용해야 합니다. 배열은 Array라고 부르는 고정 배열과 Slice라고 부르는 동적 배열이 있습니다. 여기서는 고정 배열을 사용합니다.\n\n```go\nfunc sum(numbers [3]int) (total int) {\n  number := 0\n  for i := 0; i < len(numbers); i++ {\n    number = numbers[i]\n    total += number\n  }\n  return total\n}\n\nfmt.Println([3]int{1, 2, 3}) // 6\n```\n\n## 가변 인자 함수(variadic function) 활용하기\n\n아무래도 더 많은 수를 더하려면 배열보다 좋은 방법이 필요합니다. [가변 인자 함수](https://gobyexample.com/variadic-functions)를 활용할 수 있습니다. 자바스크립트에서 [Rest Parameter](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/rest_parameters)와 같은 역할을 합니다.\n\n```go\nfunc sum(numbers ...int) (total int) {\n  number := 0\n  for i := 0; i < len(numbers); i++ {\n    number = numbers[i]\n    total += number\n  }\n  return total\n}\n\nfmt.Println(1, 2, 3, 4, 5) // 15\n```\n\n## range 활용하기\n\n[`range`](https://gobyexample.com/range)는 Array, Slice, Map과 같은 돌림직한 타입(iterable type)은 물론 문자열도(유니코드로 변환) 순회할 수 있게 해줍니다. 자바스크립트에서 [`for ...of`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for...of)와 유사한 역할을 합니다.\n\n```go\nfunc sum(numbers ...int) (total int) {\n  for i := range numbers {\n    total += numbers[i]\n  }\n  return total\n}\n\nfmt.Println(1, 2, 3, 4, 5) // 15\n```\n\nindex와 value를 동시에 반환해주기 때문에 아래와 같이 쓸 수도 있습니다. (재미있는건 [사용하지 않을 값을 반드시 언더스코어로 정의해주어야 한다](https://golang.org/doc/effective_go.html?h=underscore#blank)는 점인데, 이건 다른 구문에서도 마찬가지입니다. 보통 다른 언어에서 컨벤션으로 여겨지는게 언어에서 강제한다는 점이 신선합니다.)\n\n```go\nfunc sum(numbers ...int) (total int) {\n  for _, number := range numbers {\n    total += numbers[i]\n  }\n  return total\n}\n\nfmt.Println(1, 2, 3, 4, 5) // 15\n```\n","slug":"write-it-go-1","published":1,"updated":"2020-02-12T14:00:12.340Z","_id":"ck6jcr9h2004odirvhqjph65q","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"하나씩-더하기\"><a href=\"#하나씩-더하기\" class=\"headerlink\" title=\"하나씩 더하기\"></a>하나씩 더하기</h2><p>우선 인자를 하나씩 전달 받아서 직접 더해줄 수 있습니다.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(a <span class=\"keyword\">int</span>, b <span class=\"keyword\">int</span>, c <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b + c</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)) <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"배열과-반복문-활용하기\"><a href=\"#배열과-반복문-활용하기\" class=\"headerlink\" title=\"배열과 반복문 활용하기\"></a>배열과 반복문 활용하기</h2><p>하나씩 더해주는게 번거로우니 <code>for</code>를 사용할 수 있도록 배열을 사용할 수 있습니다. 배열의 길이를 확인하기 위해 <code>len</code> 함수도 사용해야 합니다. 배열은 Array라고 부르는 고정 배열과 Slice라고 부르는 동적 배열이 있습니다. 여기서는 고정 배열을 사용합니다.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(numbers [3]<span class=\"keyword\">int</span>)</span> <span class=\"params\">(total <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  number := <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(numbers); i++ &#123;</span><br><span class=\"line\">    number = numbers[i]</span><br><span class=\"line\">    total += number</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println([<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;) <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"가변-인자-함수-variadic-function-활용하기\"><a href=\"#가변-인자-함수-variadic-function-활용하기\" class=\"headerlink\" title=\"가변 인자 함수(variadic function) 활용하기\"></a>가변 인자 함수(variadic function) 활용하기</h2><p>아무래도 더 많은 수를 더하려면 배열보다 좋은 방법이 필요합니다. <a href=\"https://gobyexample.com/variadic-functions\" target=\"_blank\" rel=\"noopener\">가변 인자 함수</a>를 활용할 수 있습니다. 자바스크립트에서 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/rest_parameters\" target=\"_blank\" rel=\"noopener\">Rest Parameter</a>와 같은 역할을 합니다.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(numbers ...<span class=\"keyword\">int</span>)</span> <span class=\"params\">(total <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  number := <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(numbers); i++ &#123;</span><br><span class=\"line\">    number = numbers[i]</span><br><span class=\"line\">    total += number</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>) <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"range-활용하기\"><a href=\"#range-활용하기\" class=\"headerlink\" title=\"range 활용하기\"></a>range 활용하기</h2><p><a href=\"https://gobyexample.com/range\" target=\"_blank\" rel=\"noopener\"><code>range</code></a>는 Array, Slice, Map과 같은 돌림직한 타입(iterable type)은 물론 문자열도(유니코드로 변환) 순회할 수 있게 해줍니다. 자바스크립트에서 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for...of\" target=\"_blank\" rel=\"noopener\"><code>for ...of</code></a>와 유사한 역할을 합니다.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(numbers ...<span class=\"keyword\">int</span>)</span> <span class=\"params\">(total <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> numbers &#123;</span><br><span class=\"line\">    total += numbers[i]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>) <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n\n<p>index와 value를 동시에 반환해주기 때문에 아래와 같이 쓸 수도 있습니다. (재미있는건 <a href=\"https://golang.org/doc/effective_go.html?h=underscore#blank\" target=\"_blank\" rel=\"noopener\">사용하지 않을 값을 반드시 언더스코어로 정의해주어야 한다</a>는 점인데, 이건 다른 구문에서도 마찬가지입니다. 보통 다른 언어에서 컨벤션으로 여겨지는게 언어에서 강제한다는 점이 신선합니다.)</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(numbers ...<span class=\"keyword\">int</span>)</span> <span class=\"params\">(total <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> _, number := <span class=\"keyword\">range</span> numbers &#123;</span><br><span class=\"line\">    total += numbers[i]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>) <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"하나씩-더하기\"><a href=\"#하나씩-더하기\" class=\"headerlink\" title=\"하나씩 더하기\"></a>하나씩 더하기</h2><p>우선 인자를 하나씩 전달 받아서 직접 더해줄 수 있습니다.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(a <span class=\"keyword\">int</span>, b <span class=\"keyword\">int</span>, c <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b + c</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(sum(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)) <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"배열과-반복문-활용하기\"><a href=\"#배열과-반복문-활용하기\" class=\"headerlink\" title=\"배열과 반복문 활용하기\"></a>배열과 반복문 활용하기</h2><p>하나씩 더해주는게 번거로우니 <code>for</code>를 사용할 수 있도록 배열을 사용할 수 있습니다. 배열의 길이를 확인하기 위해 <code>len</code> 함수도 사용해야 합니다. 배열은 Array라고 부르는 고정 배열과 Slice라고 부르는 동적 배열이 있습니다. 여기서는 고정 배열을 사용합니다.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(numbers [3]<span class=\"keyword\">int</span>)</span> <span class=\"params\">(total <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  number := <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(numbers); i++ &#123;</span><br><span class=\"line\">    number = numbers[i]</span><br><span class=\"line\">    total += number</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println([<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;) <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"가변-인자-함수-variadic-function-활용하기\"><a href=\"#가변-인자-함수-variadic-function-활용하기\" class=\"headerlink\" title=\"가변 인자 함수(variadic function) 활용하기\"></a>가변 인자 함수(variadic function) 활용하기</h2><p>아무래도 더 많은 수를 더하려면 배열보다 좋은 방법이 필요합니다. <a href=\"https://gobyexample.com/variadic-functions\" target=\"_blank\" rel=\"noopener\">가변 인자 함수</a>를 활용할 수 있습니다. 자바스크립트에서 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/rest_parameters\" target=\"_blank\" rel=\"noopener\">Rest Parameter</a>와 같은 역할을 합니다.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(numbers ...<span class=\"keyword\">int</span>)</span> <span class=\"params\">(total <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  number := <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(numbers); i++ &#123;</span><br><span class=\"line\">    number = numbers[i]</span><br><span class=\"line\">    total += number</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>) <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"range-활용하기\"><a href=\"#range-활용하기\" class=\"headerlink\" title=\"range 활용하기\"></a>range 활용하기</h2><p><a href=\"https://gobyexample.com/range\" target=\"_blank\" rel=\"noopener\"><code>range</code></a>는 Array, Slice, Map과 같은 돌림직한 타입(iterable type)은 물론 문자열도(유니코드로 변환) 순회할 수 있게 해줍니다. 자바스크립트에서 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for...of\" target=\"_blank\" rel=\"noopener\"><code>for ...of</code></a>와 유사한 역할을 합니다.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(numbers ...<span class=\"keyword\">int</span>)</span> <span class=\"params\">(total <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> numbers &#123;</span><br><span class=\"line\">    total += numbers[i]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>) <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n\n<p>index와 value를 동시에 반환해주기 때문에 아래와 같이 쓸 수도 있습니다. (재미있는건 <a href=\"https://golang.org/doc/effective_go.html?h=underscore#blank\" target=\"_blank\" rel=\"noopener\">사용하지 않을 값을 반드시 언더스코어로 정의해주어야 한다</a>는 점인데, 이건 다른 구문에서도 마찬가지입니다. 보통 다른 언어에서 컨벤션으로 여겨지는게 언어에서 강제한다는 점이 신선합니다.)</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(numbers ...<span class=\"keyword\">int</span>)</span> <span class=\"params\">(total <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> _, number := <span class=\"keyword\">range</span> numbers &#123;</span><br><span class=\"line\">    total += numbers[i]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>) <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"Go를 배우는 이유","date":"2020-02-11T13:00:00.000Z","description":"마스코트가 너무 귀여운 탓","image":"thumbs/go-thumb.jpeg","_content":"\n## Write in Go\n\n엘사가 부른 'Let it go'라는 노래를 모르는 분은 없을 것 같습니다. 그렇다면 'Write in Go'는 어떤가요? 지금까지 모르셨다면 오늘 꼭 들어보셨으면 좋겠습니다. 이 곡은 ScaleAbility라는 아카펠라 그룹이 2014년에 발표한 곡입니다. 갑자기 웬 가수 이야기냐고요? ScaleAbility가 어떤 그룹인지 들여다보면 그 이유가 나옵니다.\n\n**\"ScaleAbility is Google NYC's a capella group.\"** 그렇습니다. ScaleAbility는 구글 개발자로 구성된 아카펠라 그룹입니다. Write in Go는 Let it go와 멜로디가 완전히 같습니다. 내용은 완전 다르죠. Go(Golang)로 코드를 작성하라고 권하는 노래입니다. Go를 사용하면 귀찮은 일이 없다고 말하죠. (\"The code never bother me anyway.\") 이 곡 덕분에 Go를 배우고 싶은 마음이 커졌습니다. [유튜브](https://www.youtube.com/watch?v=LJvEIjRBSDA)에서 들어보세요.\n\n그렇다면 ScaleAbility는 어떤 이유로 Go를 써야 한다고 말했을까요?\n\n## 쉽고 단순해서\n\nGo는 복잡함이 싫어 태어난 언어입니다. [언어 설계자들이 직접 밝혔죠.](https://web.archive.org/web/20140313072938/http://www.drdobbs.com/open-source/interview-with-ken-thompson/229502480) 때문에 키워드도 적습니다. 반복문에 for만 존재할 정도죠. (do, while이 없습니다!) [코드 서식(format)을 자동으로 맞춰줘서](https://golang.org/doc/effective_go.html#formatting) Go를 사용하는 누구나 같은 규칙에 따라 코드를 작성할 수 있습니다. 덕분에 코드 리뷰 시에 오직 논리에만 집중할 수 있죠. 가비지 컬렉션도 가능해 메모리를 직접 관리할 필요도 없습니다. 이처럼 Go는 어렵고 불필요한 건 일절 담지 않아 쉽고 단순합니다.\n\n## 빠르고 강력해서\n\n쉽고 단순하다고 해서 얕봐선 안 됩니다. Go는 엄청난 속도를 자랑합니다. 쉽고 단순하기로 유명한 [Python과 비교하면 30~50배가 빠릅니다.](https://www.edureka.co/blog/golang-vs-python/#perf) Python은 실행 단계에 해석기(Interpreter)가 필요한 한편 Go는 기계어로 미리 컴파일되기 때문에 엄청난 속도를 내는 것이죠. 그리고 Java나 C++처럼 [대형 시스템에서 운용할 수 있게 설계되었습니다.](https://youtu.be/7VcArS4Wpqk?t=575)\n\n## 진짜 이유\n\n솔직하게 말하자면 제 진짜 이유는 여기 있습니다. 쉽고 단순하면서 빠르고 강력하다는 것도 배우기로 마음 먹은 뒤에 알아본 것이죠. 진짜 이유는 회사에서 Go를 사용하기 때문입니다. (마스코트가 너무 귀여운 탓도 있습니다.) 기존의 서비스를 새로 구현하는데 Go가 쓰입니다. 서버쪽이라 아직은 제가 쓰진 않습니다. 다만, 리뷰를 해야할 것 같아 배워두려고 합니다.\n\n오랜만에 새로운 언어를 배우는거라 기대가 됩니다. 이 과정을 글로 남겨볼 생각합니다. 우선은 [공식 문서](https://golang.org/doc/)를 조금 읽어봐야겠습니다. 그리고 [강의](https://academy.nomadcoders.co/p/go-for-beginners)를 하나 들으며 실제 서비스를 만들어볼 계획입니다. [쓸데 없는 짓](https://github.com/golang/go/wiki/WebAssembly)도 조금 해볼 생각입니다. [Github 저장소](https://github.com/joeunha/write-in-go)에 배운 것을 조금씩 올리겠습니다.\n","source":"_posts/write-in-go-0.md","raw":"---\ntitle: Go를 배우는 이유\ncategories:\n  - joeun.dev\ntags:\n  - Go\n  - Golang\ndate: 2020-02-11 22:00:00\ndescription: 마스코트가 너무 귀여운 탓\nimage: thumbs/go-thumb.jpeg\n---\n\n## Write in Go\n\n엘사가 부른 'Let it go'라는 노래를 모르는 분은 없을 것 같습니다. 그렇다면 'Write in Go'는 어떤가요? 지금까지 모르셨다면 오늘 꼭 들어보셨으면 좋겠습니다. 이 곡은 ScaleAbility라는 아카펠라 그룹이 2014년에 발표한 곡입니다. 갑자기 웬 가수 이야기냐고요? ScaleAbility가 어떤 그룹인지 들여다보면 그 이유가 나옵니다.\n\n**\"ScaleAbility is Google NYC's a capella group.\"** 그렇습니다. ScaleAbility는 구글 개발자로 구성된 아카펠라 그룹입니다. Write in Go는 Let it go와 멜로디가 완전히 같습니다. 내용은 완전 다르죠. Go(Golang)로 코드를 작성하라고 권하는 노래입니다. Go를 사용하면 귀찮은 일이 없다고 말하죠. (\"The code never bother me anyway.\") 이 곡 덕분에 Go를 배우고 싶은 마음이 커졌습니다. [유튜브](https://www.youtube.com/watch?v=LJvEIjRBSDA)에서 들어보세요.\n\n그렇다면 ScaleAbility는 어떤 이유로 Go를 써야 한다고 말했을까요?\n\n## 쉽고 단순해서\n\nGo는 복잡함이 싫어 태어난 언어입니다. [언어 설계자들이 직접 밝혔죠.](https://web.archive.org/web/20140313072938/http://www.drdobbs.com/open-source/interview-with-ken-thompson/229502480) 때문에 키워드도 적습니다. 반복문에 for만 존재할 정도죠. (do, while이 없습니다!) [코드 서식(format)을 자동으로 맞춰줘서](https://golang.org/doc/effective_go.html#formatting) Go를 사용하는 누구나 같은 규칙에 따라 코드를 작성할 수 있습니다. 덕분에 코드 리뷰 시에 오직 논리에만 집중할 수 있죠. 가비지 컬렉션도 가능해 메모리를 직접 관리할 필요도 없습니다. 이처럼 Go는 어렵고 불필요한 건 일절 담지 않아 쉽고 단순합니다.\n\n## 빠르고 강력해서\n\n쉽고 단순하다고 해서 얕봐선 안 됩니다. Go는 엄청난 속도를 자랑합니다. 쉽고 단순하기로 유명한 [Python과 비교하면 30~50배가 빠릅니다.](https://www.edureka.co/blog/golang-vs-python/#perf) Python은 실행 단계에 해석기(Interpreter)가 필요한 한편 Go는 기계어로 미리 컴파일되기 때문에 엄청난 속도를 내는 것이죠. 그리고 Java나 C++처럼 [대형 시스템에서 운용할 수 있게 설계되었습니다.](https://youtu.be/7VcArS4Wpqk?t=575)\n\n## 진짜 이유\n\n솔직하게 말하자면 제 진짜 이유는 여기 있습니다. 쉽고 단순하면서 빠르고 강력하다는 것도 배우기로 마음 먹은 뒤에 알아본 것이죠. 진짜 이유는 회사에서 Go를 사용하기 때문입니다. (마스코트가 너무 귀여운 탓도 있습니다.) 기존의 서비스를 새로 구현하는데 Go가 쓰입니다. 서버쪽이라 아직은 제가 쓰진 않습니다. 다만, 리뷰를 해야할 것 같아 배워두려고 합니다.\n\n오랜만에 새로운 언어를 배우는거라 기대가 됩니다. 이 과정을 글로 남겨볼 생각합니다. 우선은 [공식 문서](https://golang.org/doc/)를 조금 읽어봐야겠습니다. 그리고 [강의](https://academy.nomadcoders.co/p/go-for-beginners)를 하나 들으며 실제 서비스를 만들어볼 계획입니다. [쓸데 없는 짓](https://github.com/golang/go/wiki/WebAssembly)도 조금 해볼 생각입니다. [Github 저장소](https://github.com/joeunha/write-in-go)에 배운 것을 조금씩 올리겠습니다.\n","slug":"write-in-go-0","published":1,"updated":"2020-02-12T13:05:05.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9h3004tdirv2oy3b7gv","content":"<h2 id=\"Write-in-Go\"><a href=\"#Write-in-Go\" class=\"headerlink\" title=\"Write in Go\"></a>Write in Go</h2><p>엘사가 부른 ‘Let it go’라는 노래를 모르는 분은 없을 것 같습니다. 그렇다면 ‘Write in Go’는 어떤가요? 지금까지 모르셨다면 오늘 꼭 들어보셨으면 좋겠습니다. 이 곡은 ScaleAbility라는 아카펠라 그룹이 2014년에 발표한 곡입니다. 갑자기 웬 가수 이야기냐고요? ScaleAbility가 어떤 그룹인지 들여다보면 그 이유가 나옵니다.</p>\n<p><strong>“ScaleAbility is Google NYC’s a capella group.”</strong> 그렇습니다. ScaleAbility는 구글 개발자로 구성된 아카펠라 그룹입니다. Write in Go는 Let it go와 멜로디가 완전히 같습니다. 내용은 완전 다르죠. Go(Golang)로 코드를 작성하라고 권하는 노래입니다. Go를 사용하면 귀찮은 일이 없다고 말하죠. (“The code never bother me anyway.”) 이 곡 덕분에 Go를 배우고 싶은 마음이 커졌습니다. <a href=\"https://www.youtube.com/watch?v=LJvEIjRBSDA\" target=\"_blank\" rel=\"noopener\">유튜브</a>에서 들어보세요.</p>\n<p>그렇다면 ScaleAbility는 어떤 이유로 Go를 써야 한다고 말했을까요?</p>\n<h2 id=\"쉽고-단순해서\"><a href=\"#쉽고-단순해서\" class=\"headerlink\" title=\"쉽고 단순해서\"></a>쉽고 단순해서</h2><p>Go는 복잡함이 싫어 태어난 언어입니다. <a href=\"https://web.archive.org/web/20140313072938/http://www.drdobbs.com/open-source/interview-with-ken-thompson/229502480\" target=\"_blank\" rel=\"noopener\">언어 설계자들이 직접 밝혔죠.</a> 때문에 키워드도 적습니다. 반복문에 for만 존재할 정도죠. (do, while이 없습니다!) <a href=\"https://golang.org/doc/effective_go.html#formatting\" target=\"_blank\" rel=\"noopener\">코드 서식(format)을 자동으로 맞춰줘서</a> Go를 사용하는 누구나 같은 규칙에 따라 코드를 작성할 수 있습니다. 덕분에 코드 리뷰 시에 오직 논리에만 집중할 수 있죠. 가비지 컬렉션도 가능해 메모리를 직접 관리할 필요도 없습니다. 이처럼 Go는 어렵고 불필요한 건 일절 담지 않아 쉽고 단순합니다.</p>\n<h2 id=\"빠르고-강력해서\"><a href=\"#빠르고-강력해서\" class=\"headerlink\" title=\"빠르고 강력해서\"></a>빠르고 강력해서</h2><p>쉽고 단순하다고 해서 얕봐선 안 됩니다. Go는 엄청난 속도를 자랑합니다. 쉽고 단순하기로 유명한 <a href=\"https://www.edureka.co/blog/golang-vs-python/#perf\" target=\"_blank\" rel=\"noopener\">Python과 비교하면 30~50배가 빠릅니다.</a> Python은 실행 단계에 해석기(Interpreter)가 필요한 한편 Go는 기계어로 미리 컴파일되기 때문에 엄청난 속도를 내는 것이죠. 그리고 Java나 C++처럼 <a href=\"https://youtu.be/7VcArS4Wpqk?t=575\" target=\"_blank\" rel=\"noopener\">대형 시스템에서 운용할 수 있게 설계되었습니다.</a></p>\n<h2 id=\"진짜-이유\"><a href=\"#진짜-이유\" class=\"headerlink\" title=\"진짜 이유\"></a>진짜 이유</h2><p>솔직하게 말하자면 제 진짜 이유는 여기 있습니다. 쉽고 단순하면서 빠르고 강력하다는 것도 배우기로 마음 먹은 뒤에 알아본 것이죠. 진짜 이유는 회사에서 Go를 사용하기 때문입니다. (마스코트가 너무 귀여운 탓도 있습니다.) 기존의 서비스를 새로 구현하는데 Go가 쓰입니다. 서버쪽이라 아직은 제가 쓰진 않습니다. 다만, 리뷰를 해야할 것 같아 배워두려고 합니다.</p>\n<p>오랜만에 새로운 언어를 배우는거라 기대가 됩니다. 이 과정을 글로 남겨볼 생각합니다. 우선은 <a href=\"https://golang.org/doc/\" target=\"_blank\" rel=\"noopener\">공식 문서</a>를 조금 읽어봐야겠습니다. 그리고 <a href=\"https://academy.nomadcoders.co/p/go-for-beginners\" target=\"_blank\" rel=\"noopener\">강의</a>를 하나 들으며 실제 서비스를 만들어볼 계획입니다. <a href=\"https://github.com/golang/go/wiki/WebAssembly\" target=\"_blank\" rel=\"noopener\">쓸데 없는 짓</a>도 조금 해볼 생각입니다. <a href=\"https://github.com/joeunha/write-in-go\" target=\"_blank\" rel=\"noopener\">Github 저장소</a>에 배운 것을 조금씩 올리겠습니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Write-in-Go\"><a href=\"#Write-in-Go\" class=\"headerlink\" title=\"Write in Go\"></a>Write in Go</h2><p>엘사가 부른 ‘Let it go’라는 노래를 모르는 분은 없을 것 같습니다. 그렇다면 ‘Write in Go’는 어떤가요? 지금까지 모르셨다면 오늘 꼭 들어보셨으면 좋겠습니다. 이 곡은 ScaleAbility라는 아카펠라 그룹이 2014년에 발표한 곡입니다. 갑자기 웬 가수 이야기냐고요? ScaleAbility가 어떤 그룹인지 들여다보면 그 이유가 나옵니다.</p>\n<p><strong>“ScaleAbility is Google NYC’s a capella group.”</strong> 그렇습니다. ScaleAbility는 구글 개발자로 구성된 아카펠라 그룹입니다. Write in Go는 Let it go와 멜로디가 완전히 같습니다. 내용은 완전 다르죠. Go(Golang)로 코드를 작성하라고 권하는 노래입니다. Go를 사용하면 귀찮은 일이 없다고 말하죠. (“The code never bother me anyway.”) 이 곡 덕분에 Go를 배우고 싶은 마음이 커졌습니다. <a href=\"https://www.youtube.com/watch?v=LJvEIjRBSDA\" target=\"_blank\" rel=\"noopener\">유튜브</a>에서 들어보세요.</p>\n<p>그렇다면 ScaleAbility는 어떤 이유로 Go를 써야 한다고 말했을까요?</p>\n<h2 id=\"쉽고-단순해서\"><a href=\"#쉽고-단순해서\" class=\"headerlink\" title=\"쉽고 단순해서\"></a>쉽고 단순해서</h2><p>Go는 복잡함이 싫어 태어난 언어입니다. <a href=\"https://web.archive.org/web/20140313072938/http://www.drdobbs.com/open-source/interview-with-ken-thompson/229502480\" target=\"_blank\" rel=\"noopener\">언어 설계자들이 직접 밝혔죠.</a> 때문에 키워드도 적습니다. 반복문에 for만 존재할 정도죠. (do, while이 없습니다!) <a href=\"https://golang.org/doc/effective_go.html#formatting\" target=\"_blank\" rel=\"noopener\">코드 서식(format)을 자동으로 맞춰줘서</a> Go를 사용하는 누구나 같은 규칙에 따라 코드를 작성할 수 있습니다. 덕분에 코드 리뷰 시에 오직 논리에만 집중할 수 있죠. 가비지 컬렉션도 가능해 메모리를 직접 관리할 필요도 없습니다. 이처럼 Go는 어렵고 불필요한 건 일절 담지 않아 쉽고 단순합니다.</p>\n<h2 id=\"빠르고-강력해서\"><a href=\"#빠르고-강력해서\" class=\"headerlink\" title=\"빠르고 강력해서\"></a>빠르고 강력해서</h2><p>쉽고 단순하다고 해서 얕봐선 안 됩니다. Go는 엄청난 속도를 자랑합니다. 쉽고 단순하기로 유명한 <a href=\"https://www.edureka.co/blog/golang-vs-python/#perf\" target=\"_blank\" rel=\"noopener\">Python과 비교하면 30~50배가 빠릅니다.</a> Python은 실행 단계에 해석기(Interpreter)가 필요한 한편 Go는 기계어로 미리 컴파일되기 때문에 엄청난 속도를 내는 것이죠. 그리고 Java나 C++처럼 <a href=\"https://youtu.be/7VcArS4Wpqk?t=575\" target=\"_blank\" rel=\"noopener\">대형 시스템에서 운용할 수 있게 설계되었습니다.</a></p>\n<h2 id=\"진짜-이유\"><a href=\"#진짜-이유\" class=\"headerlink\" title=\"진짜 이유\"></a>진짜 이유</h2><p>솔직하게 말하자면 제 진짜 이유는 여기 있습니다. 쉽고 단순하면서 빠르고 강력하다는 것도 배우기로 마음 먹은 뒤에 알아본 것이죠. 진짜 이유는 회사에서 Go를 사용하기 때문입니다. (마스코트가 너무 귀여운 탓도 있습니다.) 기존의 서비스를 새로 구현하는데 Go가 쓰입니다. 서버쪽이라 아직은 제가 쓰진 않습니다. 다만, 리뷰를 해야할 것 같아 배워두려고 합니다.</p>\n<p>오랜만에 새로운 언어를 배우는거라 기대가 됩니다. 이 과정을 글로 남겨볼 생각합니다. 우선은 <a href=\"https://golang.org/doc/\" target=\"_blank\" rel=\"noopener\">공식 문서</a>를 조금 읽어봐야겠습니다. 그리고 <a href=\"https://academy.nomadcoders.co/p/go-for-beginners\" target=\"_blank\" rel=\"noopener\">강의</a>를 하나 들으며 실제 서비스를 만들어볼 계획입니다. <a href=\"https://github.com/golang/go/wiki/WebAssembly\" target=\"_blank\" rel=\"noopener\">쓸데 없는 짓</a>도 조금 해볼 생각입니다. <a href=\"https://github.com/joeunha/write-in-go\" target=\"_blank\" rel=\"noopener\">Github 저장소</a>에 배운 것을 조금씩 올리겠습니다.</p>\n"},{"title":"든든한 우리 형, 함수형 - 논리를 꼬집다","date":"2019-12-17T11:45:27.000Z","description":"우리 형은 논리를 꼬집어 함수를 만듭니다","_content":"**개발할 때 늘 도움을 주는 우리 형, 함수형을 소개합니다**\n\n## 형을 만나다\n형을 처음 만난 건 2016년 [첫 직장](https://www.marpple.com/kr/)에서였습니다. 사수인 팀장님이 이 형과 아주 친했죠. 저는 그곳에서 일하는 동안 형의 도움을 꾸준히 받으며 성장했습니다. [Underscore](https://underscorejs.org/)라는 라이브러리를 사용하고 따라 만들면서 형에 대해 알아갔습니다. 처음에 형은 참 어렵게 느껴졌습니다. 그래도 늘 한결같은 순수한 면에 매력을 느꼈습니다. 서비스가 커가면서 형의 도움을 받는 일이 많아졌죠. 복잡도가 올라갈 때 특히 도움을 많이 받았습니다. 반복되는 코드가 발견되면 꼭 알려줬죠. 이렇게 말했습니다. \"이 부분이야, 여길 꼬집어. 이 논리를 꼬집어내.\"\n\n## 논리를 꼬집다\n처음엔 무슨 말인지 이해가 되지 않았습니다. 어디가 꼬집어야 할 논리인지 알기 힘들었죠. 잘못 꼬집어서 잘 되던 프로그램이 망가지기도 했습니다. 수많은 실수 끝에 어느 정도 느낌이 왔습니다. 결국 논리를 꼬집기 위해선 추상화가 필수였던 것입니다. 일종의 글짓기인 프로그래밍에선 다양한 논리가 존재합니다. 어떤 순서로 어떤 방식으로 프로그램이 동작하도록 할지 결정하는 논리. 이 중에서 반복되는 논리를 특정 상황에만 적용되지 않는 수준으로 끌어올리는 게 추상화입니다. 조금 더 범용적으로 적용될만한 논리를 모아 하나의 함수로 만드는 것. 그게 우리 형, 함수형이 알려준 첫 번째 도움이었습니다. \n\n## forEach\n예를 들기 가장 좋은 게 [`forEach`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)입니다. 이 친구는 `for`의 논리를 함수로 만든 친구입니다. 자바스크립트에서는 메서드 형태로 배열에만 적용되지만, 논리를 놓고 보면 배열처럼 순차적으로 값을 조회할 수 있는 모든 경우에 사용할 수 있습니다. 생각해보면 배열을 놓고 `for`와 같은 논리를 구현할 방법은 많습니다. `while`을 사용할 수도 있습니다. `for` 만해도 아주 다양한 방식으로 구현할 수 있습니다. `-1`부터 시작하거나 평범하게 `0`부터 시작할 수도 있죠. 가만 보니 어떤 구현체건 결국 논리는 값을 순차적으로 조회하는 게 핵심이군요. 사실 메서드가 아닌 함수에선 [`each`](https://underscorejs.org/#each)라고 부르는 경우가 더 많죠. 한국어로 '각각의'라는 뜻을 갖는 걸 봤을 때 순회할 수 있는 값에서 각각의 값을 확인한다는 의미인 거겠죠. 이 친구는 우리 형, 함수형이 참 좋아하는 논리가 잘 꼬집힌 함수인 것 같네요.\n\n\n\n","source":"_posts/my-bro-fp-0.md","raw":"---\ntitle: '든든한 우리 형, 함수형 - 논리를 꼬집다'\ndate: 2019-12-17 20:45:27\ncategories:\n  - paradigm\ntags:\n  - javascript\n  - 함수형 프로그래밍\n  - 든든한 우리 형\n  - forEach\ndescription: 우리 형은 논리를 꼬집어 함수를 만듭니다\n---\n**개발할 때 늘 도움을 주는 우리 형, 함수형을 소개합니다**\n\n## 형을 만나다\n형을 처음 만난 건 2016년 [첫 직장](https://www.marpple.com/kr/)에서였습니다. 사수인 팀장님이 이 형과 아주 친했죠. 저는 그곳에서 일하는 동안 형의 도움을 꾸준히 받으며 성장했습니다. [Underscore](https://underscorejs.org/)라는 라이브러리를 사용하고 따라 만들면서 형에 대해 알아갔습니다. 처음에 형은 참 어렵게 느껴졌습니다. 그래도 늘 한결같은 순수한 면에 매력을 느꼈습니다. 서비스가 커가면서 형의 도움을 받는 일이 많아졌죠. 복잡도가 올라갈 때 특히 도움을 많이 받았습니다. 반복되는 코드가 발견되면 꼭 알려줬죠. 이렇게 말했습니다. \"이 부분이야, 여길 꼬집어. 이 논리를 꼬집어내.\"\n\n## 논리를 꼬집다\n처음엔 무슨 말인지 이해가 되지 않았습니다. 어디가 꼬집어야 할 논리인지 알기 힘들었죠. 잘못 꼬집어서 잘 되던 프로그램이 망가지기도 했습니다. 수많은 실수 끝에 어느 정도 느낌이 왔습니다. 결국 논리를 꼬집기 위해선 추상화가 필수였던 것입니다. 일종의 글짓기인 프로그래밍에선 다양한 논리가 존재합니다. 어떤 순서로 어떤 방식으로 프로그램이 동작하도록 할지 결정하는 논리. 이 중에서 반복되는 논리를 특정 상황에만 적용되지 않는 수준으로 끌어올리는 게 추상화입니다. 조금 더 범용적으로 적용될만한 논리를 모아 하나의 함수로 만드는 것. 그게 우리 형, 함수형이 알려준 첫 번째 도움이었습니다. \n\n## forEach\n예를 들기 가장 좋은 게 [`forEach`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)입니다. 이 친구는 `for`의 논리를 함수로 만든 친구입니다. 자바스크립트에서는 메서드 형태로 배열에만 적용되지만, 논리를 놓고 보면 배열처럼 순차적으로 값을 조회할 수 있는 모든 경우에 사용할 수 있습니다. 생각해보면 배열을 놓고 `for`와 같은 논리를 구현할 방법은 많습니다. `while`을 사용할 수도 있습니다. `for` 만해도 아주 다양한 방식으로 구현할 수 있습니다. `-1`부터 시작하거나 평범하게 `0`부터 시작할 수도 있죠. 가만 보니 어떤 구현체건 결국 논리는 값을 순차적으로 조회하는 게 핵심이군요. 사실 메서드가 아닌 함수에선 [`each`](https://underscorejs.org/#each)라고 부르는 경우가 더 많죠. 한국어로 '각각의'라는 뜻을 갖는 걸 봤을 때 순회할 수 있는 값에서 각각의 값을 확인한다는 의미인 거겠죠. 이 친구는 우리 형, 함수형이 참 좋아하는 논리가 잘 꼬집힌 함수인 것 같네요.\n\n\n\n","slug":"my-bro-fp-0","published":1,"updated":"2020-01-07T11:27:14.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9h6004wdirv9m6vd6fa","content":"<p><strong>개발할 때 늘 도움을 주는 우리 형, 함수형을 소개합니다</strong></p>\n<h2 id=\"형을-만나다\"><a href=\"#형을-만나다\" class=\"headerlink\" title=\"형을 만나다\"></a>형을 만나다</h2><p>형을 처음 만난 건 2016년 <a href=\"https://www.marpple.com/kr/\" target=\"_blank\" rel=\"noopener\">첫 직장</a>에서였습니다. 사수인 팀장님이 이 형과 아주 친했죠. 저는 그곳에서 일하는 동안 형의 도움을 꾸준히 받으며 성장했습니다. <a href=\"https://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore</a>라는 라이브러리를 사용하고 따라 만들면서 형에 대해 알아갔습니다. 처음에 형은 참 어렵게 느껴졌습니다. 그래도 늘 한결같은 순수한 면에 매력을 느꼈습니다. 서비스가 커가면서 형의 도움을 받는 일이 많아졌죠. 복잡도가 올라갈 때 특히 도움을 많이 받았습니다. 반복되는 코드가 발견되면 꼭 알려줬죠. 이렇게 말했습니다. “이 부분이야, 여길 꼬집어. 이 논리를 꼬집어내.”</p>\n<h2 id=\"논리를-꼬집다\"><a href=\"#논리를-꼬집다\" class=\"headerlink\" title=\"논리를 꼬집다\"></a>논리를 꼬집다</h2><p>처음엔 무슨 말인지 이해가 되지 않았습니다. 어디가 꼬집어야 할 논리인지 알기 힘들었죠. 잘못 꼬집어서 잘 되던 프로그램이 망가지기도 했습니다. 수많은 실수 끝에 어느 정도 느낌이 왔습니다. 결국 논리를 꼬집기 위해선 추상화가 필수였던 것입니다. 일종의 글짓기인 프로그래밍에선 다양한 논리가 존재합니다. 어떤 순서로 어떤 방식으로 프로그램이 동작하도록 할지 결정하는 논리. 이 중에서 반복되는 논리를 특정 상황에만 적용되지 않는 수준으로 끌어올리는 게 추상화입니다. 조금 더 범용적으로 적용될만한 논리를 모아 하나의 함수로 만드는 것. 그게 우리 형, 함수형이 알려준 첫 번째 도움이었습니다. </p>\n<h2 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h2><p>예를 들기 가장 좋은 게 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\" target=\"_blank\" rel=\"noopener\"><code>forEach</code></a>입니다. 이 친구는 <code>for</code>의 논리를 함수로 만든 친구입니다. 자바스크립트에서는 메서드 형태로 배열에만 적용되지만, 논리를 놓고 보면 배열처럼 순차적으로 값을 조회할 수 있는 모든 경우에 사용할 수 있습니다. 생각해보면 배열을 놓고 <code>for</code>와 같은 논리를 구현할 방법은 많습니다. <code>while</code>을 사용할 수도 있습니다. <code>for</code> 만해도 아주 다양한 방식으로 구현할 수 있습니다. <code>-1</code>부터 시작하거나 평범하게 <code>0</code>부터 시작할 수도 있죠. 가만 보니 어떤 구현체건 결국 논리는 값을 순차적으로 조회하는 게 핵심이군요. 사실 메서드가 아닌 함수에선 <a href=\"https://underscorejs.org/#each\" target=\"_blank\" rel=\"noopener\"><code>each</code></a>라고 부르는 경우가 더 많죠. 한국어로 ‘각각의’라는 뜻을 갖는 걸 봤을 때 순회할 수 있는 값에서 각각의 값을 확인한다는 의미인 거겠죠. 이 친구는 우리 형, 함수형이 참 좋아하는 논리가 잘 꼬집힌 함수인 것 같네요.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>개발할 때 늘 도움을 주는 우리 형, 함수형을 소개합니다</strong></p>\n<h2 id=\"형을-만나다\"><a href=\"#형을-만나다\" class=\"headerlink\" title=\"형을 만나다\"></a>형을 만나다</h2><p>형을 처음 만난 건 2016년 <a href=\"https://www.marpple.com/kr/\" target=\"_blank\" rel=\"noopener\">첫 직장</a>에서였습니다. 사수인 팀장님이 이 형과 아주 친했죠. 저는 그곳에서 일하는 동안 형의 도움을 꾸준히 받으며 성장했습니다. <a href=\"https://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore</a>라는 라이브러리를 사용하고 따라 만들면서 형에 대해 알아갔습니다. 처음에 형은 참 어렵게 느껴졌습니다. 그래도 늘 한결같은 순수한 면에 매력을 느꼈습니다. 서비스가 커가면서 형의 도움을 받는 일이 많아졌죠. 복잡도가 올라갈 때 특히 도움을 많이 받았습니다. 반복되는 코드가 발견되면 꼭 알려줬죠. 이렇게 말했습니다. “이 부분이야, 여길 꼬집어. 이 논리를 꼬집어내.”</p>\n<h2 id=\"논리를-꼬집다\"><a href=\"#논리를-꼬집다\" class=\"headerlink\" title=\"논리를 꼬집다\"></a>논리를 꼬집다</h2><p>처음엔 무슨 말인지 이해가 되지 않았습니다. 어디가 꼬집어야 할 논리인지 알기 힘들었죠. 잘못 꼬집어서 잘 되던 프로그램이 망가지기도 했습니다. 수많은 실수 끝에 어느 정도 느낌이 왔습니다. 결국 논리를 꼬집기 위해선 추상화가 필수였던 것입니다. 일종의 글짓기인 프로그래밍에선 다양한 논리가 존재합니다. 어떤 순서로 어떤 방식으로 프로그램이 동작하도록 할지 결정하는 논리. 이 중에서 반복되는 논리를 특정 상황에만 적용되지 않는 수준으로 끌어올리는 게 추상화입니다. 조금 더 범용적으로 적용될만한 논리를 모아 하나의 함수로 만드는 것. 그게 우리 형, 함수형이 알려준 첫 번째 도움이었습니다. </p>\n<h2 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h2><p>예를 들기 가장 좋은 게 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\" target=\"_blank\" rel=\"noopener\"><code>forEach</code></a>입니다. 이 친구는 <code>for</code>의 논리를 함수로 만든 친구입니다. 자바스크립트에서는 메서드 형태로 배열에만 적용되지만, 논리를 놓고 보면 배열처럼 순차적으로 값을 조회할 수 있는 모든 경우에 사용할 수 있습니다. 생각해보면 배열을 놓고 <code>for</code>와 같은 논리를 구현할 방법은 많습니다. <code>while</code>을 사용할 수도 있습니다. <code>for</code> 만해도 아주 다양한 방식으로 구현할 수 있습니다. <code>-1</code>부터 시작하거나 평범하게 <code>0</code>부터 시작할 수도 있죠. 가만 보니 어떤 구현체건 결국 논리는 값을 순차적으로 조회하는 게 핵심이군요. 사실 메서드가 아닌 함수에선 <a href=\"https://underscorejs.org/#each\" target=\"_blank\" rel=\"noopener\"><code>each</code></a>라고 부르는 경우가 더 많죠. 한국어로 ‘각각의’라는 뜻을 갖는 걸 봤을 때 순회할 수 있는 값에서 각각의 값을 확인한다는 의미인 거겠죠. 이 친구는 우리 형, 함수형이 참 좋아하는 논리가 잘 꼬집힌 함수인 것 같네요.</p>\n"},{"title":"랜드서핑 - 취미의 시작","date":"2017-11-20T13:45:38.000Z","_content":"## 랜드서핑을 만나다\n\n2013년 7월, 미니 크루저보드가 크게 유행했습니다. 셀럽이 공항에서 타고 등장했었죠. 페니(Penny)라는 회사에서 나오는 보드가 가장 유명했습니다. '크루저보드 = 페니보드'로 인식되던 시절입니다. 학교에서 보드를 타고 돌아다니는 친구들을 보니 멋져보였습니다. 취미를 가져보기로 했습니다. 정가로 사면 17만원정도 했던 기억이 납니다. 친구의 도움으로 중고나라에서 로고 없는 페니보드를 5만원에 싸게 구했습니다. 1년정도 타다가 중고로 팔았습니다.\n\n2017년 4월, 대학 동문인 형님의 소개로 랜드서핑보드라는 것을 알게되었습니다. 여기서는 카버(Carver)라는 회사의 보드가 가장 유명합니다. '랜드서핑보드 = 카버보드'로 알려지고 있습니다. 정가로 알아보니 30만원이 훌쩍 넘습니다. 하지만 여기서는 대안이 없습니다. 인터넷 최저가를 뒤져 31만원에 보드를 하나 장만했습니다. 4월 29일입니다.\n\n2017년 11월, 보드를 탄지 제법 시간이 흘렀습니다. 그동안 피드백을 위해 영상을 찍어 기록을 남겼습니다. 그리고 오늘 블로그에 기록을 시작합니다.\n\n\n## 영상으로 피드백을, 공유로 즐거움을\n\n처음 보드를 타면 자세가 어정쩡합니다. 춤을 추는 것과 비슷하다고 할까요. 자기가 생각한 것과 몸이 움직이는 모양이 많이 다릅니다. 춤은 전신 거울을 보며 즉시로 교정해나갈 수 있지만 보드는 거울을 보기 어렵습니다. 그래서 영상을 남깁니다. 처음에는 아이폰(iPhone SE)을 사용했습니다. 삼각대도 없었습니다. 그나마 각진 제 아이폰이 설 수 있는 곳을 찾아서 겨우 영상을 담아갔습니다. 그정도로 충분했습니다. \n\n조금씩 자세가 좋아지는가 싶더니 영상을 더 다양한 각도로 담고 싶어졌습니다. 삼각대를 구매했습니다. 샤오미(Xiaomi)에서 나온 셀카봉 겸 삼각대를 구매했습니다. 덕분에 더 다양한 각도로 영상을 찍을 수 있게 되었습니다. 다양한 영상이 나오니 편집이 필요해집니다. 개인적인 피드백만을 위한다면 구태여 편집할 필요가 없지만 늘 영상을 공유하고 있었기에 보기 좋은 영상을 만들고 싶었습니다. iMovie를 사용하기 시작합니다. \n\n영상 전환 방식인 디졸브를 애용하면서 자기 만족을 얻었습니다. 그때 영상쪽 일을 하는 동생에게 피드백을 들었습니다. 디졸브가 없이 편집하는게 사실은 더 근사한 기술이라는 겁니다. 추석때 동생을 만나 편집의 기술을 조금 배웠습니다. 그후로 영상의 퀄리티가 좋아진 것 같습니다. 배경 음악도 넣었습니다. 유튜브에서 만들기라는 옵션에 무료 음원이 있습니다. 대부분 거기서 음원을 얻어오고 있습니다.\n\n그렇게 만들어진 영상은 현재 인스타그램과 유튜브에 공유되고 있습니다. \n\n\n#### Instagram\n\n원래 가지고 있던 계정은 비공개 상태였기에 새로운 계정을 만들었습니다. [joeun\\_surf](https://www.instagram.com/joeun_surf/)라는 계정입니다. (개인 계정이 joeun\\_ha 입니다. 나름대로 작명 규칙을 가지고 있는 샘입니다. 다음 계정은 joeun\\_something 이겠지요.) '카버보드', '랜드서핑'과 같은 태그를 공유하는 이들을 팔로우하고 좋아요를 누르며 활동을 했더니 팔로워가 생깁니다. 글을 작성하는 현재 개인 계정보다 많은 인원인 425명이 joeun\\_surf를 팔로우하고 있습니다.\n\n{% instagram BTyyuv_lKOl %}\n\n보드를 탄 첫날 찍어 올린 영상입니다. 신대방 역 아래에 자전거 연습장(자연장)에서 찍었습니다. 하루종일 스윙을 연습해서 앞으로 나갈 수 있었습니다.\n\n{% instagram BbruxnFl3xP %}\n\n최근에 올린 다운힐 영상입니다. 반포 달빛 광장 진입로에 있는 다운힐 스팟입니다. 겨울에 딱 좋은 스팟입니다. 첫날과 확연히 달라졌죠?\n\n\n#### Youtube\n\n원래 의도는 조금 더 긴 영상(1분 이상)을 업로드하는 것이 목적이었습니다. 하지만 1분 이상의 영상을 만들 정도의 집중력이 현재로선 없다는걸 알게 되었습니다. 인스타에 올린 영상 중에서 조금 정돈된 영상을 유튜브에 담고 있습니다. 페이스북이나 인스타그램에 공유할 수 없는 점 때문에 팔로워를 늘려가는게 쉽지 않습니다. 조회수도 107명이 최대입니다. 그 영상이 아래의 영상입니다. \n\n{% youtube isrTmfZu9dY %}\n\n유튜브에 처음 올렸던 영상입니다. 지금의 주행과는 차이가 있습니다. 현재까지 가장 마음에 드는 영상은 상해에서 촬영한 영상입니다. 상해의 주요 랜드마크를 돌면서 영상을 담았습니다. 고프로(GoPro, Hero6)를 사용한 첫번째 영상입니다.\n\n{% youtube MZH_3kNNGg0 %}\n\n\n#### GoPro\n\n고프로보다는 소니의 액션캠이 낫다고 생각했습니다. 야간 촬영이나 손떨림방지 기능이 훨씬 낫다고 알고 있었습니다. 하지만 면세점의 유혹을 떨쳐버리지 못했습니다. 인기 마운트인 3-Way를 포함해서 원가가 70만원에 가까운 제품을 인터넷 면세점의 쿠폰과 면세 혜택을 통해 48만원에 구매할 수 있는 기회를 저버리기 쉽지 않았습니다. 상해로 떠나는 길에 고프로를 구매했습니다. 덕분에 더 좋은 영상을 많이 담을 수 있었습니다. 기회가 되면 제품에 대한 피드백을 하겠지만 완전 추천하는 제품이라고 말하긴 어렵습니다. 소프트웨어가 불안정합니다. 그럼에도 하드웨어는 훌륭합니다. 좋은 영상을 담아주면 그걸로 제 역할은 다한 것이죠. \n\n\n## 함께하는 사람들, Landsurfers\n\n지난 5월 1일, 네이버 카페 '[랜드서퍼스](http://cafe.naver.com/landsurfers)'가 오픈했습니다. 그리고 현재 1,133명이 활동하고 있는 '가지4단계'의 건실한 카페가 되었습니다. 저를 랜드서핑 세계로 이끌어준 형님이 시작한 카페입니다. 이 분들과 함께 매주 랜드서핑을 즐기고 있습니다. 저는 반포와 분당 정모에 참석합니다. 반포 정모는 랜드서퍼스 메인 정모에 해당하는 정모로 매주 목, 일 저녁에 모입니다. 분당은 월, 목에 모입니다. 평일에는 분당 모임에 가고 일요일은 반포 모임에 참석하고 있습니다. \n\n함께하는 사람들이 있으니 자극이 되고 꾸준히 활동을 이어갈 수 있어 참 좋습니다. 특히나 서로 영상을 찍어주고 피드백을 해주면 실력 향상에 도움이 됩니다. 참 재밌는 점은 랜드서핑이라는 이름으로 모인 이 사람들이 정말 순수하다는 점입니다. 모여서 보드만 타고 헤어집니다. 누가 그렇게 하자고 제안한 바는 아니지만 다들 보드를 즐겁게 타고 싶은 그 마음으로 모였기 때문에 그것으로 충분한 듯합니다. 이들과 함께하는 시간이 점점 더 좋아집니다. \n\n\n## 꿈꾸는 랜드서퍼\n\n'우아한 라이딩을 꿈꾸는 분당의 랜드서퍼' 인스타 계정의 소개글 입니다. 처음에는 도무지 우아하게 탈 수가 없어서 우아한 라이딩을 꿈만 꿨습니다. 하지만 지금은 가끔 우아하다는 소리를 듣습니다. 꿈을 이뤄가는 중인 것입니다. 그리고 올해 해외 랜드마크에서 보드를 타보겠다는 꿈을 이루고 왔습니다. 내년에는 어떤 꿈을 이룰 수 있을까요? 개인적으로는 작은 것이라도 협찬을 받아보고 싶습니다. 보드를 탈때 입는 옷이나 신발이면 좋겠네요. 그리고 잡지나 블로그에 인터뷰를 할 수 있으면 좋겠습니다. 개발자로서 좋은 취미를 가지게 된 이야기, 랜드서핑에 대한 이야기를 나눌 수 있는 잡지면 좋을 것 같습니다. 내년이 기대되네요.","source":"_drafts/landsurfing.md","raw":"---\ntitle: \"랜드서핑 - 취미의 시작\"\ncategories:\n  - landsurfing\ndate: 2017-11-20 22:45:38\ntags:\n  - 랜드서핑\n  - youtube\n  - instagram\n  - gopro\n---\n## 랜드서핑을 만나다\n\n2013년 7월, 미니 크루저보드가 크게 유행했습니다. 셀럽이 공항에서 타고 등장했었죠. 페니(Penny)라는 회사에서 나오는 보드가 가장 유명했습니다. '크루저보드 = 페니보드'로 인식되던 시절입니다. 학교에서 보드를 타고 돌아다니는 친구들을 보니 멋져보였습니다. 취미를 가져보기로 했습니다. 정가로 사면 17만원정도 했던 기억이 납니다. 친구의 도움으로 중고나라에서 로고 없는 페니보드를 5만원에 싸게 구했습니다. 1년정도 타다가 중고로 팔았습니다.\n\n2017년 4월, 대학 동문인 형님의 소개로 랜드서핑보드라는 것을 알게되었습니다. 여기서는 카버(Carver)라는 회사의 보드가 가장 유명합니다. '랜드서핑보드 = 카버보드'로 알려지고 있습니다. 정가로 알아보니 30만원이 훌쩍 넘습니다. 하지만 여기서는 대안이 없습니다. 인터넷 최저가를 뒤져 31만원에 보드를 하나 장만했습니다. 4월 29일입니다.\n\n2017년 11월, 보드를 탄지 제법 시간이 흘렀습니다. 그동안 피드백을 위해 영상을 찍어 기록을 남겼습니다. 그리고 오늘 블로그에 기록을 시작합니다.\n\n\n## 영상으로 피드백을, 공유로 즐거움을\n\n처음 보드를 타면 자세가 어정쩡합니다. 춤을 추는 것과 비슷하다고 할까요. 자기가 생각한 것과 몸이 움직이는 모양이 많이 다릅니다. 춤은 전신 거울을 보며 즉시로 교정해나갈 수 있지만 보드는 거울을 보기 어렵습니다. 그래서 영상을 남깁니다. 처음에는 아이폰(iPhone SE)을 사용했습니다. 삼각대도 없었습니다. 그나마 각진 제 아이폰이 설 수 있는 곳을 찾아서 겨우 영상을 담아갔습니다. 그정도로 충분했습니다. \n\n조금씩 자세가 좋아지는가 싶더니 영상을 더 다양한 각도로 담고 싶어졌습니다. 삼각대를 구매했습니다. 샤오미(Xiaomi)에서 나온 셀카봉 겸 삼각대를 구매했습니다. 덕분에 더 다양한 각도로 영상을 찍을 수 있게 되었습니다. 다양한 영상이 나오니 편집이 필요해집니다. 개인적인 피드백만을 위한다면 구태여 편집할 필요가 없지만 늘 영상을 공유하고 있었기에 보기 좋은 영상을 만들고 싶었습니다. iMovie를 사용하기 시작합니다. \n\n영상 전환 방식인 디졸브를 애용하면서 자기 만족을 얻었습니다. 그때 영상쪽 일을 하는 동생에게 피드백을 들었습니다. 디졸브가 없이 편집하는게 사실은 더 근사한 기술이라는 겁니다. 추석때 동생을 만나 편집의 기술을 조금 배웠습니다. 그후로 영상의 퀄리티가 좋아진 것 같습니다. 배경 음악도 넣었습니다. 유튜브에서 만들기라는 옵션에 무료 음원이 있습니다. 대부분 거기서 음원을 얻어오고 있습니다.\n\n그렇게 만들어진 영상은 현재 인스타그램과 유튜브에 공유되고 있습니다. \n\n\n#### Instagram\n\n원래 가지고 있던 계정은 비공개 상태였기에 새로운 계정을 만들었습니다. [joeun\\_surf](https://www.instagram.com/joeun_surf/)라는 계정입니다. (개인 계정이 joeun\\_ha 입니다. 나름대로 작명 규칙을 가지고 있는 샘입니다. 다음 계정은 joeun\\_something 이겠지요.) '카버보드', '랜드서핑'과 같은 태그를 공유하는 이들을 팔로우하고 좋아요를 누르며 활동을 했더니 팔로워가 생깁니다. 글을 작성하는 현재 개인 계정보다 많은 인원인 425명이 joeun\\_surf를 팔로우하고 있습니다.\n\n{% instagram BTyyuv_lKOl %}\n\n보드를 탄 첫날 찍어 올린 영상입니다. 신대방 역 아래에 자전거 연습장(자연장)에서 찍었습니다. 하루종일 스윙을 연습해서 앞으로 나갈 수 있었습니다.\n\n{% instagram BbruxnFl3xP %}\n\n최근에 올린 다운힐 영상입니다. 반포 달빛 광장 진입로에 있는 다운힐 스팟입니다. 겨울에 딱 좋은 스팟입니다. 첫날과 확연히 달라졌죠?\n\n\n#### Youtube\n\n원래 의도는 조금 더 긴 영상(1분 이상)을 업로드하는 것이 목적이었습니다. 하지만 1분 이상의 영상을 만들 정도의 집중력이 현재로선 없다는걸 알게 되었습니다. 인스타에 올린 영상 중에서 조금 정돈된 영상을 유튜브에 담고 있습니다. 페이스북이나 인스타그램에 공유할 수 없는 점 때문에 팔로워를 늘려가는게 쉽지 않습니다. 조회수도 107명이 최대입니다. 그 영상이 아래의 영상입니다. \n\n{% youtube isrTmfZu9dY %}\n\n유튜브에 처음 올렸던 영상입니다. 지금의 주행과는 차이가 있습니다. 현재까지 가장 마음에 드는 영상은 상해에서 촬영한 영상입니다. 상해의 주요 랜드마크를 돌면서 영상을 담았습니다. 고프로(GoPro, Hero6)를 사용한 첫번째 영상입니다.\n\n{% youtube MZH_3kNNGg0 %}\n\n\n#### GoPro\n\n고프로보다는 소니의 액션캠이 낫다고 생각했습니다. 야간 촬영이나 손떨림방지 기능이 훨씬 낫다고 알고 있었습니다. 하지만 면세점의 유혹을 떨쳐버리지 못했습니다. 인기 마운트인 3-Way를 포함해서 원가가 70만원에 가까운 제품을 인터넷 면세점의 쿠폰과 면세 혜택을 통해 48만원에 구매할 수 있는 기회를 저버리기 쉽지 않았습니다. 상해로 떠나는 길에 고프로를 구매했습니다. 덕분에 더 좋은 영상을 많이 담을 수 있었습니다. 기회가 되면 제품에 대한 피드백을 하겠지만 완전 추천하는 제품이라고 말하긴 어렵습니다. 소프트웨어가 불안정합니다. 그럼에도 하드웨어는 훌륭합니다. 좋은 영상을 담아주면 그걸로 제 역할은 다한 것이죠. \n\n\n## 함께하는 사람들, Landsurfers\n\n지난 5월 1일, 네이버 카페 '[랜드서퍼스](http://cafe.naver.com/landsurfers)'가 오픈했습니다. 그리고 현재 1,133명이 활동하고 있는 '가지4단계'의 건실한 카페가 되었습니다. 저를 랜드서핑 세계로 이끌어준 형님이 시작한 카페입니다. 이 분들과 함께 매주 랜드서핑을 즐기고 있습니다. 저는 반포와 분당 정모에 참석합니다. 반포 정모는 랜드서퍼스 메인 정모에 해당하는 정모로 매주 목, 일 저녁에 모입니다. 분당은 월, 목에 모입니다. 평일에는 분당 모임에 가고 일요일은 반포 모임에 참석하고 있습니다. \n\n함께하는 사람들이 있으니 자극이 되고 꾸준히 활동을 이어갈 수 있어 참 좋습니다. 특히나 서로 영상을 찍어주고 피드백을 해주면 실력 향상에 도움이 됩니다. 참 재밌는 점은 랜드서핑이라는 이름으로 모인 이 사람들이 정말 순수하다는 점입니다. 모여서 보드만 타고 헤어집니다. 누가 그렇게 하자고 제안한 바는 아니지만 다들 보드를 즐겁게 타고 싶은 그 마음으로 모였기 때문에 그것으로 충분한 듯합니다. 이들과 함께하는 시간이 점점 더 좋아집니다. \n\n\n## 꿈꾸는 랜드서퍼\n\n'우아한 라이딩을 꿈꾸는 분당의 랜드서퍼' 인스타 계정의 소개글 입니다. 처음에는 도무지 우아하게 탈 수가 없어서 우아한 라이딩을 꿈만 꿨습니다. 하지만 지금은 가끔 우아하다는 소리를 듣습니다. 꿈을 이뤄가는 중인 것입니다. 그리고 올해 해외 랜드마크에서 보드를 타보겠다는 꿈을 이루고 왔습니다. 내년에는 어떤 꿈을 이룰 수 있을까요? 개인적으로는 작은 것이라도 협찬을 받아보고 싶습니다. 보드를 탈때 입는 옷이나 신발이면 좋겠네요. 그리고 잡지나 블로그에 인터뷰를 할 수 있으면 좋겠습니다. 개발자로서 좋은 취미를 가지게 된 이야기, 랜드서핑에 대한 이야기를 나눌 수 있는 잡지면 좋을 것 같습니다. 내년이 기대되네요.","slug":"landsurfing","published":0,"updated":"2019-12-05T15:05:29.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9ig0096dirvujxq7nc0","content":"<h2 id=\"랜드서핑을-만나다\"><a href=\"#랜드서핑을-만나다\" class=\"headerlink\" title=\"랜드서핑을 만나다\"></a>랜드서핑을 만나다</h2><p>2013년 7월, 미니 크루저보드가 크게 유행했습니다. 셀럽이 공항에서 타고 등장했었죠. 페니(Penny)라는 회사에서 나오는 보드가 가장 유명했습니다. ‘크루저보드 = 페니보드’로 인식되던 시절입니다. 학교에서 보드를 타고 돌아다니는 친구들을 보니 멋져보였습니다. 취미를 가져보기로 했습니다. 정가로 사면 17만원정도 했던 기억이 납니다. 친구의 도움으로 중고나라에서 로고 없는 페니보드를 5만원에 싸게 구했습니다. 1년정도 타다가 중고로 팔았습니다.</p>\n<p>2017년 4월, 대학 동문인 형님의 소개로 랜드서핑보드라는 것을 알게되었습니다. 여기서는 카버(Carver)라는 회사의 보드가 가장 유명합니다. ‘랜드서핑보드 = 카버보드’로 알려지고 있습니다. 정가로 알아보니 30만원이 훌쩍 넘습니다. 하지만 여기서는 대안이 없습니다. 인터넷 최저가를 뒤져 31만원에 보드를 하나 장만했습니다. 4월 29일입니다.</p>\n<p>2017년 11월, 보드를 탄지 제법 시간이 흘렀습니다. 그동안 피드백을 위해 영상을 찍어 기록을 남겼습니다. 그리고 오늘 블로그에 기록을 시작합니다.</p>\n<h2 id=\"영상으로-피드백을-공유로-즐거움을\"><a href=\"#영상으로-피드백을-공유로-즐거움을\" class=\"headerlink\" title=\"영상으로 피드백을, 공유로 즐거움을\"></a>영상으로 피드백을, 공유로 즐거움을</h2><p>처음 보드를 타면 자세가 어정쩡합니다. 춤을 추는 것과 비슷하다고 할까요. 자기가 생각한 것과 몸이 움직이는 모양이 많이 다릅니다. 춤은 전신 거울을 보며 즉시로 교정해나갈 수 있지만 보드는 거울을 보기 어렵습니다. 그래서 영상을 남깁니다. 처음에는 아이폰(iPhone SE)을 사용했습니다. 삼각대도 없었습니다. 그나마 각진 제 아이폰이 설 수 있는 곳을 찾아서 겨우 영상을 담아갔습니다. 그정도로 충분했습니다. </p>\n<p>조금씩 자세가 좋아지는가 싶더니 영상을 더 다양한 각도로 담고 싶어졌습니다. 삼각대를 구매했습니다. 샤오미(Xiaomi)에서 나온 셀카봉 겸 삼각대를 구매했습니다. 덕분에 더 다양한 각도로 영상을 찍을 수 있게 되었습니다. 다양한 영상이 나오니 편집이 필요해집니다. 개인적인 피드백만을 위한다면 구태여 편집할 필요가 없지만 늘 영상을 공유하고 있었기에 보기 좋은 영상을 만들고 싶었습니다. iMovie를 사용하기 시작합니다. </p>\n<p>영상 전환 방식인 디졸브를 애용하면서 자기 만족을 얻었습니다. 그때 영상쪽 일을 하는 동생에게 피드백을 들었습니다. 디졸브가 없이 편집하는게 사실은 더 근사한 기술이라는 겁니다. 추석때 동생을 만나 편집의 기술을 조금 배웠습니다. 그후로 영상의 퀄리티가 좋아진 것 같습니다. 배경 음악도 넣었습니다. 유튜브에서 만들기라는 옵션에 무료 음원이 있습니다. 대부분 거기서 음원을 얻어오고 있습니다.</p>\n<p>그렇게 만들어진 영상은 현재 인스타그램과 유튜브에 공유되고 있습니다. </p>\n<h4 id=\"Instagram\"><a href=\"#Instagram\" class=\"headerlink\" title=\"Instagram\"></a>Instagram</h4><p>원래 가지고 있던 계정은 비공개 상태였기에 새로운 계정을 만들었습니다. <a href=\"https://www.instagram.com/joeun_surf/\" target=\"_blank\" rel=\"noopener\">joeun_surf</a>라는 계정입니다. (개인 계정이 joeun_ha 입니다. 나름대로 작명 규칙을 가지고 있는 샘입니다. 다음 계정은 joeun_something 이겠지요.) ‘카버보드’, ‘랜드서핑’과 같은 태그를 공유하는 이들을 팔로우하고 좋아요를 누르며 활동을 했더니 팔로워가 생깁니다. 글을 작성하는 현재 개인 계정보다 많은 인원인 425명이 joeun_surf를 팔로우하고 있습니다.</p>\n<div class=\"instagram-wrapper\"><blockquote class=\"instagram-media\" data-instgrm-captioned data-instgrm-version=\"7\" style=\" background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px auto; padding:0; width:99.375%; width:-webkit-calc(100%- 2px); width:calc(100% - 2px);\"><div style=\"padding:8px;\"> <div style=\" background:#F8F8F8; line-height:0; margin-top:40px; padding:50.0% 0; text-align:center; width:100%;\"> <div style=\" background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAMUExURczMzPf399fX1+bm5mzY9AMAAADiSURBVDjLvZXbEsMgCES5/P8/t9FuRVCRmU73JWlzosgSIIZURCjo/ad+EQJJB4Hv8BFt+IDpQoCx1wjOSBFhh2XssxEIYn3ulI/6MNReE07UIWJEv8UEOWDS88LY97kqyTliJKKtuYBbruAyVh5wOHiXmpi5we58Ek028czwyuQdLKPG1Bkb4NnM+VeAnfHqn1k4+GPT6uGQcvu2h2OVuIf/gWUFyy8OWEpdyZSa3aVCqpVoVvzZZ2VTnn2wU8qzVjDDetO90GSy9mVLqtgYSy231MxrY6I2gGqjrTY0L8fxCxfCBbhWrsYYAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;\"></div></div><p style=\" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;\"><a href=\"https://www.instagram.com/p/BTyyuv_lKOl/\" style=\" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none;\" target=\"_blank\"></a></p></div></blockquote></div><script async defer src=\"//platform.instagram.com/en_US/embeds.js\"></script>\n\n<p>보드를 탄 첫날 찍어 올린 영상입니다. 신대방 역 아래에 자전거 연습장(자연장)에서 찍었습니다. 하루종일 스윙을 연습해서 앞으로 나갈 수 있었습니다.</p>\n<div class=\"instagram-wrapper\"><blockquote class=\"instagram-media\" data-instgrm-captioned data-instgrm-version=\"7\" style=\" background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px auto; padding:0; width:99.375%; width:-webkit-calc(100%- 2px); width:calc(100% - 2px);\"><div style=\"padding:8px;\"> <div style=\" background:#F8F8F8; line-height:0; margin-top:40px; padding:50.0% 0; text-align:center; width:100%;\"> <div style=\" background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAMUExURczMzPf399fX1+bm5mzY9AMAAADiSURBVDjLvZXbEsMgCES5/P8/t9FuRVCRmU73JWlzosgSIIZURCjo/ad+EQJJB4Hv8BFt+IDpQoCx1wjOSBFhh2XssxEIYn3ulI/6MNReE07UIWJEv8UEOWDS88LY97kqyTliJKKtuYBbruAyVh5wOHiXmpi5we58Ek028czwyuQdLKPG1Bkb4NnM+VeAnfHqn1k4+GPT6uGQcvu2h2OVuIf/gWUFyy8OWEpdyZSa3aVCqpVoVvzZZ2VTnn2wU8qzVjDDetO90GSy9mVLqtgYSy231MxrY6I2gGqjrTY0L8fxCxfCBbhWrsYYAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;\"></div></div><p style=\" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;\"><a href=\"https://www.instagram.com/p/BbruxnFl3xP/\" style=\" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none;\" target=\"_blank\"></a></p></div></blockquote></div><script async defer src=\"//platform.instagram.com/en_US/embeds.js\"></script>\n\n<p>최근에 올린 다운힐 영상입니다. 반포 달빛 광장 진입로에 있는 다운힐 스팟입니다. 겨울에 딱 좋은 스팟입니다. 첫날과 확연히 달라졌죠?</p>\n<h4 id=\"Youtube\"><a href=\"#Youtube\" class=\"headerlink\" title=\"Youtube\"></a>Youtube</h4><p>원래 의도는 조금 더 긴 영상(1분 이상)을 업로드하는 것이 목적이었습니다. 하지만 1분 이상의 영상을 만들 정도의 집중력이 현재로선 없다는걸 알게 되었습니다. 인스타에 올린 영상 중에서 조금 정돈된 영상을 유튜브에 담고 있습니다. 페이스북이나 인스타그램에 공유할 수 없는 점 때문에 팔로워를 늘려가는게 쉽지 않습니다. 조회수도 107명이 최대입니다. 그 영상이 아래의 영상입니다. </p>\n<div class=\"video-container\"><iframe src=\"//www.youtube.com/embed/isrTmfZu9dY\" frameborder=\"0\" allowfullscreen></iframe></div>\n\n<p>유튜브에 처음 올렸던 영상입니다. 지금의 주행과는 차이가 있습니다. 현재까지 가장 마음에 드는 영상은 상해에서 촬영한 영상입니다. 상해의 주요 랜드마크를 돌면서 영상을 담았습니다. 고프로(GoPro, Hero6)를 사용한 첫번째 영상입니다.</p>\n<div class=\"video-container\"><iframe src=\"//www.youtube.com/embed/MZH_3kNNGg0\" frameborder=\"0\" allowfullscreen></iframe></div>\n\n\n<h4 id=\"GoPro\"><a href=\"#GoPro\" class=\"headerlink\" title=\"GoPro\"></a>GoPro</h4><p>고프로보다는 소니의 액션캠이 낫다고 생각했습니다. 야간 촬영이나 손떨림방지 기능이 훨씬 낫다고 알고 있었습니다. 하지만 면세점의 유혹을 떨쳐버리지 못했습니다. 인기 마운트인 3-Way를 포함해서 원가가 70만원에 가까운 제품을 인터넷 면세점의 쿠폰과 면세 혜택을 통해 48만원에 구매할 수 있는 기회를 저버리기 쉽지 않았습니다. 상해로 떠나는 길에 고프로를 구매했습니다. 덕분에 더 좋은 영상을 많이 담을 수 있었습니다. 기회가 되면 제품에 대한 피드백을 하겠지만 완전 추천하는 제품이라고 말하긴 어렵습니다. 소프트웨어가 불안정합니다. 그럼에도 하드웨어는 훌륭합니다. 좋은 영상을 담아주면 그걸로 제 역할은 다한 것이죠. </p>\n<h2 id=\"함께하는-사람들-Landsurfers\"><a href=\"#함께하는-사람들-Landsurfers\" class=\"headerlink\" title=\"함께하는 사람들, Landsurfers\"></a>함께하는 사람들, Landsurfers</h2><p>지난 5월 1일, 네이버 카페 ‘<a href=\"http://cafe.naver.com/landsurfers\" target=\"_blank\" rel=\"noopener\">랜드서퍼스</a>‘가 오픈했습니다. 그리고 현재 1,133명이 활동하고 있는 ‘가지4단계’의 건실한 카페가 되었습니다. 저를 랜드서핑 세계로 이끌어준 형님이 시작한 카페입니다. 이 분들과 함께 매주 랜드서핑을 즐기고 있습니다. 저는 반포와 분당 정모에 참석합니다. 반포 정모는 랜드서퍼스 메인 정모에 해당하는 정모로 매주 목, 일 저녁에 모입니다. 분당은 월, 목에 모입니다. 평일에는 분당 모임에 가고 일요일은 반포 모임에 참석하고 있습니다. </p>\n<p>함께하는 사람들이 있으니 자극이 되고 꾸준히 활동을 이어갈 수 있어 참 좋습니다. 특히나 서로 영상을 찍어주고 피드백을 해주면 실력 향상에 도움이 됩니다. 참 재밌는 점은 랜드서핑이라는 이름으로 모인 이 사람들이 정말 순수하다는 점입니다. 모여서 보드만 타고 헤어집니다. 누가 그렇게 하자고 제안한 바는 아니지만 다들 보드를 즐겁게 타고 싶은 그 마음으로 모였기 때문에 그것으로 충분한 듯합니다. 이들과 함께하는 시간이 점점 더 좋아집니다. </p>\n<h2 id=\"꿈꾸는-랜드서퍼\"><a href=\"#꿈꾸는-랜드서퍼\" class=\"headerlink\" title=\"꿈꾸는 랜드서퍼\"></a>꿈꾸는 랜드서퍼</h2><p>‘우아한 라이딩을 꿈꾸는 분당의 랜드서퍼’ 인스타 계정의 소개글 입니다. 처음에는 도무지 우아하게 탈 수가 없어서 우아한 라이딩을 꿈만 꿨습니다. 하지만 지금은 가끔 우아하다는 소리를 듣습니다. 꿈을 이뤄가는 중인 것입니다. 그리고 올해 해외 랜드마크에서 보드를 타보겠다는 꿈을 이루고 왔습니다. 내년에는 어떤 꿈을 이룰 수 있을까요? 개인적으로는 작은 것이라도 협찬을 받아보고 싶습니다. 보드를 탈때 입는 옷이나 신발이면 좋겠네요. 그리고 잡지나 블로그에 인터뷰를 할 수 있으면 좋겠습니다. 개발자로서 좋은 취미를 가지게 된 이야기, 랜드서핑에 대한 이야기를 나눌 수 있는 잡지면 좋을 것 같습니다. 내년이 기대되네요.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"랜드서핑을-만나다\"><a href=\"#랜드서핑을-만나다\" class=\"headerlink\" title=\"랜드서핑을 만나다\"></a>랜드서핑을 만나다</h2><p>2013년 7월, 미니 크루저보드가 크게 유행했습니다. 셀럽이 공항에서 타고 등장했었죠. 페니(Penny)라는 회사에서 나오는 보드가 가장 유명했습니다. ‘크루저보드 = 페니보드’로 인식되던 시절입니다. 학교에서 보드를 타고 돌아다니는 친구들을 보니 멋져보였습니다. 취미를 가져보기로 했습니다. 정가로 사면 17만원정도 했던 기억이 납니다. 친구의 도움으로 중고나라에서 로고 없는 페니보드를 5만원에 싸게 구했습니다. 1년정도 타다가 중고로 팔았습니다.</p>\n<p>2017년 4월, 대학 동문인 형님의 소개로 랜드서핑보드라는 것을 알게되었습니다. 여기서는 카버(Carver)라는 회사의 보드가 가장 유명합니다. ‘랜드서핑보드 = 카버보드’로 알려지고 있습니다. 정가로 알아보니 30만원이 훌쩍 넘습니다. 하지만 여기서는 대안이 없습니다. 인터넷 최저가를 뒤져 31만원에 보드를 하나 장만했습니다. 4월 29일입니다.</p>\n<p>2017년 11월, 보드를 탄지 제법 시간이 흘렀습니다. 그동안 피드백을 위해 영상을 찍어 기록을 남겼습니다. 그리고 오늘 블로그에 기록을 시작합니다.</p>\n<h2 id=\"영상으로-피드백을-공유로-즐거움을\"><a href=\"#영상으로-피드백을-공유로-즐거움을\" class=\"headerlink\" title=\"영상으로 피드백을, 공유로 즐거움을\"></a>영상으로 피드백을, 공유로 즐거움을</h2><p>처음 보드를 타면 자세가 어정쩡합니다. 춤을 추는 것과 비슷하다고 할까요. 자기가 생각한 것과 몸이 움직이는 모양이 많이 다릅니다. 춤은 전신 거울을 보며 즉시로 교정해나갈 수 있지만 보드는 거울을 보기 어렵습니다. 그래서 영상을 남깁니다. 처음에는 아이폰(iPhone SE)을 사용했습니다. 삼각대도 없었습니다. 그나마 각진 제 아이폰이 설 수 있는 곳을 찾아서 겨우 영상을 담아갔습니다. 그정도로 충분했습니다. </p>\n<p>조금씩 자세가 좋아지는가 싶더니 영상을 더 다양한 각도로 담고 싶어졌습니다. 삼각대를 구매했습니다. 샤오미(Xiaomi)에서 나온 셀카봉 겸 삼각대를 구매했습니다. 덕분에 더 다양한 각도로 영상을 찍을 수 있게 되었습니다. 다양한 영상이 나오니 편집이 필요해집니다. 개인적인 피드백만을 위한다면 구태여 편집할 필요가 없지만 늘 영상을 공유하고 있었기에 보기 좋은 영상을 만들고 싶었습니다. iMovie를 사용하기 시작합니다. </p>\n<p>영상 전환 방식인 디졸브를 애용하면서 자기 만족을 얻었습니다. 그때 영상쪽 일을 하는 동생에게 피드백을 들었습니다. 디졸브가 없이 편집하는게 사실은 더 근사한 기술이라는 겁니다. 추석때 동생을 만나 편집의 기술을 조금 배웠습니다. 그후로 영상의 퀄리티가 좋아진 것 같습니다. 배경 음악도 넣었습니다. 유튜브에서 만들기라는 옵션에 무료 음원이 있습니다. 대부분 거기서 음원을 얻어오고 있습니다.</p>\n<p>그렇게 만들어진 영상은 현재 인스타그램과 유튜브에 공유되고 있습니다. </p>\n<h4 id=\"Instagram\"><a href=\"#Instagram\" class=\"headerlink\" title=\"Instagram\"></a>Instagram</h4><p>원래 가지고 있던 계정은 비공개 상태였기에 새로운 계정을 만들었습니다. <a href=\"https://www.instagram.com/joeun_surf/\" target=\"_blank\" rel=\"noopener\">joeun_surf</a>라는 계정입니다. (개인 계정이 joeun_ha 입니다. 나름대로 작명 규칙을 가지고 있는 샘입니다. 다음 계정은 joeun_something 이겠지요.) ‘카버보드’, ‘랜드서핑’과 같은 태그를 공유하는 이들을 팔로우하고 좋아요를 누르며 활동을 했더니 팔로워가 생깁니다. 글을 작성하는 현재 개인 계정보다 많은 인원인 425명이 joeun_surf를 팔로우하고 있습니다.</p>\n<div class=\"instagram-wrapper\"><blockquote class=\"instagram-media\" data-instgrm-captioned data-instgrm-version=\"7\" style=\" background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px auto; padding:0; width:99.375%; width:-webkit-calc(100%- 2px); width:calc(100% - 2px);\"><div style=\"padding:8px;\"> <div style=\" background:#F8F8F8; line-height:0; margin-top:40px; padding:50.0% 0; text-align:center; width:100%;\"> <div style=\" background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAMUExURczMzPf399fX1+bm5mzY9AMAAADiSURBVDjLvZXbEsMgCES5/P8/t9FuRVCRmU73JWlzosgSIIZURCjo/ad+EQJJB4Hv8BFt+IDpQoCx1wjOSBFhh2XssxEIYn3ulI/6MNReE07UIWJEv8UEOWDS88LY97kqyTliJKKtuYBbruAyVh5wOHiXmpi5we58Ek028czwyuQdLKPG1Bkb4NnM+VeAnfHqn1k4+GPT6uGQcvu2h2OVuIf/gWUFyy8OWEpdyZSa3aVCqpVoVvzZZ2VTnn2wU8qzVjDDetO90GSy9mVLqtgYSy231MxrY6I2gGqjrTY0L8fxCxfCBbhWrsYYAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;\"></div></div><p style=\" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;\"><a href=\"https://www.instagram.com/p/BTyyuv_lKOl/\" style=\" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none;\" target=\"_blank\"></a></p></div></blockquote></div><script async defer src=\"//platform.instagram.com/en_US/embeds.js\"></script>\n\n<p>보드를 탄 첫날 찍어 올린 영상입니다. 신대방 역 아래에 자전거 연습장(자연장)에서 찍었습니다. 하루종일 스윙을 연습해서 앞으로 나갈 수 있었습니다.</p>\n<div class=\"instagram-wrapper\"><blockquote class=\"instagram-media\" data-instgrm-captioned data-instgrm-version=\"7\" style=\" background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px auto; padding:0; width:99.375%; width:-webkit-calc(100%- 2px); width:calc(100% - 2px);\"><div style=\"padding:8px;\"> <div style=\" background:#F8F8F8; line-height:0; margin-top:40px; padding:50.0% 0; text-align:center; width:100%;\"> <div style=\" background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAMUExURczMzPf399fX1+bm5mzY9AMAAADiSURBVDjLvZXbEsMgCES5/P8/t9FuRVCRmU73JWlzosgSIIZURCjo/ad+EQJJB4Hv8BFt+IDpQoCx1wjOSBFhh2XssxEIYn3ulI/6MNReE07UIWJEv8UEOWDS88LY97kqyTliJKKtuYBbruAyVh5wOHiXmpi5we58Ek028czwyuQdLKPG1Bkb4NnM+VeAnfHqn1k4+GPT6uGQcvu2h2OVuIf/gWUFyy8OWEpdyZSa3aVCqpVoVvzZZ2VTnn2wU8qzVjDDetO90GSy9mVLqtgYSy231MxrY6I2gGqjrTY0L8fxCxfCBbhWrsYYAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;\"></div></div><p style=\" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;\"><a href=\"https://www.instagram.com/p/BbruxnFl3xP/\" style=\" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none;\" target=\"_blank\"></a></p></div></blockquote></div><script async defer src=\"//platform.instagram.com/en_US/embeds.js\"></script>\n\n<p>최근에 올린 다운힐 영상입니다. 반포 달빛 광장 진입로에 있는 다운힐 스팟입니다. 겨울에 딱 좋은 스팟입니다. 첫날과 확연히 달라졌죠?</p>\n<h4 id=\"Youtube\"><a href=\"#Youtube\" class=\"headerlink\" title=\"Youtube\"></a>Youtube</h4><p>원래 의도는 조금 더 긴 영상(1분 이상)을 업로드하는 것이 목적이었습니다. 하지만 1분 이상의 영상을 만들 정도의 집중력이 현재로선 없다는걸 알게 되었습니다. 인스타에 올린 영상 중에서 조금 정돈된 영상을 유튜브에 담고 있습니다. 페이스북이나 인스타그램에 공유할 수 없는 점 때문에 팔로워를 늘려가는게 쉽지 않습니다. 조회수도 107명이 최대입니다. 그 영상이 아래의 영상입니다. </p>\n<div class=\"video-container\"><iframe src=\"//www.youtube.com/embed/isrTmfZu9dY\" frameborder=\"0\" allowfullscreen></iframe></div>\n\n<p>유튜브에 처음 올렸던 영상입니다. 지금의 주행과는 차이가 있습니다. 현재까지 가장 마음에 드는 영상은 상해에서 촬영한 영상입니다. 상해의 주요 랜드마크를 돌면서 영상을 담았습니다. 고프로(GoPro, Hero6)를 사용한 첫번째 영상입니다.</p>\n<div class=\"video-container\"><iframe src=\"//www.youtube.com/embed/MZH_3kNNGg0\" frameborder=\"0\" allowfullscreen></iframe></div>\n\n\n<h4 id=\"GoPro\"><a href=\"#GoPro\" class=\"headerlink\" title=\"GoPro\"></a>GoPro</h4><p>고프로보다는 소니의 액션캠이 낫다고 생각했습니다. 야간 촬영이나 손떨림방지 기능이 훨씬 낫다고 알고 있었습니다. 하지만 면세점의 유혹을 떨쳐버리지 못했습니다. 인기 마운트인 3-Way를 포함해서 원가가 70만원에 가까운 제품을 인터넷 면세점의 쿠폰과 면세 혜택을 통해 48만원에 구매할 수 있는 기회를 저버리기 쉽지 않았습니다. 상해로 떠나는 길에 고프로를 구매했습니다. 덕분에 더 좋은 영상을 많이 담을 수 있었습니다. 기회가 되면 제품에 대한 피드백을 하겠지만 완전 추천하는 제품이라고 말하긴 어렵습니다. 소프트웨어가 불안정합니다. 그럼에도 하드웨어는 훌륭합니다. 좋은 영상을 담아주면 그걸로 제 역할은 다한 것이죠. </p>\n<h2 id=\"함께하는-사람들-Landsurfers\"><a href=\"#함께하는-사람들-Landsurfers\" class=\"headerlink\" title=\"함께하는 사람들, Landsurfers\"></a>함께하는 사람들, Landsurfers</h2><p>지난 5월 1일, 네이버 카페 ‘<a href=\"http://cafe.naver.com/landsurfers\" target=\"_blank\" rel=\"noopener\">랜드서퍼스</a>‘가 오픈했습니다. 그리고 현재 1,133명이 활동하고 있는 ‘가지4단계’의 건실한 카페가 되었습니다. 저를 랜드서핑 세계로 이끌어준 형님이 시작한 카페입니다. 이 분들과 함께 매주 랜드서핑을 즐기고 있습니다. 저는 반포와 분당 정모에 참석합니다. 반포 정모는 랜드서퍼스 메인 정모에 해당하는 정모로 매주 목, 일 저녁에 모입니다. 분당은 월, 목에 모입니다. 평일에는 분당 모임에 가고 일요일은 반포 모임에 참석하고 있습니다. </p>\n<p>함께하는 사람들이 있으니 자극이 되고 꾸준히 활동을 이어갈 수 있어 참 좋습니다. 특히나 서로 영상을 찍어주고 피드백을 해주면 실력 향상에 도움이 됩니다. 참 재밌는 점은 랜드서핑이라는 이름으로 모인 이 사람들이 정말 순수하다는 점입니다. 모여서 보드만 타고 헤어집니다. 누가 그렇게 하자고 제안한 바는 아니지만 다들 보드를 즐겁게 타고 싶은 그 마음으로 모였기 때문에 그것으로 충분한 듯합니다. 이들과 함께하는 시간이 점점 더 좋아집니다. </p>\n<h2 id=\"꿈꾸는-랜드서퍼\"><a href=\"#꿈꾸는-랜드서퍼\" class=\"headerlink\" title=\"꿈꾸는 랜드서퍼\"></a>꿈꾸는 랜드서퍼</h2><p>‘우아한 라이딩을 꿈꾸는 분당의 랜드서퍼’ 인스타 계정의 소개글 입니다. 처음에는 도무지 우아하게 탈 수가 없어서 우아한 라이딩을 꿈만 꿨습니다. 하지만 지금은 가끔 우아하다는 소리를 듣습니다. 꿈을 이뤄가는 중인 것입니다. 그리고 올해 해외 랜드마크에서 보드를 타보겠다는 꿈을 이루고 왔습니다. 내년에는 어떤 꿈을 이룰 수 있을까요? 개인적으로는 작은 것이라도 협찬을 받아보고 싶습니다. 보드를 탈때 입는 옷이나 신발이면 좋겠네요. 그리고 잡지나 블로그에 인터뷰를 할 수 있으면 좋겠습니다. 개발자로서 좋은 취미를 가지게 된 이야기, 랜드서핑에 대한 이야기를 나눌 수 있는 잡지면 좋을 것 같습니다. 내년이 기대되네요.</p>\n"},{"title":"회고 - 벌써 일년","date":"2017-07-17T14:11:11.000Z","_content":"_지난 1년을 되돌아보자_\n\n## 입사\n작년 7월 17일에 마켓프레스에 첫 출근을 했다. 입사하게 된 과정은 지금 생각해봐도 놀랍고 신기하다. 첫 출근보다 약 2개월 전인 5월 13일, 뜬금없이 받은 메일 한 통이 날아왔다. 팀장님이었다. 간단한 자기소개와 함께 이런 말을 남겼다. \"_꼭 만나보고 싶군요! 왜냐면 하조은님이 꼭 만나고 싶은 회사고 꼭 만나고 싶은 사람일 겁니다. ^^b_\" 지금 생각해봐도 참 황당한 메일이다. 헛웃음이 나온다. (지금은 팀장님이 가졌던 자신감의 이유를 알고 있다.) 다짜고짜 내가 만나고 싶을 회사라고 주장하는 사람으로부터 메일을 받았으니 황당했을 법하다. 그런데 나는 또 15분만에 답장을 했고 몇 차례 메일을 주고받은 뒤 나는 곧장 서울로 향했다. 그리고 다시 포항으로 내려가는 길, 나는 그렇게 첫 메일을 받고 92시간 만에 마켓프레스에서 일하기로 했다. 정작 첫 출근에 2개월 남짓 걸린 이유는 졸업을 위해 이수해야 하는 수업이 있었기 때문이다.\n\n## 공부\n졸업 이후에 나는 더 많은 공부를 하게 된 것 같다. 컴퓨터 공학을 전공한 것이 분명한데 모르는 것이 너무 많았다. 특히나 웹에 관해서는 거의 무지했다. 웹 서비스를 개발하는 회사에 입사했으니 웹을 공부해야 했고 그에 맞춰 필요한 언어도 공부해야 했다. 자바스크립트(JavaScript)였다. 그때까지만 해도 나의 주 언어는 C였다. 자바를 배운 적도 있고 C++도 배웠지만, 첫 언어인 C만큼 잘하진 못했다. C도 나름대로 잘하는 편이었는데, 자바스크립트는 전혀 다른 느낌이었다. 처음부터 배웠다. 이전에 공부해본답시고 사둔 책들과 회사에 있는 책을 모두 읽었다. 코뿔소 책으로 알려진 [자바스크립트 완벽 가이드](http://book.naver.com/bookdb/book_detail.nhn?bid=4561033), 더글라스 크락포드의 [자바스크립트 핵심 가이드](http://book.naver.com/bookdb/book_detail.nhn?bid=4774270), 만인의 모니터 받침대인 노란책 [프론트엔드 개발자를 위한 자바스크립트 프로그래밍](http://book.naver.com/bookdb/book_detail.nhn?bid=7204207), 존 레식 형님의 [자바스크립트 닌자 비급](http://book.naver.com/bookdb/book_detail.nhn?bid=7466145) 등을 섭렵했다. 책을 읽으면서 코드를 직접 타이핑하고 요약했다. 그 내용을 [Today I Learned(TIL)](https://github.com/joeunha/TIL)과 [Javascript Jedi](https://github.com/joeunha/javascript-jedi)에 정리했다. 100일간 일일 커밋도 했다. 그렇게 자바스크립트가 익숙해지기 시작했다.\n\n## 실전\n처음으로 동료(지금은 떠나버린 동료)와 함께 짝코딩([페어 프로그래밍 - Pair Programming](https://en.wikipedia.org/wiki/Pair_programming))을 했던 코드는 어디로 갔는지 모르겠다. github이 아닌 bitbucket에 프라이빗 저장소를 이용했는데 연습용 프로젝트였던 것 같다. 다른 사람 앞에서 코드를 짜는게 낯설었던 시기라 오타도 많이 났었다. (물론 지금도 팀장님이나 다른 고수분들 앞에서 코드를 짜려면 버벅거린다.) 그때 처음으로 누군가와 함께 코딩하는 것이 얼마나 유익한지 알게 되었던 것 같다. 그래서 이후에 대학교 친구들과도 그런 시간을 가져보려고 했지만 정작 자신의 일이 아니고, 주 사용 언어도 다르니 쉽지 않은 일이라는 것을 알게 되었다. 그래도 그 친구들과 한동안 ES6를 함께 공부했었다. 여하튼 실제로 무언가를 만드는 과정에서 공부라는 게 읽고 요약하는 것의 한계와 실행해보는 것의 이점을 다시금 깨달았다. 한 줄을 적더라도 내가 생각해낸 논리로 코드를 짜보는 게 가장 효과적인 학습이었다.\n\n종종 팀장님과 함께 코드를 짜는 일도 있었는데, 처음엔 몹시 버거웠다. 팀장님은 우아한 코드를 지향하시는데 내가 느끼기에 우아한 코드란 문법적으로 창의적이며, 논리적으로 깔끔하고, 짧은 코드를 의미했다. 당시 나에게 창의성과 논리적 탁월함은 없었고 짧은 코드는 가능했지만, 코드가 짧은 만큼 기능도 짧아서 쓸모없는 코드가 되어버리곤 했다. 결국 `if`와 `for`문의 향연이 될 수밖에 없었고 그 코드는 우아한 코드가 아니었다. 팀장님을 비롯한 팀의 선배들은 삼항 연산자를 즐겨 썼는데, 당시에 나는 그게 나쁜 습관이라고 생각했다. 학교에서 배운 바대로라면 읽기 쉬운 코드가 좋은 코드인데 삼항 연산자는 읽기가 너무 어려웠기 때문이다! 그런데 지금은 삼항 연산자가 없는 코드는 상상할 수도 없다. (삼항 연산자는 코드를 훨씬 짧게 만들어줄 뿐만 아니라 어디서나 사용 할 수 있기에 더 창의적인 표현이 가능한 사랑스러운 연산자가 아닐 수 없다) 물론 지금도 팀장님의 코드는 한 번에 따라가기 어렵다. 하지만 시간이 지나면 상당 부분 이해할 수 있으며, 요즘은 가끔 혼자서도 우아한 코드를 짤 수 있게 되었다. 우아한 코드를 짜고 나면 흥분해서 혼자 \"훌륭해\"라며 감탄하는 날이 잦아지고 있다.\n\n## 오픈소스\n우리 팀은 함수형 프로그래밍을 지향한다. 때문에 함수형 라이브러리를 사용하는데, __[Partial.js](https://github.com/marpple/partial.js)__라는 자체 제작 라이브러리를 사용한다. 이를 제작하는 과정에 나도 참여할 수 있었다. 이 전에는 팀에서 [abc.js](https://github.com/joeunha/abc-functional-javascript)라는 라이브러리를 만들기도 했는데, 이 라이브러리가 발전한 형태가 __Partial.js__다. 오픈소스로 공개해서 작업하다보니 많은 배움이 있었다. 특별히 문서 페이지를 만드는 작업을 도맡아서 했는데, 처음에는 정적 페이지를 처음부터 끝까지 다 구현하느라 정말 많이 배울 수 있었다. 특별히 코드 하이라이트 기능을 지원하는 [codemirror](https://codemirror.net/)를 사용해서 abc.js의 문서 페이지를 만들었었다. 이후에 Partial 프로젝트가 시작되면서 [partial.js의 문서 페이지](https://marpple.github.io/partial.js/docs/)도 만들었는데, 코드 실행까지 가능한 나름 제법 완성도 있는 문서 페이지였다. 하지만 단순한 HTML, CSS로 구성된 정적 페이지는 관리가 용이하지 않았기에 최종적으로 [Partial 프로젝트의 페이지](https://marpple.github.io/partial.js/)는 [hexo](https://hexo.io/) 라는 오픈소스를 이용했다. 덕분에 마크다운 문법으로 문서를 작성하고 편집할 수 있었다. hexo의 기본 테마를 바탕으로 상당 부분을 뜯어고쳐서 지금의 페이지를 만들었다. 그리고 요즘 우리 팀은 __don.js__ 라는 함수형 jQuery를 만들어 달러 `$`를 뺏어오려고 하고 있다. (Partial은 언더스코어 `_`를 네임스페이스로 쓰고 있다.)\n\n팀에서 직접 오픈소스를 만들다보니 다른 사람들의 코드를 구경할 일도 잦았다. [underscore.js](http://underscorejs.org/)나 [jQuery](http://jquery.com/)가 대표적이다. [Partial의 파이썬 버전](https://github.com/marpple/partial.py)을 구현하면서 살펴본 [underscore.py](https://github.com/serkanyersen/underscore.py)도 있다. 뒤의 두개는 객체지향적으로 구현되어 있는데 함수형과의 차이를 알 수 있었다. 코드로서의 오픈소스 뿐만 아니라 문서로서의 오픈소스에도 자주 접근했는데, 그중에 하나가 [DjangoGirls 튜토리얼](https://github.com/DjangoGirls/tutorial)이었다. 이 문서에는 풀리퀘스트를 날리기도 했다. 한글 문서에 문법나 띄어쓰기 오타를 고쳤다. 그리고 최근에는 don.js를 만들며 살펴보다가 [You Don't Need jQuery](https://github.com/oneuijs/You-Dont-Need-jQuery)에도 관여했다. (며칠보다가 알게된 점은 제이쿼리가 필요하지 않다고 말하기에는 이 문서가 충분하지 않다는 점이다.) 요즘은 이렇게 문서와 간단한 코드에 자주 접근하다보니 뭔가 글로벌한 개발자가 된 기분이다. (오늘은 제이쿼리에도 뭔가 문제가 있는 것 같아서 풀리퀘스트를 날렸는데, 10분도 안 돼서 리젝을 당하면서 글로벌한 개발자에 더욱 가까워졌다.)\n\n## 맺음\n글을 맺어야겠다. 7월 17일 11시 20분쯤 글을 적기 시작했는데, 적다 보니 12시 30분이 지났다. 지난 1년 간의 변화는 앞으로 있을 변화에 비해 별것 아닌 변화일 것이지만 지금의 나로서는 이 변화가 참 감사하다. 자바스크립트를 편하게 사용할 수 있게 되었고 하루종일 머리를 쥐어짜다가 보면 가끔씩 제법 우아한 코드를 작성할 수 있게 되었다. 파이썬, 엘릭서, 클로저를 공부했고 리액트 네이티브를 이용해 [앱](https://itunes.apple.com/kr/app/%EB%A7%88%ED%94%8C/id1196659118?mt=8)을 만들기도 했다. 친구들과 토이 프로젝트로 만든 [앱](https://itunes.apple.com/us/app/%EC%8B%9C%EC%9D%8C/id1209933766?mt=8)이 현재도 서비스되고 있으며, 서버와 클라이언트를 오가며 코드를 짤 수 있게 되었다. 무엇보다도 내가 속한 회사와 팀에 대한 확신이 생겼으며 특히 내가 공부하고 있는 언어와 분야가 잘 될 것이라는 기대가 커졌다. 팀장님이 집필한 책도 곧 나올 것이고 함수형 프로그래밍에 대한 관심도 커질 것 같다. 그때가 되면 당당하게 개발자로서 사람들 앞에 설 수 있는 개발자가 되기까지 더 열심히 머리를 쥐어짜야겠다.\n\n__놀라운 점: 이 블로그의 전신인 RABBYLAB이 시작한 날은 2015년 7월 17일이었다.__\n","source":"_posts/1-year-anniversary.md","raw":"---\ntitle: '회고 - 벌써 일년'\ndate: 2017-07-17 23:11:11\ncategories:\n  - view of value\ntags:\n  - retrospection\n  - anniversary\n  - 회고록\n---\n_지난 1년을 되돌아보자_\n\n## 입사\n작년 7월 17일에 마켓프레스에 첫 출근을 했다. 입사하게 된 과정은 지금 생각해봐도 놀랍고 신기하다. 첫 출근보다 약 2개월 전인 5월 13일, 뜬금없이 받은 메일 한 통이 날아왔다. 팀장님이었다. 간단한 자기소개와 함께 이런 말을 남겼다. \"_꼭 만나보고 싶군요! 왜냐면 하조은님이 꼭 만나고 싶은 회사고 꼭 만나고 싶은 사람일 겁니다. ^^b_\" 지금 생각해봐도 참 황당한 메일이다. 헛웃음이 나온다. (지금은 팀장님이 가졌던 자신감의 이유를 알고 있다.) 다짜고짜 내가 만나고 싶을 회사라고 주장하는 사람으로부터 메일을 받았으니 황당했을 법하다. 그런데 나는 또 15분만에 답장을 했고 몇 차례 메일을 주고받은 뒤 나는 곧장 서울로 향했다. 그리고 다시 포항으로 내려가는 길, 나는 그렇게 첫 메일을 받고 92시간 만에 마켓프레스에서 일하기로 했다. 정작 첫 출근에 2개월 남짓 걸린 이유는 졸업을 위해 이수해야 하는 수업이 있었기 때문이다.\n\n## 공부\n졸업 이후에 나는 더 많은 공부를 하게 된 것 같다. 컴퓨터 공학을 전공한 것이 분명한데 모르는 것이 너무 많았다. 특히나 웹에 관해서는 거의 무지했다. 웹 서비스를 개발하는 회사에 입사했으니 웹을 공부해야 했고 그에 맞춰 필요한 언어도 공부해야 했다. 자바스크립트(JavaScript)였다. 그때까지만 해도 나의 주 언어는 C였다. 자바를 배운 적도 있고 C++도 배웠지만, 첫 언어인 C만큼 잘하진 못했다. C도 나름대로 잘하는 편이었는데, 자바스크립트는 전혀 다른 느낌이었다. 처음부터 배웠다. 이전에 공부해본답시고 사둔 책들과 회사에 있는 책을 모두 읽었다. 코뿔소 책으로 알려진 [자바스크립트 완벽 가이드](http://book.naver.com/bookdb/book_detail.nhn?bid=4561033), 더글라스 크락포드의 [자바스크립트 핵심 가이드](http://book.naver.com/bookdb/book_detail.nhn?bid=4774270), 만인의 모니터 받침대인 노란책 [프론트엔드 개발자를 위한 자바스크립트 프로그래밍](http://book.naver.com/bookdb/book_detail.nhn?bid=7204207), 존 레식 형님의 [자바스크립트 닌자 비급](http://book.naver.com/bookdb/book_detail.nhn?bid=7466145) 등을 섭렵했다. 책을 읽으면서 코드를 직접 타이핑하고 요약했다. 그 내용을 [Today I Learned(TIL)](https://github.com/joeunha/TIL)과 [Javascript Jedi](https://github.com/joeunha/javascript-jedi)에 정리했다. 100일간 일일 커밋도 했다. 그렇게 자바스크립트가 익숙해지기 시작했다.\n\n## 실전\n처음으로 동료(지금은 떠나버린 동료)와 함께 짝코딩([페어 프로그래밍 - Pair Programming](https://en.wikipedia.org/wiki/Pair_programming))을 했던 코드는 어디로 갔는지 모르겠다. github이 아닌 bitbucket에 프라이빗 저장소를 이용했는데 연습용 프로젝트였던 것 같다. 다른 사람 앞에서 코드를 짜는게 낯설었던 시기라 오타도 많이 났었다. (물론 지금도 팀장님이나 다른 고수분들 앞에서 코드를 짜려면 버벅거린다.) 그때 처음으로 누군가와 함께 코딩하는 것이 얼마나 유익한지 알게 되었던 것 같다. 그래서 이후에 대학교 친구들과도 그런 시간을 가져보려고 했지만 정작 자신의 일이 아니고, 주 사용 언어도 다르니 쉽지 않은 일이라는 것을 알게 되었다. 그래도 그 친구들과 한동안 ES6를 함께 공부했었다. 여하튼 실제로 무언가를 만드는 과정에서 공부라는 게 읽고 요약하는 것의 한계와 실행해보는 것의 이점을 다시금 깨달았다. 한 줄을 적더라도 내가 생각해낸 논리로 코드를 짜보는 게 가장 효과적인 학습이었다.\n\n종종 팀장님과 함께 코드를 짜는 일도 있었는데, 처음엔 몹시 버거웠다. 팀장님은 우아한 코드를 지향하시는데 내가 느끼기에 우아한 코드란 문법적으로 창의적이며, 논리적으로 깔끔하고, 짧은 코드를 의미했다. 당시 나에게 창의성과 논리적 탁월함은 없었고 짧은 코드는 가능했지만, 코드가 짧은 만큼 기능도 짧아서 쓸모없는 코드가 되어버리곤 했다. 결국 `if`와 `for`문의 향연이 될 수밖에 없었고 그 코드는 우아한 코드가 아니었다. 팀장님을 비롯한 팀의 선배들은 삼항 연산자를 즐겨 썼는데, 당시에 나는 그게 나쁜 습관이라고 생각했다. 학교에서 배운 바대로라면 읽기 쉬운 코드가 좋은 코드인데 삼항 연산자는 읽기가 너무 어려웠기 때문이다! 그런데 지금은 삼항 연산자가 없는 코드는 상상할 수도 없다. (삼항 연산자는 코드를 훨씬 짧게 만들어줄 뿐만 아니라 어디서나 사용 할 수 있기에 더 창의적인 표현이 가능한 사랑스러운 연산자가 아닐 수 없다) 물론 지금도 팀장님의 코드는 한 번에 따라가기 어렵다. 하지만 시간이 지나면 상당 부분 이해할 수 있으며, 요즘은 가끔 혼자서도 우아한 코드를 짤 수 있게 되었다. 우아한 코드를 짜고 나면 흥분해서 혼자 \"훌륭해\"라며 감탄하는 날이 잦아지고 있다.\n\n## 오픈소스\n우리 팀은 함수형 프로그래밍을 지향한다. 때문에 함수형 라이브러리를 사용하는데, __[Partial.js](https://github.com/marpple/partial.js)__라는 자체 제작 라이브러리를 사용한다. 이를 제작하는 과정에 나도 참여할 수 있었다. 이 전에는 팀에서 [abc.js](https://github.com/joeunha/abc-functional-javascript)라는 라이브러리를 만들기도 했는데, 이 라이브러리가 발전한 형태가 __Partial.js__다. 오픈소스로 공개해서 작업하다보니 많은 배움이 있었다. 특별히 문서 페이지를 만드는 작업을 도맡아서 했는데, 처음에는 정적 페이지를 처음부터 끝까지 다 구현하느라 정말 많이 배울 수 있었다. 특별히 코드 하이라이트 기능을 지원하는 [codemirror](https://codemirror.net/)를 사용해서 abc.js의 문서 페이지를 만들었었다. 이후에 Partial 프로젝트가 시작되면서 [partial.js의 문서 페이지](https://marpple.github.io/partial.js/docs/)도 만들었는데, 코드 실행까지 가능한 나름 제법 완성도 있는 문서 페이지였다. 하지만 단순한 HTML, CSS로 구성된 정적 페이지는 관리가 용이하지 않았기에 최종적으로 [Partial 프로젝트의 페이지](https://marpple.github.io/partial.js/)는 [hexo](https://hexo.io/) 라는 오픈소스를 이용했다. 덕분에 마크다운 문법으로 문서를 작성하고 편집할 수 있었다. hexo의 기본 테마를 바탕으로 상당 부분을 뜯어고쳐서 지금의 페이지를 만들었다. 그리고 요즘 우리 팀은 __don.js__ 라는 함수형 jQuery를 만들어 달러 `$`를 뺏어오려고 하고 있다. (Partial은 언더스코어 `_`를 네임스페이스로 쓰고 있다.)\n\n팀에서 직접 오픈소스를 만들다보니 다른 사람들의 코드를 구경할 일도 잦았다. [underscore.js](http://underscorejs.org/)나 [jQuery](http://jquery.com/)가 대표적이다. [Partial의 파이썬 버전](https://github.com/marpple/partial.py)을 구현하면서 살펴본 [underscore.py](https://github.com/serkanyersen/underscore.py)도 있다. 뒤의 두개는 객체지향적으로 구현되어 있는데 함수형과의 차이를 알 수 있었다. 코드로서의 오픈소스 뿐만 아니라 문서로서의 오픈소스에도 자주 접근했는데, 그중에 하나가 [DjangoGirls 튜토리얼](https://github.com/DjangoGirls/tutorial)이었다. 이 문서에는 풀리퀘스트를 날리기도 했다. 한글 문서에 문법나 띄어쓰기 오타를 고쳤다. 그리고 최근에는 don.js를 만들며 살펴보다가 [You Don't Need jQuery](https://github.com/oneuijs/You-Dont-Need-jQuery)에도 관여했다. (며칠보다가 알게된 점은 제이쿼리가 필요하지 않다고 말하기에는 이 문서가 충분하지 않다는 점이다.) 요즘은 이렇게 문서와 간단한 코드에 자주 접근하다보니 뭔가 글로벌한 개발자가 된 기분이다. (오늘은 제이쿼리에도 뭔가 문제가 있는 것 같아서 풀리퀘스트를 날렸는데, 10분도 안 돼서 리젝을 당하면서 글로벌한 개발자에 더욱 가까워졌다.)\n\n## 맺음\n글을 맺어야겠다. 7월 17일 11시 20분쯤 글을 적기 시작했는데, 적다 보니 12시 30분이 지났다. 지난 1년 간의 변화는 앞으로 있을 변화에 비해 별것 아닌 변화일 것이지만 지금의 나로서는 이 변화가 참 감사하다. 자바스크립트를 편하게 사용할 수 있게 되었고 하루종일 머리를 쥐어짜다가 보면 가끔씩 제법 우아한 코드를 작성할 수 있게 되었다. 파이썬, 엘릭서, 클로저를 공부했고 리액트 네이티브를 이용해 [앱](https://itunes.apple.com/kr/app/%EB%A7%88%ED%94%8C/id1196659118?mt=8)을 만들기도 했다. 친구들과 토이 프로젝트로 만든 [앱](https://itunes.apple.com/us/app/%EC%8B%9C%EC%9D%8C/id1209933766?mt=8)이 현재도 서비스되고 있으며, 서버와 클라이언트를 오가며 코드를 짤 수 있게 되었다. 무엇보다도 내가 속한 회사와 팀에 대한 확신이 생겼으며 특히 내가 공부하고 있는 언어와 분야가 잘 될 것이라는 기대가 커졌다. 팀장님이 집필한 책도 곧 나올 것이고 함수형 프로그래밍에 대한 관심도 커질 것 같다. 그때가 되면 당당하게 개발자로서 사람들 앞에 설 수 있는 개발자가 되기까지 더 열심히 머리를 쥐어짜야겠다.\n\n__놀라운 점: 이 블로그의 전신인 RABBYLAB이 시작한 날은 2015년 7월 17일이었다.__\n","slug":"1-year-anniversary","published":1,"updated":"2020-02-09T14:20:01.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9ii0097dirvb1t5lodn","content":"<p><em>지난 1년을 되돌아보자</em></p>\n<h2 id=\"입사\"><a href=\"#입사\" class=\"headerlink\" title=\"입사\"></a>입사</h2><p>작년 7월 17일에 마켓프레스에 첫 출근을 했다. 입사하게 된 과정은 지금 생각해봐도 놀랍고 신기하다. 첫 출근보다 약 2개월 전인 5월 13일, 뜬금없이 받은 메일 한 통이 날아왔다. 팀장님이었다. 간단한 자기소개와 함께 이런 말을 남겼다. “<em>꼭 만나보고 싶군요! 왜냐면 하조은님이 꼭 만나고 싶은 회사고 꼭 만나고 싶은 사람일 겁니다. ^^b</em>“ 지금 생각해봐도 참 황당한 메일이다. 헛웃음이 나온다. (지금은 팀장님이 가졌던 자신감의 이유를 알고 있다.) 다짜고짜 내가 만나고 싶을 회사라고 주장하는 사람으로부터 메일을 받았으니 황당했을 법하다. 그런데 나는 또 15분만에 답장을 했고 몇 차례 메일을 주고받은 뒤 나는 곧장 서울로 향했다. 그리고 다시 포항으로 내려가는 길, 나는 그렇게 첫 메일을 받고 92시간 만에 마켓프레스에서 일하기로 했다. 정작 첫 출근에 2개월 남짓 걸린 이유는 졸업을 위해 이수해야 하는 수업이 있었기 때문이다.</p>\n<h2 id=\"공부\"><a href=\"#공부\" class=\"headerlink\" title=\"공부\"></a>공부</h2><p>졸업 이후에 나는 더 많은 공부를 하게 된 것 같다. 컴퓨터 공학을 전공한 것이 분명한데 모르는 것이 너무 많았다. 특히나 웹에 관해서는 거의 무지했다. 웹 서비스를 개발하는 회사에 입사했으니 웹을 공부해야 했고 그에 맞춰 필요한 언어도 공부해야 했다. 자바스크립트(JavaScript)였다. 그때까지만 해도 나의 주 언어는 C였다. 자바를 배운 적도 있고 C++도 배웠지만, 첫 언어인 C만큼 잘하진 못했다. C도 나름대로 잘하는 편이었는데, 자바스크립트는 전혀 다른 느낌이었다. 처음부터 배웠다. 이전에 공부해본답시고 사둔 책들과 회사에 있는 책을 모두 읽었다. 코뿔소 책으로 알려진 <a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=4561033\" target=\"_blank\" rel=\"noopener\">자바스크립트 완벽 가이드</a>, 더글라스 크락포드의 <a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=4774270\" target=\"_blank\" rel=\"noopener\">자바스크립트 핵심 가이드</a>, 만인의 모니터 받침대인 노란책 <a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=7204207\" target=\"_blank\" rel=\"noopener\">프론트엔드 개발자를 위한 자바스크립트 프로그래밍</a>, 존 레식 형님의 <a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=7466145\" target=\"_blank\" rel=\"noopener\">자바스크립트 닌자 비급</a> 등을 섭렵했다. 책을 읽으면서 코드를 직접 타이핑하고 요약했다. 그 내용을 <a href=\"https://github.com/joeunha/TIL\" target=\"_blank\" rel=\"noopener\">Today I Learned(TIL)</a>과 <a href=\"https://github.com/joeunha/javascript-jedi\" target=\"_blank\" rel=\"noopener\">Javascript Jedi</a>에 정리했다. 100일간 일일 커밋도 했다. 그렇게 자바스크립트가 익숙해지기 시작했다.</p>\n<h2 id=\"실전\"><a href=\"#실전\" class=\"headerlink\" title=\"실전\"></a>실전</h2><p>처음으로 동료(지금은 떠나버린 동료)와 함께 짝코딩(<a href=\"https://en.wikipedia.org/wiki/Pair_programming\" target=\"_blank\" rel=\"noopener\">페어 프로그래밍 - Pair Programming</a>)을 했던 코드는 어디로 갔는지 모르겠다. github이 아닌 bitbucket에 프라이빗 저장소를 이용했는데 연습용 프로젝트였던 것 같다. 다른 사람 앞에서 코드를 짜는게 낯설었던 시기라 오타도 많이 났었다. (물론 지금도 팀장님이나 다른 고수분들 앞에서 코드를 짜려면 버벅거린다.) 그때 처음으로 누군가와 함께 코딩하는 것이 얼마나 유익한지 알게 되었던 것 같다. 그래서 이후에 대학교 친구들과도 그런 시간을 가져보려고 했지만 정작 자신의 일이 아니고, 주 사용 언어도 다르니 쉽지 않은 일이라는 것을 알게 되었다. 그래도 그 친구들과 한동안 ES6를 함께 공부했었다. 여하튼 실제로 무언가를 만드는 과정에서 공부라는 게 읽고 요약하는 것의 한계와 실행해보는 것의 이점을 다시금 깨달았다. 한 줄을 적더라도 내가 생각해낸 논리로 코드를 짜보는 게 가장 효과적인 학습이었다.</p>\n<p>종종 팀장님과 함께 코드를 짜는 일도 있었는데, 처음엔 몹시 버거웠다. 팀장님은 우아한 코드를 지향하시는데 내가 느끼기에 우아한 코드란 문법적으로 창의적이며, 논리적으로 깔끔하고, 짧은 코드를 의미했다. 당시 나에게 창의성과 논리적 탁월함은 없었고 짧은 코드는 가능했지만, 코드가 짧은 만큼 기능도 짧아서 쓸모없는 코드가 되어버리곤 했다. 결국 <code>if</code>와 <code>for</code>문의 향연이 될 수밖에 없었고 그 코드는 우아한 코드가 아니었다. 팀장님을 비롯한 팀의 선배들은 삼항 연산자를 즐겨 썼는데, 당시에 나는 그게 나쁜 습관이라고 생각했다. 학교에서 배운 바대로라면 읽기 쉬운 코드가 좋은 코드인데 삼항 연산자는 읽기가 너무 어려웠기 때문이다! 그런데 지금은 삼항 연산자가 없는 코드는 상상할 수도 없다. (삼항 연산자는 코드를 훨씬 짧게 만들어줄 뿐만 아니라 어디서나 사용 할 수 있기에 더 창의적인 표현이 가능한 사랑스러운 연산자가 아닐 수 없다) 물론 지금도 팀장님의 코드는 한 번에 따라가기 어렵다. 하지만 시간이 지나면 상당 부분 이해할 수 있으며, 요즘은 가끔 혼자서도 우아한 코드를 짤 수 있게 되었다. 우아한 코드를 짜고 나면 흥분해서 혼자 “훌륭해”라며 감탄하는 날이 잦아지고 있다.</p>\n<h2 id=\"오픈소스\"><a href=\"#오픈소스\" class=\"headerlink\" title=\"오픈소스\"></a>오픈소스</h2><p>우리 팀은 함수형 프로그래밍을 지향한다. 때문에 함수형 라이브러리를 사용하는데, <strong><a href=\"https://github.com/marpple/partial.js\" target=\"_blank\" rel=\"noopener\">Partial.js</a></strong>라는 자체 제작 라이브러리를 사용한다. 이를 제작하는 과정에 나도 참여할 수 있었다. 이 전에는 팀에서 <a href=\"https://github.com/joeunha/abc-functional-javascript\" target=\"_blank\" rel=\"noopener\">abc.js</a>라는 라이브러리를 만들기도 했는데, 이 라이브러리가 발전한 형태가 <strong>Partial.js</strong>다. 오픈소스로 공개해서 작업하다보니 많은 배움이 있었다. 특별히 문서 페이지를 만드는 작업을 도맡아서 했는데, 처음에는 정적 페이지를 처음부터 끝까지 다 구현하느라 정말 많이 배울 수 있었다. 특별히 코드 하이라이트 기능을 지원하는 <a href=\"https://codemirror.net/\" target=\"_blank\" rel=\"noopener\">codemirror</a>를 사용해서 abc.js의 문서 페이지를 만들었었다. 이후에 Partial 프로젝트가 시작되면서 <a href=\"https://marpple.github.io/partial.js/docs/\" target=\"_blank\" rel=\"noopener\">partial.js의 문서 페이지</a>도 만들었는데, 코드 실행까지 가능한 나름 제법 완성도 있는 문서 페이지였다. 하지만 단순한 HTML, CSS로 구성된 정적 페이지는 관리가 용이하지 않았기에 최종적으로 <a href=\"https://marpple.github.io/partial.js/\" target=\"_blank\" rel=\"noopener\">Partial 프로젝트의 페이지</a>는 <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">hexo</a> 라는 오픈소스를 이용했다. 덕분에 마크다운 문법으로 문서를 작성하고 편집할 수 있었다. hexo의 기본 테마를 바탕으로 상당 부분을 뜯어고쳐서 지금의 페이지를 만들었다. 그리고 요즘 우리 팀은 <strong>don.js</strong> 라는 함수형 jQuery를 만들어 달러 <code>$</code>를 뺏어오려고 하고 있다. (Partial은 언더스코어 <code>_</code>를 네임스페이스로 쓰고 있다.)</p>\n<p>팀에서 직접 오픈소스를 만들다보니 다른 사람들의 코드를 구경할 일도 잦았다. <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">underscore.js</a>나 <a href=\"http://jquery.com/\" target=\"_blank\" rel=\"noopener\">jQuery</a>가 대표적이다. <a href=\"https://github.com/marpple/partial.py\" target=\"_blank\" rel=\"noopener\">Partial의 파이썬 버전</a>을 구현하면서 살펴본 <a href=\"https://github.com/serkanyersen/underscore.py\" target=\"_blank\" rel=\"noopener\">underscore.py</a>도 있다. 뒤의 두개는 객체지향적으로 구현되어 있는데 함수형과의 차이를 알 수 있었다. 코드로서의 오픈소스 뿐만 아니라 문서로서의 오픈소스에도 자주 접근했는데, 그중에 하나가 <a href=\"https://github.com/DjangoGirls/tutorial\" target=\"_blank\" rel=\"noopener\">DjangoGirls 튜토리얼</a>이었다. 이 문서에는 풀리퀘스트를 날리기도 했다. 한글 문서에 문법나 띄어쓰기 오타를 고쳤다. 그리고 최근에는 don.js를 만들며 살펴보다가 <a href=\"https://github.com/oneuijs/You-Dont-Need-jQuery\" target=\"_blank\" rel=\"noopener\">You Don’t Need jQuery</a>에도 관여했다. (며칠보다가 알게된 점은 제이쿼리가 필요하지 않다고 말하기에는 이 문서가 충분하지 않다는 점이다.) 요즘은 이렇게 문서와 간단한 코드에 자주 접근하다보니 뭔가 글로벌한 개발자가 된 기분이다. (오늘은 제이쿼리에도 뭔가 문제가 있는 것 같아서 풀리퀘스트를 날렸는데, 10분도 안 돼서 리젝을 당하면서 글로벌한 개발자에 더욱 가까워졌다.)</p>\n<h2 id=\"맺음\"><a href=\"#맺음\" class=\"headerlink\" title=\"맺음\"></a>맺음</h2><p>글을 맺어야겠다. 7월 17일 11시 20분쯤 글을 적기 시작했는데, 적다 보니 12시 30분이 지났다. 지난 1년 간의 변화는 앞으로 있을 변화에 비해 별것 아닌 변화일 것이지만 지금의 나로서는 이 변화가 참 감사하다. 자바스크립트를 편하게 사용할 수 있게 되었고 하루종일 머리를 쥐어짜다가 보면 가끔씩 제법 우아한 코드를 작성할 수 있게 되었다. 파이썬, 엘릭서, 클로저를 공부했고 리액트 네이티브를 이용해 <a href=\"https://itunes.apple.com/kr/app/%EB%A7%88%ED%94%8C/id1196659118?mt=8\" target=\"_blank\" rel=\"noopener\">앱</a>을 만들기도 했다. 친구들과 토이 프로젝트로 만든 <a href=\"https://itunes.apple.com/us/app/%EC%8B%9C%EC%9D%8C/id1209933766?mt=8\" target=\"_blank\" rel=\"noopener\">앱</a>이 현재도 서비스되고 있으며, 서버와 클라이언트를 오가며 코드를 짤 수 있게 되었다. 무엇보다도 내가 속한 회사와 팀에 대한 확신이 생겼으며 특히 내가 공부하고 있는 언어와 분야가 잘 될 것이라는 기대가 커졌다. 팀장님이 집필한 책도 곧 나올 것이고 함수형 프로그래밍에 대한 관심도 커질 것 같다. 그때가 되면 당당하게 개발자로서 사람들 앞에 설 수 있는 개발자가 되기까지 더 열심히 머리를 쥐어짜야겠다.</p>\n<p><strong>놀라운 점: 이 블로그의 전신인 RABBYLAB이 시작한 날은 2015년 7월 17일이었다.</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>지난 1년을 되돌아보자</em></p>\n<h2 id=\"입사\"><a href=\"#입사\" class=\"headerlink\" title=\"입사\"></a>입사</h2><p>작년 7월 17일에 마켓프레스에 첫 출근을 했다. 입사하게 된 과정은 지금 생각해봐도 놀랍고 신기하다. 첫 출근보다 약 2개월 전인 5월 13일, 뜬금없이 받은 메일 한 통이 날아왔다. 팀장님이었다. 간단한 자기소개와 함께 이런 말을 남겼다. “<em>꼭 만나보고 싶군요! 왜냐면 하조은님이 꼭 만나고 싶은 회사고 꼭 만나고 싶은 사람일 겁니다. ^^b</em>“ 지금 생각해봐도 참 황당한 메일이다. 헛웃음이 나온다. (지금은 팀장님이 가졌던 자신감의 이유를 알고 있다.) 다짜고짜 내가 만나고 싶을 회사라고 주장하는 사람으로부터 메일을 받았으니 황당했을 법하다. 그런데 나는 또 15분만에 답장을 했고 몇 차례 메일을 주고받은 뒤 나는 곧장 서울로 향했다. 그리고 다시 포항으로 내려가는 길, 나는 그렇게 첫 메일을 받고 92시간 만에 마켓프레스에서 일하기로 했다. 정작 첫 출근에 2개월 남짓 걸린 이유는 졸업을 위해 이수해야 하는 수업이 있었기 때문이다.</p>\n<h2 id=\"공부\"><a href=\"#공부\" class=\"headerlink\" title=\"공부\"></a>공부</h2><p>졸업 이후에 나는 더 많은 공부를 하게 된 것 같다. 컴퓨터 공학을 전공한 것이 분명한데 모르는 것이 너무 많았다. 특히나 웹에 관해서는 거의 무지했다. 웹 서비스를 개발하는 회사에 입사했으니 웹을 공부해야 했고 그에 맞춰 필요한 언어도 공부해야 했다. 자바스크립트(JavaScript)였다. 그때까지만 해도 나의 주 언어는 C였다. 자바를 배운 적도 있고 C++도 배웠지만, 첫 언어인 C만큼 잘하진 못했다. C도 나름대로 잘하는 편이었는데, 자바스크립트는 전혀 다른 느낌이었다. 처음부터 배웠다. 이전에 공부해본답시고 사둔 책들과 회사에 있는 책을 모두 읽었다. 코뿔소 책으로 알려진 <a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=4561033\" target=\"_blank\" rel=\"noopener\">자바스크립트 완벽 가이드</a>, 더글라스 크락포드의 <a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=4774270\" target=\"_blank\" rel=\"noopener\">자바스크립트 핵심 가이드</a>, 만인의 모니터 받침대인 노란책 <a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=7204207\" target=\"_blank\" rel=\"noopener\">프론트엔드 개발자를 위한 자바스크립트 프로그래밍</a>, 존 레식 형님의 <a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=7466145\" target=\"_blank\" rel=\"noopener\">자바스크립트 닌자 비급</a> 등을 섭렵했다. 책을 읽으면서 코드를 직접 타이핑하고 요약했다. 그 내용을 <a href=\"https://github.com/joeunha/TIL\" target=\"_blank\" rel=\"noopener\">Today I Learned(TIL)</a>과 <a href=\"https://github.com/joeunha/javascript-jedi\" target=\"_blank\" rel=\"noopener\">Javascript Jedi</a>에 정리했다. 100일간 일일 커밋도 했다. 그렇게 자바스크립트가 익숙해지기 시작했다.</p>\n<h2 id=\"실전\"><a href=\"#실전\" class=\"headerlink\" title=\"실전\"></a>실전</h2><p>처음으로 동료(지금은 떠나버린 동료)와 함께 짝코딩(<a href=\"https://en.wikipedia.org/wiki/Pair_programming\" target=\"_blank\" rel=\"noopener\">페어 프로그래밍 - Pair Programming</a>)을 했던 코드는 어디로 갔는지 모르겠다. github이 아닌 bitbucket에 프라이빗 저장소를 이용했는데 연습용 프로젝트였던 것 같다. 다른 사람 앞에서 코드를 짜는게 낯설었던 시기라 오타도 많이 났었다. (물론 지금도 팀장님이나 다른 고수분들 앞에서 코드를 짜려면 버벅거린다.) 그때 처음으로 누군가와 함께 코딩하는 것이 얼마나 유익한지 알게 되었던 것 같다. 그래서 이후에 대학교 친구들과도 그런 시간을 가져보려고 했지만 정작 자신의 일이 아니고, 주 사용 언어도 다르니 쉽지 않은 일이라는 것을 알게 되었다. 그래도 그 친구들과 한동안 ES6를 함께 공부했었다. 여하튼 실제로 무언가를 만드는 과정에서 공부라는 게 읽고 요약하는 것의 한계와 실행해보는 것의 이점을 다시금 깨달았다. 한 줄을 적더라도 내가 생각해낸 논리로 코드를 짜보는 게 가장 효과적인 학습이었다.</p>\n<p>종종 팀장님과 함께 코드를 짜는 일도 있었는데, 처음엔 몹시 버거웠다. 팀장님은 우아한 코드를 지향하시는데 내가 느끼기에 우아한 코드란 문법적으로 창의적이며, 논리적으로 깔끔하고, 짧은 코드를 의미했다. 당시 나에게 창의성과 논리적 탁월함은 없었고 짧은 코드는 가능했지만, 코드가 짧은 만큼 기능도 짧아서 쓸모없는 코드가 되어버리곤 했다. 결국 <code>if</code>와 <code>for</code>문의 향연이 될 수밖에 없었고 그 코드는 우아한 코드가 아니었다. 팀장님을 비롯한 팀의 선배들은 삼항 연산자를 즐겨 썼는데, 당시에 나는 그게 나쁜 습관이라고 생각했다. 학교에서 배운 바대로라면 읽기 쉬운 코드가 좋은 코드인데 삼항 연산자는 읽기가 너무 어려웠기 때문이다! 그런데 지금은 삼항 연산자가 없는 코드는 상상할 수도 없다. (삼항 연산자는 코드를 훨씬 짧게 만들어줄 뿐만 아니라 어디서나 사용 할 수 있기에 더 창의적인 표현이 가능한 사랑스러운 연산자가 아닐 수 없다) 물론 지금도 팀장님의 코드는 한 번에 따라가기 어렵다. 하지만 시간이 지나면 상당 부분 이해할 수 있으며, 요즘은 가끔 혼자서도 우아한 코드를 짤 수 있게 되었다. 우아한 코드를 짜고 나면 흥분해서 혼자 “훌륭해”라며 감탄하는 날이 잦아지고 있다.</p>\n<h2 id=\"오픈소스\"><a href=\"#오픈소스\" class=\"headerlink\" title=\"오픈소스\"></a>오픈소스</h2><p>우리 팀은 함수형 프로그래밍을 지향한다. 때문에 함수형 라이브러리를 사용하는데, <strong><a href=\"https://github.com/marpple/partial.js\" target=\"_blank\" rel=\"noopener\">Partial.js</a></strong>라는 자체 제작 라이브러리를 사용한다. 이를 제작하는 과정에 나도 참여할 수 있었다. 이 전에는 팀에서 <a href=\"https://github.com/joeunha/abc-functional-javascript\" target=\"_blank\" rel=\"noopener\">abc.js</a>라는 라이브러리를 만들기도 했는데, 이 라이브러리가 발전한 형태가 <strong>Partial.js</strong>다. 오픈소스로 공개해서 작업하다보니 많은 배움이 있었다. 특별히 문서 페이지를 만드는 작업을 도맡아서 했는데, 처음에는 정적 페이지를 처음부터 끝까지 다 구현하느라 정말 많이 배울 수 있었다. 특별히 코드 하이라이트 기능을 지원하는 <a href=\"https://codemirror.net/\" target=\"_blank\" rel=\"noopener\">codemirror</a>를 사용해서 abc.js의 문서 페이지를 만들었었다. 이후에 Partial 프로젝트가 시작되면서 <a href=\"https://marpple.github.io/partial.js/docs/\" target=\"_blank\" rel=\"noopener\">partial.js의 문서 페이지</a>도 만들었는데, 코드 실행까지 가능한 나름 제법 완성도 있는 문서 페이지였다. 하지만 단순한 HTML, CSS로 구성된 정적 페이지는 관리가 용이하지 않았기에 최종적으로 <a href=\"https://marpple.github.io/partial.js/\" target=\"_blank\" rel=\"noopener\">Partial 프로젝트의 페이지</a>는 <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">hexo</a> 라는 오픈소스를 이용했다. 덕분에 마크다운 문법으로 문서를 작성하고 편집할 수 있었다. hexo의 기본 테마를 바탕으로 상당 부분을 뜯어고쳐서 지금의 페이지를 만들었다. 그리고 요즘 우리 팀은 <strong>don.js</strong> 라는 함수형 jQuery를 만들어 달러 <code>$</code>를 뺏어오려고 하고 있다. (Partial은 언더스코어 <code>_</code>를 네임스페이스로 쓰고 있다.)</p>\n<p>팀에서 직접 오픈소스를 만들다보니 다른 사람들의 코드를 구경할 일도 잦았다. <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">underscore.js</a>나 <a href=\"http://jquery.com/\" target=\"_blank\" rel=\"noopener\">jQuery</a>가 대표적이다. <a href=\"https://github.com/marpple/partial.py\" target=\"_blank\" rel=\"noopener\">Partial의 파이썬 버전</a>을 구현하면서 살펴본 <a href=\"https://github.com/serkanyersen/underscore.py\" target=\"_blank\" rel=\"noopener\">underscore.py</a>도 있다. 뒤의 두개는 객체지향적으로 구현되어 있는데 함수형과의 차이를 알 수 있었다. 코드로서의 오픈소스 뿐만 아니라 문서로서의 오픈소스에도 자주 접근했는데, 그중에 하나가 <a href=\"https://github.com/DjangoGirls/tutorial\" target=\"_blank\" rel=\"noopener\">DjangoGirls 튜토리얼</a>이었다. 이 문서에는 풀리퀘스트를 날리기도 했다. 한글 문서에 문법나 띄어쓰기 오타를 고쳤다. 그리고 최근에는 don.js를 만들며 살펴보다가 <a href=\"https://github.com/oneuijs/You-Dont-Need-jQuery\" target=\"_blank\" rel=\"noopener\">You Don’t Need jQuery</a>에도 관여했다. (며칠보다가 알게된 점은 제이쿼리가 필요하지 않다고 말하기에는 이 문서가 충분하지 않다는 점이다.) 요즘은 이렇게 문서와 간단한 코드에 자주 접근하다보니 뭔가 글로벌한 개발자가 된 기분이다. (오늘은 제이쿼리에도 뭔가 문제가 있는 것 같아서 풀리퀘스트를 날렸는데, 10분도 안 돼서 리젝을 당하면서 글로벌한 개발자에 더욱 가까워졌다.)</p>\n<h2 id=\"맺음\"><a href=\"#맺음\" class=\"headerlink\" title=\"맺음\"></a>맺음</h2><p>글을 맺어야겠다. 7월 17일 11시 20분쯤 글을 적기 시작했는데, 적다 보니 12시 30분이 지났다. 지난 1년 간의 변화는 앞으로 있을 변화에 비해 별것 아닌 변화일 것이지만 지금의 나로서는 이 변화가 참 감사하다. 자바스크립트를 편하게 사용할 수 있게 되었고 하루종일 머리를 쥐어짜다가 보면 가끔씩 제법 우아한 코드를 작성할 수 있게 되었다. 파이썬, 엘릭서, 클로저를 공부했고 리액트 네이티브를 이용해 <a href=\"https://itunes.apple.com/kr/app/%EB%A7%88%ED%94%8C/id1196659118?mt=8\" target=\"_blank\" rel=\"noopener\">앱</a>을 만들기도 했다. 친구들과 토이 프로젝트로 만든 <a href=\"https://itunes.apple.com/us/app/%EC%8B%9C%EC%9D%8C/id1209933766?mt=8\" target=\"_blank\" rel=\"noopener\">앱</a>이 현재도 서비스되고 있으며, 서버와 클라이언트를 오가며 코드를 짤 수 있게 되었다. 무엇보다도 내가 속한 회사와 팀에 대한 확신이 생겼으며 특히 내가 공부하고 있는 언어와 분야가 잘 될 것이라는 기대가 커졌다. 팀장님이 집필한 책도 곧 나올 것이고 함수형 프로그래밍에 대한 관심도 커질 것 같다. 그때가 되면 당당하게 개발자로서 사람들 앞에 설 수 있는 개발자가 되기까지 더 열심히 머리를 쥐어짜야겠다.</p>\n<p><strong>놀라운 점: 이 블로그의 전신인 RABBYLAB이 시작한 날은 2015년 7월 17일이었다.</strong></p>\n"},{"title":"오늘의 함수 - lazys","date":"2018-02-17T08:23:09.000Z","description":"지연 평가(Lazy Evaluation) 기법을 위한 함수들입니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## lazys\n\n오늘은 명절을 맞아(?) `lazys` 함수 가족을 소개합니다. `lazys`라고 이름 붙인걸 보고 눈치채신 분들도 계실 것 같습니다. 바로 '지연 평가(Lazy Evaluation)' 기법을 위한 함수들입니다. 느긋한 계산법이라고 불리기도 하는 이 기법을 [위키피디아](https://ko.wikipedia.org/wiki/느긋한_계산법)에서는 __계산의 결과값이 필요할 때까지 계산을 늦추는 기법__이라고 설명합니다. 또 이러한 기법을 사용하면 __필요없는 계산을 하지 않으므로 실행을 더 빠르게__할 수 있다고 설명하는군요. 어떤 상황인지 직접 살펴보겠습니다. \n\n(예제는 [함수형 JS 스터디 시즌2](https://github.com/joeunha/functional-js-study2)의 [6주차 미션](https://github.com/joeunha/functional-js-study2/issues/6)을 토대로 합니다. [partial.js](https://marpple.github.io/partial.js/)를 라이브러리로 사용합니다.)\n\n#### (1) 어제의 함수\n\n```javascript\nvar users = [\n  { name: 'ID', age: 32, city: 'seoul', blood: 'A' },\n  { name: 'BJ', age: 31, city: 'seoul', blood: 'O' },\n  { name: 'JM', age: 32, city: 'busan', blood: 'O' },\n  { name: 'PJ', age: 27, city: 'seongnam', blood: 'B' },\n  { name: 'HA', age: 27, city: 'seoul', blood: 'O' },\n  { name: 'JE', age: 27, city: 'seongnam', blood: 'O' },\n  { name: 'JI', age: 32, city: 'incheon', blood: 'A' },\n  { name: 'MP', age: 28, city: 'seoul', blood: 'O' },\n  { name: 'JY', age: 31, city: 'seoul', blood: 'O' },\n  { name: 'TH', age: 27, city: 'busan', blood: 'AB' },\n  { name: 'DS', age: 33, city: 'incheon', blood: 'O' },\n  { name: 'YJ', age: 24, city: 'busan', blood: 'O' },\n  { name: 'MB', age: 37, city: 'incheon', blood: 'B' },\n  { name: 'JJ', age: 29, city: 'busan', blood: 'A' },\n  { name: 'TU', age: 21, city: 'seoul', blood: 'O' },\n  { name: 'UB', age: 23, city: 'seongnam', blood: 'O' },\n];\n```\n\n위의 `users`로 __부산 외에 거주하면서 혈액형이 O형인 나이가 가장 많은 세 사람의 이름__을 찾아내야 하는 상황입니다.\n\n```javascript\n_.go(users,\n  _.sort_by(user => -user.age), // 나이가 많은 순서대로 정렬\n  _.reject(user => user.city === 'busan'), // 부산 외에 거주하면서\n  _.filter(user => user.blood === 'O'),  // 혈액형이 O형인\n  _.map(user => user.name),  // 사람의 이름\n  _.take(3), // 세개\n  console.log); // [\"DS\", \"BJ\", \"JY\"]\n```\n\n익숙한 함수들로 원하는 값을 쉽게 얻어냈습니다. 낯설게 느껴지는 함수가 있다면 정렬을 위해 사용한 `_.sort_by`와 배열 중 앞의 데이터만 뽑아내는 `_.take` 함수입니다. 사용법은 그리 어렵지 않습니다. `_.sort_by`의 경우 보조함수의 리턴 값을 기준으로 오름차순으로 정렬합니다. (음수가 리턴 값이니 결과는 내림차순이겠죠.) `_.take`는 `_.first` 함수의 또 다른 별칭입니다. 두번째 인자에 숫자를 넣으면 그만큼의 길이를 갖는 배열을 리턴합니다. 예제에선 3명을 원했으니 `_.take(3)`으로 사용됐습니다. 두 함수 모두 커링을 지원합니다. \n\n위와 같은 결과를 얻기 위해서 `_.reject`, `_.filter`, `_.map`은 위에서 내려주는 배열의 길이만큼 함수를 실행해서 조건을 검사하거나 값을 추출해야합니다. 그래서 총 36회의 함수 실행이 일어나죠.\n\n```javascript\nvar count = 0;\n\n_.go(users,\n  _.sort_by(user => -user.age),\n  _.reject(user => {\n    count++;\n    return user.city === 'busan'}),\n  _.filter(user => {\n    count++;\n    return user.blood === 'O'}), \n  _.map(user => {\n    count++;\n    return user.name}), \n  _.take(3),\n  console.log); // [\"DS\", \"BJ\", \"JY\"] \n\nconsole.log(count); // 36\n```\n\n위의 예제처럼 얻길 원하는 값이 몇개 되지 않을 때, 나머지에 대해서도 함수가 계산(evaluation)되는 것은 낭비라고 생각하는게 지연 평가의 등장 배경입니다. __필요한 값들만 우선 계산하고 나머지는 계산을 지연시켜서 필요하지 않다면 계산하지 않도록 하는 기법__이 지연 평가인 것입니다. 그럼 지연평가가 적용되면 어떻게 결과가 달라질까요?\n\n#### (2) 오늘의 함수\n```javascript\nvar count = 0;\n\n_.go(users,\n  _.sort_by(user => -user.age),\n  lazys.reject(user => {\n    count++;\n    return user.city === 'busan'}),\n  lazys.filter(user => {\n    count++;\n    return user.blood === 'O'}), \n  lazys.map(user => {\n    count++;\n    return user.name}), \n  lazys.take(3),\n  console.log); // [\"DS\", \"BJ\", \"JY\"]\n\nconsole.log(count); // 16\n```\n\n`lazys`라는 네임스페이스를 갖는 함수로 기존의 함수를 대체했습니다. (`_.sort_by`는 지연 평가 함수에 포함되지 않습니다.) 함수 실행 회수를 보니 16회 입니다. 같은 결과를 만들었음에도 20회나 적게 실행된 것입니다. 어떻게 구현되었기에 이와 같은 결과를 만들어내는지 살펴보겠습니다. 먼저 `map`, `filter`, `reject`의 구현입니다. \n\n```javascript\nlet lazys = {}; // 네임스페이스 정의\nfunction make_lazy(...fns) { // [1]\n  return list => { // [2]\n    if (list.is_lazy) return list.push(fns), list; // [3]\n    let lazy = [fns]; // [4]\n    lazy.data = list; // [5]\n    lazy.is_lazy = true; // [6]\n    return lazy; // [7]\n  }\n}\n\nlazys.map = fn => make_lazy(fn, _.map) // [8]\nlazys.filter = fn => make_lazy(fn, _.filter)\nlazys.reject = fn => make_lazy(fn, _.reject)\n```\n\n[1] `make_lazy` 함수는 `take`를 제외한 함수에서 사용하는 함수입니다. 이 함수는 `take`가 최종 계산에 사용할 `lazy`라는 배열을 만들어냅니다. \n[2] `make_lazy` 함수가 리턴하는 함수는 `list`를 인자로 받습니다. 이 `list`는 예제로 따지자면 `users`에 해당합니다.\n[3] 만약에 `list`가 `is_lazy`라는 값을 참으로 가지고 있다면, `list`에 처음에 받아둔 함수(`fns`)를 그대로 넣고 `list`를 리턴합니다. '`list`가 `is_lazy`라는 값을 참으로 가지고 있다'는 조건은 이 `list`가 `lazy`임을 의미합니다.\n[4] 실제 `lazy`가 새로 생성되는 경우는 `users`와 같은 데이터가 들어왔을 경우입니다. 이때는 받아둔 함수(`fns`)를 배열로 감싸서 `lazy`를 생성합니다. 이 데이터는 이후 `take`에 의해 계산됩니다.\n[5] 진짜로 가공해야할 데이터는 `lazy`에 붙여둡니다.\n[6] `lazy`가 진짜 `lazy`임을 남겨둡니다. [3]에서 검사할 수 있었던 이유입니다.\n[7] 완성된 `lazy`를 리턴합니다. \n[8] `map`, `filter`, `reject`가 같은 방식으로 만들어집니다. 어떻게 논리를 전개할지 정해둔 보조 함수(`fn`)를 받고 `make_lazy`에게 첫번째 인자로 보조 함수, 두번째 인자로 보조 함수가 처리되어야할 논리를 담고 있는 모체가 되는 함수 전달합니다. 이 인자가 [1]에서 `fns`가 배열의 형태로 사용됩니다.\n\n앞서 만들어진 세 함수는 `lazy`라는 데이터를 만들어 `take`에 전달하는 역할을 합니다. __함수를 평가(계산)하지 않습니다.__ 실제 평가는 결과값의 양을 알고 있는 `take` 함수의 몫입니다. \n\n```javascript\nlazys.take = limit => { // [10]\n  return lazy => { // [11]\n    let i = -1, ll = lazy.length, dl = lazy.data.length, res = [];\n    while (++i < dl) { // [12]\n      let j = 0, \n      v = lazy.data[i], // [13-1]\n      rev = lazy[j][1]([v], lazy[j][0])[0]; // [13-2]\n      \n      while (rev && ++j < ll) rev = lazy[j][1]([v], lazy[j][0])[0]; // [14]\n      if (rev) {\n        res.push(rev); // [15]\n        if (res.length === limit) return res; // [16]\n      }\n    }\n  }\n}\n```\n\n[10] `limit`은 결과값의 양을 의미합니다. `lazy.take(3)`으로 호출된 오늘의 예제에서는 세개의 데이터가 채워지면 평가를 종료합니다.\n[11] 앞선 함수들이 만들어낸 `lazy`를 인자로 받습니다.\n[12] `lazt.data`에 붙어온 데이터의 길이만큼 반복합니다.\n[13-1] `v`는 `lazt.data`에서 꺼낸 하나의 값입니다. `users` 데이터의 경우로 보자면 `i`가 0일때, `v`는 `{ name: 'ID', age: 32, city: 'seoul', blood: 'A' }`와 같습니다.\n[13-2] `rev`는 [3]과 [4]에서 `lazy`로 추가된 함수들에 의해 평가된 결과값입니다. `users` 데이터의 경우로 보자면 `i`가 0일때, `_.reject([v], user => user.city === 'busan')`에 의해 평가되고 첫번째 인자를 꺼낸 결과인 `rev`는 `v`와 같은 값을 가진 상태가 됩니다. \n[14] `rev`의 결과가 존재하고 `lazy`의 길이보다 적을 때까지 `lazy`의 함수들을 꺼내 평가합니다. `rev`로 반복의 여부를 검사함으로 불필요한 평가를 하지 않을 수 있습니다.\n[15] 반복문 이후에도 `rev`가 값으로 존재한다면(`undefined`가 아니라면) 결과값 `res`에 넣습니다. \n[16] `res`의 길이가 원하는만큼 채워지면 결과를 리턴합니다. ","source":"_posts/daily-fp-17.md","raw":"---\ntitle: '오늘의 함수 - lazys'\ndate: 2018-02-17 17:23:09\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: 지연 평가(Lazy Evaluation) 기법을 위한 함수들입니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## lazys\n\n오늘은 명절을 맞아(?) `lazys` 함수 가족을 소개합니다. `lazys`라고 이름 붙인걸 보고 눈치채신 분들도 계실 것 같습니다. 바로 '지연 평가(Lazy Evaluation)' 기법을 위한 함수들입니다. 느긋한 계산법이라고 불리기도 하는 이 기법을 [위키피디아](https://ko.wikipedia.org/wiki/느긋한_계산법)에서는 __계산의 결과값이 필요할 때까지 계산을 늦추는 기법__이라고 설명합니다. 또 이러한 기법을 사용하면 __필요없는 계산을 하지 않으므로 실행을 더 빠르게__할 수 있다고 설명하는군요. 어떤 상황인지 직접 살펴보겠습니다. \n\n(예제는 [함수형 JS 스터디 시즌2](https://github.com/joeunha/functional-js-study2)의 [6주차 미션](https://github.com/joeunha/functional-js-study2/issues/6)을 토대로 합니다. [partial.js](https://marpple.github.io/partial.js/)를 라이브러리로 사용합니다.)\n\n#### (1) 어제의 함수\n\n```javascript\nvar users = [\n  { name: 'ID', age: 32, city: 'seoul', blood: 'A' },\n  { name: 'BJ', age: 31, city: 'seoul', blood: 'O' },\n  { name: 'JM', age: 32, city: 'busan', blood: 'O' },\n  { name: 'PJ', age: 27, city: 'seongnam', blood: 'B' },\n  { name: 'HA', age: 27, city: 'seoul', blood: 'O' },\n  { name: 'JE', age: 27, city: 'seongnam', blood: 'O' },\n  { name: 'JI', age: 32, city: 'incheon', blood: 'A' },\n  { name: 'MP', age: 28, city: 'seoul', blood: 'O' },\n  { name: 'JY', age: 31, city: 'seoul', blood: 'O' },\n  { name: 'TH', age: 27, city: 'busan', blood: 'AB' },\n  { name: 'DS', age: 33, city: 'incheon', blood: 'O' },\n  { name: 'YJ', age: 24, city: 'busan', blood: 'O' },\n  { name: 'MB', age: 37, city: 'incheon', blood: 'B' },\n  { name: 'JJ', age: 29, city: 'busan', blood: 'A' },\n  { name: 'TU', age: 21, city: 'seoul', blood: 'O' },\n  { name: 'UB', age: 23, city: 'seongnam', blood: 'O' },\n];\n```\n\n위의 `users`로 __부산 외에 거주하면서 혈액형이 O형인 나이가 가장 많은 세 사람의 이름__을 찾아내야 하는 상황입니다.\n\n```javascript\n_.go(users,\n  _.sort_by(user => -user.age), // 나이가 많은 순서대로 정렬\n  _.reject(user => user.city === 'busan'), // 부산 외에 거주하면서\n  _.filter(user => user.blood === 'O'),  // 혈액형이 O형인\n  _.map(user => user.name),  // 사람의 이름\n  _.take(3), // 세개\n  console.log); // [\"DS\", \"BJ\", \"JY\"]\n```\n\n익숙한 함수들로 원하는 값을 쉽게 얻어냈습니다. 낯설게 느껴지는 함수가 있다면 정렬을 위해 사용한 `_.sort_by`와 배열 중 앞의 데이터만 뽑아내는 `_.take` 함수입니다. 사용법은 그리 어렵지 않습니다. `_.sort_by`의 경우 보조함수의 리턴 값을 기준으로 오름차순으로 정렬합니다. (음수가 리턴 값이니 결과는 내림차순이겠죠.) `_.take`는 `_.first` 함수의 또 다른 별칭입니다. 두번째 인자에 숫자를 넣으면 그만큼의 길이를 갖는 배열을 리턴합니다. 예제에선 3명을 원했으니 `_.take(3)`으로 사용됐습니다. 두 함수 모두 커링을 지원합니다. \n\n위와 같은 결과를 얻기 위해서 `_.reject`, `_.filter`, `_.map`은 위에서 내려주는 배열의 길이만큼 함수를 실행해서 조건을 검사하거나 값을 추출해야합니다. 그래서 총 36회의 함수 실행이 일어나죠.\n\n```javascript\nvar count = 0;\n\n_.go(users,\n  _.sort_by(user => -user.age),\n  _.reject(user => {\n    count++;\n    return user.city === 'busan'}),\n  _.filter(user => {\n    count++;\n    return user.blood === 'O'}), \n  _.map(user => {\n    count++;\n    return user.name}), \n  _.take(3),\n  console.log); // [\"DS\", \"BJ\", \"JY\"] \n\nconsole.log(count); // 36\n```\n\n위의 예제처럼 얻길 원하는 값이 몇개 되지 않을 때, 나머지에 대해서도 함수가 계산(evaluation)되는 것은 낭비라고 생각하는게 지연 평가의 등장 배경입니다. __필요한 값들만 우선 계산하고 나머지는 계산을 지연시켜서 필요하지 않다면 계산하지 않도록 하는 기법__이 지연 평가인 것입니다. 그럼 지연평가가 적용되면 어떻게 결과가 달라질까요?\n\n#### (2) 오늘의 함수\n```javascript\nvar count = 0;\n\n_.go(users,\n  _.sort_by(user => -user.age),\n  lazys.reject(user => {\n    count++;\n    return user.city === 'busan'}),\n  lazys.filter(user => {\n    count++;\n    return user.blood === 'O'}), \n  lazys.map(user => {\n    count++;\n    return user.name}), \n  lazys.take(3),\n  console.log); // [\"DS\", \"BJ\", \"JY\"]\n\nconsole.log(count); // 16\n```\n\n`lazys`라는 네임스페이스를 갖는 함수로 기존의 함수를 대체했습니다. (`_.sort_by`는 지연 평가 함수에 포함되지 않습니다.) 함수 실행 회수를 보니 16회 입니다. 같은 결과를 만들었음에도 20회나 적게 실행된 것입니다. 어떻게 구현되었기에 이와 같은 결과를 만들어내는지 살펴보겠습니다. 먼저 `map`, `filter`, `reject`의 구현입니다. \n\n```javascript\nlet lazys = {}; // 네임스페이스 정의\nfunction make_lazy(...fns) { // [1]\n  return list => { // [2]\n    if (list.is_lazy) return list.push(fns), list; // [3]\n    let lazy = [fns]; // [4]\n    lazy.data = list; // [5]\n    lazy.is_lazy = true; // [6]\n    return lazy; // [7]\n  }\n}\n\nlazys.map = fn => make_lazy(fn, _.map) // [8]\nlazys.filter = fn => make_lazy(fn, _.filter)\nlazys.reject = fn => make_lazy(fn, _.reject)\n```\n\n[1] `make_lazy` 함수는 `take`를 제외한 함수에서 사용하는 함수입니다. 이 함수는 `take`가 최종 계산에 사용할 `lazy`라는 배열을 만들어냅니다. \n[2] `make_lazy` 함수가 리턴하는 함수는 `list`를 인자로 받습니다. 이 `list`는 예제로 따지자면 `users`에 해당합니다.\n[3] 만약에 `list`가 `is_lazy`라는 값을 참으로 가지고 있다면, `list`에 처음에 받아둔 함수(`fns`)를 그대로 넣고 `list`를 리턴합니다. '`list`가 `is_lazy`라는 값을 참으로 가지고 있다'는 조건은 이 `list`가 `lazy`임을 의미합니다.\n[4] 실제 `lazy`가 새로 생성되는 경우는 `users`와 같은 데이터가 들어왔을 경우입니다. 이때는 받아둔 함수(`fns`)를 배열로 감싸서 `lazy`를 생성합니다. 이 데이터는 이후 `take`에 의해 계산됩니다.\n[5] 진짜로 가공해야할 데이터는 `lazy`에 붙여둡니다.\n[6] `lazy`가 진짜 `lazy`임을 남겨둡니다. [3]에서 검사할 수 있었던 이유입니다.\n[7] 완성된 `lazy`를 리턴합니다. \n[8] `map`, `filter`, `reject`가 같은 방식으로 만들어집니다. 어떻게 논리를 전개할지 정해둔 보조 함수(`fn`)를 받고 `make_lazy`에게 첫번째 인자로 보조 함수, 두번째 인자로 보조 함수가 처리되어야할 논리를 담고 있는 모체가 되는 함수 전달합니다. 이 인자가 [1]에서 `fns`가 배열의 형태로 사용됩니다.\n\n앞서 만들어진 세 함수는 `lazy`라는 데이터를 만들어 `take`에 전달하는 역할을 합니다. __함수를 평가(계산)하지 않습니다.__ 실제 평가는 결과값의 양을 알고 있는 `take` 함수의 몫입니다. \n\n```javascript\nlazys.take = limit => { // [10]\n  return lazy => { // [11]\n    let i = -1, ll = lazy.length, dl = lazy.data.length, res = [];\n    while (++i < dl) { // [12]\n      let j = 0, \n      v = lazy.data[i], // [13-1]\n      rev = lazy[j][1]([v], lazy[j][0])[0]; // [13-2]\n      \n      while (rev && ++j < ll) rev = lazy[j][1]([v], lazy[j][0])[0]; // [14]\n      if (rev) {\n        res.push(rev); // [15]\n        if (res.length === limit) return res; // [16]\n      }\n    }\n  }\n}\n```\n\n[10] `limit`은 결과값의 양을 의미합니다. `lazy.take(3)`으로 호출된 오늘의 예제에서는 세개의 데이터가 채워지면 평가를 종료합니다.\n[11] 앞선 함수들이 만들어낸 `lazy`를 인자로 받습니다.\n[12] `lazt.data`에 붙어온 데이터의 길이만큼 반복합니다.\n[13-1] `v`는 `lazt.data`에서 꺼낸 하나의 값입니다. `users` 데이터의 경우로 보자면 `i`가 0일때, `v`는 `{ name: 'ID', age: 32, city: 'seoul', blood: 'A' }`와 같습니다.\n[13-2] `rev`는 [3]과 [4]에서 `lazy`로 추가된 함수들에 의해 평가된 결과값입니다. `users` 데이터의 경우로 보자면 `i`가 0일때, `_.reject([v], user => user.city === 'busan')`에 의해 평가되고 첫번째 인자를 꺼낸 결과인 `rev`는 `v`와 같은 값을 가진 상태가 됩니다. \n[14] `rev`의 결과가 존재하고 `lazy`의 길이보다 적을 때까지 `lazy`의 함수들을 꺼내 평가합니다. `rev`로 반복의 여부를 검사함으로 불필요한 평가를 하지 않을 수 있습니다.\n[15] 반복문 이후에도 `rev`가 값으로 존재한다면(`undefined`가 아니라면) 결과값 `res`에 넣습니다. \n[16] `res`의 길이가 원하는만큼 채워지면 결과를 리턴합니다. ","slug":"daily-fp-17","published":1,"updated":"2019-12-05T15:06:08.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9ik009adirvzfk5kacb","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"lazys\"><a href=\"#lazys\" class=\"headerlink\" title=\"lazys\"></a>lazys</h2><p>오늘은 명절을 맞아(?) <code>lazys</code> 함수 가족을 소개합니다. <code>lazys</code>라고 이름 붙인걸 보고 눈치채신 분들도 계실 것 같습니다. 바로 ‘지연 평가(Lazy Evaluation)’ 기법을 위한 함수들입니다. 느긋한 계산법이라고 불리기도 하는 이 기법을 <a href=\"https://ko.wikipedia.org/wiki/느긋한_계산법\" target=\"_blank\" rel=\"noopener\">위키피디아</a>에서는 <strong>계산의 결과값이 필요할 때까지 계산을 늦추는 기법</strong>이라고 설명합니다. 또 이러한 기법을 사용하면 <strong>필요없는 계산을 하지 않으므로 실행을 더 빠르게</strong>할 수 있다고 설명하는군요. 어떤 상황인지 직접 살펴보겠습니다. </p>\n<p>(예제는 <a href=\"https://github.com/joeunha/functional-js-study2\" target=\"_blank\" rel=\"noopener\">함수형 JS 스터디 시즌2</a>의 <a href=\"https://github.com/joeunha/functional-js-study2/issues/6\" target=\"_blank\" rel=\"noopener\">6주차 미션</a>을 토대로 합니다. <a href=\"https://marpple.github.io/partial.js/\" target=\"_blank\" rel=\"noopener\">partial.js</a>를 라이브러리로 사용합니다.)</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> users = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'ID'</span>, <span class=\"attr\">age</span>: <span class=\"number\">32</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seoul'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'A'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'BJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">31</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seoul'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JM'</span>, <span class=\"attr\">age</span>: <span class=\"number\">32</span>, <span class=\"attr\">city</span>: <span class=\"string\">'busan'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'PJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seongnam'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'B'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'HA'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seoul'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JE'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seongnam'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JI'</span>, <span class=\"attr\">age</span>: <span class=\"number\">32</span>, <span class=\"attr\">city</span>: <span class=\"string\">'incheon'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'A'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'MP'</span>, <span class=\"attr\">age</span>: <span class=\"number\">28</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seoul'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JY'</span>, <span class=\"attr\">age</span>: <span class=\"number\">31</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seoul'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'TH'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span>, <span class=\"attr\">city</span>: <span class=\"string\">'busan'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'AB'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'DS'</span>, <span class=\"attr\">age</span>: <span class=\"number\">33</span>, <span class=\"attr\">city</span>: <span class=\"string\">'incheon'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'YJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">24</span>, <span class=\"attr\">city</span>: <span class=\"string\">'busan'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'MB'</span>, <span class=\"attr\">age</span>: <span class=\"number\">37</span>, <span class=\"attr\">city</span>: <span class=\"string\">'incheon'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'B'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">29</span>, <span class=\"attr\">city</span>: <span class=\"string\">'busan'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'A'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'TU'</span>, <span class=\"attr\">age</span>: <span class=\"number\">21</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seoul'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'UB'</span>, <span class=\"attr\">age</span>: <span class=\"number\">23</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seongnam'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>위의 <code>users</code>로 <strong>부산 외에 거주하면서 혈액형이 O형인 나이가 가장 많은 세 사람의 이름</strong>을 찾아내야 하는 상황입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.go(users,</span><br><span class=\"line\">  _.sort_by(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> -user.age), <span class=\"comment\">// 나이가 많은 순서대로 정렬</span></span><br><span class=\"line\">  _.reject(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.city === <span class=\"string\">'busan'</span>), <span class=\"comment\">// 부산 외에 거주하면서</span></span><br><span class=\"line\">  _.filter(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.blood === <span class=\"string\">'O'</span>),  <span class=\"comment\">// 혈액형이 O형인</span></span><br><span class=\"line\">  _.map(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.name),  <span class=\"comment\">// 사람의 이름</span></span><br><span class=\"line\">  _.take(<span class=\"number\">3</span>), <span class=\"comment\">// 세개</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// [\"DS\", \"BJ\", \"JY\"]</span></span><br></pre></td></tr></table></figure>\n\n<p>익숙한 함수들로 원하는 값을 쉽게 얻어냈습니다. 낯설게 느껴지는 함수가 있다면 정렬을 위해 사용한 <code>_.sort_by</code>와 배열 중 앞의 데이터만 뽑아내는 <code>_.take</code> 함수입니다. 사용법은 그리 어렵지 않습니다. <code>_.sort_by</code>의 경우 보조함수의 리턴 값을 기준으로 오름차순으로 정렬합니다. (음수가 리턴 값이니 결과는 내림차순이겠죠.) <code>_.take</code>는 <code>_.first</code> 함수의 또 다른 별칭입니다. 두번째 인자에 숫자를 넣으면 그만큼의 길이를 갖는 배열을 리턴합니다. 예제에선 3명을 원했으니 <code>_.take(3)</code>으로 사용됐습니다. 두 함수 모두 커링을 지원합니다. </p>\n<p>위와 같은 결과를 얻기 위해서 <code>_.reject</code>, <code>_.filter</code>, <code>_.map</code>은 위에서 내려주는 배열의 길이만큼 함수를 실행해서 조건을 검사하거나 값을 추출해야합니다. 그래서 총 36회의 함수 실행이 일어나죠.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">_.go(users,</span><br><span class=\"line\">  _.sort_by(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> -user.age),</span><br><span class=\"line\">  _.reject(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user.city === <span class=\"string\">'busan'</span>&#125;),</span><br><span class=\"line\">  _.filter(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user.blood === <span class=\"string\">'O'</span>&#125;), </span><br><span class=\"line\">  _.map(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user.name&#125;), </span><br><span class=\"line\">  _.take(<span class=\"number\">3</span>),</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// [\"DS\", \"BJ\", \"JY\"] </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count); <span class=\"comment\">// 36</span></span><br></pre></td></tr></table></figure>\n\n<p>위의 예제처럼 얻길 원하는 값이 몇개 되지 않을 때, 나머지에 대해서도 함수가 계산(evaluation)되는 것은 낭비라고 생각하는게 지연 평가의 등장 배경입니다. <strong>필요한 값들만 우선 계산하고 나머지는 계산을 지연시켜서 필요하지 않다면 계산하지 않도록 하는 기법</strong>이 지연 평가인 것입니다. 그럼 지연평가가 적용되면 어떻게 결과가 달라질까요?</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">_.go(users,</span><br><span class=\"line\">  _.sort_by(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> -user.age),</span><br><span class=\"line\">  lazys.reject(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user.city === <span class=\"string\">'busan'</span>&#125;),</span><br><span class=\"line\">  lazys.filter(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user.blood === <span class=\"string\">'O'</span>&#125;), </span><br><span class=\"line\">  lazys.map(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user.name&#125;), </span><br><span class=\"line\">  lazys.take(<span class=\"number\">3</span>),</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// [\"DS\", \"BJ\", \"JY\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count); <span class=\"comment\">// 16</span></span><br></pre></td></tr></table></figure>\n\n<p><code>lazys</code>라는 네임스페이스를 갖는 함수로 기존의 함수를 대체했습니다. (<code>_.sort_by</code>는 지연 평가 함수에 포함되지 않습니다.) 함수 실행 회수를 보니 16회 입니다. 같은 결과를 만들었음에도 20회나 적게 실행된 것입니다. 어떻게 구현되었기에 이와 같은 결과를 만들어내는지 살펴보겠습니다. 먼저 <code>map</code>, <code>filter</code>, <code>reject</code>의 구현입니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> lazys = &#123;&#125;; <span class=\"comment\">// 네임스페이스 정의</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make_lazy</span>(<span class=\"params\">...fns</span>) </span>&#123; <span class=\"comment\">// [1]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">list</span> =&gt;</span> &#123; <span class=\"comment\">// [2]</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (list.is_lazy) <span class=\"keyword\">return</span> list.push(fns), list; <span class=\"comment\">// [3]</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> lazy = [fns]; <span class=\"comment\">// [4]</span></span><br><span class=\"line\">    lazy.data = list; <span class=\"comment\">// [5]</span></span><br><span class=\"line\">    lazy.is_lazy = <span class=\"literal\">true</span>; <span class=\"comment\">// [6]</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lazy; <span class=\"comment\">// [7]</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">lazys.map = <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> make_lazy(fn, _.map) <span class=\"comment\">// [8]</span></span><br><span class=\"line\">lazys.filter = <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> make_lazy(fn, _.filter)</span><br><span class=\"line\">lazys.reject = <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> make_lazy(fn, _.reject)</span><br></pre></td></tr></table></figure>\n\n<p>[1] <code>make_lazy</code> 함수는 <code>take</code>를 제외한 함수에서 사용하는 함수입니다. 이 함수는 <code>take</code>가 최종 계산에 사용할 <code>lazy</code>라는 배열을 만들어냅니다.<br>[2] <code>make_lazy</code> 함수가 리턴하는 함수는 <code>list</code>를 인자로 받습니다. 이 <code>list</code>는 예제로 따지자면 <code>users</code>에 해당합니다.<br>[3] 만약에 <code>list</code>가 <code>is_lazy</code>라는 값을 참으로 가지고 있다면, <code>list</code>에 처음에 받아둔 함수(<code>fns</code>)를 그대로 넣고 <code>list</code>를 리턴합니다. ‘<code>list</code>가 <code>is_lazy</code>라는 값을 참으로 가지고 있다’는 조건은 이 <code>list</code>가 <code>lazy</code>임을 의미합니다.<br>[4] 실제 <code>lazy</code>가 새로 생성되는 경우는 <code>users</code>와 같은 데이터가 들어왔을 경우입니다. 이때는 받아둔 함수(<code>fns</code>)를 배열로 감싸서 <code>lazy</code>를 생성합니다. 이 데이터는 이후 <code>take</code>에 의해 계산됩니다.<br>[5] 진짜로 가공해야할 데이터는 <code>lazy</code>에 붙여둡니다.<br>[6] <code>lazy</code>가 진짜 <code>lazy</code>임을 남겨둡니다. [3]에서 검사할 수 있었던 이유입니다.<br>[7] 완성된 <code>lazy</code>를 리턴합니다.<br>[8] <code>map</code>, <code>filter</code>, <code>reject</code>가 같은 방식으로 만들어집니다. 어떻게 논리를 전개할지 정해둔 보조 함수(<code>fn</code>)를 받고 <code>make_lazy</code>에게 첫번째 인자로 보조 함수, 두번째 인자로 보조 함수가 처리되어야할 논리를 담고 있는 모체가 되는 함수 전달합니다. 이 인자가 [1]에서 <code>fns</code>가 배열의 형태로 사용됩니다.</p>\n<p>앞서 만들어진 세 함수는 <code>lazy</code>라는 데이터를 만들어 <code>take</code>에 전달하는 역할을 합니다. <strong>함수를 평가(계산)하지 않습니다.</strong> 실제 평가는 결과값의 양을 알고 있는 <code>take</code> 함수의 몫입니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lazys.take = <span class=\"function\"><span class=\"params\">limit</span> =&gt;</span> &#123; <span class=\"comment\">// [10]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">lazy</span> =&gt;</span> &#123; <span class=\"comment\">// [11]</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">-1</span>, ll = lazy.length, dl = lazy.data.length, res = [];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (++i &lt; dl) &#123; <span class=\"comment\">// [12]</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> j = <span class=\"number\">0</span>, </span><br><span class=\"line\">      v = lazy.data[i], <span class=\"comment\">// [13-1]</span></span><br><span class=\"line\">      rev = lazy[j][<span class=\"number\">1</span>]([v], lazy[j][<span class=\"number\">0</span>])[<span class=\"number\">0</span>]; <span class=\"comment\">// [13-2]</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">while</span> (rev &amp;&amp; ++j &lt; ll) rev = lazy[j][<span class=\"number\">1</span>]([v], lazy[j][<span class=\"number\">0</span>])[<span class=\"number\">0</span>]; <span class=\"comment\">// [14]</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rev) &#123;</span><br><span class=\"line\">        res.push(rev); <span class=\"comment\">// [15]</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res.length === limit) <span class=\"keyword\">return</span> res; <span class=\"comment\">// [16]</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>[10] <code>limit</code>은 결과값의 양을 의미합니다. <code>lazy.take(3)</code>으로 호출된 오늘의 예제에서는 세개의 데이터가 채워지면 평가를 종료합니다.<br>[11] 앞선 함수들이 만들어낸 <code>lazy</code>를 인자로 받습니다.<br>[12] <code>lazt.data</code>에 붙어온 데이터의 길이만큼 반복합니다.<br>[13-1] <code>v</code>는 <code>lazt.data</code>에서 꺼낸 하나의 값입니다. <code>users</code> 데이터의 경우로 보자면 <code>i</code>가 0일때, <code>v</code>는 <code>{ name: &#39;ID&#39;, age: 32, city: &#39;seoul&#39;, blood: &#39;A&#39; }</code>와 같습니다.<br>[13-2] <code>rev</code>는 [3]과 [4]에서 <code>lazy</code>로 추가된 함수들에 의해 평가된 결과값입니다. <code>users</code> 데이터의 경우로 보자면 <code>i</code>가 0일때, <code>_.reject([v], user =&gt; user.city === &#39;busan&#39;)</code>에 의해 평가되고 첫번째 인자를 꺼낸 결과인 <code>rev</code>는 <code>v</code>와 같은 값을 가진 상태가 됩니다.<br>[14] <code>rev</code>의 결과가 존재하고 <code>lazy</code>의 길이보다 적을 때까지 <code>lazy</code>의 함수들을 꺼내 평가합니다. <code>rev</code>로 반복의 여부를 검사함으로 불필요한 평가를 하지 않을 수 있습니다.<br>[15] 반복문 이후에도 <code>rev</code>가 값으로 존재한다면(<code>undefined</code>가 아니라면) 결과값 <code>res</code>에 넣습니다.<br>[16] <code>res</code>의 길이가 원하는만큼 채워지면 결과를 리턴합니다. </p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"lazys\"><a href=\"#lazys\" class=\"headerlink\" title=\"lazys\"></a>lazys</h2><p>오늘은 명절을 맞아(?) <code>lazys</code> 함수 가족을 소개합니다. <code>lazys</code>라고 이름 붙인걸 보고 눈치채신 분들도 계실 것 같습니다. 바로 ‘지연 평가(Lazy Evaluation)’ 기법을 위한 함수들입니다. 느긋한 계산법이라고 불리기도 하는 이 기법을 <a href=\"https://ko.wikipedia.org/wiki/느긋한_계산법\" target=\"_blank\" rel=\"noopener\">위키피디아</a>에서는 <strong>계산의 결과값이 필요할 때까지 계산을 늦추는 기법</strong>이라고 설명합니다. 또 이러한 기법을 사용하면 <strong>필요없는 계산을 하지 않으므로 실행을 더 빠르게</strong>할 수 있다고 설명하는군요. 어떤 상황인지 직접 살펴보겠습니다. </p>\n<p>(예제는 <a href=\"https://github.com/joeunha/functional-js-study2\" target=\"_blank\" rel=\"noopener\">함수형 JS 스터디 시즌2</a>의 <a href=\"https://github.com/joeunha/functional-js-study2/issues/6\" target=\"_blank\" rel=\"noopener\">6주차 미션</a>을 토대로 합니다. <a href=\"https://marpple.github.io/partial.js/\" target=\"_blank\" rel=\"noopener\">partial.js</a>를 라이브러리로 사용합니다.)</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> users = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'ID'</span>, <span class=\"attr\">age</span>: <span class=\"number\">32</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seoul'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'A'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'BJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">31</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seoul'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JM'</span>, <span class=\"attr\">age</span>: <span class=\"number\">32</span>, <span class=\"attr\">city</span>: <span class=\"string\">'busan'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'PJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seongnam'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'B'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'HA'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seoul'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JE'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seongnam'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JI'</span>, <span class=\"attr\">age</span>: <span class=\"number\">32</span>, <span class=\"attr\">city</span>: <span class=\"string\">'incheon'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'A'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'MP'</span>, <span class=\"attr\">age</span>: <span class=\"number\">28</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seoul'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JY'</span>, <span class=\"attr\">age</span>: <span class=\"number\">31</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seoul'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'TH'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span>, <span class=\"attr\">city</span>: <span class=\"string\">'busan'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'AB'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'DS'</span>, <span class=\"attr\">age</span>: <span class=\"number\">33</span>, <span class=\"attr\">city</span>: <span class=\"string\">'incheon'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'YJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">24</span>, <span class=\"attr\">city</span>: <span class=\"string\">'busan'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'MB'</span>, <span class=\"attr\">age</span>: <span class=\"number\">37</span>, <span class=\"attr\">city</span>: <span class=\"string\">'incheon'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'B'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">29</span>, <span class=\"attr\">city</span>: <span class=\"string\">'busan'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'A'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'TU'</span>, <span class=\"attr\">age</span>: <span class=\"number\">21</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seoul'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'UB'</span>, <span class=\"attr\">age</span>: <span class=\"number\">23</span>, <span class=\"attr\">city</span>: <span class=\"string\">'seongnam'</span>, <span class=\"attr\">blood</span>: <span class=\"string\">'O'</span> &#125;,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>위의 <code>users</code>로 <strong>부산 외에 거주하면서 혈액형이 O형인 나이가 가장 많은 세 사람의 이름</strong>을 찾아내야 하는 상황입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.go(users,</span><br><span class=\"line\">  _.sort_by(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> -user.age), <span class=\"comment\">// 나이가 많은 순서대로 정렬</span></span><br><span class=\"line\">  _.reject(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.city === <span class=\"string\">'busan'</span>), <span class=\"comment\">// 부산 외에 거주하면서</span></span><br><span class=\"line\">  _.filter(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.blood === <span class=\"string\">'O'</span>),  <span class=\"comment\">// 혈액형이 O형인</span></span><br><span class=\"line\">  _.map(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> user.name),  <span class=\"comment\">// 사람의 이름</span></span><br><span class=\"line\">  _.take(<span class=\"number\">3</span>), <span class=\"comment\">// 세개</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// [\"DS\", \"BJ\", \"JY\"]</span></span><br></pre></td></tr></table></figure>\n\n<p>익숙한 함수들로 원하는 값을 쉽게 얻어냈습니다. 낯설게 느껴지는 함수가 있다면 정렬을 위해 사용한 <code>_.sort_by</code>와 배열 중 앞의 데이터만 뽑아내는 <code>_.take</code> 함수입니다. 사용법은 그리 어렵지 않습니다. <code>_.sort_by</code>의 경우 보조함수의 리턴 값을 기준으로 오름차순으로 정렬합니다. (음수가 리턴 값이니 결과는 내림차순이겠죠.) <code>_.take</code>는 <code>_.first</code> 함수의 또 다른 별칭입니다. 두번째 인자에 숫자를 넣으면 그만큼의 길이를 갖는 배열을 리턴합니다. 예제에선 3명을 원했으니 <code>_.take(3)</code>으로 사용됐습니다. 두 함수 모두 커링을 지원합니다. </p>\n<p>위와 같은 결과를 얻기 위해서 <code>_.reject</code>, <code>_.filter</code>, <code>_.map</code>은 위에서 내려주는 배열의 길이만큼 함수를 실행해서 조건을 검사하거나 값을 추출해야합니다. 그래서 총 36회의 함수 실행이 일어나죠.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">_.go(users,</span><br><span class=\"line\">  _.sort_by(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> -user.age),</span><br><span class=\"line\">  _.reject(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user.city === <span class=\"string\">'busan'</span>&#125;),</span><br><span class=\"line\">  _.filter(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user.blood === <span class=\"string\">'O'</span>&#125;), </span><br><span class=\"line\">  _.map(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user.name&#125;), </span><br><span class=\"line\">  _.take(<span class=\"number\">3</span>),</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// [\"DS\", \"BJ\", \"JY\"] </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count); <span class=\"comment\">// 36</span></span><br></pre></td></tr></table></figure>\n\n<p>위의 예제처럼 얻길 원하는 값이 몇개 되지 않을 때, 나머지에 대해서도 함수가 계산(evaluation)되는 것은 낭비라고 생각하는게 지연 평가의 등장 배경입니다. <strong>필요한 값들만 우선 계산하고 나머지는 계산을 지연시켜서 필요하지 않다면 계산하지 않도록 하는 기법</strong>이 지연 평가인 것입니다. 그럼 지연평가가 적용되면 어떻게 결과가 달라질까요?</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">_.go(users,</span><br><span class=\"line\">  _.sort_by(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> -user.age),</span><br><span class=\"line\">  lazys.reject(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user.city === <span class=\"string\">'busan'</span>&#125;),</span><br><span class=\"line\">  lazys.filter(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user.blood === <span class=\"string\">'O'</span>&#125;), </span><br><span class=\"line\">  lazys.map(<span class=\"function\"><span class=\"params\">user</span> =&gt;</span> &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user.name&#125;), </span><br><span class=\"line\">  lazys.take(<span class=\"number\">3</span>),</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// [\"DS\", \"BJ\", \"JY\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count); <span class=\"comment\">// 16</span></span><br></pre></td></tr></table></figure>\n\n<p><code>lazys</code>라는 네임스페이스를 갖는 함수로 기존의 함수를 대체했습니다. (<code>_.sort_by</code>는 지연 평가 함수에 포함되지 않습니다.) 함수 실행 회수를 보니 16회 입니다. 같은 결과를 만들었음에도 20회나 적게 실행된 것입니다. 어떻게 구현되었기에 이와 같은 결과를 만들어내는지 살펴보겠습니다. 먼저 <code>map</code>, <code>filter</code>, <code>reject</code>의 구현입니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> lazys = &#123;&#125;; <span class=\"comment\">// 네임스페이스 정의</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make_lazy</span>(<span class=\"params\">...fns</span>) </span>&#123; <span class=\"comment\">// [1]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">list</span> =&gt;</span> &#123; <span class=\"comment\">// [2]</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (list.is_lazy) <span class=\"keyword\">return</span> list.push(fns), list; <span class=\"comment\">// [3]</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> lazy = [fns]; <span class=\"comment\">// [4]</span></span><br><span class=\"line\">    lazy.data = list; <span class=\"comment\">// [5]</span></span><br><span class=\"line\">    lazy.is_lazy = <span class=\"literal\">true</span>; <span class=\"comment\">// [6]</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lazy; <span class=\"comment\">// [7]</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">lazys.map = <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> make_lazy(fn, _.map) <span class=\"comment\">// [8]</span></span><br><span class=\"line\">lazys.filter = <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> make_lazy(fn, _.filter)</span><br><span class=\"line\">lazys.reject = <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> make_lazy(fn, _.reject)</span><br></pre></td></tr></table></figure>\n\n<p>[1] <code>make_lazy</code> 함수는 <code>take</code>를 제외한 함수에서 사용하는 함수입니다. 이 함수는 <code>take</code>가 최종 계산에 사용할 <code>lazy</code>라는 배열을 만들어냅니다.<br>[2] <code>make_lazy</code> 함수가 리턴하는 함수는 <code>list</code>를 인자로 받습니다. 이 <code>list</code>는 예제로 따지자면 <code>users</code>에 해당합니다.<br>[3] 만약에 <code>list</code>가 <code>is_lazy</code>라는 값을 참으로 가지고 있다면, <code>list</code>에 처음에 받아둔 함수(<code>fns</code>)를 그대로 넣고 <code>list</code>를 리턴합니다. ‘<code>list</code>가 <code>is_lazy</code>라는 값을 참으로 가지고 있다’는 조건은 이 <code>list</code>가 <code>lazy</code>임을 의미합니다.<br>[4] 실제 <code>lazy</code>가 새로 생성되는 경우는 <code>users</code>와 같은 데이터가 들어왔을 경우입니다. 이때는 받아둔 함수(<code>fns</code>)를 배열로 감싸서 <code>lazy</code>를 생성합니다. 이 데이터는 이후 <code>take</code>에 의해 계산됩니다.<br>[5] 진짜로 가공해야할 데이터는 <code>lazy</code>에 붙여둡니다.<br>[6] <code>lazy</code>가 진짜 <code>lazy</code>임을 남겨둡니다. [3]에서 검사할 수 있었던 이유입니다.<br>[7] 완성된 <code>lazy</code>를 리턴합니다.<br>[8] <code>map</code>, <code>filter</code>, <code>reject</code>가 같은 방식으로 만들어집니다. 어떻게 논리를 전개할지 정해둔 보조 함수(<code>fn</code>)를 받고 <code>make_lazy</code>에게 첫번째 인자로 보조 함수, 두번째 인자로 보조 함수가 처리되어야할 논리를 담고 있는 모체가 되는 함수 전달합니다. 이 인자가 [1]에서 <code>fns</code>가 배열의 형태로 사용됩니다.</p>\n<p>앞서 만들어진 세 함수는 <code>lazy</code>라는 데이터를 만들어 <code>take</code>에 전달하는 역할을 합니다. <strong>함수를 평가(계산)하지 않습니다.</strong> 실제 평가는 결과값의 양을 알고 있는 <code>take</code> 함수의 몫입니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lazys.take = <span class=\"function\"><span class=\"params\">limit</span> =&gt;</span> &#123; <span class=\"comment\">// [10]</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">lazy</span> =&gt;</span> &#123; <span class=\"comment\">// [11]</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">-1</span>, ll = lazy.length, dl = lazy.data.length, res = [];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (++i &lt; dl) &#123; <span class=\"comment\">// [12]</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> j = <span class=\"number\">0</span>, </span><br><span class=\"line\">      v = lazy.data[i], <span class=\"comment\">// [13-1]</span></span><br><span class=\"line\">      rev = lazy[j][<span class=\"number\">1</span>]([v], lazy[j][<span class=\"number\">0</span>])[<span class=\"number\">0</span>]; <span class=\"comment\">// [13-2]</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">while</span> (rev &amp;&amp; ++j &lt; ll) rev = lazy[j][<span class=\"number\">1</span>]([v], lazy[j][<span class=\"number\">0</span>])[<span class=\"number\">0</span>]; <span class=\"comment\">// [14]</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rev) &#123;</span><br><span class=\"line\">        res.push(rev); <span class=\"comment\">// [15]</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (res.length === limit) <span class=\"keyword\">return</span> res; <span class=\"comment\">// [16]</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>[10] <code>limit</code>은 결과값의 양을 의미합니다. <code>lazy.take(3)</code>으로 호출된 오늘의 예제에서는 세개의 데이터가 채워지면 평가를 종료합니다.<br>[11] 앞선 함수들이 만들어낸 <code>lazy</code>를 인자로 받습니다.<br>[12] <code>lazt.data</code>에 붙어온 데이터의 길이만큼 반복합니다.<br>[13-1] <code>v</code>는 <code>lazt.data</code>에서 꺼낸 하나의 값입니다. <code>users</code> 데이터의 경우로 보자면 <code>i</code>가 0일때, <code>v</code>는 <code>{ name: &#39;ID&#39;, age: 32, city: &#39;seoul&#39;, blood: &#39;A&#39; }</code>와 같습니다.<br>[13-2] <code>rev</code>는 [3]과 [4]에서 <code>lazy</code>로 추가된 함수들에 의해 평가된 결과값입니다. <code>users</code> 데이터의 경우로 보자면 <code>i</code>가 0일때, <code>_.reject([v], user =&gt; user.city === &#39;busan&#39;)</code>에 의해 평가되고 첫번째 인자를 꺼낸 결과인 <code>rev</code>는 <code>v</code>와 같은 값을 가진 상태가 됩니다.<br>[14] <code>rev</code>의 결과가 존재하고 <code>lazy</code>의 길이보다 적을 때까지 <code>lazy</code>의 함수들을 꺼내 평가합니다. <code>rev</code>로 반복의 여부를 검사함으로 불필요한 평가를 하지 않을 수 있습니다.<br>[15] 반복문 이후에도 <code>rev</code>가 값으로 존재한다면(<code>undefined</code>가 아니라면) 결과값 <code>res</code>에 넣습니다.<br>[16] <code>res</code>의 길이가 원하는만큼 채워지면 결과를 리턴합니다. </p>\n"},{"title":"오늘의 함수 - map","date":"2018-05-20T11:00:00.000Z","description":"map은 돌림직한 데이터형(collection)을 순회하면서 새로운 값으로 매핑(mapping)해서 새로운 배열을 반환합니다.","_content":"_오늘 발견한 특별한 함수를 소개합니다_\n\n## map\n\n오늘은 조금 특별한 함수를 소개합니다. `map` 함수입니다. 사실 이 함수 자체가 특별한 것은 아닙니다. 이미 [pluck 함수](/programming/javascript-daily-function-19/)에서 등장한 적도 있고 함수형 프로그래밍에서 기본기처럼 사용되는 함수입니다. 오늘의 함수가 특별한 이유는 구현 방식 때문입니다. 한창 진행 중인 강의([프로그래머스에서 주최한 유인동님의 강의](https://programmers.co.kr/learn/courses/3409))에서 구현하는 방식으로 구현해볼까 합니다. 거기에 조금 더 응용을 해볼까 합니다. 우선 `map`이 필요한 상황과 사용 방법에 대해 살펴보겠습니다.\n\n\n#### (1) 어제의 함수\n\n```javascript\nmap(a => a + 10, [1, 2, 3, 4, 5]); // [11, 12, 13, 14, 15]\n```\n\n아시다시피 `map`은 돌림직한 데이터형(collection)을 순회하면서 새로운 값으로 매핑(mapping)해서 새로운 배열을 반환합니다. 위의 코드를 보시면 아시겠지만 기존에 구현하던 것과 차이가 있습니다. 배열보다 함수가 먼저 나옵니다. 이는 [Ramda.js의 사용법](https://ramdajs.com/docs/#map)과 같습니다. \n\n기본적인 구현은 아래와 같이 할 수 있습니다.\n\n```javascript\nfunction map(f, coll) {\n  let res = [];\n  for (const x of coll) res.push(f(x));\n  return res;\n}\n```\n\n오늘의 구현은 조금 더 복잡합니다. 비동기 상황을 지원하는 `reduce`와 `then`함수 등을 활용해서 비동기 상황을 지원하는 `map`을 구현해보겠습니다. 기본적으로 사용될 `reduce`와 `then` 함수의 구현은 아래와 같습니다. \n\n```javascript\n// Promise가 주어지면 then 으로 풀어서 값을 전달하는 then 함수\nconst then = (f, x) => x instanceof Promise ? x.then(f) : f(x);\n\n// then 함수를 활용해 비동기 상황을 지원하도록 만들어진 reduce 함수\nfunction reduce(f, coll, acc) {\n  return then(function(coll) {\n    const iter = coll[Symbol.iterator]();\n    return then(function recur(acc) {\n      for (const x of iter) \n        if ((acc = f(acc, x)) instanceof Promise) return acc.then(recur);\n      return acc;\n    }, acc === undefined ? iter.next().value : acc);\n  }, coll);\n}\n\n// 아래와 같이 동작합니다.\nreduce((a, b) => a + b, [1, 2, 3, 4, 5], 10); // 25\n\n// 아래와 같은 비동기 상황을 지원합니다.\nreduce((a, b) => a + b, Promise.resolve([1, 2, 3, 4, 5]), 10).then(console.log);\nreduce((a, b) => a + b, [1, 2, 3, 4, 5], Promise.resolve(10)).then(console.log);\n```\n\n#### (2) 오늘의 함수\n\n`reduce` 함수는 추상화 레벨이 높은 함수라서 콜렉션을 순회하는 대부분의 함수를 구현할 수 있습니다. 이러한 특징을 활용해서 `map`을 구현하겠습니다. 대략적인 골격은 아래와 같겠죠.\n\n```javascript\nconst map = (f, coll) => {\n  return reduce((res, x) => { \n    res.push(f(x)); \n    return res; \n  }, coll, [])\n};\n```\n\n배열을 초기값으로 하는 `reduce`의 형태로 구현이 가능합니다. 축약하면 아래와 같습니다.\n\n```javascript\nconst map = (f, coll) => reduce((res, x) => (res.push(f(x)), res), coll, []);\n```\n\n여기서 `push`라는 함수를 만들어볼 수 있겠습니다. `(res.push(f(x)), res)`와 같이 push 메서드를 실행하고 본체(배열)을 반환하는 함수입니다.\n\n```javascript\nconst push = (arr, v) => (arr.push(v), arr);\nconst map = (f, coll) => reduce((res, x) => push(res, f(x)), coll, []);\n```\n\n그럼 테스트를 해보겠습니다. \n\n```javascript\nmap(a => a + 10, [1, 2, 3, 4, 5]); // [11, 12, 13, 14, 15]\nmap(a => a + 10, Promise.resolve([1, 2, 3, 4, 5])).then(console.log); // [11, 12, 13, 14, 15]\n// map(a => Promise.resolve(a + 10), [1, 2, 3, 4, 5]).then(console.log); // Uncaught TypeError: map(...).then is not a function\nmap(a => Promise.resolve(a + 10), [1, 2, 3, 4, 5]); // [Promise, Promise, Promise, Promise, Promise]\n```\n\n두가지 경우는 잘 통과했지만 마지막은 실패하는 모습을 보여줍니다. 생각해보면 미리 만들어둔 `reduce`는 인자로 전달되는 값(coll, acc)가 비동기인 경우만을 제어합니다. 함수가 만들어낸 값이 비동기일 경우를 제어하지 못하죠. 이제 `map`에도 `then`을 사용해야할 순간입니다. 함수에 적용한 결과가 Promise일지도 모른다는 가정으로 접근해야겠죠.\n\n```javascript\nconst push = (arr, v) => (arr.push(v), arr);\nconst map = (f, coll) => reduce(\n  (res, x) => then(v => push(res, v), f(x)), // <-- 여기가 포인트!\n  coll, []);\n\nmap(a => Promise.resolve(a + 10), [1, 2, 3, 4, 5]).then(console.log); // [11, 12, 13, 14, 15]\n```\n\n이제 원하는대로 동작합니다. `f(x)`의 결과값을 `then` 함수의 두번째 인자로 전달하면 됩니다. 그리고 `push` 함수로 결과를 만들면 되죠. 이미 원하던 바는 이뤘습니다. \n\n#### (3) 더보기\n\n아래부터는 굳이 안해도 되는 구간입니다. 함수로 쪼개면 이렇게도 할 수 있음을 보여드리려고 합니다. 한번 막 만들어보겠습니다. 우선 `push` 함수를 고쳐보겠습니다.\n\n```javascript\nconst push = arr => v => (arr.push(v), arr);\nconst map = (f, coll) => reduce(\n  (res, x) => then(push(res), f(x)), // <-- 간결해진 함수\n  coll, []);\n```\n\n`push` 함수를 함수를 반환하는 함수로 만들고 첫번째 함수에서 배열을 두번째 함수에서 값을 받는 함수로 만들면 `map` 내부에서 보다 간결하게 표현할 수 있습니다. \n\n조금 더 간결한 표현을 위해 몇가지 함수의 도움을 받아야합니다. [`pipe`](/programming/javascript-daily-function-20/), `spread`가 필요합니다. 두 함수를 만들기 위해선 또 두개의 함수가 더 필요한데, 배열을 멀티 리턴 값으로 치환해주는 [`to_mr`](/programming/javascript-daily-function-14/)과 `go` 함수가 필요합니다. 이미 몇차례 소개해드린 적이 있어서 간단하게 구현만 살피겠습니다.\n\n```javascript\n// 배열을 받아 멀티 리턴 값으로 치환하는 to_mr 함수 (이전에 소개드린 방식과 구현이 다릅니다)\nconst to_mr = arr => ({ __mr: true, value: arr });\n\n// 첫번째로는 함수를 받고 두번째로는 인자를 받아 순서대로 실행한 뒤 멀티 리턴으로 반환하는 spread 함수\nconst spread = (...fs) => (...args) => to_mr(fs.map((f, i) => f(args[i])));\n\n// 시작값과 함수들을 받아 즉시 함수들을 실행하는 go 함수\nconst go = (x, ...fs) => reduce((res, f) => res.__mr ? f(...res.value) : f(res), fs, x);\n\n// 함수들을 합성하는 pipe 함수\nconst pipe = (...fs) => (...args) => go(to_mr(args), ...fs);\n```\n\n위의 함수 중 두가지 함수 `spread`와 `pipe`를 사용하면 아래와 같이 간결한 `map`을 만들 수 있습니다.\n\n```javascript\n// const map = (f, coll) => reduce((res, x) => then(push(res), f(x)), coll, []); // 기존 구현\nconst map = (f, coll) => reduce(\n  pipe(spread(push, f), then), // <-- 함수로 함수를 만들기!\n  coll, []);\n```\n\n기존 구현에서 `(res, x) => then(push(res), f(x))` 이 부분을 가만 살펴보면 전달되는 인자의 순서와 `then`내부에 실행되는 함수가 필요로하는 인자의 순서가 같음을 알 수 있습니다. 이때 `spread`를 사용하면 좋겠다는 생각이 들죠. 사용할 함수를 미리 `spread`에 적용해두고 그 결과를 `then` 함수에 적용하기 위해선 `pipe` 함수가 필요한거죠. 결국 `spread` 함수의 최종 실행 결과는 `push(res), f(x)`과 같습니다. 이 결과가 `then`에 전달됩니다. 멀티 리턴을 지원하는 `pipe` 함수이기에 이와 같은 전개가 가능합니다. \n\n여기에 덧해서 커링을 지원하는 `map`을 만들려면 `curry` 함수가 필요합니다.\n\n```javascript\nconst curry = fn => (x, y) => y === undefined ? y => fn(x, y) : fn(x, y);\nconst map = curry((f, coll) => reduce(pipe(spread(push, f), then), coll, []));\n```\n\n인자가 하나만 들어오면 커링을 하고 그렇지 않으면 즉시 실행합니다. 이제 `go` 함수를 써서 보다 함수형스럽게(?) 표현할 수 있습니다.\n\n```javascript\n// map(a => Promise.resolve(a + 20), [1, 2, 3, 4, 5]).then(console.log); \n\ngo([1, 2, 3, 4, 5], \n  map(a => Promise.resolve(a + 20)), \n  console.log); // [11, 12, 13, 14, 15]\n```\n","source":"_posts/daily-fp-21.md","raw":"---\ntitle: '오늘의 함수 - map'\ndate: 2018-05-20 20:00:00\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\ndescription: map은 돌림직한 데이터형(collection)을 순회하면서 새로운 값으로 매핑(mapping)해서 새로운 배열을 반환합니다.\n---\n_오늘 발견한 특별한 함수를 소개합니다_\n\n## map\n\n오늘은 조금 특별한 함수를 소개합니다. `map` 함수입니다. 사실 이 함수 자체가 특별한 것은 아닙니다. 이미 [pluck 함수](/programming/javascript-daily-function-19/)에서 등장한 적도 있고 함수형 프로그래밍에서 기본기처럼 사용되는 함수입니다. 오늘의 함수가 특별한 이유는 구현 방식 때문입니다. 한창 진행 중인 강의([프로그래머스에서 주최한 유인동님의 강의](https://programmers.co.kr/learn/courses/3409))에서 구현하는 방식으로 구현해볼까 합니다. 거기에 조금 더 응용을 해볼까 합니다. 우선 `map`이 필요한 상황과 사용 방법에 대해 살펴보겠습니다.\n\n\n#### (1) 어제의 함수\n\n```javascript\nmap(a => a + 10, [1, 2, 3, 4, 5]); // [11, 12, 13, 14, 15]\n```\n\n아시다시피 `map`은 돌림직한 데이터형(collection)을 순회하면서 새로운 값으로 매핑(mapping)해서 새로운 배열을 반환합니다. 위의 코드를 보시면 아시겠지만 기존에 구현하던 것과 차이가 있습니다. 배열보다 함수가 먼저 나옵니다. 이는 [Ramda.js의 사용법](https://ramdajs.com/docs/#map)과 같습니다. \n\n기본적인 구현은 아래와 같이 할 수 있습니다.\n\n```javascript\nfunction map(f, coll) {\n  let res = [];\n  for (const x of coll) res.push(f(x));\n  return res;\n}\n```\n\n오늘의 구현은 조금 더 복잡합니다. 비동기 상황을 지원하는 `reduce`와 `then`함수 등을 활용해서 비동기 상황을 지원하는 `map`을 구현해보겠습니다. 기본적으로 사용될 `reduce`와 `then` 함수의 구현은 아래와 같습니다. \n\n```javascript\n// Promise가 주어지면 then 으로 풀어서 값을 전달하는 then 함수\nconst then = (f, x) => x instanceof Promise ? x.then(f) : f(x);\n\n// then 함수를 활용해 비동기 상황을 지원하도록 만들어진 reduce 함수\nfunction reduce(f, coll, acc) {\n  return then(function(coll) {\n    const iter = coll[Symbol.iterator]();\n    return then(function recur(acc) {\n      for (const x of iter) \n        if ((acc = f(acc, x)) instanceof Promise) return acc.then(recur);\n      return acc;\n    }, acc === undefined ? iter.next().value : acc);\n  }, coll);\n}\n\n// 아래와 같이 동작합니다.\nreduce((a, b) => a + b, [1, 2, 3, 4, 5], 10); // 25\n\n// 아래와 같은 비동기 상황을 지원합니다.\nreduce((a, b) => a + b, Promise.resolve([1, 2, 3, 4, 5]), 10).then(console.log);\nreduce((a, b) => a + b, [1, 2, 3, 4, 5], Promise.resolve(10)).then(console.log);\n```\n\n#### (2) 오늘의 함수\n\n`reduce` 함수는 추상화 레벨이 높은 함수라서 콜렉션을 순회하는 대부분의 함수를 구현할 수 있습니다. 이러한 특징을 활용해서 `map`을 구현하겠습니다. 대략적인 골격은 아래와 같겠죠.\n\n```javascript\nconst map = (f, coll) => {\n  return reduce((res, x) => { \n    res.push(f(x)); \n    return res; \n  }, coll, [])\n};\n```\n\n배열을 초기값으로 하는 `reduce`의 형태로 구현이 가능합니다. 축약하면 아래와 같습니다.\n\n```javascript\nconst map = (f, coll) => reduce((res, x) => (res.push(f(x)), res), coll, []);\n```\n\n여기서 `push`라는 함수를 만들어볼 수 있겠습니다. `(res.push(f(x)), res)`와 같이 push 메서드를 실행하고 본체(배열)을 반환하는 함수입니다.\n\n```javascript\nconst push = (arr, v) => (arr.push(v), arr);\nconst map = (f, coll) => reduce((res, x) => push(res, f(x)), coll, []);\n```\n\n그럼 테스트를 해보겠습니다. \n\n```javascript\nmap(a => a + 10, [1, 2, 3, 4, 5]); // [11, 12, 13, 14, 15]\nmap(a => a + 10, Promise.resolve([1, 2, 3, 4, 5])).then(console.log); // [11, 12, 13, 14, 15]\n// map(a => Promise.resolve(a + 10), [1, 2, 3, 4, 5]).then(console.log); // Uncaught TypeError: map(...).then is not a function\nmap(a => Promise.resolve(a + 10), [1, 2, 3, 4, 5]); // [Promise, Promise, Promise, Promise, Promise]\n```\n\n두가지 경우는 잘 통과했지만 마지막은 실패하는 모습을 보여줍니다. 생각해보면 미리 만들어둔 `reduce`는 인자로 전달되는 값(coll, acc)가 비동기인 경우만을 제어합니다. 함수가 만들어낸 값이 비동기일 경우를 제어하지 못하죠. 이제 `map`에도 `then`을 사용해야할 순간입니다. 함수에 적용한 결과가 Promise일지도 모른다는 가정으로 접근해야겠죠.\n\n```javascript\nconst push = (arr, v) => (arr.push(v), arr);\nconst map = (f, coll) => reduce(\n  (res, x) => then(v => push(res, v), f(x)), // <-- 여기가 포인트!\n  coll, []);\n\nmap(a => Promise.resolve(a + 10), [1, 2, 3, 4, 5]).then(console.log); // [11, 12, 13, 14, 15]\n```\n\n이제 원하는대로 동작합니다. `f(x)`의 결과값을 `then` 함수의 두번째 인자로 전달하면 됩니다. 그리고 `push` 함수로 결과를 만들면 되죠. 이미 원하던 바는 이뤘습니다. \n\n#### (3) 더보기\n\n아래부터는 굳이 안해도 되는 구간입니다. 함수로 쪼개면 이렇게도 할 수 있음을 보여드리려고 합니다. 한번 막 만들어보겠습니다. 우선 `push` 함수를 고쳐보겠습니다.\n\n```javascript\nconst push = arr => v => (arr.push(v), arr);\nconst map = (f, coll) => reduce(\n  (res, x) => then(push(res), f(x)), // <-- 간결해진 함수\n  coll, []);\n```\n\n`push` 함수를 함수를 반환하는 함수로 만들고 첫번째 함수에서 배열을 두번째 함수에서 값을 받는 함수로 만들면 `map` 내부에서 보다 간결하게 표현할 수 있습니다. \n\n조금 더 간결한 표현을 위해 몇가지 함수의 도움을 받아야합니다. [`pipe`](/programming/javascript-daily-function-20/), `spread`가 필요합니다. 두 함수를 만들기 위해선 또 두개의 함수가 더 필요한데, 배열을 멀티 리턴 값으로 치환해주는 [`to_mr`](/programming/javascript-daily-function-14/)과 `go` 함수가 필요합니다. 이미 몇차례 소개해드린 적이 있어서 간단하게 구현만 살피겠습니다.\n\n```javascript\n// 배열을 받아 멀티 리턴 값으로 치환하는 to_mr 함수 (이전에 소개드린 방식과 구현이 다릅니다)\nconst to_mr = arr => ({ __mr: true, value: arr });\n\n// 첫번째로는 함수를 받고 두번째로는 인자를 받아 순서대로 실행한 뒤 멀티 리턴으로 반환하는 spread 함수\nconst spread = (...fs) => (...args) => to_mr(fs.map((f, i) => f(args[i])));\n\n// 시작값과 함수들을 받아 즉시 함수들을 실행하는 go 함수\nconst go = (x, ...fs) => reduce((res, f) => res.__mr ? f(...res.value) : f(res), fs, x);\n\n// 함수들을 합성하는 pipe 함수\nconst pipe = (...fs) => (...args) => go(to_mr(args), ...fs);\n```\n\n위의 함수 중 두가지 함수 `spread`와 `pipe`를 사용하면 아래와 같이 간결한 `map`을 만들 수 있습니다.\n\n```javascript\n// const map = (f, coll) => reduce((res, x) => then(push(res), f(x)), coll, []); // 기존 구현\nconst map = (f, coll) => reduce(\n  pipe(spread(push, f), then), // <-- 함수로 함수를 만들기!\n  coll, []);\n```\n\n기존 구현에서 `(res, x) => then(push(res), f(x))` 이 부분을 가만 살펴보면 전달되는 인자의 순서와 `then`내부에 실행되는 함수가 필요로하는 인자의 순서가 같음을 알 수 있습니다. 이때 `spread`를 사용하면 좋겠다는 생각이 들죠. 사용할 함수를 미리 `spread`에 적용해두고 그 결과를 `then` 함수에 적용하기 위해선 `pipe` 함수가 필요한거죠. 결국 `spread` 함수의 최종 실행 결과는 `push(res), f(x)`과 같습니다. 이 결과가 `then`에 전달됩니다. 멀티 리턴을 지원하는 `pipe` 함수이기에 이와 같은 전개가 가능합니다. \n\n여기에 덧해서 커링을 지원하는 `map`을 만들려면 `curry` 함수가 필요합니다.\n\n```javascript\nconst curry = fn => (x, y) => y === undefined ? y => fn(x, y) : fn(x, y);\nconst map = curry((f, coll) => reduce(pipe(spread(push, f), then), coll, []));\n```\n\n인자가 하나만 들어오면 커링을 하고 그렇지 않으면 즉시 실행합니다. 이제 `go` 함수를 써서 보다 함수형스럽게(?) 표현할 수 있습니다.\n\n```javascript\n// map(a => Promise.resolve(a + 20), [1, 2, 3, 4, 5]).then(console.log); \n\ngo([1, 2, 3, 4, 5], \n  map(a => Promise.resolve(a + 20)), \n  console.log); // [11, 12, 13, 14, 15]\n```\n","slug":"daily-fp-21","published":1,"updated":"2019-12-05T15:06:08.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9im009bdirv6jfhshik","content":"<p><em>오늘 발견한 특별한 함수를 소개합니다</em></p>\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><p>오늘은 조금 특별한 함수를 소개합니다. <code>map</code> 함수입니다. 사실 이 함수 자체가 특별한 것은 아닙니다. 이미 <a href=\"/programming/javascript-daily-function-19/\">pluck 함수</a>에서 등장한 적도 있고 함수형 프로그래밍에서 기본기처럼 사용되는 함수입니다. 오늘의 함수가 특별한 이유는 구현 방식 때문입니다. 한창 진행 중인 강의(<a href=\"https://programmers.co.kr/learn/courses/3409\" target=\"_blank\" rel=\"noopener\">프로그래머스에서 주최한 유인동님의 강의</a>)에서 구현하는 방식으로 구현해볼까 합니다. 거기에 조금 더 응용을 해볼까 합니다. 우선 <code>map</code>이 필요한 상황과 사용 방법에 대해 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a + <span class=\"number\">10</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]); <span class=\"comment\">// [11, 12, 13, 14, 15]</span></span><br></pre></td></tr></table></figure>\n\n<p>아시다시피 <code>map</code>은 돌림직한 데이터형(collection)을 순회하면서 새로운 값으로 매핑(mapping)해서 새로운 배열을 반환합니다. 위의 코드를 보시면 아시겠지만 기존에 구현하던 것과 차이가 있습니다. 배열보다 함수가 먼저 나옵니다. 이는 <a href=\"https://ramdajs.com/docs/#map\" target=\"_blank\" rel=\"noopener\">Ramda.js의 사용법</a>과 같습니다. </p>\n<p>기본적인 구현은 아래와 같이 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">f, coll</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> coll) res.push(f(x));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>오늘의 구현은 조금 더 복잡합니다. 비동기 상황을 지원하는 <code>reduce</code>와 <code>then</code>함수 등을 활용해서 비동기 상황을 지원하는 <code>map</code>을 구현해보겠습니다. 기본적으로 사용될 <code>reduce</code>와 <code>then</code> 함수의 구현은 아래와 같습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Promise가 주어지면 then 으로 풀어서 값을 전달하는 then 함수</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> then = <span class=\"function\">(<span class=\"params\">f, x</span>) =&gt;</span> x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span> ? x.then(f) : f(x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// then 함수를 활용해 비동기 상황을 지원하도록 만들어진 reduce 함수</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reduce</span>(<span class=\"params\">f, coll, acc</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">coll</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> iter = coll[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> then(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recur</span>(<span class=\"params\">acc</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> iter) </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((acc = f(acc, x)) <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) <span class=\"keyword\">return</span> acc.then(recur);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> acc;</span><br><span class=\"line\">    &#125;, acc === <span class=\"literal\">undefined</span> ? iter.next().value : acc);</span><br><span class=\"line\">  &#125;, coll);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 아래와 같이 동작합니다.</span></span><br><span class=\"line\">reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], <span class=\"number\">10</span>); <span class=\"comment\">// 25</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 아래와 같은 비동기 상황을 지원합니다.</span></span><br><span class=\"line\">reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b, <span class=\"built_in\">Promise</span>.resolve([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]), <span class=\"number\">10</span>).then(<span class=\"built_in\">console</span>.log);</span><br><span class=\"line\">reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], <span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">10</span>)).then(<span class=\"built_in\">console</span>.log);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><p><code>reduce</code> 함수는 추상화 레벨이 높은 함수라서 콜렉션을 순회하는 대부분의 함수를 구현할 수 있습니다. 이러한 특징을 활용해서 <code>map</code>을 구현하겠습니다. 대략적인 골격은 아래와 같겠죠.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\">(<span class=\"params\">f, coll</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce(<span class=\"function\">(<span class=\"params\">res, x</span>) =&gt;</span> &#123; </span><br><span class=\"line\">    res.push(f(x)); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res; </span><br><span class=\"line\">  &#125;, coll, [])</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>배열을 초기값으로 하는 <code>reduce</code>의 형태로 구현이 가능합니다. 축약하면 아래와 같습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\">(<span class=\"params\">f, coll</span>) =&gt;</span> reduce(<span class=\"function\">(<span class=\"params\">res, x</span>) =&gt;</span> (res.push(f(x)), res), coll, []);</span><br></pre></td></tr></table></figure>\n\n<p>여기서 <code>push</code>라는 함수를 만들어볼 수 있겠습니다. <code>(res.push(f(x)), res)</code>와 같이 push 메서드를 실행하고 본체(배열)을 반환하는 함수입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> push = <span class=\"function\">(<span class=\"params\">arr, v</span>) =&gt;</span> (arr.push(v), arr);</span><br><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\">(<span class=\"params\">f, coll</span>) =&gt;</span> reduce(<span class=\"function\">(<span class=\"params\">res, x</span>) =&gt;</span> push(res, f(x)), coll, []);</span><br></pre></td></tr></table></figure>\n\n<p>그럼 테스트를 해보겠습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a + <span class=\"number\">10</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]); <span class=\"comment\">// [11, 12, 13, 14, 15]</span></span><br><span class=\"line\">map(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a + <span class=\"number\">10</span>, <span class=\"built_in\">Promise</span>.resolve([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])).then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// [11, 12, 13, 14, 15]</span></span><br><span class=\"line\"><span class=\"comment\">// map(a =&gt; Promise.resolve(a + 10), [1, 2, 3, 4, 5]).then(console.log); // Uncaught TypeError: map(...).then is not a function</span></span><br><span class=\"line\">map(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(a + <span class=\"number\">10</span>), [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]); <span class=\"comment\">// [Promise, Promise, Promise, Promise, Promise]</span></span><br></pre></td></tr></table></figure>\n\n<p>두가지 경우는 잘 통과했지만 마지막은 실패하는 모습을 보여줍니다. 생각해보면 미리 만들어둔 <code>reduce</code>는 인자로 전달되는 값(coll, acc)가 비동기인 경우만을 제어합니다. 함수가 만들어낸 값이 비동기일 경우를 제어하지 못하죠. 이제 <code>map</code>에도 <code>then</code>을 사용해야할 순간입니다. 함수에 적용한 결과가 Promise일지도 모른다는 가정으로 접근해야겠죠.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> push = <span class=\"function\">(<span class=\"params\">arr, v</span>) =&gt;</span> (arr.push(v), arr);</span><br><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\">(<span class=\"params\">f, coll</span>) =&gt;</span> reduce(</span><br><span class=\"line\">  (res, x) =&gt; then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> push(res, v), f(x)), <span class=\"comment\">// &lt;-- 여기가 포인트!</span></span><br><span class=\"line\">  coll, []);</span><br><span class=\"line\"></span><br><span class=\"line\">map(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(a + <span class=\"number\">10</span>), [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]).then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// [11, 12, 13, 14, 15]</span></span><br></pre></td></tr></table></figure>\n\n<p>이제 원하는대로 동작합니다. <code>f(x)</code>의 결과값을 <code>then</code> 함수의 두번째 인자로 전달하면 됩니다. 그리고 <code>push</code> 함수로 결과를 만들면 되죠. 이미 원하던 바는 이뤘습니다. </p>\n<h4 id=\"3-더보기\"><a href=\"#3-더보기\" class=\"headerlink\" title=\"(3) 더보기\"></a>(3) 더보기</h4><p>아래부터는 굳이 안해도 되는 구간입니다. 함수로 쪼개면 이렇게도 할 수 있음을 보여드리려고 합니다. 한번 막 만들어보겠습니다. 우선 <code>push</code> 함수를 고쳐보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> push = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> <span class=\"function\"><span class=\"params\">v</span> =&gt;</span> (arr.push(v), arr);</span><br><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\">(<span class=\"params\">f, coll</span>) =&gt;</span> reduce(</span><br><span class=\"line\">  (res, x) =&gt; then(push(res), f(x)), <span class=\"comment\">// &lt;-- 간결해진 함수</span></span><br><span class=\"line\">  coll, []);</span><br></pre></td></tr></table></figure>\n\n<p><code>push</code> 함수를 함수를 반환하는 함수로 만들고 첫번째 함수에서 배열을 두번째 함수에서 값을 받는 함수로 만들면 <code>map</code> 내부에서 보다 간결하게 표현할 수 있습니다. </p>\n<p>조금 더 간결한 표현을 위해 몇가지 함수의 도움을 받아야합니다. <a href=\"/programming/javascript-daily-function-20/\"><code>pipe</code></a>, <code>spread</code>가 필요합니다. 두 함수를 만들기 위해선 또 두개의 함수가 더 필요한데, 배열을 멀티 리턴 값으로 치환해주는 <a href=\"/programming/javascript-daily-function-14/\"><code>to_mr</code></a>과 <code>go</code> 함수가 필요합니다. 이미 몇차례 소개해드린 적이 있어서 간단하게 구현만 살피겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 배열을 받아 멀티 리턴 값으로 치환하는 to_mr 함수 (이전에 소개드린 방식과 구현이 다릅니다)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> to_mr = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> (&#123; <span class=\"attr\">__mr</span>: <span class=\"literal\">true</span>, <span class=\"attr\">value</span>: arr &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 첫번째로는 함수를 받고 두번째로는 인자를 받아 순서대로 실행한 뒤 멀티 리턴으로 반환하는 spread 함수</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> spread = <span class=\"function\">(<span class=\"params\">...fs</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> to_mr(fs.map(<span class=\"function\">(<span class=\"params\">f, i</span>) =&gt;</span> f(args[i])));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 시작값과 함수들을 받아 즉시 함수들을 실행하는 go 함수</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> go = <span class=\"function\">(<span class=\"params\">x, ...fs</span>) =&gt;</span> reduce(<span class=\"function\">(<span class=\"params\">res, f</span>) =&gt;</span> res.__mr ? f(...res.value) : f(res), fs, x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 함수들을 합성하는 pipe 함수</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pipe = <span class=\"function\">(<span class=\"params\">...fs</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> go(to_mr(args), ...fs);</span><br></pre></td></tr></table></figure>\n\n<p>위의 함수 중 두가지 함수 <code>spread</code>와 <code>pipe</code>를 사용하면 아래와 같이 간결한 <code>map</code>을 만들 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// const map = (f, coll) =&gt; reduce((res, x) =&gt; then(push(res), f(x)), coll, []); // 기존 구현</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\">(<span class=\"params\">f, coll</span>) =&gt;</span> reduce(</span><br><span class=\"line\">  pipe(spread(push, f), then), <span class=\"comment\">// &lt;-- 함수로 함수를 만들기!</span></span><br><span class=\"line\">  coll, []);</span><br></pre></td></tr></table></figure>\n\n<p>기존 구현에서 <code>(res, x) =&gt; then(push(res), f(x))</code> 이 부분을 가만 살펴보면 전달되는 인자의 순서와 <code>then</code>내부에 실행되는 함수가 필요로하는 인자의 순서가 같음을 알 수 있습니다. 이때 <code>spread</code>를 사용하면 좋겠다는 생각이 들죠. 사용할 함수를 미리 <code>spread</code>에 적용해두고 그 결과를 <code>then</code> 함수에 적용하기 위해선 <code>pipe</code> 함수가 필요한거죠. 결국 <code>spread</code> 함수의 최종 실행 결과는 <code>push(res), f(x)</code>과 같습니다. 이 결과가 <code>then</code>에 전달됩니다. 멀티 리턴을 지원하는 <code>pipe</code> 함수이기에 이와 같은 전개가 가능합니다. </p>\n<p>여기에 덧해서 커링을 지원하는 <code>map</code>을 만들려면 <code>curry</code> 함수가 필요합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> curry = <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> y === <span class=\"literal\">undefined</span> ? <span class=\"function\"><span class=\"params\">y</span> =&gt;</span> fn(x, y) : fn(x, y);</span><br><span class=\"line\"><span class=\"keyword\">const</span> map = curry(<span class=\"function\">(<span class=\"params\">f, coll</span>) =&gt;</span> reduce(pipe(spread(push, f), then), coll, []));</span><br></pre></td></tr></table></figure>\n\n<p>인자가 하나만 들어오면 커링을 하고 그렇지 않으면 즉시 실행합니다. 이제 <code>go</code> 함수를 써서 보다 함수형스럽게(?) 표현할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// map(a =&gt; Promise.resolve(a + 20), [1, 2, 3, 4, 5]).then(console.log); </span></span><br><span class=\"line\"></span><br><span class=\"line\">go([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], </span><br><span class=\"line\">  map(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(a + <span class=\"number\">20</span>)), </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// [11, 12, 13, 14, 15]</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 특별한 함수를 소개합니다</em></p>\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><p>오늘은 조금 특별한 함수를 소개합니다. <code>map</code> 함수입니다. 사실 이 함수 자체가 특별한 것은 아닙니다. 이미 <a href=\"/programming/javascript-daily-function-19/\">pluck 함수</a>에서 등장한 적도 있고 함수형 프로그래밍에서 기본기처럼 사용되는 함수입니다. 오늘의 함수가 특별한 이유는 구현 방식 때문입니다. 한창 진행 중인 강의(<a href=\"https://programmers.co.kr/learn/courses/3409\" target=\"_blank\" rel=\"noopener\">프로그래머스에서 주최한 유인동님의 강의</a>)에서 구현하는 방식으로 구현해볼까 합니다. 거기에 조금 더 응용을 해볼까 합니다. 우선 <code>map</code>이 필요한 상황과 사용 방법에 대해 살펴보겠습니다.</p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a + <span class=\"number\">10</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]); <span class=\"comment\">// [11, 12, 13, 14, 15]</span></span><br></pre></td></tr></table></figure>\n\n<p>아시다시피 <code>map</code>은 돌림직한 데이터형(collection)을 순회하면서 새로운 값으로 매핑(mapping)해서 새로운 배열을 반환합니다. 위의 코드를 보시면 아시겠지만 기존에 구현하던 것과 차이가 있습니다. 배열보다 함수가 먼저 나옵니다. 이는 <a href=\"https://ramdajs.com/docs/#map\" target=\"_blank\" rel=\"noopener\">Ramda.js의 사용법</a>과 같습니다. </p>\n<p>기본적인 구현은 아래와 같이 할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">f, coll</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> res = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> coll) res.push(f(x));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>오늘의 구현은 조금 더 복잡합니다. 비동기 상황을 지원하는 <code>reduce</code>와 <code>then</code>함수 등을 활용해서 비동기 상황을 지원하는 <code>map</code>을 구현해보겠습니다. 기본적으로 사용될 <code>reduce</code>와 <code>then</code> 함수의 구현은 아래와 같습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Promise가 주어지면 then 으로 풀어서 값을 전달하는 then 함수</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> then = <span class=\"function\">(<span class=\"params\">f, x</span>) =&gt;</span> x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span> ? x.then(f) : f(x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// then 함수를 활용해 비동기 상황을 지원하도록 만들어진 reduce 함수</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reduce</span>(<span class=\"params\">f, coll, acc</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">coll</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> iter = coll[<span class=\"built_in\">Symbol</span>.iterator]();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> then(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recur</span>(<span class=\"params\">acc</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> x <span class=\"keyword\">of</span> iter) </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((acc = f(acc, x)) <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) <span class=\"keyword\">return</span> acc.then(recur);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> acc;</span><br><span class=\"line\">    &#125;, acc === <span class=\"literal\">undefined</span> ? iter.next().value : acc);</span><br><span class=\"line\">  &#125;, coll);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 아래와 같이 동작합니다.</span></span><br><span class=\"line\">reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], <span class=\"number\">10</span>); <span class=\"comment\">// 25</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 아래와 같은 비동기 상황을 지원합니다.</span></span><br><span class=\"line\">reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b, <span class=\"built_in\">Promise</span>.resolve([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]), <span class=\"number\">10</span>).then(<span class=\"built_in\">console</span>.log);</span><br><span class=\"line\">reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], <span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">10</span>)).then(<span class=\"built_in\">console</span>.log);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><p><code>reduce</code> 함수는 추상화 레벨이 높은 함수라서 콜렉션을 순회하는 대부분의 함수를 구현할 수 있습니다. 이러한 특징을 활용해서 <code>map</code>을 구현하겠습니다. 대략적인 골격은 아래와 같겠죠.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\">(<span class=\"params\">f, coll</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce(<span class=\"function\">(<span class=\"params\">res, x</span>) =&gt;</span> &#123; </span><br><span class=\"line\">    res.push(f(x)); </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res; </span><br><span class=\"line\">  &#125;, coll, [])</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>배열을 초기값으로 하는 <code>reduce</code>의 형태로 구현이 가능합니다. 축약하면 아래와 같습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\">(<span class=\"params\">f, coll</span>) =&gt;</span> reduce(<span class=\"function\">(<span class=\"params\">res, x</span>) =&gt;</span> (res.push(f(x)), res), coll, []);</span><br></pre></td></tr></table></figure>\n\n<p>여기서 <code>push</code>라는 함수를 만들어볼 수 있겠습니다. <code>(res.push(f(x)), res)</code>와 같이 push 메서드를 실행하고 본체(배열)을 반환하는 함수입니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> push = <span class=\"function\">(<span class=\"params\">arr, v</span>) =&gt;</span> (arr.push(v), arr);</span><br><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\">(<span class=\"params\">f, coll</span>) =&gt;</span> reduce(<span class=\"function\">(<span class=\"params\">res, x</span>) =&gt;</span> push(res, f(x)), coll, []);</span><br></pre></td></tr></table></figure>\n\n<p>그럼 테스트를 해보겠습니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a + <span class=\"number\">10</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]); <span class=\"comment\">// [11, 12, 13, 14, 15]</span></span><br><span class=\"line\">map(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a + <span class=\"number\">10</span>, <span class=\"built_in\">Promise</span>.resolve([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>])).then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// [11, 12, 13, 14, 15]</span></span><br><span class=\"line\"><span class=\"comment\">// map(a =&gt; Promise.resolve(a + 10), [1, 2, 3, 4, 5]).then(console.log); // Uncaught TypeError: map(...).then is not a function</span></span><br><span class=\"line\">map(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(a + <span class=\"number\">10</span>), [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]); <span class=\"comment\">// [Promise, Promise, Promise, Promise, Promise]</span></span><br></pre></td></tr></table></figure>\n\n<p>두가지 경우는 잘 통과했지만 마지막은 실패하는 모습을 보여줍니다. 생각해보면 미리 만들어둔 <code>reduce</code>는 인자로 전달되는 값(coll, acc)가 비동기인 경우만을 제어합니다. 함수가 만들어낸 값이 비동기일 경우를 제어하지 못하죠. 이제 <code>map</code>에도 <code>then</code>을 사용해야할 순간입니다. 함수에 적용한 결과가 Promise일지도 모른다는 가정으로 접근해야겠죠.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> push = <span class=\"function\">(<span class=\"params\">arr, v</span>) =&gt;</span> (arr.push(v), arr);</span><br><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\">(<span class=\"params\">f, coll</span>) =&gt;</span> reduce(</span><br><span class=\"line\">  (res, x) =&gt; then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> push(res, v), f(x)), <span class=\"comment\">// &lt;-- 여기가 포인트!</span></span><br><span class=\"line\">  coll, []);</span><br><span class=\"line\"></span><br><span class=\"line\">map(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(a + <span class=\"number\">10</span>), [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]).then(<span class=\"built_in\">console</span>.log); <span class=\"comment\">// [11, 12, 13, 14, 15]</span></span><br></pre></td></tr></table></figure>\n\n<p>이제 원하는대로 동작합니다. <code>f(x)</code>의 결과값을 <code>then</code> 함수의 두번째 인자로 전달하면 됩니다. 그리고 <code>push</code> 함수로 결과를 만들면 되죠. 이미 원하던 바는 이뤘습니다. </p>\n<h4 id=\"3-더보기\"><a href=\"#3-더보기\" class=\"headerlink\" title=\"(3) 더보기\"></a>(3) 더보기</h4><p>아래부터는 굳이 안해도 되는 구간입니다. 함수로 쪼개면 이렇게도 할 수 있음을 보여드리려고 합니다. 한번 막 만들어보겠습니다. 우선 <code>push</code> 함수를 고쳐보겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> push = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> <span class=\"function\"><span class=\"params\">v</span> =&gt;</span> (arr.push(v), arr);</span><br><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\">(<span class=\"params\">f, coll</span>) =&gt;</span> reduce(</span><br><span class=\"line\">  (res, x) =&gt; then(push(res), f(x)), <span class=\"comment\">// &lt;-- 간결해진 함수</span></span><br><span class=\"line\">  coll, []);</span><br></pre></td></tr></table></figure>\n\n<p><code>push</code> 함수를 함수를 반환하는 함수로 만들고 첫번째 함수에서 배열을 두번째 함수에서 값을 받는 함수로 만들면 <code>map</code> 내부에서 보다 간결하게 표현할 수 있습니다. </p>\n<p>조금 더 간결한 표현을 위해 몇가지 함수의 도움을 받아야합니다. <a href=\"/programming/javascript-daily-function-20/\"><code>pipe</code></a>, <code>spread</code>가 필요합니다. 두 함수를 만들기 위해선 또 두개의 함수가 더 필요한데, 배열을 멀티 리턴 값으로 치환해주는 <a href=\"/programming/javascript-daily-function-14/\"><code>to_mr</code></a>과 <code>go</code> 함수가 필요합니다. 이미 몇차례 소개해드린 적이 있어서 간단하게 구현만 살피겠습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 배열을 받아 멀티 리턴 값으로 치환하는 to_mr 함수 (이전에 소개드린 방식과 구현이 다릅니다)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> to_mr = <span class=\"function\"><span class=\"params\">arr</span> =&gt;</span> (&#123; <span class=\"attr\">__mr</span>: <span class=\"literal\">true</span>, <span class=\"attr\">value</span>: arr &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 첫번째로는 함수를 받고 두번째로는 인자를 받아 순서대로 실행한 뒤 멀티 리턴으로 반환하는 spread 함수</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> spread = <span class=\"function\">(<span class=\"params\">...fs</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> to_mr(fs.map(<span class=\"function\">(<span class=\"params\">f, i</span>) =&gt;</span> f(args[i])));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 시작값과 함수들을 받아 즉시 함수들을 실행하는 go 함수</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> go = <span class=\"function\">(<span class=\"params\">x, ...fs</span>) =&gt;</span> reduce(<span class=\"function\">(<span class=\"params\">res, f</span>) =&gt;</span> res.__mr ? f(...res.value) : f(res), fs, x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 함수들을 합성하는 pipe 함수</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> pipe = <span class=\"function\">(<span class=\"params\">...fs</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> go(to_mr(args), ...fs);</span><br></pre></td></tr></table></figure>\n\n<p>위의 함수 중 두가지 함수 <code>spread</code>와 <code>pipe</code>를 사용하면 아래와 같이 간결한 <code>map</code>을 만들 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// const map = (f, coll) =&gt; reduce((res, x) =&gt; then(push(res), f(x)), coll, []); // 기존 구현</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\">(<span class=\"params\">f, coll</span>) =&gt;</span> reduce(</span><br><span class=\"line\">  pipe(spread(push, f), then), <span class=\"comment\">// &lt;-- 함수로 함수를 만들기!</span></span><br><span class=\"line\">  coll, []);</span><br></pre></td></tr></table></figure>\n\n<p>기존 구현에서 <code>(res, x) =&gt; then(push(res), f(x))</code> 이 부분을 가만 살펴보면 전달되는 인자의 순서와 <code>then</code>내부에 실행되는 함수가 필요로하는 인자의 순서가 같음을 알 수 있습니다. 이때 <code>spread</code>를 사용하면 좋겠다는 생각이 들죠. 사용할 함수를 미리 <code>spread</code>에 적용해두고 그 결과를 <code>then</code> 함수에 적용하기 위해선 <code>pipe</code> 함수가 필요한거죠. 결국 <code>spread</code> 함수의 최종 실행 결과는 <code>push(res), f(x)</code>과 같습니다. 이 결과가 <code>then</code>에 전달됩니다. 멀티 리턴을 지원하는 <code>pipe</code> 함수이기에 이와 같은 전개가 가능합니다. </p>\n<p>여기에 덧해서 커링을 지원하는 <code>map</code>을 만들려면 <code>curry</code> 함수가 필요합니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> curry = <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> y === <span class=\"literal\">undefined</span> ? <span class=\"function\"><span class=\"params\">y</span> =&gt;</span> fn(x, y) : fn(x, y);</span><br><span class=\"line\"><span class=\"keyword\">const</span> map = curry(<span class=\"function\">(<span class=\"params\">f, coll</span>) =&gt;</span> reduce(pipe(spread(push, f), then), coll, []));</span><br></pre></td></tr></table></figure>\n\n<p>인자가 하나만 들어오면 커링을 하고 그렇지 않으면 즉시 실행합니다. 이제 <code>go</code> 함수를 써서 보다 함수형스럽게(?) 표현할 수 있습니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// map(a =&gt; Promise.resolve(a + 20), [1, 2, 3, 4, 5]).then(console.log); </span></span><br><span class=\"line\"></span><br><span class=\"line\">go([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], </span><br><span class=\"line\">  map(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"built_in\">Promise</span>.resolve(a + <span class=\"number\">20</span>)), </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// [11, 12, 13, 14, 15]</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"오늘의 함수 - match","date":"2019-06-17T11:00:00.000Z","description":"match는 조건에 맞는 함수를 실행하는 함수를 만듭니다.","_content":"_오늘 발견한 재미있는 함수를 소개합니다_\n\n## match\n\n오늘 다뤄볼 함수는 [몇번 다룬 적 있는 조건문 함수](/tags/조건문-함수/) 중 하나인 `match` 함수 입니다. 다른 조건문 함수보다 특별한 지점을 갖진 않지만 시간이 지나 조금 다른 방식으로 구현하게 되어 오늘의 함수로 소개드려보고자 합니다. 본문을 이해하기 위해선 함수를 합성하는 함수인 [`pipe`](/programming/javascript-daily-function-5/)나 다수의 함수를 연속적으로 실행시키는 함수에 대한 이해가 필요합니다. \n\n#### (1) 어제의 함수\n\n예시를 설명하기 위해 장황한 컨텍스트를 설명하기 보다 함수만을 보여드리는게 좋을 것 같아 바로 `match`를 사용하지 않는 경우를 보여드리겠습니다. `match` 함수가 필요한 상황입니다. \n\n```javascript\nswitch (parseInt(input_value)) {\n  case 1:\n    action3(action2(action1(value)));\n    break;\n  case 2:\n    action3(action2(action1(value)));\n    break;\n  default:\n    action4(value);\n    return;\n}\n```\n\n예제코드는 사용자로부터 특정한 값(`input_value`)을 전달 받고 이에 대해 몇가지 액션을 취하는 동작(`action`)을 합니다. switch-case 구문은 그 자체로 가독성이 좋은 코드입니다. 하지만 오늘 집중하고 싶은건 `pipe` 같은 합성 함수에서 조건문 함수를 사용하는 방식입니다. 만약에 함수를 합성하는 파이프라인 안에서 위의 코드를 삽입하면 아래와 같이 처리하게 됩니다.\n\n```javascript\nconst pipeline = pipe(\n  parseInt,\n  value => {\n    switch (value) {\n      case 1:\n        action3(action2(action1(value)));\n        break;\n      case 2:\n        action3(action2(action1(value)));\n        break;\n      default:\n        action4(value);\n        return;\n    }   \n  }\n);\n\npipeline(input_value);\n```\n\n모양새나 가독성이 나쁘지 않습니다. 하지만 모든걸 함수로 표현하고 싶은 욕심이 드는군요! 오늘의 함수로 구현해볼까요?\n\n#### (2) 오늘의 함수\n\n```javascript\nconst pipeline = pipe(\n  parseInt,\n  match\n    .case(1)(action1, action2, action3)\n    .case(2)(action1, action2, action3)\n    .default(action4)\n);\n\npipeline(input_value);\n```\n\n위와 같이 표현할 수 있습니다. `match` 함수는 `case`와 `default`라는 메서드를 가진 함수네요. 그리고 `case`는 연속해서 실행하면서 조건에 맞으면 실행할 함수들을 넣어주고 있습니다. 군더더기 없이 깔끔하게 표현되는 것 같네요. 그럼 구현은 어떻게 했을까요? 아래의 코드를 살펴보겠습니다. 오늘의 구현은 위에서 아래로 읽지 마시고 주석으로 표기된 순서대로 살펴보시면 이해가 쉽습니다! \n\n**구현체 톺아보기 1**\n```javascript\nconst match = (function self(input) { // [1] self 함수가 선언됩니다. input을 인자로 받는군요!\n  const init = () => {\n    self.actions = {};\n    self.case = condition => (...fns) => { // [5] case 메서드를 self 함수에 달아주네요.\n        self.actions[condition] = fns;\n        return self;\n    };\n    self.default = (...fns) => { // [6] default도 마찬가지구요. \n        self.actions.__default__ = fns;\n        return self;\n    };\n  };\n\n  if (input === undefined) { // [3] 아무런 값이 들어오질 않았으니 여기에 걸립니다.\n    init(); // [4] 뭔갈 초기화 해주고 있네요?\n    return self; // [7] 그리곤 자신을 반환합니다.\n  }\n  \n  if (input && self.actions[input]) { // 아직은 보지 않으셔도 괜찮습니다.\n    const matarials = [input, ...self.actions[input]];\n    const result = matarials.reduce(call);\n    init();\n    return result;\n  } else if (input && !self.actions[input]) {\n    const matarials = [input, ...self.actions.__default__];\n    const result = matarials.reduce(call);\n    init();\n    return result;\n  } \n})(); // [2] 오잉? 함수가 바로 실행됩니다! 아무런 값도 넘겨주지 않았어요.\n```\n\n여기까지 잘 따라오셨나요? 1번부터 7번까지 거치며 `match` 함수를 생성했습니다. 즉시 실행한 결과를 통해 `self` 함수가 반환됐죠. 이 결과로 `const match = self;`가 된 상황입니다. 다만 이 `match`는 `self` 내부에 선언된 `init` 함수를 통해 몇가지 값을 가진 상태가 되었습니다. 이 상황에서 실제로 `match`를 사용하게 되면 어떤 일이 벌어지는지 살펴보죠. 제일 아래에 실행부로 스크롤을 내려서 시작하세요. 이번에도 순서대로 따라오시면 됩니다.\n\n**구현체 톺아보기 2**\n```javascript\nconst match = (function self(input) {\n  const init = () => {\n    self.actions = {};\n    self.case = condition => (...fns) => { // [3] 내부를 살펴보죠. 아닛, case는 함수를 반환하는 함수였네요!\n        self.actions[condition] = fns; // [4] 아! fns는 아래에서 선언한 action1, action2, action3를 담은 배열이군요.\n        // [4-1] 이 배열을 self가 가진 객체인 actions라는 곳에 담아두고 있네요. \n        // [4-2] 키 값이 처음 case를 실행할때 전달된 값(condition)이라는 점을 눈여겨보세요.\n        return self; // [5] 다시 자기 자신을 반환하는군요.\n    };\n    self.default = (...fns) => { // [8] 음... 이건 case와 조금 다르네요. \n        self.actions.__default__ = fns; // [9] 바로 action4를 __default__라는 키의 값으로 담습니다.\n        return self; // [10] 이번에도 자기 자신은 반환하는군요!\n    };\n  };\n\n  if (input === undefined) {\n    // ...\n  }\n  \n  if (input && self.actions[input]) { // 지금도 때가 아니군요.\n    const matarials = [input, ...self.actions[input]];\n    const result = matarials.reduce(call);\n    init();\n    return result;\n  } else if (input && !self.actions[input]) {\n    const matarials = [input, ...self.actions.__default__];\n    const result = matarials.reduce(call);\n    init();\n    return result;\n  } \n})();\n\n\nconst pipeline = pipe(\n  parseInt,\n  match // [1] match는 바로 메서드인 case를 부르는군요. \n    .case(1)(action1, action2, action3) // [2] 오호, case가 두번 연속 실행됐습니다. 어떤 일이 일어난걸까요?\n    .case(2)(action1, action2, action3) // [6] 2번부터 5번까지 한번 더 수행합니다. 이제 self.actions는 두개의 키를 갖겠죠?\n    .default(action4) // [7] 여기선 어떤 일이 벌어질까요?\n);\n\npipeline(input_value);\n```\n\n쉽지 않으셨을 것 같습니다. 1번부터 무려 10번까지 달려오셨습니다. 복잡한 로직을 잘 따라오고 계시다면 정말 대단하신겁니다. 어렴풋이 내용이 이해가 가셨다면 한번 보세요. 지금 10번에서 반환한 값이 `self`였습니다. 무슨 일이 벌어진걸까요?\n\n```javascript\nconst pipeline = pipe(\n  parseInt,\n  self // default까지 실행되면 이 자리에 self만 남습니다. \n  // match\n  //   .case(1)(action1, action2, action3)\n  //   .case(2)(action1, action2, action3)\n  //   .default(action4)\n);\n```\n\n**\"default까지 실행되면 이 자리에 self만 남습니다.\"** 이게 무슨 말이죠? 왜 다시 `self`가 남은건가요. 처음 선안한 `self`와 지금의 이 함수는 어떻게 다른거죠? 두 함수는 같은 로직을 갖지만 재료가 다릅니다. 마지막에 남은 `self`는 **조건(condition)과 조건에 따른 행동(action)을 알고 있는 상태의 함수입니다.** 이 함수에게 이제 어떤 값이 들어오면 그 값에 따라 특정 행동(action)을 할 준비가 된 상황이죠. 이 상태는 `match.case`, `match.default`를 통해 `self.actions`에 저장되어 있습니다. 이해가 되셨나요? 이제 마무리를 지어보죠!\n\n**구현체 톺아보기 3**\n```javascript\nconst call = (x, f) => f(x); // [7-1] 인자와 실행할 함수를 전달하면 함수에 인자를 넣어 실행합니다.\n\nconst match = (function self(input) { // [3] 이제는 input을 가지고 왔을겁니다. (parseInt의 결과값)\n  const init = () => {\n    // ...\n  };\n\n  if (input === undefined) {\n    // ...\n  }\n  \n  if (self.actions[input]) { // [4] 만약에 input 값에 해당하는 키가 존재하면 여기를 거칩니다.\n    const matarials = [input, ...self.actions[input]]; // [6] 우리가 가진 재료들을 모아 (이때는 조건에 맞는 함수들)\n    const result = matarials.reduce(call); // [7] 결과를 만들어냅니다!\n    init(); // [8] 다음에 또 match 함수를 사용하기 위해 초기화를 해줍니다.\n    return result; // [9] 결과를 반환하면 끝입니다.\n  } else if (!self.actions[input]) { // [5] 아니라면 여기겠죠!\n    const matarials = [input, ...self.actions.__default__];\n    const result = matarials.reduce(call);\n    init();\n    return result;\n  } \n})();\n\nconst pipeline = pipe(\n  parseInt,\n  match // [2] 코드가 실행되는 상황에 이 자리는 self 함수가 차지하고 있습니다.\n    .case(1)(action1, action2, action3)\n    .case(2)(action1, action2, action3)\n    .default(action4)\n);\n\npipeline(input_value); // [1] 합성해둔 함수가 실행됩니다.\n```\n\n어떠셨나요? 이번 함수는 제법 길고 복잡해서 설명을 주석으로 장황하게 적었습니다. 다소 여러우셨을 것 같습니다. \n\n여기까지 이 글을 꼼꼼하게 보셨든 쓰윽 보셨든 아마 이런 생각이 드실겁니다. _\"함수형 이거... 이렇게까지 (복잡하고 어렵게) 해야하는거야?\"_ 제 생각이 정답은 아니지만, _이렇게까지 하실 필요는 없습니다._ 사실 순수하게 로직만 남은 작은 함수를 조합해서 프로그래밍하는게 함수형이지 이런 복잡한 함수의 내부를 들여다보는게 함수형 프로그래밍은 아닙니다. **다만 라이브러리로 구현된 함수만을 사용해 우리가 원하는 것을 온전히 구현해내지 못할 가능성이 큽니다. 때문에 조금 복잡한 함수(순수 함수)를 직접 만들고 뜯어보는 역량이 고급 함수형 프로그래밍에 지대한 영향을 끼친다고 생각합니다.** 그러한 연고로 이렇게 복잡한 코드를 구현해봤습니다. 어떻게 느끼셨을지 모르지만, \"이거 제법 재밌네\" 하는 정도의 느낌을 가져가셨으면 좋겠습니다. \n\n긴 글 읽고 따라와주셔서 감사합니다! 다음에 또 뵙겠습니다.","source":"_posts/daily-fp-22.md","raw":"---\ntitle: '오늘의 함수 - match'\ndate: 2019-06-17 20:00:00\ncategories:\n  - programming\ntags:\n  - javascript\n  - 오늘의 함수\n  - 함수형 프로그래밍\n  - 조건문 함수\ndescription: match는 조건에 맞는 함수를 실행하는 함수를 만듭니다.\n---\n_오늘 발견한 재미있는 함수를 소개합니다_\n\n## match\n\n오늘 다뤄볼 함수는 [몇번 다룬 적 있는 조건문 함수](/tags/조건문-함수/) 중 하나인 `match` 함수 입니다. 다른 조건문 함수보다 특별한 지점을 갖진 않지만 시간이 지나 조금 다른 방식으로 구현하게 되어 오늘의 함수로 소개드려보고자 합니다. 본문을 이해하기 위해선 함수를 합성하는 함수인 [`pipe`](/programming/javascript-daily-function-5/)나 다수의 함수를 연속적으로 실행시키는 함수에 대한 이해가 필요합니다. \n\n#### (1) 어제의 함수\n\n예시를 설명하기 위해 장황한 컨텍스트를 설명하기 보다 함수만을 보여드리는게 좋을 것 같아 바로 `match`를 사용하지 않는 경우를 보여드리겠습니다. `match` 함수가 필요한 상황입니다. \n\n```javascript\nswitch (parseInt(input_value)) {\n  case 1:\n    action3(action2(action1(value)));\n    break;\n  case 2:\n    action3(action2(action1(value)));\n    break;\n  default:\n    action4(value);\n    return;\n}\n```\n\n예제코드는 사용자로부터 특정한 값(`input_value`)을 전달 받고 이에 대해 몇가지 액션을 취하는 동작(`action`)을 합니다. switch-case 구문은 그 자체로 가독성이 좋은 코드입니다. 하지만 오늘 집중하고 싶은건 `pipe` 같은 합성 함수에서 조건문 함수를 사용하는 방식입니다. 만약에 함수를 합성하는 파이프라인 안에서 위의 코드를 삽입하면 아래와 같이 처리하게 됩니다.\n\n```javascript\nconst pipeline = pipe(\n  parseInt,\n  value => {\n    switch (value) {\n      case 1:\n        action3(action2(action1(value)));\n        break;\n      case 2:\n        action3(action2(action1(value)));\n        break;\n      default:\n        action4(value);\n        return;\n    }   \n  }\n);\n\npipeline(input_value);\n```\n\n모양새나 가독성이 나쁘지 않습니다. 하지만 모든걸 함수로 표현하고 싶은 욕심이 드는군요! 오늘의 함수로 구현해볼까요?\n\n#### (2) 오늘의 함수\n\n```javascript\nconst pipeline = pipe(\n  parseInt,\n  match\n    .case(1)(action1, action2, action3)\n    .case(2)(action1, action2, action3)\n    .default(action4)\n);\n\npipeline(input_value);\n```\n\n위와 같이 표현할 수 있습니다. `match` 함수는 `case`와 `default`라는 메서드를 가진 함수네요. 그리고 `case`는 연속해서 실행하면서 조건에 맞으면 실행할 함수들을 넣어주고 있습니다. 군더더기 없이 깔끔하게 표현되는 것 같네요. 그럼 구현은 어떻게 했을까요? 아래의 코드를 살펴보겠습니다. 오늘의 구현은 위에서 아래로 읽지 마시고 주석으로 표기된 순서대로 살펴보시면 이해가 쉽습니다! \n\n**구현체 톺아보기 1**\n```javascript\nconst match = (function self(input) { // [1] self 함수가 선언됩니다. input을 인자로 받는군요!\n  const init = () => {\n    self.actions = {};\n    self.case = condition => (...fns) => { // [5] case 메서드를 self 함수에 달아주네요.\n        self.actions[condition] = fns;\n        return self;\n    };\n    self.default = (...fns) => { // [6] default도 마찬가지구요. \n        self.actions.__default__ = fns;\n        return self;\n    };\n  };\n\n  if (input === undefined) { // [3] 아무런 값이 들어오질 않았으니 여기에 걸립니다.\n    init(); // [4] 뭔갈 초기화 해주고 있네요?\n    return self; // [7] 그리곤 자신을 반환합니다.\n  }\n  \n  if (input && self.actions[input]) { // 아직은 보지 않으셔도 괜찮습니다.\n    const matarials = [input, ...self.actions[input]];\n    const result = matarials.reduce(call);\n    init();\n    return result;\n  } else if (input && !self.actions[input]) {\n    const matarials = [input, ...self.actions.__default__];\n    const result = matarials.reduce(call);\n    init();\n    return result;\n  } \n})(); // [2] 오잉? 함수가 바로 실행됩니다! 아무런 값도 넘겨주지 않았어요.\n```\n\n여기까지 잘 따라오셨나요? 1번부터 7번까지 거치며 `match` 함수를 생성했습니다. 즉시 실행한 결과를 통해 `self` 함수가 반환됐죠. 이 결과로 `const match = self;`가 된 상황입니다. 다만 이 `match`는 `self` 내부에 선언된 `init` 함수를 통해 몇가지 값을 가진 상태가 되었습니다. 이 상황에서 실제로 `match`를 사용하게 되면 어떤 일이 벌어지는지 살펴보죠. 제일 아래에 실행부로 스크롤을 내려서 시작하세요. 이번에도 순서대로 따라오시면 됩니다.\n\n**구현체 톺아보기 2**\n```javascript\nconst match = (function self(input) {\n  const init = () => {\n    self.actions = {};\n    self.case = condition => (...fns) => { // [3] 내부를 살펴보죠. 아닛, case는 함수를 반환하는 함수였네요!\n        self.actions[condition] = fns; // [4] 아! fns는 아래에서 선언한 action1, action2, action3를 담은 배열이군요.\n        // [4-1] 이 배열을 self가 가진 객체인 actions라는 곳에 담아두고 있네요. \n        // [4-2] 키 값이 처음 case를 실행할때 전달된 값(condition)이라는 점을 눈여겨보세요.\n        return self; // [5] 다시 자기 자신을 반환하는군요.\n    };\n    self.default = (...fns) => { // [8] 음... 이건 case와 조금 다르네요. \n        self.actions.__default__ = fns; // [9] 바로 action4를 __default__라는 키의 값으로 담습니다.\n        return self; // [10] 이번에도 자기 자신은 반환하는군요!\n    };\n  };\n\n  if (input === undefined) {\n    // ...\n  }\n  \n  if (input && self.actions[input]) { // 지금도 때가 아니군요.\n    const matarials = [input, ...self.actions[input]];\n    const result = matarials.reduce(call);\n    init();\n    return result;\n  } else if (input && !self.actions[input]) {\n    const matarials = [input, ...self.actions.__default__];\n    const result = matarials.reduce(call);\n    init();\n    return result;\n  } \n})();\n\n\nconst pipeline = pipe(\n  parseInt,\n  match // [1] match는 바로 메서드인 case를 부르는군요. \n    .case(1)(action1, action2, action3) // [2] 오호, case가 두번 연속 실행됐습니다. 어떤 일이 일어난걸까요?\n    .case(2)(action1, action2, action3) // [6] 2번부터 5번까지 한번 더 수행합니다. 이제 self.actions는 두개의 키를 갖겠죠?\n    .default(action4) // [7] 여기선 어떤 일이 벌어질까요?\n);\n\npipeline(input_value);\n```\n\n쉽지 않으셨을 것 같습니다. 1번부터 무려 10번까지 달려오셨습니다. 복잡한 로직을 잘 따라오고 계시다면 정말 대단하신겁니다. 어렴풋이 내용이 이해가 가셨다면 한번 보세요. 지금 10번에서 반환한 값이 `self`였습니다. 무슨 일이 벌어진걸까요?\n\n```javascript\nconst pipeline = pipe(\n  parseInt,\n  self // default까지 실행되면 이 자리에 self만 남습니다. \n  // match\n  //   .case(1)(action1, action2, action3)\n  //   .case(2)(action1, action2, action3)\n  //   .default(action4)\n);\n```\n\n**\"default까지 실행되면 이 자리에 self만 남습니다.\"** 이게 무슨 말이죠? 왜 다시 `self`가 남은건가요. 처음 선안한 `self`와 지금의 이 함수는 어떻게 다른거죠? 두 함수는 같은 로직을 갖지만 재료가 다릅니다. 마지막에 남은 `self`는 **조건(condition)과 조건에 따른 행동(action)을 알고 있는 상태의 함수입니다.** 이 함수에게 이제 어떤 값이 들어오면 그 값에 따라 특정 행동(action)을 할 준비가 된 상황이죠. 이 상태는 `match.case`, `match.default`를 통해 `self.actions`에 저장되어 있습니다. 이해가 되셨나요? 이제 마무리를 지어보죠!\n\n**구현체 톺아보기 3**\n```javascript\nconst call = (x, f) => f(x); // [7-1] 인자와 실행할 함수를 전달하면 함수에 인자를 넣어 실행합니다.\n\nconst match = (function self(input) { // [3] 이제는 input을 가지고 왔을겁니다. (parseInt의 결과값)\n  const init = () => {\n    // ...\n  };\n\n  if (input === undefined) {\n    // ...\n  }\n  \n  if (self.actions[input]) { // [4] 만약에 input 값에 해당하는 키가 존재하면 여기를 거칩니다.\n    const matarials = [input, ...self.actions[input]]; // [6] 우리가 가진 재료들을 모아 (이때는 조건에 맞는 함수들)\n    const result = matarials.reduce(call); // [7] 결과를 만들어냅니다!\n    init(); // [8] 다음에 또 match 함수를 사용하기 위해 초기화를 해줍니다.\n    return result; // [9] 결과를 반환하면 끝입니다.\n  } else if (!self.actions[input]) { // [5] 아니라면 여기겠죠!\n    const matarials = [input, ...self.actions.__default__];\n    const result = matarials.reduce(call);\n    init();\n    return result;\n  } \n})();\n\nconst pipeline = pipe(\n  parseInt,\n  match // [2] 코드가 실행되는 상황에 이 자리는 self 함수가 차지하고 있습니다.\n    .case(1)(action1, action2, action3)\n    .case(2)(action1, action2, action3)\n    .default(action4)\n);\n\npipeline(input_value); // [1] 합성해둔 함수가 실행됩니다.\n```\n\n어떠셨나요? 이번 함수는 제법 길고 복잡해서 설명을 주석으로 장황하게 적었습니다. 다소 여러우셨을 것 같습니다. \n\n여기까지 이 글을 꼼꼼하게 보셨든 쓰윽 보셨든 아마 이런 생각이 드실겁니다. _\"함수형 이거... 이렇게까지 (복잡하고 어렵게) 해야하는거야?\"_ 제 생각이 정답은 아니지만, _이렇게까지 하실 필요는 없습니다._ 사실 순수하게 로직만 남은 작은 함수를 조합해서 프로그래밍하는게 함수형이지 이런 복잡한 함수의 내부를 들여다보는게 함수형 프로그래밍은 아닙니다. **다만 라이브러리로 구현된 함수만을 사용해 우리가 원하는 것을 온전히 구현해내지 못할 가능성이 큽니다. 때문에 조금 복잡한 함수(순수 함수)를 직접 만들고 뜯어보는 역량이 고급 함수형 프로그래밍에 지대한 영향을 끼친다고 생각합니다.** 그러한 연고로 이렇게 복잡한 코드를 구현해봤습니다. 어떻게 느끼셨을지 모르지만, \"이거 제법 재밌네\" 하는 정도의 느낌을 가져가셨으면 좋겠습니다. \n\n긴 글 읽고 따라와주셔서 감사합니다! 다음에 또 뵙겠습니다.","slug":"daily-fp-22","published":1,"updated":"2019-12-05T15:06:08.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9io009ddirvhqz3612g","content":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h2><p>오늘 다뤄볼 함수는 <a href=\"/tags/조건문-함수/\">몇번 다룬 적 있는 조건문 함수</a> 중 하나인 <code>match</code> 함수 입니다. 다른 조건문 함수보다 특별한 지점을 갖진 않지만 시간이 지나 조금 다른 방식으로 구현하게 되어 오늘의 함수로 소개드려보고자 합니다. 본문을 이해하기 위해선 함수를 합성하는 함수인 <a href=\"/programming/javascript-daily-function-5/\"><code>pipe</code></a>나 다수의 함수를 연속적으로 실행시키는 함수에 대한 이해가 필요합니다. </p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><p>예시를 설명하기 위해 장황한 컨텍스트를 설명하기 보다 함수만을 보여드리는게 좋을 것 같아 바로 <code>match</code>를 사용하지 않는 경우를 보여드리겠습니다. <code>match</code> 함수가 필요한 상황입니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (<span class=\"built_in\">parseInt</span>(input_value)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    action3(action2(action1(value)));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">    action3(action2(action1(value)));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    action4(value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>예제코드는 사용자로부터 특정한 값(<code>input_value</code>)을 전달 받고 이에 대해 몇가지 액션을 취하는 동작(<code>action</code>)을 합니다. switch-case 구문은 그 자체로 가독성이 좋은 코드입니다. 하지만 오늘 집중하고 싶은건 <code>pipe</code> 같은 합성 함수에서 조건문 함수를 사용하는 방식입니다. 만약에 함수를 합성하는 파이프라인 안에서 위의 코드를 삽입하면 아래와 같이 처리하게 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pipeline = pipe(</span><br><span class=\"line\">  <span class=\"built_in\">parseInt</span>,</span><br><span class=\"line\">  value =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (value) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        action3(action2(action1(value)));</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        action3(action2(action1(value)));</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        action4(value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">pipeline(input_value);</span><br></pre></td></tr></table></figure>\n\n<p>모양새나 가독성이 나쁘지 않습니다. 하지만 모든걸 함수로 표현하고 싶은 욕심이 드는군요! 오늘의 함수로 구현해볼까요?</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pipeline = pipe(</span><br><span class=\"line\">  <span class=\"built_in\">parseInt</span>,</span><br><span class=\"line\">  match</span><br><span class=\"line\">    .case(<span class=\"number\">1</span>)(action1, action2, action3)</span><br><span class=\"line\">    .case(<span class=\"number\">2</span>)(action1, action2, action3)</span><br><span class=\"line\">    .default(action4)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">pipeline(input_value);</span><br></pre></td></tr></table></figure>\n\n<p>위와 같이 표현할 수 있습니다. <code>match</code> 함수는 <code>case</code>와 <code>default</code>라는 메서드를 가진 함수네요. 그리고 <code>case</code>는 연속해서 실행하면서 조건에 맞으면 실행할 함수들을 넣어주고 있습니다. 군더더기 없이 깔끔하게 표현되는 것 같네요. 그럼 구현은 어떻게 했을까요? 아래의 코드를 살펴보겠습니다. 오늘의 구현은 위에서 아래로 읽지 마시고 주석으로 표기된 순서대로 살펴보시면 이해가 쉽습니다! </p>\n<p><strong>구현체 톺아보기 1</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> match = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">self</span>(<span class=\"params\">input</span>) </span>&#123; <span class=\"comment\">// [1] self 함수가 선언됩니다. input을 인자로 받는군요!</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> init = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    self.actions = &#123;&#125;;</span><br><span class=\"line\">    self.case = <span class=\"function\"><span class=\"params\">condition</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> &#123; <span class=\"comment\">// [5] case 메서드를 self 함수에 달아주네요.</span></span><br><span class=\"line\">        self.actions[condition] = fns;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    self.default = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> &#123; <span class=\"comment\">// [6] default도 마찬가지구요. </span></span><br><span class=\"line\">        self.actions.__default__ = fns;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input === <span class=\"literal\">undefined</span>) &#123; <span class=\"comment\">// [3] 아무런 값이 들어오질 않았으니 여기에 걸립니다.</span></span><br><span class=\"line\">    init(); <span class=\"comment\">// [4] 뭔갈 초기화 해주고 있네요?</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> self; <span class=\"comment\">// [7] 그리곤 자신을 반환합니다.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input &amp;&amp; self.actions[input]) &#123; <span class=\"comment\">// 아직은 보지 않으셔도 괜찮습니다.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> matarials = [input, ...self.actions[input]];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = matarials.reduce(call);</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (input &amp;&amp; !self.actions[input]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> matarials = [input, ...self.actions.__default__];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = matarials.reduce(call);</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;)(); <span class=\"comment\">// [2] 오잉? 함수가 바로 실행됩니다! 아무런 값도 넘겨주지 않았어요.</span></span><br></pre></td></tr></table></figure>\n\n<p>여기까지 잘 따라오셨나요? 1번부터 7번까지 거치며 <code>match</code> 함수를 생성했습니다. 즉시 실행한 결과를 통해 <code>self</code> 함수가 반환됐죠. 이 결과로 <code>const match = self;</code>가 된 상황입니다. 다만 이 <code>match</code>는 <code>self</code> 내부에 선언된 <code>init</code> 함수를 통해 몇가지 값을 가진 상태가 되었습니다. 이 상황에서 실제로 <code>match</code>를 사용하게 되면 어떤 일이 벌어지는지 살펴보죠. 제일 아래에 실행부로 스크롤을 내려서 시작하세요. 이번에도 순서대로 따라오시면 됩니다.</p>\n<p><strong>구현체 톺아보기 2</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> match = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">self</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> init = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    self.actions = &#123;&#125;;</span><br><span class=\"line\">    self.case = <span class=\"function\"><span class=\"params\">condition</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> &#123; <span class=\"comment\">// [3] 내부를 살펴보죠. 아닛, case는 함수를 반환하는 함수였네요!</span></span><br><span class=\"line\">        self.actions[condition] = fns; <span class=\"comment\">// [4] 아! fns는 아래에서 선언한 action1, action2, action3를 담은 배열이군요.</span></span><br><span class=\"line\">        <span class=\"comment\">// [4-1] 이 배열을 self가 가진 객체인 actions라는 곳에 담아두고 있네요. </span></span><br><span class=\"line\">        <span class=\"comment\">// [4-2] 키 값이 처음 case를 실행할때 전달된 값(condition)이라는 점을 눈여겨보세요.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self; <span class=\"comment\">// [5] 다시 자기 자신을 반환하는군요.</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    self.default = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> &#123; <span class=\"comment\">// [8] 음... 이건 case와 조금 다르네요. </span></span><br><span class=\"line\">        self.actions.__default__ = fns; <span class=\"comment\">// [9] 바로 action4를 __default__라는 키의 값으로 담습니다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self; <span class=\"comment\">// [10] 이번에도 자기 자신은 반환하는군요!</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input &amp;&amp; self.actions[input]) &#123; <span class=\"comment\">// 지금도 때가 아니군요.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> matarials = [input, ...self.actions[input]];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = matarials.reduce(call);</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (input &amp;&amp; !self.actions[input]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> matarials = [input, ...self.actions.__default__];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = matarials.reduce(call);</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> pipeline = pipe(</span><br><span class=\"line\">  <span class=\"built_in\">parseInt</span>,</span><br><span class=\"line\">  match <span class=\"comment\">// [1] match는 바로 메서드인 case를 부르는군요. </span></span><br><span class=\"line\">    .case(<span class=\"number\">1</span>)(action1, action2, action3) <span class=\"comment\">// [2] 오호, case가 두번 연속 실행됐습니다. 어떤 일이 일어난걸까요?</span></span><br><span class=\"line\">    .case(<span class=\"number\">2</span>)(action1, action2, action3) <span class=\"comment\">// [6] 2번부터 5번까지 한번 더 수행합니다. 이제 self.actions는 두개의 키를 갖겠죠?</span></span><br><span class=\"line\">    .default(action4) <span class=\"comment\">// [7] 여기선 어떤 일이 벌어질까요?</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">pipeline(input_value);</span><br></pre></td></tr></table></figure>\n\n<p>쉽지 않으셨을 것 같습니다. 1번부터 무려 10번까지 달려오셨습니다. 복잡한 로직을 잘 따라오고 계시다면 정말 대단하신겁니다. 어렴풋이 내용이 이해가 가셨다면 한번 보세요. 지금 10번에서 반환한 값이 <code>self</code>였습니다. 무슨 일이 벌어진걸까요?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pipeline = pipe(</span><br><span class=\"line\">  <span class=\"built_in\">parseInt</span>,</span><br><span class=\"line\">  self <span class=\"comment\">// default까지 실행되면 이 자리에 self만 남습니다. </span></span><br><span class=\"line\">  <span class=\"comment\">// match</span></span><br><span class=\"line\">  <span class=\"comment\">//   .case(1)(action1, action2, action3)</span></span><br><span class=\"line\">  <span class=\"comment\">//   .case(2)(action1, action2, action3)</span></span><br><span class=\"line\">  <span class=\"comment\">//   .default(action4)</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><strong>“default까지 실행되면 이 자리에 self만 남습니다.”</strong> 이게 무슨 말이죠? 왜 다시 <code>self</code>가 남은건가요. 처음 선안한 <code>self</code>와 지금의 이 함수는 어떻게 다른거죠? 두 함수는 같은 로직을 갖지만 재료가 다릅니다. 마지막에 남은 <code>self</code>는 <strong>조건(condition)과 조건에 따른 행동(action)을 알고 있는 상태의 함수입니다.</strong> 이 함수에게 이제 어떤 값이 들어오면 그 값에 따라 특정 행동(action)을 할 준비가 된 상황이죠. 이 상태는 <code>match.case</code>, <code>match.default</code>를 통해 <code>self.actions</code>에 저장되어 있습니다. 이해가 되셨나요? 이제 마무리를 지어보죠!</p>\n<p><strong>구현체 톺아보기 3</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> call = <span class=\"function\">(<span class=\"params\">x, f</span>) =&gt;</span> f(x); <span class=\"comment\">// [7-1] 인자와 실행할 함수를 전달하면 함수에 인자를 넣어 실행합니다.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> match = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">self</span>(<span class=\"params\">input</span>) </span>&#123; <span class=\"comment\">// [3] 이제는 input을 가지고 왔을겁니다. (parseInt의 결과값)</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> init = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (self.actions[input]) &#123; <span class=\"comment\">// [4] 만약에 input 값에 해당하는 키가 존재하면 여기를 거칩니다.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> matarials = [input, ...self.actions[input]]; <span class=\"comment\">// [6] 우리가 가진 재료들을 모아 (이때는 조건에 맞는 함수들)</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = matarials.reduce(call); <span class=\"comment\">// [7] 결과를 만들어냅니다!</span></span><br><span class=\"line\">    init(); <span class=\"comment\">// [8] 다음에 또 match 함수를 사용하기 위해 초기화를 해줍니다.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result; <span class=\"comment\">// [9] 결과를 반환하면 끝입니다.</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!self.actions[input]) &#123; <span class=\"comment\">// [5] 아니라면 여기겠죠!</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> matarials = [input, ...self.actions.__default__];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = matarials.reduce(call);</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> pipeline = pipe(</span><br><span class=\"line\">  <span class=\"built_in\">parseInt</span>,</span><br><span class=\"line\">  match <span class=\"comment\">// [2] 코드가 실행되는 상황에 이 자리는 self 함수가 차지하고 있습니다.</span></span><br><span class=\"line\">    .case(<span class=\"number\">1</span>)(action1, action2, action3)</span><br><span class=\"line\">    .case(<span class=\"number\">2</span>)(action1, action2, action3)</span><br><span class=\"line\">    .default(action4)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">pipeline(input_value); <span class=\"comment\">// [1] 합성해둔 함수가 실행됩니다.</span></span><br></pre></td></tr></table></figure>\n\n<p>어떠셨나요? 이번 함수는 제법 길고 복잡해서 설명을 주석으로 장황하게 적었습니다. 다소 여러우셨을 것 같습니다. </p>\n<p>여기까지 이 글을 꼼꼼하게 보셨든 쓰윽 보셨든 아마 이런 생각이 드실겁니다. <em>“함수형 이거… 이렇게까지 (복잡하고 어렵게) 해야하는거야?”</em> 제 생각이 정답은 아니지만, <em>이렇게까지 하실 필요는 없습니다.</em> 사실 순수하게 로직만 남은 작은 함수를 조합해서 프로그래밍하는게 함수형이지 이런 복잡한 함수의 내부를 들여다보는게 함수형 프로그래밍은 아닙니다. <strong>다만 라이브러리로 구현된 함수만을 사용해 우리가 원하는 것을 온전히 구현해내지 못할 가능성이 큽니다. 때문에 조금 복잡한 함수(순수 함수)를 직접 만들고 뜯어보는 역량이 고급 함수형 프로그래밍에 지대한 영향을 끼친다고 생각합니다.</strong> 그러한 연고로 이렇게 복잡한 코드를 구현해봤습니다. 어떻게 느끼셨을지 모르지만, “이거 제법 재밌네” 하는 정도의 느낌을 가져가셨으면 좋겠습니다. </p>\n<p>긴 글 읽고 따라와주셔서 감사합니다! 다음에 또 뵙겠습니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>오늘 발견한 재미있는 함수를 소개합니다</em></p>\n<h2 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match\"></a>match</h2><p>오늘 다뤄볼 함수는 <a href=\"/tags/조건문-함수/\">몇번 다룬 적 있는 조건문 함수</a> 중 하나인 <code>match</code> 함수 입니다. 다른 조건문 함수보다 특별한 지점을 갖진 않지만 시간이 지나 조금 다른 방식으로 구현하게 되어 오늘의 함수로 소개드려보고자 합니다. 본문을 이해하기 위해선 함수를 합성하는 함수인 <a href=\"/programming/javascript-daily-function-5/\"><code>pipe</code></a>나 다수의 함수를 연속적으로 실행시키는 함수에 대한 이해가 필요합니다. </p>\n<h4 id=\"1-어제의-함수\"><a href=\"#1-어제의-함수\" class=\"headerlink\" title=\"(1) 어제의 함수\"></a>(1) 어제의 함수</h4><p>예시를 설명하기 위해 장황한 컨텍스트를 설명하기 보다 함수만을 보여드리는게 좋을 것 같아 바로 <code>match</code>를 사용하지 않는 경우를 보여드리겠습니다. <code>match</code> 함수가 필요한 상황입니다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (<span class=\"built_in\">parseInt</span>(input_value)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    action3(action2(action1(value)));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">    action3(action2(action1(value)));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    action4(value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>예제코드는 사용자로부터 특정한 값(<code>input_value</code>)을 전달 받고 이에 대해 몇가지 액션을 취하는 동작(<code>action</code>)을 합니다. switch-case 구문은 그 자체로 가독성이 좋은 코드입니다. 하지만 오늘 집중하고 싶은건 <code>pipe</code> 같은 합성 함수에서 조건문 함수를 사용하는 방식입니다. 만약에 함수를 합성하는 파이프라인 안에서 위의 코드를 삽입하면 아래와 같이 처리하게 됩니다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pipeline = pipe(</span><br><span class=\"line\">  <span class=\"built_in\">parseInt</span>,</span><br><span class=\"line\">  value =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (value) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        action3(action2(action1(value)));</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        action3(action2(action1(value)));</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        action4(value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">pipeline(input_value);</span><br></pre></td></tr></table></figure>\n\n<p>모양새나 가독성이 나쁘지 않습니다. 하지만 모든걸 함수로 표현하고 싶은 욕심이 드는군요! 오늘의 함수로 구현해볼까요?</p>\n<h4 id=\"2-오늘의-함수\"><a href=\"#2-오늘의-함수\" class=\"headerlink\" title=\"(2) 오늘의 함수\"></a>(2) 오늘의 함수</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pipeline = pipe(</span><br><span class=\"line\">  <span class=\"built_in\">parseInt</span>,</span><br><span class=\"line\">  match</span><br><span class=\"line\">    .case(<span class=\"number\">1</span>)(action1, action2, action3)</span><br><span class=\"line\">    .case(<span class=\"number\">2</span>)(action1, action2, action3)</span><br><span class=\"line\">    .default(action4)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">pipeline(input_value);</span><br></pre></td></tr></table></figure>\n\n<p>위와 같이 표현할 수 있습니다. <code>match</code> 함수는 <code>case</code>와 <code>default</code>라는 메서드를 가진 함수네요. 그리고 <code>case</code>는 연속해서 실행하면서 조건에 맞으면 실행할 함수들을 넣어주고 있습니다. 군더더기 없이 깔끔하게 표현되는 것 같네요. 그럼 구현은 어떻게 했을까요? 아래의 코드를 살펴보겠습니다. 오늘의 구현은 위에서 아래로 읽지 마시고 주석으로 표기된 순서대로 살펴보시면 이해가 쉽습니다! </p>\n<p><strong>구현체 톺아보기 1</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> match = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">self</span>(<span class=\"params\">input</span>) </span>&#123; <span class=\"comment\">// [1] self 함수가 선언됩니다. input을 인자로 받는군요!</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> init = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    self.actions = &#123;&#125;;</span><br><span class=\"line\">    self.case = <span class=\"function\"><span class=\"params\">condition</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> &#123; <span class=\"comment\">// [5] case 메서드를 self 함수에 달아주네요.</span></span><br><span class=\"line\">        self.actions[condition] = fns;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    self.default = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> &#123; <span class=\"comment\">// [6] default도 마찬가지구요. </span></span><br><span class=\"line\">        self.actions.__default__ = fns;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input === <span class=\"literal\">undefined</span>) &#123; <span class=\"comment\">// [3] 아무런 값이 들어오질 않았으니 여기에 걸립니다.</span></span><br><span class=\"line\">    init(); <span class=\"comment\">// [4] 뭔갈 초기화 해주고 있네요?</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> self; <span class=\"comment\">// [7] 그리곤 자신을 반환합니다.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input &amp;&amp; self.actions[input]) &#123; <span class=\"comment\">// 아직은 보지 않으셔도 괜찮습니다.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> matarials = [input, ...self.actions[input]];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = matarials.reduce(call);</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (input &amp;&amp; !self.actions[input]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> matarials = [input, ...self.actions.__default__];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = matarials.reduce(call);</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;)(); <span class=\"comment\">// [2] 오잉? 함수가 바로 실행됩니다! 아무런 값도 넘겨주지 않았어요.</span></span><br></pre></td></tr></table></figure>\n\n<p>여기까지 잘 따라오셨나요? 1번부터 7번까지 거치며 <code>match</code> 함수를 생성했습니다. 즉시 실행한 결과를 통해 <code>self</code> 함수가 반환됐죠. 이 결과로 <code>const match = self;</code>가 된 상황입니다. 다만 이 <code>match</code>는 <code>self</code> 내부에 선언된 <code>init</code> 함수를 통해 몇가지 값을 가진 상태가 되었습니다. 이 상황에서 실제로 <code>match</code>를 사용하게 되면 어떤 일이 벌어지는지 살펴보죠. 제일 아래에 실행부로 스크롤을 내려서 시작하세요. 이번에도 순서대로 따라오시면 됩니다.</p>\n<p><strong>구현체 톺아보기 2</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> match = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">self</span>(<span class=\"params\">input</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> init = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    self.actions = &#123;&#125;;</span><br><span class=\"line\">    self.case = <span class=\"function\"><span class=\"params\">condition</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> &#123; <span class=\"comment\">// [3] 내부를 살펴보죠. 아닛, case는 함수를 반환하는 함수였네요!</span></span><br><span class=\"line\">        self.actions[condition] = fns; <span class=\"comment\">// [4] 아! fns는 아래에서 선언한 action1, action2, action3를 담은 배열이군요.</span></span><br><span class=\"line\">        <span class=\"comment\">// [4-1] 이 배열을 self가 가진 객체인 actions라는 곳에 담아두고 있네요. </span></span><br><span class=\"line\">        <span class=\"comment\">// [4-2] 키 값이 처음 case를 실행할때 전달된 값(condition)이라는 점을 눈여겨보세요.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self; <span class=\"comment\">// [5] 다시 자기 자신을 반환하는군요.</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    self.default = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> &#123; <span class=\"comment\">// [8] 음... 이건 case와 조금 다르네요. </span></span><br><span class=\"line\">        self.actions.__default__ = fns; <span class=\"comment\">// [9] 바로 action4를 __default__라는 키의 값으로 담습니다.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self; <span class=\"comment\">// [10] 이번에도 자기 자신은 반환하는군요!</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input &amp;&amp; self.actions[input]) &#123; <span class=\"comment\">// 지금도 때가 아니군요.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> matarials = [input, ...self.actions[input]];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = matarials.reduce(call);</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (input &amp;&amp; !self.actions[input]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> matarials = [input, ...self.actions.__default__];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = matarials.reduce(call);</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> pipeline = pipe(</span><br><span class=\"line\">  <span class=\"built_in\">parseInt</span>,</span><br><span class=\"line\">  match <span class=\"comment\">// [1] match는 바로 메서드인 case를 부르는군요. </span></span><br><span class=\"line\">    .case(<span class=\"number\">1</span>)(action1, action2, action3) <span class=\"comment\">// [2] 오호, case가 두번 연속 실행됐습니다. 어떤 일이 일어난걸까요?</span></span><br><span class=\"line\">    .case(<span class=\"number\">2</span>)(action1, action2, action3) <span class=\"comment\">// [6] 2번부터 5번까지 한번 더 수행합니다. 이제 self.actions는 두개의 키를 갖겠죠?</span></span><br><span class=\"line\">    .default(action4) <span class=\"comment\">// [7] 여기선 어떤 일이 벌어질까요?</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">pipeline(input_value);</span><br></pre></td></tr></table></figure>\n\n<p>쉽지 않으셨을 것 같습니다. 1번부터 무려 10번까지 달려오셨습니다. 복잡한 로직을 잘 따라오고 계시다면 정말 대단하신겁니다. 어렴풋이 내용이 이해가 가셨다면 한번 보세요. 지금 10번에서 반환한 값이 <code>self</code>였습니다. 무슨 일이 벌어진걸까요?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> pipeline = pipe(</span><br><span class=\"line\">  <span class=\"built_in\">parseInt</span>,</span><br><span class=\"line\">  self <span class=\"comment\">// default까지 실행되면 이 자리에 self만 남습니다. </span></span><br><span class=\"line\">  <span class=\"comment\">// match</span></span><br><span class=\"line\">  <span class=\"comment\">//   .case(1)(action1, action2, action3)</span></span><br><span class=\"line\">  <span class=\"comment\">//   .case(2)(action1, action2, action3)</span></span><br><span class=\"line\">  <span class=\"comment\">//   .default(action4)</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><strong>“default까지 실행되면 이 자리에 self만 남습니다.”</strong> 이게 무슨 말이죠? 왜 다시 <code>self</code>가 남은건가요. 처음 선안한 <code>self</code>와 지금의 이 함수는 어떻게 다른거죠? 두 함수는 같은 로직을 갖지만 재료가 다릅니다. 마지막에 남은 <code>self</code>는 <strong>조건(condition)과 조건에 따른 행동(action)을 알고 있는 상태의 함수입니다.</strong> 이 함수에게 이제 어떤 값이 들어오면 그 값에 따라 특정 행동(action)을 할 준비가 된 상황이죠. 이 상태는 <code>match.case</code>, <code>match.default</code>를 통해 <code>self.actions</code>에 저장되어 있습니다. 이해가 되셨나요? 이제 마무리를 지어보죠!</p>\n<p><strong>구현체 톺아보기 3</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> call = <span class=\"function\">(<span class=\"params\">x, f</span>) =&gt;</span> f(x); <span class=\"comment\">// [7-1] 인자와 실행할 함수를 전달하면 함수에 인자를 넣어 실행합니다.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> match = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">self</span>(<span class=\"params\">input</span>) </span>&#123; <span class=\"comment\">// [3] 이제는 input을 가지고 왔을겁니다. (parseInt의 결과값)</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> init = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (self.actions[input]) &#123; <span class=\"comment\">// [4] 만약에 input 값에 해당하는 키가 존재하면 여기를 거칩니다.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> matarials = [input, ...self.actions[input]]; <span class=\"comment\">// [6] 우리가 가진 재료들을 모아 (이때는 조건에 맞는 함수들)</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = matarials.reduce(call); <span class=\"comment\">// [7] 결과를 만들어냅니다!</span></span><br><span class=\"line\">    init(); <span class=\"comment\">// [8] 다음에 또 match 함수를 사용하기 위해 초기화를 해줍니다.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result; <span class=\"comment\">// [9] 결과를 반환하면 끝입니다.</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!self.actions[input]) &#123; <span class=\"comment\">// [5] 아니라면 여기겠죠!</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> matarials = [input, ...self.actions.__default__];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = matarials.reduce(call);</span><br><span class=\"line\">    init();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> pipeline = pipe(</span><br><span class=\"line\">  <span class=\"built_in\">parseInt</span>,</span><br><span class=\"line\">  match <span class=\"comment\">// [2] 코드가 실행되는 상황에 이 자리는 self 함수가 차지하고 있습니다.</span></span><br><span class=\"line\">    .case(<span class=\"number\">1</span>)(action1, action2, action3)</span><br><span class=\"line\">    .case(<span class=\"number\">2</span>)(action1, action2, action3)</span><br><span class=\"line\">    .default(action4)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">pipeline(input_value); <span class=\"comment\">// [1] 합성해둔 함수가 실행됩니다.</span></span><br></pre></td></tr></table></figure>\n\n<p>어떠셨나요? 이번 함수는 제법 길고 복잡해서 설명을 주석으로 장황하게 적었습니다. 다소 여러우셨을 것 같습니다. </p>\n<p>여기까지 이 글을 꼼꼼하게 보셨든 쓰윽 보셨든 아마 이런 생각이 드실겁니다. <em>“함수형 이거… 이렇게까지 (복잡하고 어렵게) 해야하는거야?”</em> 제 생각이 정답은 아니지만, <em>이렇게까지 하실 필요는 없습니다.</em> 사실 순수하게 로직만 남은 작은 함수를 조합해서 프로그래밍하는게 함수형이지 이런 복잡한 함수의 내부를 들여다보는게 함수형 프로그래밍은 아닙니다. <strong>다만 라이브러리로 구현된 함수만을 사용해 우리가 원하는 것을 온전히 구현해내지 못할 가능성이 큽니다. 때문에 조금 복잡한 함수(순수 함수)를 직접 만들고 뜯어보는 역량이 고급 함수형 프로그래밍에 지대한 영향을 끼친다고 생각합니다.</strong> 그러한 연고로 이렇게 복잡한 코드를 구현해봤습니다. 어떻게 느끼셨을지 모르지만, “이거 제법 재밌네” 하는 정도의 느낌을 가져가셨으면 좋겠습니다. </p>\n<p>긴 글 읽고 따라와주셔서 감사합니다! 다음에 또 뵙겠습니다.</p>\n"},{"title":"함수형 자바스크립트 - 고차 함수와 커링(currying)","date":"2017-10-18T09:49:54.000Z","_content":"## 고차 함수와 커링(currying)\n함수형 프로그래밍의 꽃인 고차 함수 개념과 커링에 대해서 이야기 해보자.\n(모든 예제는 웹 브라우저의 '검사' 도구를 열어서 테스트할 수 있다.)\n\n### 보조 함수의 활용\n##### 1. 고차 함수란?\n고차 함수는 __값으로 다룰 수 있는 함수__다. 함수를 값으로 다룰 수 있기 때문에 __함수를 인자로 사용__할 수도 있고 함수를 __리턴값으로 사용__할 수도 있다. 이러한 특징을 잘 보여주는 예제가 [지난 시간](/programming/functional-js-study/) 살펴본 함수들이 가진 보조함수들이다. `each`를 다시 한번 살펴보자.\n\n```javascript\neach([1,2,3,4,5], num => console.log(num)); // _each 함수에 두번째 인자로 함수가 사용된다.\n```\n\n화살표 함수로 정의된 `num => console.log(num)`가 `each` 함수의 인자로 전달되고 이는 보조함수의 역할을 한다. 인자로 함수를 넘겨서 어떤 일을 수행해야하는지를 전달한다면 함수의 추상화 레벨이 올라간다. `each`의 경우 반복적으로 동일한 일을 처리하는 경우를 추상화해두고 그 일이 어떤 일인지는 개발자가 함수를 호출하는 시기에 결정할 수 있도록 위임한 것이다. \n\n```javascript\nvar persons = [\n  { name: 'JE', age: 27 }, \n  { name: 'SJ', age: 34 },\n  { name: 'HR', age: 38 },\n  { name: 'YS', age: 27 }\n];\nvar YB = filter(persons, person => person.age < 30);\nconsole.log(YB); // [{ name: 'JE', age: 27 }, { name: 'YS', age: 27 }]\n```\n\n`filter` 함수는 어떤 조건에 따라 원하는 데이터를 골라내는 함수다. 위의 예제는 30세 미만의 사람만 골라냈다. 고차 함수인 `person => person.age < 30` 함수를 어떤 조건을 정의해 전달함으로써 추상화된 `filter` 라는 함수를 사용할 수 있었다.\n\n\n##### 2. callback, iteratee, predicate의 차이\n지난 시간에 확인한 것처럼 `each` 함수의 내부에서는 두번째 인자로 전달되는 보조함수를 `iter`라고 정의하고 있는데 이는 'iteratee'의 준말이다. 반복되는 함수라는 뜻이다. `filter` 함수는 같은 함수를 `predi`라고 정의하고 있다. 술부라는 의미를 가진 'predicate'의 준말이다. 결과값이 어떠해야 하는지 정의하고 있는 함수이기 때문이다. \n보조함수 중에서 잘 알려진 함수는 'callback' 함수다. 유명세 때문인지 '보조함수(고차함수) === 콜백함수'라고 생각하는 경우도 있다. 하지만 보조함수가 가지는 이름 callback, iteratee, predicate는 그 함수가 하는 역할에 따라 지어진 이름일 뿐이다. callback 함수가 '회신'이라는 의미를 가지고 비동기 상황이 끝난 뒤에 어떠한 일을 할지 정의하는 함수인 것처럼 다른 보조함수들도 그에 맞는 이름을 갖는 것이다. \n\n\n지금까지 인자로 사용하는 함수인 보조함수를 통해 고차 함수를 알아봤다. 그렇다면 리턴값으로 사용되는 고차 함수는 어떤 경우가 있을까? 커링(currying)을 통해 그 예를 살펴보자.\n\n### 고차 함수의 응용\n##### 0. 커링이란?\n수학자 Haskell Curry의 이름을 딴 이 기법은 __함수가 함수를 만드는 기법__이다. 함수로 함수를 만들기 위해선 결과값으로 함수를 전달할 수 있어야한다. 이 지점에서 리턴값으로 사용할 수 있는 고차 함수가 등장한다. \n\n```javascript\nfunction add(a) {\n  return function(b) {\n    return a + b;\n  }\n}\n```\n커링을 이야기할때 가장 자주 등장하는 형태의 함수다. 이 함수 `add`는 인자 `a`를 받고 익명 함수를 리턴한다. 리턴된 익명 함수는 `b`를 받고 `a`와 `b`를 더한 값을 리턴한다. 리턴되는 익명 함수는 `a`에 대해 알고 있는 클로저다. 때문에 이후에 들어오는 값인 `b`와 `a`를 이용해 어떠한 일을 할 수 있는 함수가 된다. \n\n`add` 함수는 이렇게 사용할 수 있다.\n```javascript\nvar add10 = add(10); // <-- 함수를 리턴했다.\nconsole.log(add10(11)); // 21\nconsole.log(add10(21)); // 31\n```\n\n`10`이라는 값을 알고 있는 익명 함수가 `add10`이라는 변수에 담긴다. 클로저인 익명 함수가 `add10`이라는 이름을 갖게된 것이다. 새로운 이름을 가진 이 함수가 실행되면 자신이 알고 있는 `10`과 새로 받는 값을 모두 이용할 수 있다. 최초의 `add` 함수 정의에서 두 값을 더하는 것으로 정했기 때문에 이후에 들어온 값 `11`이나 `21`을 `10`과 더하는 일을 수행한다. \n\n`add` 함수를 정의할 때 화살표 함수를 사용하면 조금 더 근사하다.\n\n```javascript\nvar add = a => b => a + b;\n```\n\n이러한 형태의 함수는 미리 정의된 일 밖에 할 수 없으니 아쉽다. 커링하는 일 자체를 추상화하는 새로운 함수를 만들어보자.\n\n##### 1. curry 함수\n```javascript\nfunction curry(fn) {\n  return function(a) {\n    return function(b) {\n      return fn(a, b);\n    }\n  }\n}\n// var curry = a => b => fn(a, b);\n```\n\n함수가 익명 함수를 리턴했는데 그 함수가 다시 함수를 리턴한다. 복잡한것처럼 보이지만 단순하다. 천천히 살펴보자. \n\n우선 `curry`는 함수를 인자로 받는다. 이때 받은 함수를 커링이 되는 함수로 만드는 것이 `curry` 함수의 목표다. 목표를 달성하기 위해 다짜고짜 첫번째 익명 함수를 리턴한다. 첫번째 익명 함수는 `fn`이 사용할 첫번째 인자를 받는 함수다. `a`를 받은 뒤에 다시 한번 더 익명 함수를 리턴한다. 두번째 익명 함수다. 두번째 함수는 `fn`에게 필요한 두번째 인자를 받고 `fn`을 실행한다. 그 결과를 리턴한다. 글로만 읽으면 어떻게 동작하는지 이해하기 어렵다. 예제를 보자.\n\n```javascript\nvar add = curry((a, b) => a + b); // <-- 첫번째 함수를 리턴했다.\n\nvar add10 = add(10); // <-- 두번째 함수를 리턴했다.\nconsole.log(add10(11)); // 21\nconsole.log(add10(21)); // 31\n```\n\n커링하는 일을 추상화 해둔 `curry`라는 함수를 사용했다. 덕분에 어떤 일을 할지 `curry`에 함수에 전달하는 것만으로 커링이 가능한 함수를 만들 수 있게 되었다. 다른 함수도 쉽게 만들 수 있다.\n\n```javascript\nvar sum = curry((a, b) => a - b);\nvar sum10 = sum(10);\n\nconsole.log(sum10(5)); // 5\n```\n\n이처럼 `curry` 함수를 이용해서 사칙 연산 함수들을 커링이 가능한 함수로 만들 수 있다. 그런데 가만 생각해보면 좀 이상하다 `sum10`이라는 이름을 생각해보자. __10을 뺄 준비가 된 함수__여야할 것 같은데 반대가 되어버린다. (이 대목에서 이상하다고 생각하지 않아도 괜찮다.) `curryr`이라는 함수를 만들어서 덜 이상하게 순서를 바꿔보자. \n\n```javascript\nvar curryr = a => b => fn(b, a);\n\nvar sum = curryr((a, b) => a - b);\nvar sum10 = sum(10);\n\nconsole.log(sum10(5)); // -5\n```\n\n`curryr`을 구현하기 위해선 인자 `fn`의 인자 순서를 뒤집어주면(reverse) 된다. 이제 `sum10`은 __10을 뺄 준비가 된 함수__가 됐다. 어떤 수가 들어오건 10을 뺀다. 이 상태가 되면 이제 지난 시간에 만들어둔 함수들을 발전시킬 수 있다.\n\n```javascript\n// 커링 적용 전\ngo([1,2,3,4,5,6,7,8,9,10],\n  arr => filter(arr, num => num % 2), // <-- 함수로 한번 감싸서 실행시킨다.\n  arr => each(arr, num => console.log(num))); // <-- 코드가 복잡하다.\n\nfilter = curryr(filter);\neach = curryr(each);\n\n// 커링 적용 후\ngo([1,2,3,4,5,6,7,8,9,10],\n  filter(num => num % 2), // <-- 어떤 일을 해야하는지 알고 있는 함수가 이 자리에 리턴된다.\n  each(num => console.log(num))); // <-- 코드가 간결하다.\n```\n\n커링이 적용된 발전된 함수는 `go` 함수 안에서 보다 간결하게 의미를 전달 수 있는 코드가 되었다. `filter`와 `each`가 보조함수를 기억한 함수를 리턴한 뒤에 `go`가 실행되면 `go`는 첫번째 인자인 배열을 `filter`와 `each`가 남긴 함수에게 전달해서 각각의 일을 수행하도록 한다. 커링으로 간결하고 읽기 좋은 코드가 되었다. \n\n하지만 이 코드에서도 문제가 남아있다. 바로 커링이 적용된 함수들을 원래 방법대로 사용할 수 없다는 점이다. 지금 상황에서는 `filter`에 인자를 동시에 두개를 넘겨도 함수를 리턴할 것이다. 약간의 수정이 필요하다.\n\n```javascript\nfunction curryr(fn) {\n  return function(a, b) {\n    return !b ? function(b) {\n      return fn(b, a);\n    } : fn(a, b);\n  }\n}\n// var curryr = fn => (a, b) => (!b ? b => fn(b, a) : fn(a, b))\n```\n\n첫번째 익명 함수에 인자가 하나만 들어왔다면 커링을 적용한 함수를 리턴하고 그렇지 않다면 그냥 원래 방법대로 함수를 실행핟 결과를 리턴하도록 바꿔주면 모든 문제가 해결된다. 물론 인자를 두개 받지 못한다는 단점은 여전히 존재한다. 이 문제는 다음 시간에 해결할 계획이다.\n\n##### 2. `pipe` 함수 만들기\n`pipe` 함수는 함수를 조합하는 함수다. 여러 개의 함수가 조합된 새로운 함수를 만들기 위해 사용한다. 이런 식으로 사용할 것이다.\n```javascript\nvar odd_sum = pipe(filter(n => n % 2), reduce((t, n) => t + n));\n\ngo([1,2,3,4,5,6,7],\n  odd_sum,\n  console.log); // 16\n```\n\n`filter`와 `reduce`를 조합해서 홀수값의 총합을 만드는 함수를 만들었다. 이 함수는 어떤 배열이 들어와도 홀수값의 합을 반환하는 함수가 된다. 이처럼 반복적으로 사용될만한 함수 조합을 `pipe`로 묶어서 정의해두면 함수의 활용성이 좋아진다. \n\n끝으로 어떻게 구현하는지 살펴보자. 아래와 같이 `go`를 사용하면 쉽게 구현할 수 있다.\n```javascript\nvar slice = Array.prototype.slice;\nfunction pipe() {\n  var fns = slice.call(arguments)\n  return function(seed) {\n    return go.apply(null, [seed, ...fns]);\n  }\n}\n```\n\n---\n\n### 전체 스터디 일정\n  - 1주차 - [기본 함수 구현하고 사용하기](/programming/functional-js-study/)\n  - 2주차 - 고차 함수와 커링(currying)\n  - 3주차 - [함수형 자바스크립트 라이브러리](/programming/functional-js-study-2/)\n  - 4주차 - Movie Box 1: 필터링, 정렬\n  - _5주차 - Movie Box 2: 필터링, 정렬 복습_\n  - _6주차 - Movie Box 3: 지연평가 L, memoize_\n  - _7주차 - Movie Box 4: 비동기 상황 다루기_\n\n[예제 코드](https://github.com/joeunha/functional-js-study/tree/master/02_week)","source":"_posts/functional-js-study-1.md","raw":"---\ntitle: '함수형 자바스크립트 - 고차 함수와 커링(currying)'\ncategories:\n  - programming\ntags:\n  - javascript\n  - 자바스크립트\n  - 함수형 프로그래밍\n  - 함수형 자바스크립트\ndate: 2017-10-18 18:49:54\n---\n## 고차 함수와 커링(currying)\n함수형 프로그래밍의 꽃인 고차 함수 개념과 커링에 대해서 이야기 해보자.\n(모든 예제는 웹 브라우저의 '검사' 도구를 열어서 테스트할 수 있다.)\n\n### 보조 함수의 활용\n##### 1. 고차 함수란?\n고차 함수는 __값으로 다룰 수 있는 함수__다. 함수를 값으로 다룰 수 있기 때문에 __함수를 인자로 사용__할 수도 있고 함수를 __리턴값으로 사용__할 수도 있다. 이러한 특징을 잘 보여주는 예제가 [지난 시간](/programming/functional-js-study/) 살펴본 함수들이 가진 보조함수들이다. `each`를 다시 한번 살펴보자.\n\n```javascript\neach([1,2,3,4,5], num => console.log(num)); // _each 함수에 두번째 인자로 함수가 사용된다.\n```\n\n화살표 함수로 정의된 `num => console.log(num)`가 `each` 함수의 인자로 전달되고 이는 보조함수의 역할을 한다. 인자로 함수를 넘겨서 어떤 일을 수행해야하는지를 전달한다면 함수의 추상화 레벨이 올라간다. `each`의 경우 반복적으로 동일한 일을 처리하는 경우를 추상화해두고 그 일이 어떤 일인지는 개발자가 함수를 호출하는 시기에 결정할 수 있도록 위임한 것이다. \n\n```javascript\nvar persons = [\n  { name: 'JE', age: 27 }, \n  { name: 'SJ', age: 34 },\n  { name: 'HR', age: 38 },\n  { name: 'YS', age: 27 }\n];\nvar YB = filter(persons, person => person.age < 30);\nconsole.log(YB); // [{ name: 'JE', age: 27 }, { name: 'YS', age: 27 }]\n```\n\n`filter` 함수는 어떤 조건에 따라 원하는 데이터를 골라내는 함수다. 위의 예제는 30세 미만의 사람만 골라냈다. 고차 함수인 `person => person.age < 30` 함수를 어떤 조건을 정의해 전달함으로써 추상화된 `filter` 라는 함수를 사용할 수 있었다.\n\n\n##### 2. callback, iteratee, predicate의 차이\n지난 시간에 확인한 것처럼 `each` 함수의 내부에서는 두번째 인자로 전달되는 보조함수를 `iter`라고 정의하고 있는데 이는 'iteratee'의 준말이다. 반복되는 함수라는 뜻이다. `filter` 함수는 같은 함수를 `predi`라고 정의하고 있다. 술부라는 의미를 가진 'predicate'의 준말이다. 결과값이 어떠해야 하는지 정의하고 있는 함수이기 때문이다. \n보조함수 중에서 잘 알려진 함수는 'callback' 함수다. 유명세 때문인지 '보조함수(고차함수) === 콜백함수'라고 생각하는 경우도 있다. 하지만 보조함수가 가지는 이름 callback, iteratee, predicate는 그 함수가 하는 역할에 따라 지어진 이름일 뿐이다. callback 함수가 '회신'이라는 의미를 가지고 비동기 상황이 끝난 뒤에 어떠한 일을 할지 정의하는 함수인 것처럼 다른 보조함수들도 그에 맞는 이름을 갖는 것이다. \n\n\n지금까지 인자로 사용하는 함수인 보조함수를 통해 고차 함수를 알아봤다. 그렇다면 리턴값으로 사용되는 고차 함수는 어떤 경우가 있을까? 커링(currying)을 통해 그 예를 살펴보자.\n\n### 고차 함수의 응용\n##### 0. 커링이란?\n수학자 Haskell Curry의 이름을 딴 이 기법은 __함수가 함수를 만드는 기법__이다. 함수로 함수를 만들기 위해선 결과값으로 함수를 전달할 수 있어야한다. 이 지점에서 리턴값으로 사용할 수 있는 고차 함수가 등장한다. \n\n```javascript\nfunction add(a) {\n  return function(b) {\n    return a + b;\n  }\n}\n```\n커링을 이야기할때 가장 자주 등장하는 형태의 함수다. 이 함수 `add`는 인자 `a`를 받고 익명 함수를 리턴한다. 리턴된 익명 함수는 `b`를 받고 `a`와 `b`를 더한 값을 리턴한다. 리턴되는 익명 함수는 `a`에 대해 알고 있는 클로저다. 때문에 이후에 들어오는 값인 `b`와 `a`를 이용해 어떠한 일을 할 수 있는 함수가 된다. \n\n`add` 함수는 이렇게 사용할 수 있다.\n```javascript\nvar add10 = add(10); // <-- 함수를 리턴했다.\nconsole.log(add10(11)); // 21\nconsole.log(add10(21)); // 31\n```\n\n`10`이라는 값을 알고 있는 익명 함수가 `add10`이라는 변수에 담긴다. 클로저인 익명 함수가 `add10`이라는 이름을 갖게된 것이다. 새로운 이름을 가진 이 함수가 실행되면 자신이 알고 있는 `10`과 새로 받는 값을 모두 이용할 수 있다. 최초의 `add` 함수 정의에서 두 값을 더하는 것으로 정했기 때문에 이후에 들어온 값 `11`이나 `21`을 `10`과 더하는 일을 수행한다. \n\n`add` 함수를 정의할 때 화살표 함수를 사용하면 조금 더 근사하다.\n\n```javascript\nvar add = a => b => a + b;\n```\n\n이러한 형태의 함수는 미리 정의된 일 밖에 할 수 없으니 아쉽다. 커링하는 일 자체를 추상화하는 새로운 함수를 만들어보자.\n\n##### 1. curry 함수\n```javascript\nfunction curry(fn) {\n  return function(a) {\n    return function(b) {\n      return fn(a, b);\n    }\n  }\n}\n// var curry = a => b => fn(a, b);\n```\n\n함수가 익명 함수를 리턴했는데 그 함수가 다시 함수를 리턴한다. 복잡한것처럼 보이지만 단순하다. 천천히 살펴보자. \n\n우선 `curry`는 함수를 인자로 받는다. 이때 받은 함수를 커링이 되는 함수로 만드는 것이 `curry` 함수의 목표다. 목표를 달성하기 위해 다짜고짜 첫번째 익명 함수를 리턴한다. 첫번째 익명 함수는 `fn`이 사용할 첫번째 인자를 받는 함수다. `a`를 받은 뒤에 다시 한번 더 익명 함수를 리턴한다. 두번째 익명 함수다. 두번째 함수는 `fn`에게 필요한 두번째 인자를 받고 `fn`을 실행한다. 그 결과를 리턴한다. 글로만 읽으면 어떻게 동작하는지 이해하기 어렵다. 예제를 보자.\n\n```javascript\nvar add = curry((a, b) => a + b); // <-- 첫번째 함수를 리턴했다.\n\nvar add10 = add(10); // <-- 두번째 함수를 리턴했다.\nconsole.log(add10(11)); // 21\nconsole.log(add10(21)); // 31\n```\n\n커링하는 일을 추상화 해둔 `curry`라는 함수를 사용했다. 덕분에 어떤 일을 할지 `curry`에 함수에 전달하는 것만으로 커링이 가능한 함수를 만들 수 있게 되었다. 다른 함수도 쉽게 만들 수 있다.\n\n```javascript\nvar sum = curry((a, b) => a - b);\nvar sum10 = sum(10);\n\nconsole.log(sum10(5)); // 5\n```\n\n이처럼 `curry` 함수를 이용해서 사칙 연산 함수들을 커링이 가능한 함수로 만들 수 있다. 그런데 가만 생각해보면 좀 이상하다 `sum10`이라는 이름을 생각해보자. __10을 뺄 준비가 된 함수__여야할 것 같은데 반대가 되어버린다. (이 대목에서 이상하다고 생각하지 않아도 괜찮다.) `curryr`이라는 함수를 만들어서 덜 이상하게 순서를 바꿔보자. \n\n```javascript\nvar curryr = a => b => fn(b, a);\n\nvar sum = curryr((a, b) => a - b);\nvar sum10 = sum(10);\n\nconsole.log(sum10(5)); // -5\n```\n\n`curryr`을 구현하기 위해선 인자 `fn`의 인자 순서를 뒤집어주면(reverse) 된다. 이제 `sum10`은 __10을 뺄 준비가 된 함수__가 됐다. 어떤 수가 들어오건 10을 뺀다. 이 상태가 되면 이제 지난 시간에 만들어둔 함수들을 발전시킬 수 있다.\n\n```javascript\n// 커링 적용 전\ngo([1,2,3,4,5,6,7,8,9,10],\n  arr => filter(arr, num => num % 2), // <-- 함수로 한번 감싸서 실행시킨다.\n  arr => each(arr, num => console.log(num))); // <-- 코드가 복잡하다.\n\nfilter = curryr(filter);\neach = curryr(each);\n\n// 커링 적용 후\ngo([1,2,3,4,5,6,7,8,9,10],\n  filter(num => num % 2), // <-- 어떤 일을 해야하는지 알고 있는 함수가 이 자리에 리턴된다.\n  each(num => console.log(num))); // <-- 코드가 간결하다.\n```\n\n커링이 적용된 발전된 함수는 `go` 함수 안에서 보다 간결하게 의미를 전달 수 있는 코드가 되었다. `filter`와 `each`가 보조함수를 기억한 함수를 리턴한 뒤에 `go`가 실행되면 `go`는 첫번째 인자인 배열을 `filter`와 `each`가 남긴 함수에게 전달해서 각각의 일을 수행하도록 한다. 커링으로 간결하고 읽기 좋은 코드가 되었다. \n\n하지만 이 코드에서도 문제가 남아있다. 바로 커링이 적용된 함수들을 원래 방법대로 사용할 수 없다는 점이다. 지금 상황에서는 `filter`에 인자를 동시에 두개를 넘겨도 함수를 리턴할 것이다. 약간의 수정이 필요하다.\n\n```javascript\nfunction curryr(fn) {\n  return function(a, b) {\n    return !b ? function(b) {\n      return fn(b, a);\n    } : fn(a, b);\n  }\n}\n// var curryr = fn => (a, b) => (!b ? b => fn(b, a) : fn(a, b))\n```\n\n첫번째 익명 함수에 인자가 하나만 들어왔다면 커링을 적용한 함수를 리턴하고 그렇지 않다면 그냥 원래 방법대로 함수를 실행핟 결과를 리턴하도록 바꿔주면 모든 문제가 해결된다. 물론 인자를 두개 받지 못한다는 단점은 여전히 존재한다. 이 문제는 다음 시간에 해결할 계획이다.\n\n##### 2. `pipe` 함수 만들기\n`pipe` 함수는 함수를 조합하는 함수다. 여러 개의 함수가 조합된 새로운 함수를 만들기 위해 사용한다. 이런 식으로 사용할 것이다.\n```javascript\nvar odd_sum = pipe(filter(n => n % 2), reduce((t, n) => t + n));\n\ngo([1,2,3,4,5,6,7],\n  odd_sum,\n  console.log); // 16\n```\n\n`filter`와 `reduce`를 조합해서 홀수값의 총합을 만드는 함수를 만들었다. 이 함수는 어떤 배열이 들어와도 홀수값의 합을 반환하는 함수가 된다. 이처럼 반복적으로 사용될만한 함수 조합을 `pipe`로 묶어서 정의해두면 함수의 활용성이 좋아진다. \n\n끝으로 어떻게 구현하는지 살펴보자. 아래와 같이 `go`를 사용하면 쉽게 구현할 수 있다.\n```javascript\nvar slice = Array.prototype.slice;\nfunction pipe() {\n  var fns = slice.call(arguments)\n  return function(seed) {\n    return go.apply(null, [seed, ...fns]);\n  }\n}\n```\n\n---\n\n### 전체 스터디 일정\n  - 1주차 - [기본 함수 구현하고 사용하기](/programming/functional-js-study/)\n  - 2주차 - 고차 함수와 커링(currying)\n  - 3주차 - [함수형 자바스크립트 라이브러리](/programming/functional-js-study-2/)\n  - 4주차 - Movie Box 1: 필터링, 정렬\n  - _5주차 - Movie Box 2: 필터링, 정렬 복습_\n  - _6주차 - Movie Box 3: 지연평가 L, memoize_\n  - _7주차 - Movie Box 4: 비동기 상황 다루기_\n\n[예제 코드](https://github.com/joeunha/functional-js-study/tree/master/02_week)","slug":"functional-js-study-1","published":1,"updated":"2019-12-05T15:05:29.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9is009hdirvq9jbrkzs","content":"<h2 id=\"고차-함수와-커링-currying\"><a href=\"#고차-함수와-커링-currying\" class=\"headerlink\" title=\"고차 함수와 커링(currying)\"></a>고차 함수와 커링(currying)</h2><p>함수형 프로그래밍의 꽃인 고차 함수 개념과 커링에 대해서 이야기 해보자.<br>(모든 예제는 웹 브라우저의 ‘검사’ 도구를 열어서 테스트할 수 있다.)</p>\n<h3 id=\"보조-함수의-활용\"><a href=\"#보조-함수의-활용\" class=\"headerlink\" title=\"보조 함수의 활용\"></a>보조 함수의 활용</h3><h5 id=\"1-고차-함수란\"><a href=\"#1-고차-함수란\" class=\"headerlink\" title=\"1. 고차 함수란?\"></a>1. 고차 함수란?</h5><p>고차 함수는 <strong>값으로 다룰 수 있는 함수</strong>다. 함수를 값으로 다룰 수 있기 때문에 <strong>함수를 인자로 사용</strong>할 수도 있고 함수를 <strong>리턴값으로 사용</strong>할 수도 있다. 이러한 특징을 잘 보여주는 예제가 <a href=\"/programming/functional-js-study/\">지난 시간</a> 살펴본 함수들이 가진 보조함수들이다. <code>each</code>를 다시 한번 살펴보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">each([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>], num =&gt; <span class=\"built_in\">console</span>.log(num)); <span class=\"comment\">// _each 함수에 두번째 인자로 함수가 사용된다.</span></span><br></pre></td></tr></table></figure>\n\n<p>화살표 함수로 정의된 <code>num =&gt; console.log(num)</code>가 <code>each</code> 함수의 인자로 전달되고 이는 보조함수의 역할을 한다. 인자로 함수를 넘겨서 어떤 일을 수행해야하는지를 전달한다면 함수의 추상화 레벨이 올라간다. <code>each</code>의 경우 반복적으로 동일한 일을 처리하는 경우를 추상화해두고 그 일이 어떤 일인지는 개발자가 함수를 호출하는 시기에 결정할 수 있도록 위임한 것이다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> persons = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JE'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span> &#125;, </span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'SJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">34</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'HR'</span>, <span class=\"attr\">age</span>: <span class=\"number\">38</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'YS'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span> &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">var</span> YB = filter(persons, person =&gt; person.age &lt; <span class=\"number\">30</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(YB); <span class=\"comment\">// [&#123; name: 'JE', age: 27 &#125;, &#123; name: 'YS', age: 27 &#125;]</span></span><br></pre></td></tr></table></figure>\n\n<p><code>filter</code> 함수는 어떤 조건에 따라 원하는 데이터를 골라내는 함수다. 위의 예제는 30세 미만의 사람만 골라냈다. 고차 함수인 <code>person =&gt; person.age &lt; 30</code> 함수를 어떤 조건을 정의해 전달함으로써 추상화된 <code>filter</code> 라는 함수를 사용할 수 있었다.</p>\n<h5 id=\"2-callback-iteratee-predicate의-차이\"><a href=\"#2-callback-iteratee-predicate의-차이\" class=\"headerlink\" title=\"2. callback, iteratee, predicate의 차이\"></a>2. callback, iteratee, predicate의 차이</h5><p>지난 시간에 확인한 것처럼 <code>each</code> 함수의 내부에서는 두번째 인자로 전달되는 보조함수를 <code>iter</code>라고 정의하고 있는데 이는 ‘iteratee’의 준말이다. 반복되는 함수라는 뜻이다. <code>filter</code> 함수는 같은 함수를 <code>predi</code>라고 정의하고 있다. 술부라는 의미를 가진 ‘predicate’의 준말이다. 결과값이 어떠해야 하는지 정의하고 있는 함수이기 때문이다.<br>보조함수 중에서 잘 알려진 함수는 ‘callback’ 함수다. 유명세 때문인지 ‘보조함수(고차함수) === 콜백함수’라고 생각하는 경우도 있다. 하지만 보조함수가 가지는 이름 callback, iteratee, predicate는 그 함수가 하는 역할에 따라 지어진 이름일 뿐이다. callback 함수가 ‘회신’이라는 의미를 가지고 비동기 상황이 끝난 뒤에 어떠한 일을 할지 정의하는 함수인 것처럼 다른 보조함수들도 그에 맞는 이름을 갖는 것이다. </p>\n<p>지금까지 인자로 사용하는 함수인 보조함수를 통해 고차 함수를 알아봤다. 그렇다면 리턴값으로 사용되는 고차 함수는 어떤 경우가 있을까? 커링(currying)을 통해 그 예를 살펴보자.</p>\n<h3 id=\"고차-함수의-응용\"><a href=\"#고차-함수의-응용\" class=\"headerlink\" title=\"고차 함수의 응용\"></a>고차 함수의 응용</h3><h5 id=\"0-커링이란\"><a href=\"#0-커링이란\" class=\"headerlink\" title=\"0. 커링이란?\"></a>0. 커링이란?</h5><p>수학자 Haskell Curry의 이름을 딴 이 기법은 <strong>함수가 함수를 만드는 기법</strong>이다. 함수로 함수를 만들기 위해선 결과값으로 함수를 전달할 수 있어야한다. 이 지점에서 리턴값으로 사용할 수 있는 고차 함수가 등장한다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>커링을 이야기할때 가장 자주 등장하는 형태의 함수다. 이 함수 <code>add</code>는 인자 <code>a</code>를 받고 익명 함수를 리턴한다. 리턴된 익명 함수는 <code>b</code>를 받고 <code>a</code>와 <code>b</code>를 더한 값을 리턴한다. 리턴되는 익명 함수는 <code>a</code>에 대해 알고 있는 클로저다. 때문에 이후에 들어오는 값인 <code>b</code>와 <code>a</code>를 이용해 어떠한 일을 할 수 있는 함수가 된다. </p>\n<p><code>add</code> 함수는 이렇게 사용할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add10 = add(<span class=\"number\">10</span>); <span class=\"comment\">// &lt;-- 함수를 리턴했다.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add10(<span class=\"number\">11</span>)); <span class=\"comment\">// 21</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add10(<span class=\"number\">21</span>)); <span class=\"comment\">// 31</span></span><br></pre></td></tr></table></figure>\n\n<p><code>10</code>이라는 값을 알고 있는 익명 함수가 <code>add10</code>이라는 변수에 담긴다. 클로저인 익명 함수가 <code>add10</code>이라는 이름을 갖게된 것이다. 새로운 이름을 가진 이 함수가 실행되면 자신이 알고 있는 <code>10</code>과 새로 받는 값을 모두 이용할 수 있다. 최초의 <code>add</code> 함수 정의에서 두 값을 더하는 것으로 정했기 때문에 이후에 들어온 값 <code>11</code>이나 <code>21</code>을 <code>10</code>과 더하는 일을 수행한다. </p>\n<p><code>add</code> 함수를 정의할 때 화살표 함수를 사용하면 조금 더 근사하다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"function\"><span class=\"params\">b</span> =&gt;</span> a + b;</span><br></pre></td></tr></table></figure>\n\n<p>이러한 형태의 함수는 미리 정의된 일 밖에 할 수 없으니 아쉽다. 커링하는 일 자체를 추상화하는 새로운 함수를 만들어보자.</p>\n<h5 id=\"1-curry-함수\"><a href=\"#1-curry-함수\" class=\"headerlink\" title=\"1. curry 함수\"></a>1. curry 함수</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fn(a, b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// var curry = a =&gt; b =&gt; fn(a, b);</span></span><br></pre></td></tr></table></figure>\n\n<p>함수가 익명 함수를 리턴했는데 그 함수가 다시 함수를 리턴한다. 복잡한것처럼 보이지만 단순하다. 천천히 살펴보자. </p>\n<p>우선 <code>curry</code>는 함수를 인자로 받는다. 이때 받은 함수를 커링이 되는 함수로 만드는 것이 <code>curry</code> 함수의 목표다. 목표를 달성하기 위해 다짜고짜 첫번째 익명 함수를 리턴한다. 첫번째 익명 함수는 <code>fn</code>이 사용할 첫번째 인자를 받는 함수다. <code>a</code>를 받은 뒤에 다시 한번 더 익명 함수를 리턴한다. 두번째 익명 함수다. 두번째 함수는 <code>fn</code>에게 필요한 두번째 인자를 받고 <code>fn</code>을 실행한다. 그 결과를 리턴한다. 글로만 읽으면 어떻게 동작하는지 이해하기 어렵다. 예제를 보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = curry(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b); <span class=\"comment\">// &lt;-- 첫번째 함수를 리턴했다.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> add10 = add(<span class=\"number\">10</span>); <span class=\"comment\">// &lt;-- 두번째 함수를 리턴했다.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add10(<span class=\"number\">11</span>)); <span class=\"comment\">// 21</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add10(<span class=\"number\">21</span>)); <span class=\"comment\">// 31</span></span><br></pre></td></tr></table></figure>\n\n<p>커링하는 일을 추상화 해둔 <code>curry</code>라는 함수를 사용했다. 덕분에 어떤 일을 할지 <code>curry</code>에 함수에 전달하는 것만으로 커링이 가능한 함수를 만들 수 있게 되었다. 다른 함수도 쉽게 만들 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = curry(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum10 = sum(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum10(<span class=\"number\">5</span>)); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p>이처럼 <code>curry</code> 함수를 이용해서 사칙 연산 함수들을 커링이 가능한 함수로 만들 수 있다. 그런데 가만 생각해보면 좀 이상하다 <code>sum10</code>이라는 이름을 생각해보자. <strong>10을 뺄 준비가 된 함수</strong>여야할 것 같은데 반대가 되어버린다. (이 대목에서 이상하다고 생각하지 않아도 괜찮다.) <code>curryr</code>이라는 함수를 만들어서 덜 이상하게 순서를 바꿔보자. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> curryr = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"function\"><span class=\"params\">b</span> =&gt;</span> fn(b, a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = curryr(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum10 = sum(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum10(<span class=\"number\">5</span>)); <span class=\"comment\">// -5</span></span><br></pre></td></tr></table></figure>\n\n<p><code>curryr</code>을 구현하기 위해선 인자 <code>fn</code>의 인자 순서를 뒤집어주면(reverse) 된다. 이제 <code>sum10</code>은 <strong>10을 뺄 준비가 된 함수</strong>가 됐다. 어떤 수가 들어오건 10을 뺀다. 이 상태가 되면 이제 지난 시간에 만들어둔 함수들을 발전시킬 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 커링 적용 전</span></span><br><span class=\"line\">go([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>],</span><br><span class=\"line\">  arr =&gt; filter(arr, num =&gt; num % <span class=\"number\">2</span>), <span class=\"comment\">// &lt;-- 함수로 한번 감싸서 실행시킨다.</span></span><br><span class=\"line\">  arr =&gt; each(arr, num =&gt; <span class=\"built_in\">console</span>.log(num))); <span class=\"comment\">// &lt;-- 코드가 복잡하다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">filter = curryr(filter);</span><br><span class=\"line\">each = curryr(each);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 커링 적용 후</span></span><br><span class=\"line\">go([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>],</span><br><span class=\"line\">  filter(<span class=\"function\"><span class=\"params\">num</span> =&gt;</span> num % <span class=\"number\">2</span>), <span class=\"comment\">// &lt;-- 어떤 일을 해야하는지 알고 있는 함수가 이 자리에 리턴된다.</span></span><br><span class=\"line\">  each(<span class=\"function\"><span class=\"params\">num</span> =&gt;</span> <span class=\"built_in\">console</span>.log(num))); <span class=\"comment\">// &lt;-- 코드가 간결하다.</span></span><br></pre></td></tr></table></figure>\n\n<p>커링이 적용된 발전된 함수는 <code>go</code> 함수 안에서 보다 간결하게 의미를 전달 수 있는 코드가 되었다. <code>filter</code>와 <code>each</code>가 보조함수를 기억한 함수를 리턴한 뒤에 <code>go</code>가 실행되면 <code>go</code>는 첫번째 인자인 배열을 <code>filter</code>와 <code>each</code>가 남긴 함수에게 전달해서 각각의 일을 수행하도록 한다. 커링으로 간결하고 읽기 좋은 코드가 되었다. </p>\n<p>하지만 이 코드에서도 문제가 남아있다. 바로 커링이 적용된 함수들을 원래 방법대로 사용할 수 없다는 점이다. 지금 상황에서는 <code>filter</code>에 인자를 동시에 두개를 넘겨도 함수를 리턴할 것이다. 약간의 수정이 필요하다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curryr</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !b ? <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fn(b, a);</span><br><span class=\"line\">    &#125; : fn(a, b);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// var curryr = fn =&gt; (a, b) =&gt; (!b ? b =&gt; fn(b, a) : fn(a, b))</span></span><br></pre></td></tr></table></figure>\n\n<p>첫번째 익명 함수에 인자가 하나만 들어왔다면 커링을 적용한 함수를 리턴하고 그렇지 않다면 그냥 원래 방법대로 함수를 실행핟 결과를 리턴하도록 바꿔주면 모든 문제가 해결된다. 물론 인자를 두개 받지 못한다는 단점은 여전히 존재한다. 이 문제는 다음 시간에 해결할 계획이다.</p>\n<h5 id=\"2-pipe-함수-만들기\"><a href=\"#2-pipe-함수-만들기\" class=\"headerlink\" title=\"2. pipe 함수 만들기\"></a>2. <code>pipe</code> 함수 만들기</h5><p><code>pipe</code> 함수는 함수를 조합하는 함수다. 여러 개의 함수가 조합된 새로운 함수를 만들기 위해 사용한다. 이런 식으로 사용할 것이다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> odd_sum = pipe(filter(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n % <span class=\"number\">2</span>), reduce(<span class=\"function\">(<span class=\"params\">t, n</span>) =&gt;</span> t + n));</span><br><span class=\"line\"></span><br><span class=\"line\">go([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>],</span><br><span class=\"line\">  odd_sum,</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// 16</span></span><br></pre></td></tr></table></figure>\n\n<p><code>filter</code>와 <code>reduce</code>를 조합해서 홀수값의 총합을 만드는 함수를 만들었다. 이 함수는 어떤 배열이 들어와도 홀수값의 합을 반환하는 함수가 된다. 이처럼 반복적으로 사용될만한 함수 조합을 <code>pipe</code>로 묶어서 정의해두면 함수의 활용성이 좋아진다. </p>\n<p>끝으로 어떻게 구현하는지 살펴보자. 아래와 같이 <code>go</code>를 사용하면 쉽게 구현할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> slice = <span class=\"built_in\">Array</span>.prototype.slice;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pipe</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fns = slice.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">seed</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> go.apply(<span class=\"literal\">null</span>, [seed, ...fns]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"전체-스터디-일정\"><a href=\"#전체-스터디-일정\" class=\"headerlink\" title=\"전체 스터디 일정\"></a>전체 스터디 일정</h3><ul>\n<li>1주차 - <a href=\"/programming/functional-js-study/\">기본 함수 구현하고 사용하기</a></li>\n<li>2주차 - 고차 함수와 커링(currying)</li>\n<li>3주차 - <a href=\"/programming/functional-js-study-2/\">함수형 자바스크립트 라이브러리</a></li>\n<li>4주차 - Movie Box 1: 필터링, 정렬</li>\n<li><em>5주차 - Movie Box 2: 필터링, 정렬 복습</em></li>\n<li><em>6주차 - Movie Box 3: 지연평가 L, memoize</em></li>\n<li><em>7주차 - Movie Box 4: 비동기 상황 다루기</em></li>\n</ul>\n<p><a href=\"https://github.com/joeunha/functional-js-study/tree/master/02_week\" target=\"_blank\" rel=\"noopener\">예제 코드</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"고차-함수와-커링-currying\"><a href=\"#고차-함수와-커링-currying\" class=\"headerlink\" title=\"고차 함수와 커링(currying)\"></a>고차 함수와 커링(currying)</h2><p>함수형 프로그래밍의 꽃인 고차 함수 개념과 커링에 대해서 이야기 해보자.<br>(모든 예제는 웹 브라우저의 ‘검사’ 도구를 열어서 테스트할 수 있다.)</p>\n<h3 id=\"보조-함수의-활용\"><a href=\"#보조-함수의-활용\" class=\"headerlink\" title=\"보조 함수의 활용\"></a>보조 함수의 활용</h3><h5 id=\"1-고차-함수란\"><a href=\"#1-고차-함수란\" class=\"headerlink\" title=\"1. 고차 함수란?\"></a>1. 고차 함수란?</h5><p>고차 함수는 <strong>값으로 다룰 수 있는 함수</strong>다. 함수를 값으로 다룰 수 있기 때문에 <strong>함수를 인자로 사용</strong>할 수도 있고 함수를 <strong>리턴값으로 사용</strong>할 수도 있다. 이러한 특징을 잘 보여주는 예제가 <a href=\"/programming/functional-js-study/\">지난 시간</a> 살펴본 함수들이 가진 보조함수들이다. <code>each</code>를 다시 한번 살펴보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">each([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>], num =&gt; <span class=\"built_in\">console</span>.log(num)); <span class=\"comment\">// _each 함수에 두번째 인자로 함수가 사용된다.</span></span><br></pre></td></tr></table></figure>\n\n<p>화살표 함수로 정의된 <code>num =&gt; console.log(num)</code>가 <code>each</code> 함수의 인자로 전달되고 이는 보조함수의 역할을 한다. 인자로 함수를 넘겨서 어떤 일을 수행해야하는지를 전달한다면 함수의 추상화 레벨이 올라간다. <code>each</code>의 경우 반복적으로 동일한 일을 처리하는 경우를 추상화해두고 그 일이 어떤 일인지는 개발자가 함수를 호출하는 시기에 결정할 수 있도록 위임한 것이다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> persons = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JE'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span> &#125;, </span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'SJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">34</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'HR'</span>, <span class=\"attr\">age</span>: <span class=\"number\">38</span> &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"string\">'YS'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span> &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">var</span> YB = filter(persons, person =&gt; person.age &lt; <span class=\"number\">30</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(YB); <span class=\"comment\">// [&#123; name: 'JE', age: 27 &#125;, &#123; name: 'YS', age: 27 &#125;]</span></span><br></pre></td></tr></table></figure>\n\n<p><code>filter</code> 함수는 어떤 조건에 따라 원하는 데이터를 골라내는 함수다. 위의 예제는 30세 미만의 사람만 골라냈다. 고차 함수인 <code>person =&gt; person.age &lt; 30</code> 함수를 어떤 조건을 정의해 전달함으로써 추상화된 <code>filter</code> 라는 함수를 사용할 수 있었다.</p>\n<h5 id=\"2-callback-iteratee-predicate의-차이\"><a href=\"#2-callback-iteratee-predicate의-차이\" class=\"headerlink\" title=\"2. callback, iteratee, predicate의 차이\"></a>2. callback, iteratee, predicate의 차이</h5><p>지난 시간에 확인한 것처럼 <code>each</code> 함수의 내부에서는 두번째 인자로 전달되는 보조함수를 <code>iter</code>라고 정의하고 있는데 이는 ‘iteratee’의 준말이다. 반복되는 함수라는 뜻이다. <code>filter</code> 함수는 같은 함수를 <code>predi</code>라고 정의하고 있다. 술부라는 의미를 가진 ‘predicate’의 준말이다. 결과값이 어떠해야 하는지 정의하고 있는 함수이기 때문이다.<br>보조함수 중에서 잘 알려진 함수는 ‘callback’ 함수다. 유명세 때문인지 ‘보조함수(고차함수) === 콜백함수’라고 생각하는 경우도 있다. 하지만 보조함수가 가지는 이름 callback, iteratee, predicate는 그 함수가 하는 역할에 따라 지어진 이름일 뿐이다. callback 함수가 ‘회신’이라는 의미를 가지고 비동기 상황이 끝난 뒤에 어떠한 일을 할지 정의하는 함수인 것처럼 다른 보조함수들도 그에 맞는 이름을 갖는 것이다. </p>\n<p>지금까지 인자로 사용하는 함수인 보조함수를 통해 고차 함수를 알아봤다. 그렇다면 리턴값으로 사용되는 고차 함수는 어떤 경우가 있을까? 커링(currying)을 통해 그 예를 살펴보자.</p>\n<h3 id=\"고차-함수의-응용\"><a href=\"#고차-함수의-응용\" class=\"headerlink\" title=\"고차 함수의 응용\"></a>고차 함수의 응용</h3><h5 id=\"0-커링이란\"><a href=\"#0-커링이란\" class=\"headerlink\" title=\"0. 커링이란?\"></a>0. 커링이란?</h5><p>수학자 Haskell Curry의 이름을 딴 이 기법은 <strong>함수가 함수를 만드는 기법</strong>이다. 함수로 함수를 만들기 위해선 결과값으로 함수를 전달할 수 있어야한다. 이 지점에서 리턴값으로 사용할 수 있는 고차 함수가 등장한다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>커링을 이야기할때 가장 자주 등장하는 형태의 함수다. 이 함수 <code>add</code>는 인자 <code>a</code>를 받고 익명 함수를 리턴한다. 리턴된 익명 함수는 <code>b</code>를 받고 <code>a</code>와 <code>b</code>를 더한 값을 리턴한다. 리턴되는 익명 함수는 <code>a</code>에 대해 알고 있는 클로저다. 때문에 이후에 들어오는 값인 <code>b</code>와 <code>a</code>를 이용해 어떠한 일을 할 수 있는 함수가 된다. </p>\n<p><code>add</code> 함수는 이렇게 사용할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add10 = add(<span class=\"number\">10</span>); <span class=\"comment\">// &lt;-- 함수를 리턴했다.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add10(<span class=\"number\">11</span>)); <span class=\"comment\">// 21</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add10(<span class=\"number\">21</span>)); <span class=\"comment\">// 31</span></span><br></pre></td></tr></table></figure>\n\n<p><code>10</code>이라는 값을 알고 있는 익명 함수가 <code>add10</code>이라는 변수에 담긴다. 클로저인 익명 함수가 <code>add10</code>이라는 이름을 갖게된 것이다. 새로운 이름을 가진 이 함수가 실행되면 자신이 알고 있는 <code>10</code>과 새로 받는 값을 모두 이용할 수 있다. 최초의 <code>add</code> 함수 정의에서 두 값을 더하는 것으로 정했기 때문에 이후에 들어온 값 <code>11</code>이나 <code>21</code>을 <code>10</code>과 더하는 일을 수행한다. </p>\n<p><code>add</code> 함수를 정의할 때 화살표 함수를 사용하면 조금 더 근사하다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"function\"><span class=\"params\">b</span> =&gt;</span> a + b;</span><br></pre></td></tr></table></figure>\n\n<p>이러한 형태의 함수는 미리 정의된 일 밖에 할 수 없으니 아쉽다. 커링하는 일 자체를 추상화하는 새로운 함수를 만들어보자.</p>\n<h5 id=\"1-curry-함수\"><a href=\"#1-curry-함수\" class=\"headerlink\" title=\"1. curry 함수\"></a>1. curry 함수</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fn(a, b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// var curry = a =&gt; b =&gt; fn(a, b);</span></span><br></pre></td></tr></table></figure>\n\n<p>함수가 익명 함수를 리턴했는데 그 함수가 다시 함수를 리턴한다. 복잡한것처럼 보이지만 단순하다. 천천히 살펴보자. </p>\n<p>우선 <code>curry</code>는 함수를 인자로 받는다. 이때 받은 함수를 커링이 되는 함수로 만드는 것이 <code>curry</code> 함수의 목표다. 목표를 달성하기 위해 다짜고짜 첫번째 익명 함수를 리턴한다. 첫번째 익명 함수는 <code>fn</code>이 사용할 첫번째 인자를 받는 함수다. <code>a</code>를 받은 뒤에 다시 한번 더 익명 함수를 리턴한다. 두번째 익명 함수다. 두번째 함수는 <code>fn</code>에게 필요한 두번째 인자를 받고 <code>fn</code>을 실행한다. 그 결과를 리턴한다. 글로만 읽으면 어떻게 동작하는지 이해하기 어렵다. 예제를 보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = curry(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b); <span class=\"comment\">// &lt;-- 첫번째 함수를 리턴했다.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> add10 = add(<span class=\"number\">10</span>); <span class=\"comment\">// &lt;-- 두번째 함수를 리턴했다.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add10(<span class=\"number\">11</span>)); <span class=\"comment\">// 21</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add10(<span class=\"number\">21</span>)); <span class=\"comment\">// 31</span></span><br></pre></td></tr></table></figure>\n\n<p>커링하는 일을 추상화 해둔 <code>curry</code>라는 함수를 사용했다. 덕분에 어떤 일을 할지 <code>curry</code>에 함수에 전달하는 것만으로 커링이 가능한 함수를 만들 수 있게 되었다. 다른 함수도 쉽게 만들 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = curry(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum10 = sum(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum10(<span class=\"number\">5</span>)); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p>이처럼 <code>curry</code> 함수를 이용해서 사칙 연산 함수들을 커링이 가능한 함수로 만들 수 있다. 그런데 가만 생각해보면 좀 이상하다 <code>sum10</code>이라는 이름을 생각해보자. <strong>10을 뺄 준비가 된 함수</strong>여야할 것 같은데 반대가 되어버린다. (이 대목에서 이상하다고 생각하지 않아도 괜찮다.) <code>curryr</code>이라는 함수를 만들어서 덜 이상하게 순서를 바꿔보자. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> curryr = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"function\"><span class=\"params\">b</span> =&gt;</span> fn(b, a);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = curryr(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum10 = sum(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum10(<span class=\"number\">5</span>)); <span class=\"comment\">// -5</span></span><br></pre></td></tr></table></figure>\n\n<p><code>curryr</code>을 구현하기 위해선 인자 <code>fn</code>의 인자 순서를 뒤집어주면(reverse) 된다. 이제 <code>sum10</code>은 <strong>10을 뺄 준비가 된 함수</strong>가 됐다. 어떤 수가 들어오건 10을 뺀다. 이 상태가 되면 이제 지난 시간에 만들어둔 함수들을 발전시킬 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 커링 적용 전</span></span><br><span class=\"line\">go([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>],</span><br><span class=\"line\">  arr =&gt; filter(arr, num =&gt; num % <span class=\"number\">2</span>), <span class=\"comment\">// &lt;-- 함수로 한번 감싸서 실행시킨다.</span></span><br><span class=\"line\">  arr =&gt; each(arr, num =&gt; <span class=\"built_in\">console</span>.log(num))); <span class=\"comment\">// &lt;-- 코드가 복잡하다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">filter = curryr(filter);</span><br><span class=\"line\">each = curryr(each);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 커링 적용 후</span></span><br><span class=\"line\">go([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>],</span><br><span class=\"line\">  filter(<span class=\"function\"><span class=\"params\">num</span> =&gt;</span> num % <span class=\"number\">2</span>), <span class=\"comment\">// &lt;-- 어떤 일을 해야하는지 알고 있는 함수가 이 자리에 리턴된다.</span></span><br><span class=\"line\">  each(<span class=\"function\"><span class=\"params\">num</span> =&gt;</span> <span class=\"built_in\">console</span>.log(num))); <span class=\"comment\">// &lt;-- 코드가 간결하다.</span></span><br></pre></td></tr></table></figure>\n\n<p>커링이 적용된 발전된 함수는 <code>go</code> 함수 안에서 보다 간결하게 의미를 전달 수 있는 코드가 되었다. <code>filter</code>와 <code>each</code>가 보조함수를 기억한 함수를 리턴한 뒤에 <code>go</code>가 실행되면 <code>go</code>는 첫번째 인자인 배열을 <code>filter</code>와 <code>each</code>가 남긴 함수에게 전달해서 각각의 일을 수행하도록 한다. 커링으로 간결하고 읽기 좋은 코드가 되었다. </p>\n<p>하지만 이 코드에서도 문제가 남아있다. 바로 커링이 적용된 함수들을 원래 방법대로 사용할 수 없다는 점이다. 지금 상황에서는 <code>filter</code>에 인자를 동시에 두개를 넘겨도 함수를 리턴할 것이다. 약간의 수정이 필요하다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curryr</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !b ? <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fn(b, a);</span><br><span class=\"line\">    &#125; : fn(a, b);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// var curryr = fn =&gt; (a, b) =&gt; (!b ? b =&gt; fn(b, a) : fn(a, b))</span></span><br></pre></td></tr></table></figure>\n\n<p>첫번째 익명 함수에 인자가 하나만 들어왔다면 커링을 적용한 함수를 리턴하고 그렇지 않다면 그냥 원래 방법대로 함수를 실행핟 결과를 리턴하도록 바꿔주면 모든 문제가 해결된다. 물론 인자를 두개 받지 못한다는 단점은 여전히 존재한다. 이 문제는 다음 시간에 해결할 계획이다.</p>\n<h5 id=\"2-pipe-함수-만들기\"><a href=\"#2-pipe-함수-만들기\" class=\"headerlink\" title=\"2. pipe 함수 만들기\"></a>2. <code>pipe</code> 함수 만들기</h5><p><code>pipe</code> 함수는 함수를 조합하는 함수다. 여러 개의 함수가 조합된 새로운 함수를 만들기 위해 사용한다. 이런 식으로 사용할 것이다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> odd_sum = pipe(filter(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n % <span class=\"number\">2</span>), reduce(<span class=\"function\">(<span class=\"params\">t, n</span>) =&gt;</span> t + n));</span><br><span class=\"line\"></span><br><span class=\"line\">go([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>],</span><br><span class=\"line\">  odd_sum,</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// 16</span></span><br></pre></td></tr></table></figure>\n\n<p><code>filter</code>와 <code>reduce</code>를 조합해서 홀수값의 총합을 만드는 함수를 만들었다. 이 함수는 어떤 배열이 들어와도 홀수값의 합을 반환하는 함수가 된다. 이처럼 반복적으로 사용될만한 함수 조합을 <code>pipe</code>로 묶어서 정의해두면 함수의 활용성이 좋아진다. </p>\n<p>끝으로 어떻게 구현하는지 살펴보자. 아래와 같이 <code>go</code>를 사용하면 쉽게 구현할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> slice = <span class=\"built_in\">Array</span>.prototype.slice;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pipe</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fns = slice.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">seed</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> go.apply(<span class=\"literal\">null</span>, [seed, ...fns]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"전체-스터디-일정\"><a href=\"#전체-스터디-일정\" class=\"headerlink\" title=\"전체 스터디 일정\"></a>전체 스터디 일정</h3><ul>\n<li>1주차 - <a href=\"/programming/functional-js-study/\">기본 함수 구현하고 사용하기</a></li>\n<li>2주차 - 고차 함수와 커링(currying)</li>\n<li>3주차 - <a href=\"/programming/functional-js-study-2/\">함수형 자바스크립트 라이브러리</a></li>\n<li>4주차 - Movie Box 1: 필터링, 정렬</li>\n<li><em>5주차 - Movie Box 2: 필터링, 정렬 복습</em></li>\n<li><em>6주차 - Movie Box 3: 지연평가 L, memoize</em></li>\n<li><em>7주차 - Movie Box 4: 비동기 상황 다루기</em></li>\n</ul>\n<p><a href=\"https://github.com/joeunha/functional-js-study/tree/master/02_week\" target=\"_blank\" rel=\"noopener\">예제 코드</a></p>\n"},{"title":"함수형 자바스크립트 - 기본 함수 구현하고 사용하기","date":"2017-10-17T06:36:32.000Z","_content":"## 기본 함수 구현하고 사용하기\n함수형 프로그래밍에서 사용되는 기본 함수인 `each`, `map`, `filter`, `reduce` 함수와 함수를 실행하는 함수인 `go` 함수를 사용해보고 직접 구현해보자.\n(모든 예제는 웹 브라우저의 '검사' 도구를 열어서 테스트할 수 있다.)\n\n### 함수형 실전 코드 예제 소개\n#### 0. 예제 데이터\n\n이하 예제에서 사용될 데이터이다. `products`는 객체 형태의 상품 정보를 담고 있는 배열이다. 장바구니에 담긴 데이터라고 가정하고 있다.\n```javascript\nvar products = [\n  {\n    is_selected: true, // <--- 장바구니에서 체크 박스 선택\n    name: \"반팔티\",\n    price: 10000, // <--- 기본 가격\n    sizes: [ // <---- 장바구니에 담은 동일 상품의 사이즈 별 수량과 가격\n      { name: \"L\", quantity: 2, price: 0 },\n      { name: \"XL\", quantity: 3, price: 0 },\n      { name: \"2XL\", quantity: 2, price: 2000 }, // <-- 옵션의 추가 가격\n    ]\n  },\n  {\n    is_selected: true,\n    name: \"후드티\",\n    price: 21000,\n    sizes: [\n      { name: \"L\", quantity: 3, price: -1000 },\n      { name: \"2XL\", quantity: 1, price: 2000 },\n    ]\n  },\n  {\n    is_selected: false,\n    name: \"맨투맨\",\n    price: 16000,\n    sizes: [\n      { name: \"L\", quantity: 4, price: 0 }\n    ]\n  }\n];\n```\n\n#### 1. 모든 제품의 전체 수량 구하기\n\n제품의 전체 수량을 구하는 코드는 아래와 같이 작성할 수 있다.\n```javascript\nvar sum_total_quantity = function(products) { // <-- 제품의 전체 수량을 구하는 함수\n  return reduce(products, function(tq, product) {\n    return reduce(product.sizes, function(tq2, size) {\n      return tq2 + size.quantity;\n    }, tq);\n  }, 0)\n};\n\nvar total_quantity = sum_total_quantity(products); // <-- 예제 데이터를 넣으면 전체 수량을 구할 수 있다.\nconsole.log(total_quantity); // 15\n```\n\n코드를 살펴보자. 우선 코드에 등장하는 `reduce` 함수는 돌림직한 데이터(Array, ArrayLike, Object)를 '줄여나가는(reduce)' 함수다. underscore와 같은 라이브러리에선 `fold`라는 이름으로도 사용된다. 이와 같은 표현을 사용하면 `reduce` 함수는 데이터를 '접는(fold)' 함수인 셈이다. \n\n다시 위의 코드를 보면 가장 밖에 있는 함수가 `products`를 받을 준비를 하고 있다. 이 `products`는 `reduce`에게 전달된다. `reduce` 함수는 세개의 인사를 받는데, __접을 데이터__, __어떻게 접을지 정의하는 함수__, __접을 때 사용할 초기값__을 받는다. 여기서 `products`가 접을 데이터가 되고 두번째 함수가 어떻게 접을지를 정의하고 있다. 초기값으로는 `0`을 넘겼다. 그리고 넘겨진 값들로 인해 만들어진 결과를 리턴한다.\n\n이때 어떻게 접을지 정의한 두번째 인자인 함수를 보면 다시 `reduce`를 사용하고 있는 것을 알 수 있다. 같은 함수가 반복되니 헷갈린다. 하지만 데이터를 보면 그 이유가 드러난다. 우리가 원하는 값은 제품의 수량을 의미하는 `quantity`다. 그런데 값은 `sizes`라는 배열 안에 있기에 다시 한번 `reduce`를 호출한 것이다. 다시 말해 두번째로 호출되는 `reduce`는 `sizes` 배열 안의 값을 접어나가는 함수, 먼저 호출된 `reduce`는 두번째에 의해 접힌 결과를 한번 더 접는 함수인 것이다.\n\n두번째로 호출되는 `reduce`를 다시 살펴보면 앞서 말한 것처럼 `sizes` 배열을 접을 데이터로 전달한다. 그리고 초기값에 `tq`를 전달하는데 이때 `tq`는 첫번째 `reduce`가 전달한 `0`에 해당하는 값이다. 이 값은 `products` 배열을 돌면서 값이 계속 누적된다. 값이 쌓여가고 접혀가는 것이다. (이해가 되지 않는다면 우선 넘어간다.) 그리고 어떻게 접을지 정의한 함수에서 진짜 수량을 더한다. `tq2 + size.quantity` 이를 통해 값을 더해나가면 우리가 원하는 총 수량을 구할 수 있다.\n\n위의 과정을 통해 만들어진 함수가 실제로 동작하는 것은 호출이 일어났을 때다. `var total_quantity = sum_total_quantity(products);`처럼 코드를 실행하고 그 결과를 변수에 저장해서 다시 로그 함수에 넘길 수 있지만 선언된 `sum_total_quantity` 함수를 `go` 함수와 함께 사용하면 아래와 같은 코드가 된다. 별도의 변수 선언 없이 원하는 일을 할 수 있다.\n```javascript\ngo(products, \n  sum_total_quantity, \n  console.log); // 15\n```\n\n\n#### 2. 선택된 제품의 전체 수량 구하기\n\n선택된 제품들의 수량만을 구하는 코드는 아래와 같다.\n```javascript\nvar selected_products = filter(products, product => product.is_selected); // <-- 선택된 제품만 골라낸 데이터\nvar selected_products_total_quantity = sum_total_quantity(selected_products);\n\nconsole.log(selected_product_total_quantity); // 11\n```\n\n비교적 간단한 코드다. `_filter` 함수를 이용해서 우리가 필요한 데이터를 골라내고 있다. 이 함수는 말 그대로 원하는 데이터만을 '거르는' 함수다. 두번째 인자로 전달된 함수는 거를 기준을 제시한다. 리턴값이 참이면 그 값은 `_filter` 필요한 데이터라는 의미가 된다. 위의 코드에서는 선택된 데이터만을 골라내고 있다. \n\n마찬가지로 `go` 함수를 사용하면 아래와 같이 표현할 수 있다.\n```javascript\ngo(products,\n  products => _filter(products, product => product.is_selected),\n  sum_total_quantity,\n  console.log); // 11\n```\n\n\n### 기본 함수 직접 구현하기\n\n#### 1. `each`\n`each` 함수는 `for`와 같은 반복문을 대체하는 함수다. 오늘 만들 다른 함수들과 마찬가지로 돌림직한 데이터를 돌면서 어떤 동작을 한다. 다른 함수들이 부수효과를 지양하는 것에 반해 이 함수는 부수효과를 이용한다. 인자로 __돌림직한 데이터__와 __돌면서 무엇을 할지 정의한 함수__를 받는다. \n\n사용의 예는 아래와 같다.\n```javascript\neach([1,2,3,4,5], num => console.log(num)); // <-- 1부터 5까지 순서대로 로그가 남는다.\n```\n\n실제 함수는 아래와 같이 구현되어 있다.\n```javascript\nfunction each(list, iter) {\n  if (Array.isArray(list)) { // <-- 배열을 돌리기 위한 부분\n    for (var i = 0, len = list.length; i < len; i++) \n      iter(list[i], i, list);\n  } else { // <-- 그 외의 객체를 돌리기 위한 부분\n    var keys = Object.keys(list);\n    for (var i = 0, len = keys.length; i < len; i++) \n      iter(list[keys[i]], keys[i], list);\n  }\n}\n```\n\n코드를 살펴보면 `for` 구문으로 데이터를 순회하며 `iter`라고 정의한 보조 함수를 한번씩 실행시켜주고 있다. 배열과 객체를 구분해서 값을 찾고 보조 함수에 전달하는데 보조 함수에 전달하는 값은 __순서대로 찾은 값__, __그 값의 인덱스(키)__, __원본 배열(객체)__이다. 이렇게 전달된 인자들을 이용해 `each` 함수를 보다 유연하게 사용할 수 있게 된다.\n\n\n#### 2. `map`\n`map` 함수는 데이터를 돌면서 값을 매핑하고 새로운 배열을 리턴하는 함수다. 앞서 언급한 것처럼 부수효과를 지양한다. `each`와 마찬가지로 인자로 __돌림직한 데이터__와 __돌면서 무엇을 할지 정의한 함수__를 받는다. 차이점은 받은 함수가 새로운 배열의 값을 정의한다는 점이다.\n\n사용의 예는 아래와 같다.\n```javascript\nvar result = map([1,2,3,4,5], num => num + 10);\nconsole.log(result); // [11, 12, 13, 14, 15]\n```\n\n실제 함수는 아래와 같이 구현되어 있다.\n```javascript\nfunction map(list, iter) {\n  var res = [];\n  if (Array.isArray(list)) {\n    for (var i = 0, len = list.length; i < len; i++) \n      res[i] = iter(list[i], i, list);\n  } else {\n    var keys = Object.keys(list);\n    for (var i = 0, len = keys.length; i < len; i++) \n      res[i] = iter(list[keys[i]], keys[i], list);\n  }\n  return res;\n}\n```\n\n`each` 함수와 다른 점은 `res`라는 결과값을 내부에서 정의하고 이를 반환한다는 것이다. 결과적으로 `map`은 보조함수에 의해 정의된 값을 담은 새로운 배열을 리턴한다. \n\n\n#### 3. `filter`\n위에서 이미 살펴본 `filter` 함수는 데이터를 거르는 함수다. 사실 `each`를 제외한 모든 함수는 리턴값이 중요하다. 그 값을 전달함으로 다른 함수와 소통한다. \n\n사용의 예는 이미 위에서 살펴보았으니 구현체만 살펴보자.\n```javascript\nfunction filter(list, predi) {\n  var res = [];\n  if (Array.isArray(list)) {\n    for (var i = 0, len = list.length; i < len; i++) \n      if (predi(list[i], i, list)) \n        res.push(list[i]);\n  } else {\n    var keys = Object.keys(list);\n    for (var i = 0, len = keys.length; i < len; i++) \n      if (predi(list[keys[i]], keys[i], list)) \n        res.push(list[keys[i]]);\n  }\n  return res;\n}\n```\n\n`map`처럼 결과값 `res`를 갖지만 보조함수(`predi`)가 리턴한 값이 아닌 보조함수의 실행 결과가 참인 경우에만 값을 결과값에 담는다.\n\n\n#### 4. `reduce`\n역시 이미 앞서 만나본 함수다. `reduce`는 데이터를 접는 함수다. 다른 함수들과 달리 세개의 인자를 값으로 받는다.\n\n미리 봤던 예제보다 단순한 예제를 살펴보고 구현으로 넘어가자.\n```javascript\nvar result = reduce([1,2,3,4,5,6,7,8,9,10], function(memo, num) {\n  return memo + num;\n}, 0);\nconsole.log(result); // 55\n```\n\n세개의 인자를 전달 받았다. 첫번째 인자는 1부터 10까지를 담고 있는 배열이다. 이를 어떻게 처리할지 알고 있는 함수와 초기 값을 나머지 인자로 받았다. 예제에서 보조함수는 받은 값을 더하는 함수다. 결과적으로 `reduce`는 1부터 10까지의 총합을 반환한다. \n\n이를 구현한 코드는 아래와 같다.\n```javascript\nfunction reduce(list, iter, memo) {\n  var i = 0;\n  if (Array.isArray(list)) {\n    var res = (memo !== undefined ? memo : list[i++]); // <-- 남다른 결과값 선언부\n    for (var len = list.length; i < len; i++) \n      res = iter(res, list[i], i, list);\n  } else {\n    var keys = Object.keys(list), res = (memo !== undefined ? memo : list[keys[i++]]);\n    for (var len = keys.length; i < len; i++) \n      res = iter(res, list[keys[i]], keys[i], list);\n  }\n  return res;\n}\n```\n\n결과값 `res`를 선언하는 부분이 조금 남다르다. 앞선 `map`, `filter`가 배열을 리턴했던 것과 달리 `reduce`는 결과값의 데이터형이 호출 당시에 결정된다. 코드에서 `memo`에 해당하는 변수가 바로 초기값이다. 결과값은 초기값의 데이터형에 의해 정해지기 때문에 `res`를 선언하는 과정에서 `memo`가 데이터를 가지고 있는지를 검사한다. `undefined`인 경우 호출 당시 초기값이 전달되지 않은 것으로 판단하고 `list`의 첫번째 값을 초기값으로 사용한다. \n\n이후에 다른 함수들과 마찬가지로 반복문을 수행한다. 이때 보조함수 `iter`가 리턴하는 값을 결과값에 덮어씌운다. `list`의 마지막 값을 가지고 보조함수가 수행한 결과가 최종 결과값이 된다.\n\n\n#### 5. `go`\n`go` 함수는 파이프라인 코딩이 가능하도록 돕는 함수다. 클로저(Clojure)에서의 `->>` 연산자나 엘릭서(Elixir)에서의 `|>` 연산자와 같은 역할을 한다. 첫번째로 받은 인자(데이터)를 두번째로 받은 인자(함수)에 넘긴다. 두번째 함수가 리턴하는 값을 다시 세번째 인자(함수)로 넘긴다. 예시를 한번 더 살펴보자.\n\n```javascript\ngo([1,2,3,4,5,6,7,8,9,10],\n  arr => filter(arr, num => num % 2), // <-- 홀수 값만을 갖는 배열을 리턴한다.\n  arr => reduce(arr, (total, num) => total + num), // [1, 3, 5, 7, 9]을 더하여 리턴한다.\n  console.log); // 25\n```\n\n코드는 아래와 같이 구현되어 있다.\n```javascript\nvar slice = Array.prototype.slice;\nfunction go(seed) {\n  var fns = slice.call(arguments, 1);\n  return reduce(fns, (se, fn) => fn(se), seed);\n}\n```\n\n짧은 코드지만 재미난 구석이 많은 코드다. 살펴보자. 우선 `slice`를 사용해서 `arguments` 객체를 배열로 만들어준다. 첫번째 인자인 `seed`를 제외한 나머지들을 모두 `fns`라는 변수에 선언하는데 첫번째 인자를 제외한 모든 인자가 함수일 것이기 때문이다. 이제 이 함수들을 순서대로 실행시켜나가면 된다. 그런데 뜬금없이 `reduce`가 등장한다. 잠깐 생각해보자.\n\n`go`는 첫번째 인자로 들어온 __데이터를 여러 함수들에 통과시키며 리턴값을 만들어가는 함수__다. 데이터를 변형해서 무엇으로 만들어가는 함수는 이미 하나 있었다. 데이터를 접는 함수라고 소개했던 `reduce`가 그런 역할을 한다. __초기값의 데이터형__을 기준으로 __돌림직한 데이터__를 돌면서 데이터를 접어나간다. 우리는 이미 돌림직한 데이터인 `fns`(배열)와 초기값인 `seed`를 가지고 있다. 이제 필요한건 오직 __어떻게 접어나갈지 정의하는 함수__뿐이다. 그렇다. 이게 바로 `reduce`가 사용된 이유다. 이렇게 이미 정의된 함수 덕에 보다 쉽게 새로운 함수를 만들 수 있다. 이제 어떻게 접어나갈지 살펴보자.\n\n우리는 `fns`가 갖고 있는 함수들의 실행 결과가 필요하다. 이 작업을 단지 `(se, fn) => fn(se)`라고 정의함으로 해결할 수 있다. 이미 정의된 어떤 함수 덕분이다. 여기서 `se`는 처음에는 `seed`와 같은 값이었다가 이후에는 `fn`의 리턴값이 될 것이다. `fn`은 `reduce`의 내부에서 반복문으로 배열(`fns`)을 돌며 계속해서 다음 값을 넘겨서 받게 되는 함수다. \n\n\n### 문제 풀어보기\n끝으로 앞서 소개된 '함수형 실전 코드 예제'와 유사한 예제를 풀어보자. 데이터는 `products`라는 변수에 선언되어 있다. ('검사' 창에서 풀어볼 수 있다.) \n\n1. 모든 제품의 총 가격\n2. 선택된 제품의 총 가격 \n\n---\n\n### 전체 스터디 일정\n  - 1주차 - 기본 함수 구현하고 사용하기\n  - 2주차 - [고차 함수와 커링(currying)](/programming/functional-js-study-1/) \n  - 3주차 - [함수형 자바스크립트 라이브러리](/programming/functional-js-study-2/)\n  - 4주차 - Movie Box 1: 필터링, 정렬\n  - _5주차 - Movie Box 2: 필터링, 정렬 복습_\n  - _6주차 - Movie Box 3: 지연평가 L, memoize_\n  - _7주차 - Movie Box 4: 비동기 상황 다루기_\n\n[예제 코드](https://github.com/joeunha/functional-js-study/tree/master/01_week)\n\n<script src=\"/js/functional.js\"></script>\n<script async>\nvar products = [\n  {\n    is_selected: true, // <--- 장바구니에서 체크 박스 선택\n    name: \"반팔티\",\n    price: 10000, // <--- 기본 가격\n    sizes: [ // <---- 장바구니에 담은 동일 상품의 사이즈 별 수량과 가격\n      { name: \"L\", quantity: 2, price: 0 },\n      { name: \"XL\", quantity: 3, price: 0 },\n      { name: \"2XL\", quantity: 2, price: 2000 }, // <-- 옵션의 추가 가격\n    ]\n  },\n  {\n    is_selected: true,\n    name: \"후드티\",\n    price: 21000,\n    sizes: [\n      { name: \"L\", quantity: 3, price: -1000 },\n      { name: \"2XL\", quantity: 1, price: 2000 },\n    ]\n  },\n  {\n    is_selected: false,\n    name: \"맨투맨\",\n    price: 16000,\n    sizes: [\n      { name: \"L\", quantity: 4, price: 0 }\n    ]\n  }\n];\n\nif (location.pathname === '/2017/10/17/functional-js-study/')\n  console.log(`\n  [문제 풀어보기]\n    0. 데이터 변수 이름: products\n    1. 모든 제품의 총 가격\n    2. 선택된 제품의 총 가격 \n  `)\n</script>","source":"_posts/functional-js-study-0.md","raw":"---\ntitle: '함수형 자바스크립트 - 기본 함수 구현하고 사용하기'\ncategories:\n  - programming\ntags:\n  - javascript\n  - 자바스크립트\n  - 함수형 프로그래밍\n  - 함수형 자바스크립트\ndate: 2017-10-17 15:36:32\n---\n## 기본 함수 구현하고 사용하기\n함수형 프로그래밍에서 사용되는 기본 함수인 `each`, `map`, `filter`, `reduce` 함수와 함수를 실행하는 함수인 `go` 함수를 사용해보고 직접 구현해보자.\n(모든 예제는 웹 브라우저의 '검사' 도구를 열어서 테스트할 수 있다.)\n\n### 함수형 실전 코드 예제 소개\n#### 0. 예제 데이터\n\n이하 예제에서 사용될 데이터이다. `products`는 객체 형태의 상품 정보를 담고 있는 배열이다. 장바구니에 담긴 데이터라고 가정하고 있다.\n```javascript\nvar products = [\n  {\n    is_selected: true, // <--- 장바구니에서 체크 박스 선택\n    name: \"반팔티\",\n    price: 10000, // <--- 기본 가격\n    sizes: [ // <---- 장바구니에 담은 동일 상품의 사이즈 별 수량과 가격\n      { name: \"L\", quantity: 2, price: 0 },\n      { name: \"XL\", quantity: 3, price: 0 },\n      { name: \"2XL\", quantity: 2, price: 2000 }, // <-- 옵션의 추가 가격\n    ]\n  },\n  {\n    is_selected: true,\n    name: \"후드티\",\n    price: 21000,\n    sizes: [\n      { name: \"L\", quantity: 3, price: -1000 },\n      { name: \"2XL\", quantity: 1, price: 2000 },\n    ]\n  },\n  {\n    is_selected: false,\n    name: \"맨투맨\",\n    price: 16000,\n    sizes: [\n      { name: \"L\", quantity: 4, price: 0 }\n    ]\n  }\n];\n```\n\n#### 1. 모든 제품의 전체 수량 구하기\n\n제품의 전체 수량을 구하는 코드는 아래와 같이 작성할 수 있다.\n```javascript\nvar sum_total_quantity = function(products) { // <-- 제품의 전체 수량을 구하는 함수\n  return reduce(products, function(tq, product) {\n    return reduce(product.sizes, function(tq2, size) {\n      return tq2 + size.quantity;\n    }, tq);\n  }, 0)\n};\n\nvar total_quantity = sum_total_quantity(products); // <-- 예제 데이터를 넣으면 전체 수량을 구할 수 있다.\nconsole.log(total_quantity); // 15\n```\n\n코드를 살펴보자. 우선 코드에 등장하는 `reduce` 함수는 돌림직한 데이터(Array, ArrayLike, Object)를 '줄여나가는(reduce)' 함수다. underscore와 같은 라이브러리에선 `fold`라는 이름으로도 사용된다. 이와 같은 표현을 사용하면 `reduce` 함수는 데이터를 '접는(fold)' 함수인 셈이다. \n\n다시 위의 코드를 보면 가장 밖에 있는 함수가 `products`를 받을 준비를 하고 있다. 이 `products`는 `reduce`에게 전달된다. `reduce` 함수는 세개의 인사를 받는데, __접을 데이터__, __어떻게 접을지 정의하는 함수__, __접을 때 사용할 초기값__을 받는다. 여기서 `products`가 접을 데이터가 되고 두번째 함수가 어떻게 접을지를 정의하고 있다. 초기값으로는 `0`을 넘겼다. 그리고 넘겨진 값들로 인해 만들어진 결과를 리턴한다.\n\n이때 어떻게 접을지 정의한 두번째 인자인 함수를 보면 다시 `reduce`를 사용하고 있는 것을 알 수 있다. 같은 함수가 반복되니 헷갈린다. 하지만 데이터를 보면 그 이유가 드러난다. 우리가 원하는 값은 제품의 수량을 의미하는 `quantity`다. 그런데 값은 `sizes`라는 배열 안에 있기에 다시 한번 `reduce`를 호출한 것이다. 다시 말해 두번째로 호출되는 `reduce`는 `sizes` 배열 안의 값을 접어나가는 함수, 먼저 호출된 `reduce`는 두번째에 의해 접힌 결과를 한번 더 접는 함수인 것이다.\n\n두번째로 호출되는 `reduce`를 다시 살펴보면 앞서 말한 것처럼 `sizes` 배열을 접을 데이터로 전달한다. 그리고 초기값에 `tq`를 전달하는데 이때 `tq`는 첫번째 `reduce`가 전달한 `0`에 해당하는 값이다. 이 값은 `products` 배열을 돌면서 값이 계속 누적된다. 값이 쌓여가고 접혀가는 것이다. (이해가 되지 않는다면 우선 넘어간다.) 그리고 어떻게 접을지 정의한 함수에서 진짜 수량을 더한다. `tq2 + size.quantity` 이를 통해 값을 더해나가면 우리가 원하는 총 수량을 구할 수 있다.\n\n위의 과정을 통해 만들어진 함수가 실제로 동작하는 것은 호출이 일어났을 때다. `var total_quantity = sum_total_quantity(products);`처럼 코드를 실행하고 그 결과를 변수에 저장해서 다시 로그 함수에 넘길 수 있지만 선언된 `sum_total_quantity` 함수를 `go` 함수와 함께 사용하면 아래와 같은 코드가 된다. 별도의 변수 선언 없이 원하는 일을 할 수 있다.\n```javascript\ngo(products, \n  sum_total_quantity, \n  console.log); // 15\n```\n\n\n#### 2. 선택된 제품의 전체 수량 구하기\n\n선택된 제품들의 수량만을 구하는 코드는 아래와 같다.\n```javascript\nvar selected_products = filter(products, product => product.is_selected); // <-- 선택된 제품만 골라낸 데이터\nvar selected_products_total_quantity = sum_total_quantity(selected_products);\n\nconsole.log(selected_product_total_quantity); // 11\n```\n\n비교적 간단한 코드다. `_filter` 함수를 이용해서 우리가 필요한 데이터를 골라내고 있다. 이 함수는 말 그대로 원하는 데이터만을 '거르는' 함수다. 두번째 인자로 전달된 함수는 거를 기준을 제시한다. 리턴값이 참이면 그 값은 `_filter` 필요한 데이터라는 의미가 된다. 위의 코드에서는 선택된 데이터만을 골라내고 있다. \n\n마찬가지로 `go` 함수를 사용하면 아래와 같이 표현할 수 있다.\n```javascript\ngo(products,\n  products => _filter(products, product => product.is_selected),\n  sum_total_quantity,\n  console.log); // 11\n```\n\n\n### 기본 함수 직접 구현하기\n\n#### 1. `each`\n`each` 함수는 `for`와 같은 반복문을 대체하는 함수다. 오늘 만들 다른 함수들과 마찬가지로 돌림직한 데이터를 돌면서 어떤 동작을 한다. 다른 함수들이 부수효과를 지양하는 것에 반해 이 함수는 부수효과를 이용한다. 인자로 __돌림직한 데이터__와 __돌면서 무엇을 할지 정의한 함수__를 받는다. \n\n사용의 예는 아래와 같다.\n```javascript\neach([1,2,3,4,5], num => console.log(num)); // <-- 1부터 5까지 순서대로 로그가 남는다.\n```\n\n실제 함수는 아래와 같이 구현되어 있다.\n```javascript\nfunction each(list, iter) {\n  if (Array.isArray(list)) { // <-- 배열을 돌리기 위한 부분\n    for (var i = 0, len = list.length; i < len; i++) \n      iter(list[i], i, list);\n  } else { // <-- 그 외의 객체를 돌리기 위한 부분\n    var keys = Object.keys(list);\n    for (var i = 0, len = keys.length; i < len; i++) \n      iter(list[keys[i]], keys[i], list);\n  }\n}\n```\n\n코드를 살펴보면 `for` 구문으로 데이터를 순회하며 `iter`라고 정의한 보조 함수를 한번씩 실행시켜주고 있다. 배열과 객체를 구분해서 값을 찾고 보조 함수에 전달하는데 보조 함수에 전달하는 값은 __순서대로 찾은 값__, __그 값의 인덱스(키)__, __원본 배열(객체)__이다. 이렇게 전달된 인자들을 이용해 `each` 함수를 보다 유연하게 사용할 수 있게 된다.\n\n\n#### 2. `map`\n`map` 함수는 데이터를 돌면서 값을 매핑하고 새로운 배열을 리턴하는 함수다. 앞서 언급한 것처럼 부수효과를 지양한다. `each`와 마찬가지로 인자로 __돌림직한 데이터__와 __돌면서 무엇을 할지 정의한 함수__를 받는다. 차이점은 받은 함수가 새로운 배열의 값을 정의한다는 점이다.\n\n사용의 예는 아래와 같다.\n```javascript\nvar result = map([1,2,3,4,5], num => num + 10);\nconsole.log(result); // [11, 12, 13, 14, 15]\n```\n\n실제 함수는 아래와 같이 구현되어 있다.\n```javascript\nfunction map(list, iter) {\n  var res = [];\n  if (Array.isArray(list)) {\n    for (var i = 0, len = list.length; i < len; i++) \n      res[i] = iter(list[i], i, list);\n  } else {\n    var keys = Object.keys(list);\n    for (var i = 0, len = keys.length; i < len; i++) \n      res[i] = iter(list[keys[i]], keys[i], list);\n  }\n  return res;\n}\n```\n\n`each` 함수와 다른 점은 `res`라는 결과값을 내부에서 정의하고 이를 반환한다는 것이다. 결과적으로 `map`은 보조함수에 의해 정의된 값을 담은 새로운 배열을 리턴한다. \n\n\n#### 3. `filter`\n위에서 이미 살펴본 `filter` 함수는 데이터를 거르는 함수다. 사실 `each`를 제외한 모든 함수는 리턴값이 중요하다. 그 값을 전달함으로 다른 함수와 소통한다. \n\n사용의 예는 이미 위에서 살펴보았으니 구현체만 살펴보자.\n```javascript\nfunction filter(list, predi) {\n  var res = [];\n  if (Array.isArray(list)) {\n    for (var i = 0, len = list.length; i < len; i++) \n      if (predi(list[i], i, list)) \n        res.push(list[i]);\n  } else {\n    var keys = Object.keys(list);\n    for (var i = 0, len = keys.length; i < len; i++) \n      if (predi(list[keys[i]], keys[i], list)) \n        res.push(list[keys[i]]);\n  }\n  return res;\n}\n```\n\n`map`처럼 결과값 `res`를 갖지만 보조함수(`predi`)가 리턴한 값이 아닌 보조함수의 실행 결과가 참인 경우에만 값을 결과값에 담는다.\n\n\n#### 4. `reduce`\n역시 이미 앞서 만나본 함수다. `reduce`는 데이터를 접는 함수다. 다른 함수들과 달리 세개의 인자를 값으로 받는다.\n\n미리 봤던 예제보다 단순한 예제를 살펴보고 구현으로 넘어가자.\n```javascript\nvar result = reduce([1,2,3,4,5,6,7,8,9,10], function(memo, num) {\n  return memo + num;\n}, 0);\nconsole.log(result); // 55\n```\n\n세개의 인자를 전달 받았다. 첫번째 인자는 1부터 10까지를 담고 있는 배열이다. 이를 어떻게 처리할지 알고 있는 함수와 초기 값을 나머지 인자로 받았다. 예제에서 보조함수는 받은 값을 더하는 함수다. 결과적으로 `reduce`는 1부터 10까지의 총합을 반환한다. \n\n이를 구현한 코드는 아래와 같다.\n```javascript\nfunction reduce(list, iter, memo) {\n  var i = 0;\n  if (Array.isArray(list)) {\n    var res = (memo !== undefined ? memo : list[i++]); // <-- 남다른 결과값 선언부\n    for (var len = list.length; i < len; i++) \n      res = iter(res, list[i], i, list);\n  } else {\n    var keys = Object.keys(list), res = (memo !== undefined ? memo : list[keys[i++]]);\n    for (var len = keys.length; i < len; i++) \n      res = iter(res, list[keys[i]], keys[i], list);\n  }\n  return res;\n}\n```\n\n결과값 `res`를 선언하는 부분이 조금 남다르다. 앞선 `map`, `filter`가 배열을 리턴했던 것과 달리 `reduce`는 결과값의 데이터형이 호출 당시에 결정된다. 코드에서 `memo`에 해당하는 변수가 바로 초기값이다. 결과값은 초기값의 데이터형에 의해 정해지기 때문에 `res`를 선언하는 과정에서 `memo`가 데이터를 가지고 있는지를 검사한다. `undefined`인 경우 호출 당시 초기값이 전달되지 않은 것으로 판단하고 `list`의 첫번째 값을 초기값으로 사용한다. \n\n이후에 다른 함수들과 마찬가지로 반복문을 수행한다. 이때 보조함수 `iter`가 리턴하는 값을 결과값에 덮어씌운다. `list`의 마지막 값을 가지고 보조함수가 수행한 결과가 최종 결과값이 된다.\n\n\n#### 5. `go`\n`go` 함수는 파이프라인 코딩이 가능하도록 돕는 함수다. 클로저(Clojure)에서의 `->>` 연산자나 엘릭서(Elixir)에서의 `|>` 연산자와 같은 역할을 한다. 첫번째로 받은 인자(데이터)를 두번째로 받은 인자(함수)에 넘긴다. 두번째 함수가 리턴하는 값을 다시 세번째 인자(함수)로 넘긴다. 예시를 한번 더 살펴보자.\n\n```javascript\ngo([1,2,3,4,5,6,7,8,9,10],\n  arr => filter(arr, num => num % 2), // <-- 홀수 값만을 갖는 배열을 리턴한다.\n  arr => reduce(arr, (total, num) => total + num), // [1, 3, 5, 7, 9]을 더하여 리턴한다.\n  console.log); // 25\n```\n\n코드는 아래와 같이 구현되어 있다.\n```javascript\nvar slice = Array.prototype.slice;\nfunction go(seed) {\n  var fns = slice.call(arguments, 1);\n  return reduce(fns, (se, fn) => fn(se), seed);\n}\n```\n\n짧은 코드지만 재미난 구석이 많은 코드다. 살펴보자. 우선 `slice`를 사용해서 `arguments` 객체를 배열로 만들어준다. 첫번째 인자인 `seed`를 제외한 나머지들을 모두 `fns`라는 변수에 선언하는데 첫번째 인자를 제외한 모든 인자가 함수일 것이기 때문이다. 이제 이 함수들을 순서대로 실행시켜나가면 된다. 그런데 뜬금없이 `reduce`가 등장한다. 잠깐 생각해보자.\n\n`go`는 첫번째 인자로 들어온 __데이터를 여러 함수들에 통과시키며 리턴값을 만들어가는 함수__다. 데이터를 변형해서 무엇으로 만들어가는 함수는 이미 하나 있었다. 데이터를 접는 함수라고 소개했던 `reduce`가 그런 역할을 한다. __초기값의 데이터형__을 기준으로 __돌림직한 데이터__를 돌면서 데이터를 접어나간다. 우리는 이미 돌림직한 데이터인 `fns`(배열)와 초기값인 `seed`를 가지고 있다. 이제 필요한건 오직 __어떻게 접어나갈지 정의하는 함수__뿐이다. 그렇다. 이게 바로 `reduce`가 사용된 이유다. 이렇게 이미 정의된 함수 덕에 보다 쉽게 새로운 함수를 만들 수 있다. 이제 어떻게 접어나갈지 살펴보자.\n\n우리는 `fns`가 갖고 있는 함수들의 실행 결과가 필요하다. 이 작업을 단지 `(se, fn) => fn(se)`라고 정의함으로 해결할 수 있다. 이미 정의된 어떤 함수 덕분이다. 여기서 `se`는 처음에는 `seed`와 같은 값이었다가 이후에는 `fn`의 리턴값이 될 것이다. `fn`은 `reduce`의 내부에서 반복문으로 배열(`fns`)을 돌며 계속해서 다음 값을 넘겨서 받게 되는 함수다. \n\n\n### 문제 풀어보기\n끝으로 앞서 소개된 '함수형 실전 코드 예제'와 유사한 예제를 풀어보자. 데이터는 `products`라는 변수에 선언되어 있다. ('검사' 창에서 풀어볼 수 있다.) \n\n1. 모든 제품의 총 가격\n2. 선택된 제품의 총 가격 \n\n---\n\n### 전체 스터디 일정\n  - 1주차 - 기본 함수 구현하고 사용하기\n  - 2주차 - [고차 함수와 커링(currying)](/programming/functional-js-study-1/) \n  - 3주차 - [함수형 자바스크립트 라이브러리](/programming/functional-js-study-2/)\n  - 4주차 - Movie Box 1: 필터링, 정렬\n  - _5주차 - Movie Box 2: 필터링, 정렬 복습_\n  - _6주차 - Movie Box 3: 지연평가 L, memoize_\n  - _7주차 - Movie Box 4: 비동기 상황 다루기_\n\n[예제 코드](https://github.com/joeunha/functional-js-study/tree/master/01_week)\n\n<script src=\"/js/functional.js\"></script>\n<script async>\nvar products = [\n  {\n    is_selected: true, // <--- 장바구니에서 체크 박스 선택\n    name: \"반팔티\",\n    price: 10000, // <--- 기본 가격\n    sizes: [ // <---- 장바구니에 담은 동일 상품의 사이즈 별 수량과 가격\n      { name: \"L\", quantity: 2, price: 0 },\n      { name: \"XL\", quantity: 3, price: 0 },\n      { name: \"2XL\", quantity: 2, price: 2000 }, // <-- 옵션의 추가 가격\n    ]\n  },\n  {\n    is_selected: true,\n    name: \"후드티\",\n    price: 21000,\n    sizes: [\n      { name: \"L\", quantity: 3, price: -1000 },\n      { name: \"2XL\", quantity: 1, price: 2000 },\n    ]\n  },\n  {\n    is_selected: false,\n    name: \"맨투맨\",\n    price: 16000,\n    sizes: [\n      { name: \"L\", quantity: 4, price: 0 }\n    ]\n  }\n];\n\nif (location.pathname === '/2017/10/17/functional-js-study/')\n  console.log(`\n  [문제 풀어보기]\n    0. 데이터 변수 이름: products\n    1. 모든 제품의 총 가격\n    2. 선택된 제품의 총 가격 \n  `)\n</script>","slug":"functional-js-study-0","published":1,"updated":"2019-12-05T15:06:08.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9iu009kdirve2nt355g","content":"<h2 id=\"기본-함수-구현하고-사용하기\"><a href=\"#기본-함수-구현하고-사용하기\" class=\"headerlink\" title=\"기본 함수 구현하고 사용하기\"></a>기본 함수 구현하고 사용하기</h2><p>함수형 프로그래밍에서 사용되는 기본 함수인 <code>each</code>, <code>map</code>, <code>filter</code>, <code>reduce</code> 함수와 함수를 실행하는 함수인 <code>go</code> 함수를 사용해보고 직접 구현해보자.<br>(모든 예제는 웹 브라우저의 ‘검사’ 도구를 열어서 테스트할 수 있다.)</p>\n<h3 id=\"함수형-실전-코드-예제-소개\"><a href=\"#함수형-실전-코드-예제-소개\" class=\"headerlink\" title=\"함수형 실전 코드 예제 소개\"></a>함수형 실전 코드 예제 소개</h3><h4 id=\"0-예제-데이터\"><a href=\"#0-예제-데이터\" class=\"headerlink\" title=\"0. 예제 데이터\"></a>0. 예제 데이터</h4><p>이하 예제에서 사용될 데이터이다. <code>products</code>는 객체 형태의 상품 정보를 담고 있는 배열이다. 장바구니에 담긴 데이터라고 가정하고 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> products = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    is_selected: <span class=\"literal\">true</span>, <span class=\"comment\">// &lt;--- 장바구니에서 체크 박스 선택</span></span><br><span class=\"line\">    name: <span class=\"string\">\"반팔티\"</span>,</span><br><span class=\"line\">    price: <span class=\"number\">10000</span>, <span class=\"comment\">// &lt;--- 기본 가격</span></span><br><span class=\"line\">    sizes: [ <span class=\"comment\">// &lt;---- 장바구니에 담은 동일 상품의 사이즈 별 수량과 가격</span></span><br><span class=\"line\">      &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"L\"</span>, <span class=\"attr\">quantity</span>: <span class=\"number\">2</span>, <span class=\"attr\">price</span>: <span class=\"number\">0</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"XL\"</span>, <span class=\"attr\">quantity</span>: <span class=\"number\">3</span>, <span class=\"attr\">price</span>: <span class=\"number\">0</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"2XL\"</span>, <span class=\"attr\">quantity</span>: <span class=\"number\">2</span>, <span class=\"attr\">price</span>: <span class=\"number\">2000</span> &#125;, <span class=\"comment\">// &lt;-- 옵션의 추가 가격</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    is_selected: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    name: <span class=\"string\">\"후드티\"</span>,</span><br><span class=\"line\">    price: <span class=\"number\">21000</span>,</span><br><span class=\"line\">    sizes: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"L\"</span>, <span class=\"attr\">quantity</span>: <span class=\"number\">3</span>, <span class=\"attr\">price</span>: <span class=\"number\">-1000</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"2XL\"</span>, <span class=\"attr\">quantity</span>: <span class=\"number\">1</span>, <span class=\"attr\">price</span>: <span class=\"number\">2000</span> &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    is_selected: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    name: <span class=\"string\">\"맨투맨\"</span>,</span><br><span class=\"line\">    price: <span class=\"number\">16000</span>,</span><br><span class=\"line\">    sizes: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"L\"</span>, <span class=\"attr\">quantity</span>: <span class=\"number\">4</span>, <span class=\"attr\">price</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-모든-제품의-전체-수량-구하기\"><a href=\"#1-모든-제품의-전체-수량-구하기\" class=\"headerlink\" title=\"1. 모든 제품의 전체 수량 구하기\"></a>1. 모든 제품의 전체 수량 구하기</h4><p>제품의 전체 수량을 구하는 코드는 아래와 같이 작성할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum_total_quantity = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">products</span>) </span>&#123; <span class=\"comment\">// &lt;-- 제품의 전체 수량을 구하는 함수</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce(products, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tq, product</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reduce(product.sizes, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tq2, size</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> tq2 + size.quantity;</span><br><span class=\"line\">    &#125;, tq);</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> total_quantity = sum_total_quantity(products); <span class=\"comment\">// &lt;-- 예제 데이터를 넣으면 전체 수량을 구할 수 있다.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(total_quantity); <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n\n<p>코드를 살펴보자. 우선 코드에 등장하는 <code>reduce</code> 함수는 돌림직한 데이터(Array, ArrayLike, Object)를 ‘줄여나가는(reduce)’ 함수다. underscore와 같은 라이브러리에선 <code>fold</code>라는 이름으로도 사용된다. 이와 같은 표현을 사용하면 <code>reduce</code> 함수는 데이터를 ‘접는(fold)’ 함수인 셈이다. </p>\n<p>다시 위의 코드를 보면 가장 밖에 있는 함수가 <code>products</code>를 받을 준비를 하고 있다. 이 <code>products</code>는 <code>reduce</code>에게 전달된다. <code>reduce</code> 함수는 세개의 인사를 받는데, <strong>접을 데이터</strong>, <strong>어떻게 접을지 정의하는 함수</strong>, <strong>접을 때 사용할 초기값</strong>을 받는다. 여기서 <code>products</code>가 접을 데이터가 되고 두번째 함수가 어떻게 접을지를 정의하고 있다. 초기값으로는 <code>0</code>을 넘겼다. 그리고 넘겨진 값들로 인해 만들어진 결과를 리턴한다.</p>\n<p>이때 어떻게 접을지 정의한 두번째 인자인 함수를 보면 다시 <code>reduce</code>를 사용하고 있는 것을 알 수 있다. 같은 함수가 반복되니 헷갈린다. 하지만 데이터를 보면 그 이유가 드러난다. 우리가 원하는 값은 제품의 수량을 의미하는 <code>quantity</code>다. 그런데 값은 <code>sizes</code>라는 배열 안에 있기에 다시 한번 <code>reduce</code>를 호출한 것이다. 다시 말해 두번째로 호출되는 <code>reduce</code>는 <code>sizes</code> 배열 안의 값을 접어나가는 함수, 먼저 호출된 <code>reduce</code>는 두번째에 의해 접힌 결과를 한번 더 접는 함수인 것이다.</p>\n<p>두번째로 호출되는 <code>reduce</code>를 다시 살펴보면 앞서 말한 것처럼 <code>sizes</code> 배열을 접을 데이터로 전달한다. 그리고 초기값에 <code>tq</code>를 전달하는데 이때 <code>tq</code>는 첫번째 <code>reduce</code>가 전달한 <code>0</code>에 해당하는 값이다. 이 값은 <code>products</code> 배열을 돌면서 값이 계속 누적된다. 값이 쌓여가고 접혀가는 것이다. (이해가 되지 않는다면 우선 넘어간다.) 그리고 어떻게 접을지 정의한 함수에서 진짜 수량을 더한다. <code>tq2 + size.quantity</code> 이를 통해 값을 더해나가면 우리가 원하는 총 수량을 구할 수 있다.</p>\n<p>위의 과정을 통해 만들어진 함수가 실제로 동작하는 것은 호출이 일어났을 때다. <code>var total_quantity = sum_total_quantity(products);</code>처럼 코드를 실행하고 그 결과를 변수에 저장해서 다시 로그 함수에 넘길 수 있지만 선언된 <code>sum_total_quantity</code> 함수를 <code>go</code> 함수와 함께 사용하면 아래와 같은 코드가 된다. 별도의 변수 선언 없이 원하는 일을 할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go(products, </span><br><span class=\"line\">  sum_total_quantity, </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-선택된-제품의-전체-수량-구하기\"><a href=\"#2-선택된-제품의-전체-수량-구하기\" class=\"headerlink\" title=\"2. 선택된 제품의 전체 수량 구하기\"></a>2. 선택된 제품의 전체 수량 구하기</h4><p>선택된 제품들의 수량만을 구하는 코드는 아래와 같다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> selected_products = filter(products, product =&gt; product.is_selected); <span class=\"comment\">// &lt;-- 선택된 제품만 골라낸 데이터</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> selected_products_total_quantity = sum_total_quantity(selected_products);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(selected_product_total_quantity); <span class=\"comment\">// 11</span></span><br></pre></td></tr></table></figure>\n\n<p>비교적 간단한 코드다. <code>_filter</code> 함수를 이용해서 우리가 필요한 데이터를 골라내고 있다. 이 함수는 말 그대로 원하는 데이터만을 ‘거르는’ 함수다. 두번째 인자로 전달된 함수는 거를 기준을 제시한다. 리턴값이 참이면 그 값은 <code>_filter</code> 필요한 데이터라는 의미가 된다. 위의 코드에서는 선택된 데이터만을 골라내고 있다. </p>\n<p>마찬가지로 <code>go</code> 함수를 사용하면 아래와 같이 표현할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go(products,</span><br><span class=\"line\">  products =&gt; _filter(products, product =&gt; product.is_selected),</span><br><span class=\"line\">  sum_total_quantity,</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// 11</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"기본-함수-직접-구현하기\"><a href=\"#기본-함수-직접-구현하기\" class=\"headerlink\" title=\"기본 함수 직접 구현하기\"></a>기본 함수 직접 구현하기</h3><h4 id=\"1-each\"><a href=\"#1-each\" class=\"headerlink\" title=\"1. each\"></a>1. <code>each</code></h4><p><code>each</code> 함수는 <code>for</code>와 같은 반복문을 대체하는 함수다. 오늘 만들 다른 함수들과 마찬가지로 돌림직한 데이터를 돌면서 어떤 동작을 한다. 다른 함수들이 부수효과를 지양하는 것에 반해 이 함수는 부수효과를 이용한다. 인자로 <strong>돌림직한 데이터</strong>와 <strong>돌면서 무엇을 할지 정의한 함수</strong>를 받는다. </p>\n<p>사용의 예는 아래와 같다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">each([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>], num =&gt; <span class=\"built_in\">console</span>.log(num)); <span class=\"comment\">// &lt;-- 1부터 5까지 순서대로 로그가 남는다.</span></span><br></pre></td></tr></table></figure>\n\n<p>실제 함수는 아래와 같이 구현되어 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">each</span>(<span class=\"params\">list, iter</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(list)) &#123; <span class=\"comment\">// &lt;-- 배열을 돌리기 위한 부분</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = list.length; i &lt; len; i++) </span><br><span class=\"line\">      iter(list[i], i, list);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// &lt;-- 그 외의 객체를 돌리기 위한 부분</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> keys = <span class=\"built_in\">Object</span>.keys(list);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = keys.length; i &lt; len; i++) </span><br><span class=\"line\">      iter(list[keys[i]], keys[i], list);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>코드를 살펴보면 <code>for</code> 구문으로 데이터를 순회하며 <code>iter</code>라고 정의한 보조 함수를 한번씩 실행시켜주고 있다. 배열과 객체를 구분해서 값을 찾고 보조 함수에 전달하는데 보조 함수에 전달하는 값은 <strong>순서대로 찾은 값</strong>, <strong>그 값의 인덱스(키)</strong>, <strong>원본 배열(객체)</strong>이다. 이렇게 전달된 인자들을 이용해 <code>each</code> 함수를 보다 유연하게 사용할 수 있게 된다.</p>\n<h4 id=\"2-map\"><a href=\"#2-map\" class=\"headerlink\" title=\"2. map\"></a>2. <code>map</code></h4><p><code>map</code> 함수는 데이터를 돌면서 값을 매핑하고 새로운 배열을 리턴하는 함수다. 앞서 언급한 것처럼 부수효과를 지양한다. <code>each</code>와 마찬가지로 인자로 <strong>돌림직한 데이터</strong>와 <strong>돌면서 무엇을 할지 정의한 함수</strong>를 받는다. 차이점은 받은 함수가 새로운 배열의 값을 정의한다는 점이다.</p>\n<p>사용의 예는 아래와 같다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = map([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>], num =&gt; num + <span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [11, 12, 13, 14, 15]</span></span><br></pre></td></tr></table></figure>\n\n<p>실제 함수는 아래와 같이 구현되어 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">list, iter</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(list)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = list.length; i &lt; len; i++) </span><br><span class=\"line\">      res[i] = iter(list[i], i, list);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> keys = <span class=\"built_in\">Object</span>.keys(list);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = keys.length; i &lt; len; i++) </span><br><span class=\"line\">      res[i] = iter(list[keys[i]], keys[i], list);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>each</code> 함수와 다른 점은 <code>res</code>라는 결과값을 내부에서 정의하고 이를 반환한다는 것이다. 결과적으로 <code>map</code>은 보조함수에 의해 정의된 값을 담은 새로운 배열을 리턴한다. </p>\n<h4 id=\"3-filter\"><a href=\"#3-filter\" class=\"headerlink\" title=\"3. filter\"></a>3. <code>filter</code></h4><p>위에서 이미 살펴본 <code>filter</code> 함수는 데이터를 거르는 함수다. 사실 <code>each</code>를 제외한 모든 함수는 리턴값이 중요하다. 그 값을 전달함으로 다른 함수와 소통한다. </p>\n<p>사용의 예는 이미 위에서 살펴보았으니 구현체만 살펴보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filter</span>(<span class=\"params\">list, predi</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(list)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = list.length; i &lt; len; i++) </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (predi(list[i], i, list)) </span><br><span class=\"line\">        res.push(list[i]);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> keys = <span class=\"built_in\">Object</span>.keys(list);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = keys.length; i &lt; len; i++) </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (predi(list[keys[i]], keys[i], list)) </span><br><span class=\"line\">        res.push(list[keys[i]]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>map</code>처럼 결과값 <code>res</code>를 갖지만 보조함수(<code>predi</code>)가 리턴한 값이 아닌 보조함수의 실행 결과가 참인 경우에만 값을 결과값에 담는다.</p>\n<h4 id=\"4-reduce\"><a href=\"#4-reduce\" class=\"headerlink\" title=\"4. reduce\"></a>4. <code>reduce</code></h4><p>역시 이미 앞서 만나본 함수다. <code>reduce</code>는 데이터를 접는 함수다. 다른 함수들과 달리 세개의 인자를 값으로 받는다.</p>\n<p>미리 봤던 예제보다 단순한 예제를 살펴보고 구현으로 넘어가자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = reduce([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">memo, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> memo + num;</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// 55</span></span><br></pre></td></tr></table></figure>\n\n<p>세개의 인자를 전달 받았다. 첫번째 인자는 1부터 10까지를 담고 있는 배열이다. 이를 어떻게 처리할지 알고 있는 함수와 초기 값을 나머지 인자로 받았다. 예제에서 보조함수는 받은 값을 더하는 함수다. 결과적으로 <code>reduce</code>는 1부터 10까지의 총합을 반환한다. </p>\n<p>이를 구현한 코드는 아래와 같다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reduce</span>(<span class=\"params\">list, iter, memo</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(list)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = (memo !== <span class=\"literal\">undefined</span> ? memo : list[i++]); <span class=\"comment\">// &lt;-- 남다른 결과값 선언부</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> len = list.length; i &lt; len; i++) </span><br><span class=\"line\">      res = iter(res, list[i], i, list);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> keys = <span class=\"built_in\">Object</span>.keys(list), res = (memo !== <span class=\"literal\">undefined</span> ? memo : list[keys[i++]]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> len = keys.length; i &lt; len; i++) </span><br><span class=\"line\">      res = iter(res, list[keys[i]], keys[i], list);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>결과값 <code>res</code>를 선언하는 부분이 조금 남다르다. 앞선 <code>map</code>, <code>filter</code>가 배열을 리턴했던 것과 달리 <code>reduce</code>는 결과값의 데이터형이 호출 당시에 결정된다. 코드에서 <code>memo</code>에 해당하는 변수가 바로 초기값이다. 결과값은 초기값의 데이터형에 의해 정해지기 때문에 <code>res</code>를 선언하는 과정에서 <code>memo</code>가 데이터를 가지고 있는지를 검사한다. <code>undefined</code>인 경우 호출 당시 초기값이 전달되지 않은 것으로 판단하고 <code>list</code>의 첫번째 값을 초기값으로 사용한다. </p>\n<p>이후에 다른 함수들과 마찬가지로 반복문을 수행한다. 이때 보조함수 <code>iter</code>가 리턴하는 값을 결과값에 덮어씌운다. <code>list</code>의 마지막 값을 가지고 보조함수가 수행한 결과가 최종 결과값이 된다.</p>\n<h4 id=\"5-go\"><a href=\"#5-go\" class=\"headerlink\" title=\"5. go\"></a>5. <code>go</code></h4><p><code>go</code> 함수는 파이프라인 코딩이 가능하도록 돕는 함수다. 클로저(Clojure)에서의 <code>-&gt;&gt;</code> 연산자나 엘릭서(Elixir)에서의 <code>|&gt;</code> 연산자와 같은 역할을 한다. 첫번째로 받은 인자(데이터)를 두번째로 받은 인자(함수)에 넘긴다. 두번째 함수가 리턴하는 값을 다시 세번째 인자(함수)로 넘긴다. 예시를 한번 더 살펴보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>],</span><br><span class=\"line\">  arr =&gt; filter(arr, num =&gt; num % <span class=\"number\">2</span>), <span class=\"comment\">// &lt;-- 홀수 값만을 갖는 배열을 리턴한다.</span></span><br><span class=\"line\">  arr =&gt; reduce(arr, (total, num) =&gt; total + num), <span class=\"comment\">// [1, 3, 5, 7, 9]을 더하여 리턴한다.</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// 25</span></span><br></pre></td></tr></table></figure>\n\n<p>코드는 아래와 같이 구현되어 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> slice = <span class=\"built_in\">Array</span>.prototype.slice;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\">seed</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fns = slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce(fns, (se, fn) =&gt; fn(se), seed);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>짧은 코드지만 재미난 구석이 많은 코드다. 살펴보자. 우선 <code>slice</code>를 사용해서 <code>arguments</code> 객체를 배열로 만들어준다. 첫번째 인자인 <code>seed</code>를 제외한 나머지들을 모두 <code>fns</code>라는 변수에 선언하는데 첫번째 인자를 제외한 모든 인자가 함수일 것이기 때문이다. 이제 이 함수들을 순서대로 실행시켜나가면 된다. 그런데 뜬금없이 <code>reduce</code>가 등장한다. 잠깐 생각해보자.</p>\n<p><code>go</code>는 첫번째 인자로 들어온 <strong>데이터를 여러 함수들에 통과시키며 리턴값을 만들어가는 함수</strong>다. 데이터를 변형해서 무엇으로 만들어가는 함수는 이미 하나 있었다. 데이터를 접는 함수라고 소개했던 <code>reduce</code>가 그런 역할을 한다. <strong>초기값의 데이터형</strong>을 기준으로 <strong>돌림직한 데이터</strong>를 돌면서 데이터를 접어나간다. 우리는 이미 돌림직한 데이터인 <code>fns</code>(배열)와 초기값인 <code>seed</code>를 가지고 있다. 이제 필요한건 오직 <strong>어떻게 접어나갈지 정의하는 함수</strong>뿐이다. 그렇다. 이게 바로 <code>reduce</code>가 사용된 이유다. 이렇게 이미 정의된 함수 덕에 보다 쉽게 새로운 함수를 만들 수 있다. 이제 어떻게 접어나갈지 살펴보자.</p>\n<p>우리는 <code>fns</code>가 갖고 있는 함수들의 실행 결과가 필요하다. 이 작업을 단지 <code>(se, fn) =&gt; fn(se)</code>라고 정의함으로 해결할 수 있다. 이미 정의된 어떤 함수 덕분이다. 여기서 <code>se</code>는 처음에는 <code>seed</code>와 같은 값이었다가 이후에는 <code>fn</code>의 리턴값이 될 것이다. <code>fn</code>은 <code>reduce</code>의 내부에서 반복문으로 배열(<code>fns</code>)을 돌며 계속해서 다음 값을 넘겨서 받게 되는 함수다. </p>\n<h3 id=\"문제-풀어보기\"><a href=\"#문제-풀어보기\" class=\"headerlink\" title=\"문제 풀어보기\"></a>문제 풀어보기</h3><p>끝으로 앞서 소개된 ‘함수형 실전 코드 예제’와 유사한 예제를 풀어보자. 데이터는 <code>products</code>라는 변수에 선언되어 있다. (‘검사’ 창에서 풀어볼 수 있다.) </p>\n<ol>\n<li>모든 제품의 총 가격</li>\n<li>선택된 제품의 총 가격 </li>\n</ol>\n<hr>\n<h3 id=\"전체-스터디-일정\"><a href=\"#전체-스터디-일정\" class=\"headerlink\" title=\"전체 스터디 일정\"></a>전체 스터디 일정</h3><ul>\n<li>1주차 - 기본 함수 구현하고 사용하기</li>\n<li>2주차 - <a href=\"/programming/functional-js-study-1/\">고차 함수와 커링(currying)</a> </li>\n<li>3주차 - <a href=\"/programming/functional-js-study-2/\">함수형 자바스크립트 라이브러리</a></li>\n<li>4주차 - Movie Box 1: 필터링, 정렬</li>\n<li><em>5주차 - Movie Box 2: 필터링, 정렬 복습</em></li>\n<li><em>6주차 - Movie Box 3: 지연평가 L, memoize</em></li>\n<li><em>7주차 - Movie Box 4: 비동기 상황 다루기</em></li>\n</ul>\n<p><a href=\"https://github.com/joeunha/functional-js-study/tree/master/01_week\" target=\"_blank\" rel=\"noopener\">예제 코드</a></p>\n<script src=\"/js/functional.js\"></script>\n<script async>\nvar products = [\n  {\n    is_selected: true, // <--- 장바구니에서 체크 박스 선택\n    name: \"반팔티\",\n    price: 10000, // <--- 기본 가격\n    sizes: [ // <---- 장바구니에 담은 동일 상품의 사이즈 별 수량과 가격\n      { name: \"L\", quantity: 2, price: 0 },\n      { name: \"XL\", quantity: 3, price: 0 },\n      { name: \"2XL\", quantity: 2, price: 2000 }, // <-- 옵션의 추가 가격\n    ]\n  },\n  {\n    is_selected: true,\n    name: \"후드티\",\n    price: 21000,\n    sizes: [\n      { name: \"L\", quantity: 3, price: -1000 },\n      { name: \"2XL\", quantity: 1, price: 2000 },\n    ]\n  },\n  {\n    is_selected: false,\n    name: \"맨투맨\",\n    price: 16000,\n    sizes: [\n      { name: \"L\", quantity: 4, price: 0 }\n    ]\n  }\n];\n\nif (location.pathname === '/2017/10/17/functional-js-study/')\n  console.log(`\n  [문제 풀어보기]\n    0. 데이터 변수 이름: products\n    1. 모든 제품의 총 가격\n    2. 선택된 제품의 총 가격 \n  `)\n</script>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"기본-함수-구현하고-사용하기\"><a href=\"#기본-함수-구현하고-사용하기\" class=\"headerlink\" title=\"기본 함수 구현하고 사용하기\"></a>기본 함수 구현하고 사용하기</h2><p>함수형 프로그래밍에서 사용되는 기본 함수인 <code>each</code>, <code>map</code>, <code>filter</code>, <code>reduce</code> 함수와 함수를 실행하는 함수인 <code>go</code> 함수를 사용해보고 직접 구현해보자.<br>(모든 예제는 웹 브라우저의 ‘검사’ 도구를 열어서 테스트할 수 있다.)</p>\n<h3 id=\"함수형-실전-코드-예제-소개\"><a href=\"#함수형-실전-코드-예제-소개\" class=\"headerlink\" title=\"함수형 실전 코드 예제 소개\"></a>함수형 실전 코드 예제 소개</h3><h4 id=\"0-예제-데이터\"><a href=\"#0-예제-데이터\" class=\"headerlink\" title=\"0. 예제 데이터\"></a>0. 예제 데이터</h4><p>이하 예제에서 사용될 데이터이다. <code>products</code>는 객체 형태의 상품 정보를 담고 있는 배열이다. 장바구니에 담긴 데이터라고 가정하고 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> products = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    is_selected: <span class=\"literal\">true</span>, <span class=\"comment\">// &lt;--- 장바구니에서 체크 박스 선택</span></span><br><span class=\"line\">    name: <span class=\"string\">\"반팔티\"</span>,</span><br><span class=\"line\">    price: <span class=\"number\">10000</span>, <span class=\"comment\">// &lt;--- 기본 가격</span></span><br><span class=\"line\">    sizes: [ <span class=\"comment\">// &lt;---- 장바구니에 담은 동일 상품의 사이즈 별 수량과 가격</span></span><br><span class=\"line\">      &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"L\"</span>, <span class=\"attr\">quantity</span>: <span class=\"number\">2</span>, <span class=\"attr\">price</span>: <span class=\"number\">0</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"XL\"</span>, <span class=\"attr\">quantity</span>: <span class=\"number\">3</span>, <span class=\"attr\">price</span>: <span class=\"number\">0</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"2XL\"</span>, <span class=\"attr\">quantity</span>: <span class=\"number\">2</span>, <span class=\"attr\">price</span>: <span class=\"number\">2000</span> &#125;, <span class=\"comment\">// &lt;-- 옵션의 추가 가격</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    is_selected: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    name: <span class=\"string\">\"후드티\"</span>,</span><br><span class=\"line\">    price: <span class=\"number\">21000</span>,</span><br><span class=\"line\">    sizes: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"L\"</span>, <span class=\"attr\">quantity</span>: <span class=\"number\">3</span>, <span class=\"attr\">price</span>: <span class=\"number\">-1000</span> &#125;,</span><br><span class=\"line\">      &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"2XL\"</span>, <span class=\"attr\">quantity</span>: <span class=\"number\">1</span>, <span class=\"attr\">price</span>: <span class=\"number\">2000</span> &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    is_selected: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    name: <span class=\"string\">\"맨투맨\"</span>,</span><br><span class=\"line\">    price: <span class=\"number\">16000</span>,</span><br><span class=\"line\">    sizes: [</span><br><span class=\"line\">      &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"L\"</span>, <span class=\"attr\">quantity</span>: <span class=\"number\">4</span>, <span class=\"attr\">price</span>: <span class=\"number\">0</span> &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-모든-제품의-전체-수량-구하기\"><a href=\"#1-모든-제품의-전체-수량-구하기\" class=\"headerlink\" title=\"1. 모든 제품의 전체 수량 구하기\"></a>1. 모든 제품의 전체 수량 구하기</h4><p>제품의 전체 수량을 구하는 코드는 아래와 같이 작성할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum_total_quantity = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">products</span>) </span>&#123; <span class=\"comment\">// &lt;-- 제품의 전체 수량을 구하는 함수</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce(products, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tq, product</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reduce(product.sizes, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tq2, size</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> tq2 + size.quantity;</span><br><span class=\"line\">    &#125;, tq);</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> total_quantity = sum_total_quantity(products); <span class=\"comment\">// &lt;-- 예제 데이터를 넣으면 전체 수량을 구할 수 있다.</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(total_quantity); <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n\n<p>코드를 살펴보자. 우선 코드에 등장하는 <code>reduce</code> 함수는 돌림직한 데이터(Array, ArrayLike, Object)를 ‘줄여나가는(reduce)’ 함수다. underscore와 같은 라이브러리에선 <code>fold</code>라는 이름으로도 사용된다. 이와 같은 표현을 사용하면 <code>reduce</code> 함수는 데이터를 ‘접는(fold)’ 함수인 셈이다. </p>\n<p>다시 위의 코드를 보면 가장 밖에 있는 함수가 <code>products</code>를 받을 준비를 하고 있다. 이 <code>products</code>는 <code>reduce</code>에게 전달된다. <code>reduce</code> 함수는 세개의 인사를 받는데, <strong>접을 데이터</strong>, <strong>어떻게 접을지 정의하는 함수</strong>, <strong>접을 때 사용할 초기값</strong>을 받는다. 여기서 <code>products</code>가 접을 데이터가 되고 두번째 함수가 어떻게 접을지를 정의하고 있다. 초기값으로는 <code>0</code>을 넘겼다. 그리고 넘겨진 값들로 인해 만들어진 결과를 리턴한다.</p>\n<p>이때 어떻게 접을지 정의한 두번째 인자인 함수를 보면 다시 <code>reduce</code>를 사용하고 있는 것을 알 수 있다. 같은 함수가 반복되니 헷갈린다. 하지만 데이터를 보면 그 이유가 드러난다. 우리가 원하는 값은 제품의 수량을 의미하는 <code>quantity</code>다. 그런데 값은 <code>sizes</code>라는 배열 안에 있기에 다시 한번 <code>reduce</code>를 호출한 것이다. 다시 말해 두번째로 호출되는 <code>reduce</code>는 <code>sizes</code> 배열 안의 값을 접어나가는 함수, 먼저 호출된 <code>reduce</code>는 두번째에 의해 접힌 결과를 한번 더 접는 함수인 것이다.</p>\n<p>두번째로 호출되는 <code>reduce</code>를 다시 살펴보면 앞서 말한 것처럼 <code>sizes</code> 배열을 접을 데이터로 전달한다. 그리고 초기값에 <code>tq</code>를 전달하는데 이때 <code>tq</code>는 첫번째 <code>reduce</code>가 전달한 <code>0</code>에 해당하는 값이다. 이 값은 <code>products</code> 배열을 돌면서 값이 계속 누적된다. 값이 쌓여가고 접혀가는 것이다. (이해가 되지 않는다면 우선 넘어간다.) 그리고 어떻게 접을지 정의한 함수에서 진짜 수량을 더한다. <code>tq2 + size.quantity</code> 이를 통해 값을 더해나가면 우리가 원하는 총 수량을 구할 수 있다.</p>\n<p>위의 과정을 통해 만들어진 함수가 실제로 동작하는 것은 호출이 일어났을 때다. <code>var total_quantity = sum_total_quantity(products);</code>처럼 코드를 실행하고 그 결과를 변수에 저장해서 다시 로그 함수에 넘길 수 있지만 선언된 <code>sum_total_quantity</code> 함수를 <code>go</code> 함수와 함께 사용하면 아래와 같은 코드가 된다. 별도의 변수 선언 없이 원하는 일을 할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go(products, </span><br><span class=\"line\">  sum_total_quantity, </span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-선택된-제품의-전체-수량-구하기\"><a href=\"#2-선택된-제품의-전체-수량-구하기\" class=\"headerlink\" title=\"2. 선택된 제품의 전체 수량 구하기\"></a>2. 선택된 제품의 전체 수량 구하기</h4><p>선택된 제품들의 수량만을 구하는 코드는 아래와 같다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> selected_products = filter(products, product =&gt; product.is_selected); <span class=\"comment\">// &lt;-- 선택된 제품만 골라낸 데이터</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> selected_products_total_quantity = sum_total_quantity(selected_products);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(selected_product_total_quantity); <span class=\"comment\">// 11</span></span><br></pre></td></tr></table></figure>\n\n<p>비교적 간단한 코드다. <code>_filter</code> 함수를 이용해서 우리가 필요한 데이터를 골라내고 있다. 이 함수는 말 그대로 원하는 데이터만을 ‘거르는’ 함수다. 두번째 인자로 전달된 함수는 거를 기준을 제시한다. 리턴값이 참이면 그 값은 <code>_filter</code> 필요한 데이터라는 의미가 된다. 위의 코드에서는 선택된 데이터만을 골라내고 있다. </p>\n<p>마찬가지로 <code>go</code> 함수를 사용하면 아래와 같이 표현할 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go(products,</span><br><span class=\"line\">  products =&gt; _filter(products, product =&gt; product.is_selected),</span><br><span class=\"line\">  sum_total_quantity,</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// 11</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"기본-함수-직접-구현하기\"><a href=\"#기본-함수-직접-구현하기\" class=\"headerlink\" title=\"기본 함수 직접 구현하기\"></a>기본 함수 직접 구현하기</h3><h4 id=\"1-each\"><a href=\"#1-each\" class=\"headerlink\" title=\"1. each\"></a>1. <code>each</code></h4><p><code>each</code> 함수는 <code>for</code>와 같은 반복문을 대체하는 함수다. 오늘 만들 다른 함수들과 마찬가지로 돌림직한 데이터를 돌면서 어떤 동작을 한다. 다른 함수들이 부수효과를 지양하는 것에 반해 이 함수는 부수효과를 이용한다. 인자로 <strong>돌림직한 데이터</strong>와 <strong>돌면서 무엇을 할지 정의한 함수</strong>를 받는다. </p>\n<p>사용의 예는 아래와 같다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">each([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>], num =&gt; <span class=\"built_in\">console</span>.log(num)); <span class=\"comment\">// &lt;-- 1부터 5까지 순서대로 로그가 남는다.</span></span><br></pre></td></tr></table></figure>\n\n<p>실제 함수는 아래와 같이 구현되어 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">each</span>(<span class=\"params\">list, iter</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(list)) &#123; <span class=\"comment\">// &lt;-- 배열을 돌리기 위한 부분</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = list.length; i &lt; len; i++) </span><br><span class=\"line\">      iter(list[i], i, list);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// &lt;-- 그 외의 객체를 돌리기 위한 부분</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> keys = <span class=\"built_in\">Object</span>.keys(list);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = keys.length; i &lt; len; i++) </span><br><span class=\"line\">      iter(list[keys[i]], keys[i], list);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>코드를 살펴보면 <code>for</code> 구문으로 데이터를 순회하며 <code>iter</code>라고 정의한 보조 함수를 한번씩 실행시켜주고 있다. 배열과 객체를 구분해서 값을 찾고 보조 함수에 전달하는데 보조 함수에 전달하는 값은 <strong>순서대로 찾은 값</strong>, <strong>그 값의 인덱스(키)</strong>, <strong>원본 배열(객체)</strong>이다. 이렇게 전달된 인자들을 이용해 <code>each</code> 함수를 보다 유연하게 사용할 수 있게 된다.</p>\n<h4 id=\"2-map\"><a href=\"#2-map\" class=\"headerlink\" title=\"2. map\"></a>2. <code>map</code></h4><p><code>map</code> 함수는 데이터를 돌면서 값을 매핑하고 새로운 배열을 리턴하는 함수다. 앞서 언급한 것처럼 부수효과를 지양한다. <code>each</code>와 마찬가지로 인자로 <strong>돌림직한 데이터</strong>와 <strong>돌면서 무엇을 할지 정의한 함수</strong>를 받는다. 차이점은 받은 함수가 새로운 배열의 값을 정의한다는 점이다.</p>\n<p>사용의 예는 아래와 같다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = map([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>], num =&gt; num + <span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// [11, 12, 13, 14, 15]</span></span><br></pre></td></tr></table></figure>\n\n<p>실제 함수는 아래와 같이 구현되어 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">list, iter</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(list)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = list.length; i &lt; len; i++) </span><br><span class=\"line\">      res[i] = iter(list[i], i, list);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> keys = <span class=\"built_in\">Object</span>.keys(list);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = keys.length; i &lt; len; i++) </span><br><span class=\"line\">      res[i] = iter(list[keys[i]], keys[i], list);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>each</code> 함수와 다른 점은 <code>res</code>라는 결과값을 내부에서 정의하고 이를 반환한다는 것이다. 결과적으로 <code>map</code>은 보조함수에 의해 정의된 값을 담은 새로운 배열을 리턴한다. </p>\n<h4 id=\"3-filter\"><a href=\"#3-filter\" class=\"headerlink\" title=\"3. filter\"></a>3. <code>filter</code></h4><p>위에서 이미 살펴본 <code>filter</code> 함수는 데이터를 거르는 함수다. 사실 <code>each</code>를 제외한 모든 함수는 리턴값이 중요하다. 그 값을 전달함으로 다른 함수와 소통한다. </p>\n<p>사용의 예는 이미 위에서 살펴보았으니 구현체만 살펴보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filter</span>(<span class=\"params\">list, predi</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(list)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = list.length; i &lt; len; i++) </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (predi(list[i], i, list)) </span><br><span class=\"line\">        res.push(list[i]);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> keys = <span class=\"built_in\">Object</span>.keys(list);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = keys.length; i &lt; len; i++) </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (predi(list[keys[i]], keys[i], list)) </span><br><span class=\"line\">        res.push(list[keys[i]]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>map</code>처럼 결과값 <code>res</code>를 갖지만 보조함수(<code>predi</code>)가 리턴한 값이 아닌 보조함수의 실행 결과가 참인 경우에만 값을 결과값에 담는다.</p>\n<h4 id=\"4-reduce\"><a href=\"#4-reduce\" class=\"headerlink\" title=\"4. reduce\"></a>4. <code>reduce</code></h4><p>역시 이미 앞서 만나본 함수다. <code>reduce</code>는 데이터를 접는 함수다. 다른 함수들과 달리 세개의 인자를 값으로 받는다.</p>\n<p>미리 봤던 예제보다 단순한 예제를 살펴보고 구현으로 넘어가자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = reduce([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">memo, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> memo + num;</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result); <span class=\"comment\">// 55</span></span><br></pre></td></tr></table></figure>\n\n<p>세개의 인자를 전달 받았다. 첫번째 인자는 1부터 10까지를 담고 있는 배열이다. 이를 어떻게 처리할지 알고 있는 함수와 초기 값을 나머지 인자로 받았다. 예제에서 보조함수는 받은 값을 더하는 함수다. 결과적으로 <code>reduce</code>는 1부터 10까지의 총합을 반환한다. </p>\n<p>이를 구현한 코드는 아래와 같다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reduce</span>(<span class=\"params\">list, iter, memo</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(list)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = (memo !== <span class=\"literal\">undefined</span> ? memo : list[i++]); <span class=\"comment\">// &lt;-- 남다른 결과값 선언부</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> len = list.length; i &lt; len; i++) </span><br><span class=\"line\">      res = iter(res, list[i], i, list);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> keys = <span class=\"built_in\">Object</span>.keys(list), res = (memo !== <span class=\"literal\">undefined</span> ? memo : list[keys[i++]]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> len = keys.length; i &lt; len; i++) </span><br><span class=\"line\">      res = iter(res, list[keys[i]], keys[i], list);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>결과값 <code>res</code>를 선언하는 부분이 조금 남다르다. 앞선 <code>map</code>, <code>filter</code>가 배열을 리턴했던 것과 달리 <code>reduce</code>는 결과값의 데이터형이 호출 당시에 결정된다. 코드에서 <code>memo</code>에 해당하는 변수가 바로 초기값이다. 결과값은 초기값의 데이터형에 의해 정해지기 때문에 <code>res</code>를 선언하는 과정에서 <code>memo</code>가 데이터를 가지고 있는지를 검사한다. <code>undefined</code>인 경우 호출 당시 초기값이 전달되지 않은 것으로 판단하고 <code>list</code>의 첫번째 값을 초기값으로 사용한다. </p>\n<p>이후에 다른 함수들과 마찬가지로 반복문을 수행한다. 이때 보조함수 <code>iter</code>가 리턴하는 값을 결과값에 덮어씌운다. <code>list</code>의 마지막 값을 가지고 보조함수가 수행한 결과가 최종 결과값이 된다.</p>\n<h4 id=\"5-go\"><a href=\"#5-go\" class=\"headerlink\" title=\"5. go\"></a>5. <code>go</code></h4><p><code>go</code> 함수는 파이프라인 코딩이 가능하도록 돕는 함수다. 클로저(Clojure)에서의 <code>-&gt;&gt;</code> 연산자나 엘릭서(Elixir)에서의 <code>|&gt;</code> 연산자와 같은 역할을 한다. 첫번째로 받은 인자(데이터)를 두번째로 받은 인자(함수)에 넘긴다. 두번째 함수가 리턴하는 값을 다시 세번째 인자(함수)로 넘긴다. 예시를 한번 더 살펴보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>],</span><br><span class=\"line\">  arr =&gt; filter(arr, num =&gt; num % <span class=\"number\">2</span>), <span class=\"comment\">// &lt;-- 홀수 값만을 갖는 배열을 리턴한다.</span></span><br><span class=\"line\">  arr =&gt; reduce(arr, (total, num) =&gt; total + num), <span class=\"comment\">// [1, 3, 5, 7, 9]을 더하여 리턴한다.</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// 25</span></span><br></pre></td></tr></table></figure>\n\n<p>코드는 아래와 같이 구현되어 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> slice = <span class=\"built_in\">Array</span>.prototype.slice;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">go</span>(<span class=\"params\">seed</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fns = slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce(fns, (se, fn) =&gt; fn(se), seed);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>짧은 코드지만 재미난 구석이 많은 코드다. 살펴보자. 우선 <code>slice</code>를 사용해서 <code>arguments</code> 객체를 배열로 만들어준다. 첫번째 인자인 <code>seed</code>를 제외한 나머지들을 모두 <code>fns</code>라는 변수에 선언하는데 첫번째 인자를 제외한 모든 인자가 함수일 것이기 때문이다. 이제 이 함수들을 순서대로 실행시켜나가면 된다. 그런데 뜬금없이 <code>reduce</code>가 등장한다. 잠깐 생각해보자.</p>\n<p><code>go</code>는 첫번째 인자로 들어온 <strong>데이터를 여러 함수들에 통과시키며 리턴값을 만들어가는 함수</strong>다. 데이터를 변형해서 무엇으로 만들어가는 함수는 이미 하나 있었다. 데이터를 접는 함수라고 소개했던 <code>reduce</code>가 그런 역할을 한다. <strong>초기값의 데이터형</strong>을 기준으로 <strong>돌림직한 데이터</strong>를 돌면서 데이터를 접어나간다. 우리는 이미 돌림직한 데이터인 <code>fns</code>(배열)와 초기값인 <code>seed</code>를 가지고 있다. 이제 필요한건 오직 <strong>어떻게 접어나갈지 정의하는 함수</strong>뿐이다. 그렇다. 이게 바로 <code>reduce</code>가 사용된 이유다. 이렇게 이미 정의된 함수 덕에 보다 쉽게 새로운 함수를 만들 수 있다. 이제 어떻게 접어나갈지 살펴보자.</p>\n<p>우리는 <code>fns</code>가 갖고 있는 함수들의 실행 결과가 필요하다. 이 작업을 단지 <code>(se, fn) =&gt; fn(se)</code>라고 정의함으로 해결할 수 있다. 이미 정의된 어떤 함수 덕분이다. 여기서 <code>se</code>는 처음에는 <code>seed</code>와 같은 값이었다가 이후에는 <code>fn</code>의 리턴값이 될 것이다. <code>fn</code>은 <code>reduce</code>의 내부에서 반복문으로 배열(<code>fns</code>)을 돌며 계속해서 다음 값을 넘겨서 받게 되는 함수다. </p>\n<h3 id=\"문제-풀어보기\"><a href=\"#문제-풀어보기\" class=\"headerlink\" title=\"문제 풀어보기\"></a>문제 풀어보기</h3><p>끝으로 앞서 소개된 ‘함수형 실전 코드 예제’와 유사한 예제를 풀어보자. 데이터는 <code>products</code>라는 변수에 선언되어 있다. (‘검사’ 창에서 풀어볼 수 있다.) </p>\n<ol>\n<li>모든 제품의 총 가격</li>\n<li>선택된 제품의 총 가격 </li>\n</ol>\n<hr>\n<h3 id=\"전체-스터디-일정\"><a href=\"#전체-스터디-일정\" class=\"headerlink\" title=\"전체 스터디 일정\"></a>전체 스터디 일정</h3><ul>\n<li>1주차 - 기본 함수 구현하고 사용하기</li>\n<li>2주차 - <a href=\"/programming/functional-js-study-1/\">고차 함수와 커링(currying)</a> </li>\n<li>3주차 - <a href=\"/programming/functional-js-study-2/\">함수형 자바스크립트 라이브러리</a></li>\n<li>4주차 - Movie Box 1: 필터링, 정렬</li>\n<li><em>5주차 - Movie Box 2: 필터링, 정렬 복습</em></li>\n<li><em>6주차 - Movie Box 3: 지연평가 L, memoize</em></li>\n<li><em>7주차 - Movie Box 4: 비동기 상황 다루기</em></li>\n</ul>\n<p><a href=\"https://github.com/joeunha/functional-js-study/tree/master/01_week\" target=\"_blank\" rel=\"noopener\">예제 코드</a></p>\n<script src=\"/js/functional.js\"></script>\n<script async>\nvar products = [\n  {\n    is_selected: true, // <--- 장바구니에서 체크 박스 선택\n    name: \"반팔티\",\n    price: 10000, // <--- 기본 가격\n    sizes: [ // <---- 장바구니에 담은 동일 상품의 사이즈 별 수량과 가격\n      { name: \"L\", quantity: 2, price: 0 },\n      { name: \"XL\", quantity: 3, price: 0 },\n      { name: \"2XL\", quantity: 2, price: 2000 }, // <-- 옵션의 추가 가격\n    ]\n  },\n  {\n    is_selected: true,\n    name: \"후드티\",\n    price: 21000,\n    sizes: [\n      { name: \"L\", quantity: 3, price: -1000 },\n      { name: \"2XL\", quantity: 1, price: 2000 },\n    ]\n  },\n  {\n    is_selected: false,\n    name: \"맨투맨\",\n    price: 16000,\n    sizes: [\n      { name: \"L\", quantity: 4, price: 0 }\n    ]\n  }\n];\n\nif (location.pathname === '/2017/10/17/functional-js-study/')\n  console.log(`\n  [문제 풀어보기]\n    0. 데이터 변수 이름: products\n    1. 모든 제품의 총 가격\n    2. 선택된 제품의 총 가격 \n  `)\n</script>"},{"title":"나와 같다면 - 직장이 아니라 직업","date":"2017-04-05T14:11:26.000Z","_content":"##### '나와 같다면' 시리즈 소개\n  _'그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼'_ 김연우씨가 불러서 더 유명한 노래 '나와 같다면'에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.\n\n* * *\n\n## 직장이 아니라 직업\n\n### 나의 선택\n나는 직장이 아닌 직업을 선택했다. 개발자라는 직업을 선택했다. 그리고 특정 직장(기업)이 아닌 업계를 선택했다. IT업계와 스타트업계가 그것이다. 나는 개발자로서 IT 업계에 종사하는 사람이다. 스타트업에 일하는 사람으로서 스타트업계에 종사하는 사람이다. 대학 졸업은 앞둔 나는 개발이 하고 싶었다. 잘 하는 편은 아니었지만 그래도 뭔가 새로운 서비스를 만드는 일이 하고 싶었다. 내가 작성한 코드로 돌아가는 서비스를 만들었들 때 그 서비스를 이용하는 유저들의 반응이 궁금했다. 나는 개발자가 되고 싶었고, 개발자라는 직업을 선택했다. 사회생활의 시작을 준비하면서 이 길을 선택했다.\n\n\n### 새로운 시대\n우리 세대는 이제 직장이 아니라 직업을 선택해야 한다. 더 이상 평생직장은 없다. 평생 나를 먹여 살려줄 회사는 없다. 이름만 들으면 다 아는 대기업이라면 안정적인 공기업이라면 다르지 않을까. 한동안 돈은 많이 벌 수 있을지 모르겠다. 하지만 오래 가진 않을 것이다. 새로운 시대가 오고 있다. 바로 4차 산업의 시대다.\n정치권에서도 4차 산업 시대를 운운한다. 어떤 시대가 될지 정확히 알 수 없지만 한 가지 확실한 것은 지금과 일의 개념이 많이 달라질 것이라는 점이다. 기업은 더 이상 반복적으로 누구나 할 수 있는 일을 사람에게 맡기지 않을 것이다. 이윤을 추구하는 기업의 특성상 그러한 일을 사람에게 맡기는 건 비효율적이기 때문이다. 그렇다면 직장이 아니라 직업을 선택하면 안전하단 말인가? 사실 또 그렇다고 말하긴 좀 어렵지만 그래도 직장을 선택하는 것보다는 낫다. 직장을 선택하는 것과 직업을 선택하는 것의 차이는 주도성에 있기 때문이다.\n\n\n### 주도성과 창의력\n직업을 선택하는 행위는 직장을 선택하는 행위보다 내가 어떤 일을 할 것인지 선택할 수 있는 주도성 혹은 주체성이라고 할 수 있는 어떤 자주적인 선택 능력이 더 필요하다. 직장은 다양한 일을 하는 사람, 팀 혹은 집단의 집합인데 직장을 선택한다는 것은 이러한 집합을 선택한다는 의미이다. 특정 직장에 들어가길 원한다는 것은 그들이 하는 일 중 어떤 것이 자신에게 맡겨지더라도 무관하다고 말하는 것과 같다. 결국 자신이 어떤 일을 할지에 대해서는 선택을 포기한 것이다. 반면 직업은 어떤 일 자체를 의미한다. 직업을 선택한다는 것은 그 일을 선택한다는 것을 의미한다. 전자의 선택보다 훨씬 주체적이고 구체적인 선택을 하는 것이다.\n직장과 직업을 선택하는 차이가 주도성에 있는데, 그 주도성이 왜 중요하고 좋은 것이냐고 묻는다면 다시 4차 산업 시대를 이야기로 돌아가야 한다. 반복되는 작업은 기계와 소프트웨어가 대신하는 시대가 올 것이다. 그 시대에서 살아남는 방법은 이전과는 다른 선택을 하는 것이다. 기계가 따라 할 수 없는 선택을 하는 것이다. 기계가 아직 학습하지 못한 형태의 선택을 하는 것이다. 개인적으로는 이러한 형태의, 이전과는 다른 선택을 할 수 있는 능력이 창의력이라고 생각한다. 새로운 방식을 선택하는 능력, 새로운 방법을 선택하는 능력이 창의력이다. 창의력은 주도적으로 선택한 일에서 나온다. 주도적으로 일을 선택한 사람만이 일을 창의적으로 해결하려고 노력할 것이다. 무슨 일을 해야 하는지 선택할 수도 없는 직장에 간다면 우리는 주도성을 잃어갈 것이고 이는 선택하는 능력, 창의력을 잃어가는 것을 의미한다. 이미 우리는 학교 생활을 통해서 창의력을 잃었다고 말한다면 이렇게 말하고 싶다. 그러니까 더 이상 창의력을 잃어서는 안 된다. 주도성으로부터 나오는 창의력만이 새로운 시대에서 우리를 살아남게 할 것이기 때문이다.\n\n\n### 업계(業界)\n같은 일을 하는 사람들의 세계, 업계. 직업을 선택한다는 것은 업계를 선택하는 것이다. 업계는 직장보다 더 넓은 세계다. 이곳은 더 자유롭다. 그리고 더 안전하다.\n업계가 직장보다 더 넓은 세계라는 점은 굳이 설명할 필요가 없다. 직장은 특정 집단의 이윤을 추구하는 곳이지만 업계는 같은 유형의 일을 하는 사람들의 집합이다. 다양한 기업에 일하는 사람들의 총합에서 같은 유형의 일을 하는 사람을 모아둔 것이다. 훨씬 많은 사람이 있으며 다양한 국가의 사람이 존재할 수 있다. 또한 넓은 장소일수록 활동 반경이 넓어지고 자유로워지는 것처럼 이처럼 넓은 세계에서는 더욱 자유로울 수 있다. 일례로 이직에 관한 사례들을 들어봐도 그렇다. 듣자 하니 실리콘밸리에서는 능력이 된다면 더 자주 이직한다고 한다. 1년에 한 번씩 이직하더라도 그것을 능력이라고 생각한다고 한다. (이직과 함께 연봉도 오른다고 한다.) 심지어는 이처럼 능력 있는 이직꾼(?)들은 특정 회사에 소속되려 하지 않는다. 극단적인 자유를 누리면서 일한다. 바로 디지털 노마드다. 컴퓨터가 있고 인터넷이 된다면 어디서든 일한다. 이 같은 일이 가능한 것은 그들이 직업을 선택했기 때문이다.\n\n자유롭지만 또한 안전한 이유는 무엇일까. 직장이 아닌 직업을 선택하기에 가장 두려운 부분이 바로 불안정에 대한 두려움 때문일 것이다. 남들이 알아주는 안정적인 직장을 선택하면 때론 일이 고달프더라도 그리고 내가 무슨 일을 하는지 잘 모르더라도 안정적으로 월급을 받을 수 있으니 그걸로 족하다는 생각을 할 것이다. 사실은 그렇지 않다. 물론 모든 경우가 그렇지 않다고 단정 지을 수 없는 부분이 있다. 하지만 앞서 말한 것처럼 새로운 시대에 우리는 어느 누구도 안정적인 직장을 가질 수 없다. 우리는 그나마 안정적인 직업을 가질 수 있을 뿐이다. 업계에 들어오는 것이 보다 안정적이고 안전한 이유는 그 세계가 넓기 때문이다. 이건 또 무슨 도돌이표 같은 소리인가. 잘 생각해보자. 더 넓은 세계에서는 또 다른 장소로의 이동이 자유롭다. 자유롭다는 것은 제약이 적다는 것이다. 이동(이직)의 장벽이 낮다는 것이다. 바로 이 지점이다. 평생직장이 없기에 우리는 잦은 이직을 경험해야 하고 또한 선택해야 한다. 그렇기 때문에 우리는 넓은 세계, 이동이 용이한 세계에 들어가야 한다. 그것이 보다 안정적인 삶을 영위할 수 있는 방법이다.\n\n\n### 고통의 길\n사실 직업을 선택하는 것은 고통의 길이다. 앞서 말한 창의력으로 새로운 시대에서 살아남는 것과 이직의 자유로움을 얻기 위해선 고통이 따른다. 단순히 직장이 아닌 직업을 선택했다고 곧장 주어지는 선물이 아니다. 업계에서 쓰일만한 능력을 갖추기 위해 계속 공부하고 발전해야 한다. 그 모든 과정이 재미있고 보람찰 때도 있겠지만 때론 상당히 고통스러울 것이다. 그렇지만 우리가 직업을 선택하지 않는다면 이러한 고통도 없이 애써볼 시간도 없이 막다른 길에 이르게 될 것이다.\n\n\n### 나와 같다면\n사회라는 새로운 세상으로 들어서는 길, 그 길은 갈림길이다.\n남들이 부러워하는 안정적인 직장인의 길과 불안정하고 인정받지 못하는 것처럼 보이는 직업인의 길이다. 어떤 길을 선택할 것인가.","source":"_posts/like-me-1.md","raw":"---\ntitle: '나와 같다면 - 직장이 아니라 직업'\ncategories:\n  - view of value\ntags:\n  - opinion\n  - 나와 같다면\ndate: 2017-04-05 23:11:26\n---\n##### '나와 같다면' 시리즈 소개\n  _'그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼'_ 김연우씨가 불러서 더 유명한 노래 '나와 같다면'에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.\n\n* * *\n\n## 직장이 아니라 직업\n\n### 나의 선택\n나는 직장이 아닌 직업을 선택했다. 개발자라는 직업을 선택했다. 그리고 특정 직장(기업)이 아닌 업계를 선택했다. IT업계와 스타트업계가 그것이다. 나는 개발자로서 IT 업계에 종사하는 사람이다. 스타트업에 일하는 사람으로서 스타트업계에 종사하는 사람이다. 대학 졸업은 앞둔 나는 개발이 하고 싶었다. 잘 하는 편은 아니었지만 그래도 뭔가 새로운 서비스를 만드는 일이 하고 싶었다. 내가 작성한 코드로 돌아가는 서비스를 만들었들 때 그 서비스를 이용하는 유저들의 반응이 궁금했다. 나는 개발자가 되고 싶었고, 개발자라는 직업을 선택했다. 사회생활의 시작을 준비하면서 이 길을 선택했다.\n\n\n### 새로운 시대\n우리 세대는 이제 직장이 아니라 직업을 선택해야 한다. 더 이상 평생직장은 없다. 평생 나를 먹여 살려줄 회사는 없다. 이름만 들으면 다 아는 대기업이라면 안정적인 공기업이라면 다르지 않을까. 한동안 돈은 많이 벌 수 있을지 모르겠다. 하지만 오래 가진 않을 것이다. 새로운 시대가 오고 있다. 바로 4차 산업의 시대다.\n정치권에서도 4차 산업 시대를 운운한다. 어떤 시대가 될지 정확히 알 수 없지만 한 가지 확실한 것은 지금과 일의 개념이 많이 달라질 것이라는 점이다. 기업은 더 이상 반복적으로 누구나 할 수 있는 일을 사람에게 맡기지 않을 것이다. 이윤을 추구하는 기업의 특성상 그러한 일을 사람에게 맡기는 건 비효율적이기 때문이다. 그렇다면 직장이 아니라 직업을 선택하면 안전하단 말인가? 사실 또 그렇다고 말하긴 좀 어렵지만 그래도 직장을 선택하는 것보다는 낫다. 직장을 선택하는 것과 직업을 선택하는 것의 차이는 주도성에 있기 때문이다.\n\n\n### 주도성과 창의력\n직업을 선택하는 행위는 직장을 선택하는 행위보다 내가 어떤 일을 할 것인지 선택할 수 있는 주도성 혹은 주체성이라고 할 수 있는 어떤 자주적인 선택 능력이 더 필요하다. 직장은 다양한 일을 하는 사람, 팀 혹은 집단의 집합인데 직장을 선택한다는 것은 이러한 집합을 선택한다는 의미이다. 특정 직장에 들어가길 원한다는 것은 그들이 하는 일 중 어떤 것이 자신에게 맡겨지더라도 무관하다고 말하는 것과 같다. 결국 자신이 어떤 일을 할지에 대해서는 선택을 포기한 것이다. 반면 직업은 어떤 일 자체를 의미한다. 직업을 선택한다는 것은 그 일을 선택한다는 것을 의미한다. 전자의 선택보다 훨씬 주체적이고 구체적인 선택을 하는 것이다.\n직장과 직업을 선택하는 차이가 주도성에 있는데, 그 주도성이 왜 중요하고 좋은 것이냐고 묻는다면 다시 4차 산업 시대를 이야기로 돌아가야 한다. 반복되는 작업은 기계와 소프트웨어가 대신하는 시대가 올 것이다. 그 시대에서 살아남는 방법은 이전과는 다른 선택을 하는 것이다. 기계가 따라 할 수 없는 선택을 하는 것이다. 기계가 아직 학습하지 못한 형태의 선택을 하는 것이다. 개인적으로는 이러한 형태의, 이전과는 다른 선택을 할 수 있는 능력이 창의력이라고 생각한다. 새로운 방식을 선택하는 능력, 새로운 방법을 선택하는 능력이 창의력이다. 창의력은 주도적으로 선택한 일에서 나온다. 주도적으로 일을 선택한 사람만이 일을 창의적으로 해결하려고 노력할 것이다. 무슨 일을 해야 하는지 선택할 수도 없는 직장에 간다면 우리는 주도성을 잃어갈 것이고 이는 선택하는 능력, 창의력을 잃어가는 것을 의미한다. 이미 우리는 학교 생활을 통해서 창의력을 잃었다고 말한다면 이렇게 말하고 싶다. 그러니까 더 이상 창의력을 잃어서는 안 된다. 주도성으로부터 나오는 창의력만이 새로운 시대에서 우리를 살아남게 할 것이기 때문이다.\n\n\n### 업계(業界)\n같은 일을 하는 사람들의 세계, 업계. 직업을 선택한다는 것은 업계를 선택하는 것이다. 업계는 직장보다 더 넓은 세계다. 이곳은 더 자유롭다. 그리고 더 안전하다.\n업계가 직장보다 더 넓은 세계라는 점은 굳이 설명할 필요가 없다. 직장은 특정 집단의 이윤을 추구하는 곳이지만 업계는 같은 유형의 일을 하는 사람들의 집합이다. 다양한 기업에 일하는 사람들의 총합에서 같은 유형의 일을 하는 사람을 모아둔 것이다. 훨씬 많은 사람이 있으며 다양한 국가의 사람이 존재할 수 있다. 또한 넓은 장소일수록 활동 반경이 넓어지고 자유로워지는 것처럼 이처럼 넓은 세계에서는 더욱 자유로울 수 있다. 일례로 이직에 관한 사례들을 들어봐도 그렇다. 듣자 하니 실리콘밸리에서는 능력이 된다면 더 자주 이직한다고 한다. 1년에 한 번씩 이직하더라도 그것을 능력이라고 생각한다고 한다. (이직과 함께 연봉도 오른다고 한다.) 심지어는 이처럼 능력 있는 이직꾼(?)들은 특정 회사에 소속되려 하지 않는다. 극단적인 자유를 누리면서 일한다. 바로 디지털 노마드다. 컴퓨터가 있고 인터넷이 된다면 어디서든 일한다. 이 같은 일이 가능한 것은 그들이 직업을 선택했기 때문이다.\n\n자유롭지만 또한 안전한 이유는 무엇일까. 직장이 아닌 직업을 선택하기에 가장 두려운 부분이 바로 불안정에 대한 두려움 때문일 것이다. 남들이 알아주는 안정적인 직장을 선택하면 때론 일이 고달프더라도 그리고 내가 무슨 일을 하는지 잘 모르더라도 안정적으로 월급을 받을 수 있으니 그걸로 족하다는 생각을 할 것이다. 사실은 그렇지 않다. 물론 모든 경우가 그렇지 않다고 단정 지을 수 없는 부분이 있다. 하지만 앞서 말한 것처럼 새로운 시대에 우리는 어느 누구도 안정적인 직장을 가질 수 없다. 우리는 그나마 안정적인 직업을 가질 수 있을 뿐이다. 업계에 들어오는 것이 보다 안정적이고 안전한 이유는 그 세계가 넓기 때문이다. 이건 또 무슨 도돌이표 같은 소리인가. 잘 생각해보자. 더 넓은 세계에서는 또 다른 장소로의 이동이 자유롭다. 자유롭다는 것은 제약이 적다는 것이다. 이동(이직)의 장벽이 낮다는 것이다. 바로 이 지점이다. 평생직장이 없기에 우리는 잦은 이직을 경험해야 하고 또한 선택해야 한다. 그렇기 때문에 우리는 넓은 세계, 이동이 용이한 세계에 들어가야 한다. 그것이 보다 안정적인 삶을 영위할 수 있는 방법이다.\n\n\n### 고통의 길\n사실 직업을 선택하는 것은 고통의 길이다. 앞서 말한 창의력으로 새로운 시대에서 살아남는 것과 이직의 자유로움을 얻기 위해선 고통이 따른다. 단순히 직장이 아닌 직업을 선택했다고 곧장 주어지는 선물이 아니다. 업계에서 쓰일만한 능력을 갖추기 위해 계속 공부하고 발전해야 한다. 그 모든 과정이 재미있고 보람찰 때도 있겠지만 때론 상당히 고통스러울 것이다. 그렇지만 우리가 직업을 선택하지 않는다면 이러한 고통도 없이 애써볼 시간도 없이 막다른 길에 이르게 될 것이다.\n\n\n### 나와 같다면\n사회라는 새로운 세상으로 들어서는 길, 그 길은 갈림길이다.\n남들이 부러워하는 안정적인 직장인의 길과 불안정하고 인정받지 못하는 것처럼 보이는 직업인의 길이다. 어떤 길을 선택할 것인가.","slug":"like-me-1","published":1,"updated":"2019-07-15T12:01:16.458Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9iw009odirvt6lq8chg","content":"<h5 id=\"‘나와-같다면’-시리즈-소개\"><a href=\"#‘나와-같다면’-시리즈-소개\" class=\"headerlink\" title=\"‘나와 같다면’ 시리즈 소개\"></a>‘나와 같다면’ 시리즈 소개</h5><p>  <em>‘그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼’</em> 김연우씨가 불러서 더 유명한 노래 ‘나와 같다면’에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.</p>\n<hr>\n<h2 id=\"직장이-아니라-직업\"><a href=\"#직장이-아니라-직업\" class=\"headerlink\" title=\"직장이 아니라 직업\"></a>직장이 아니라 직업</h2><h3 id=\"나의-선택\"><a href=\"#나의-선택\" class=\"headerlink\" title=\"나의 선택\"></a>나의 선택</h3><p>나는 직장이 아닌 직업을 선택했다. 개발자라는 직업을 선택했다. 그리고 특정 직장(기업)이 아닌 업계를 선택했다. IT업계와 스타트업계가 그것이다. 나는 개발자로서 IT 업계에 종사하는 사람이다. 스타트업에 일하는 사람으로서 스타트업계에 종사하는 사람이다. 대학 졸업은 앞둔 나는 개발이 하고 싶었다. 잘 하는 편은 아니었지만 그래도 뭔가 새로운 서비스를 만드는 일이 하고 싶었다. 내가 작성한 코드로 돌아가는 서비스를 만들었들 때 그 서비스를 이용하는 유저들의 반응이 궁금했다. 나는 개발자가 되고 싶었고, 개발자라는 직업을 선택했다. 사회생활의 시작을 준비하면서 이 길을 선택했다.</p>\n<h3 id=\"새로운-시대\"><a href=\"#새로운-시대\" class=\"headerlink\" title=\"새로운 시대\"></a>새로운 시대</h3><p>우리 세대는 이제 직장이 아니라 직업을 선택해야 한다. 더 이상 평생직장은 없다. 평생 나를 먹여 살려줄 회사는 없다. 이름만 들으면 다 아는 대기업이라면 안정적인 공기업이라면 다르지 않을까. 한동안 돈은 많이 벌 수 있을지 모르겠다. 하지만 오래 가진 않을 것이다. 새로운 시대가 오고 있다. 바로 4차 산업의 시대다.<br>정치권에서도 4차 산업 시대를 운운한다. 어떤 시대가 될지 정확히 알 수 없지만 한 가지 확실한 것은 지금과 일의 개념이 많이 달라질 것이라는 점이다. 기업은 더 이상 반복적으로 누구나 할 수 있는 일을 사람에게 맡기지 않을 것이다. 이윤을 추구하는 기업의 특성상 그러한 일을 사람에게 맡기는 건 비효율적이기 때문이다. 그렇다면 직장이 아니라 직업을 선택하면 안전하단 말인가? 사실 또 그렇다고 말하긴 좀 어렵지만 그래도 직장을 선택하는 것보다는 낫다. 직장을 선택하는 것과 직업을 선택하는 것의 차이는 주도성에 있기 때문이다.</p>\n<h3 id=\"주도성과-창의력\"><a href=\"#주도성과-창의력\" class=\"headerlink\" title=\"주도성과 창의력\"></a>주도성과 창의력</h3><p>직업을 선택하는 행위는 직장을 선택하는 행위보다 내가 어떤 일을 할 것인지 선택할 수 있는 주도성 혹은 주체성이라고 할 수 있는 어떤 자주적인 선택 능력이 더 필요하다. 직장은 다양한 일을 하는 사람, 팀 혹은 집단의 집합인데 직장을 선택한다는 것은 이러한 집합을 선택한다는 의미이다. 특정 직장에 들어가길 원한다는 것은 그들이 하는 일 중 어떤 것이 자신에게 맡겨지더라도 무관하다고 말하는 것과 같다. 결국 자신이 어떤 일을 할지에 대해서는 선택을 포기한 것이다. 반면 직업은 어떤 일 자체를 의미한다. 직업을 선택한다는 것은 그 일을 선택한다는 것을 의미한다. 전자의 선택보다 훨씬 주체적이고 구체적인 선택을 하는 것이다.<br>직장과 직업을 선택하는 차이가 주도성에 있는데, 그 주도성이 왜 중요하고 좋은 것이냐고 묻는다면 다시 4차 산업 시대를 이야기로 돌아가야 한다. 반복되는 작업은 기계와 소프트웨어가 대신하는 시대가 올 것이다. 그 시대에서 살아남는 방법은 이전과는 다른 선택을 하는 것이다. 기계가 따라 할 수 없는 선택을 하는 것이다. 기계가 아직 학습하지 못한 형태의 선택을 하는 것이다. 개인적으로는 이러한 형태의, 이전과는 다른 선택을 할 수 있는 능력이 창의력이라고 생각한다. 새로운 방식을 선택하는 능력, 새로운 방법을 선택하는 능력이 창의력이다. 창의력은 주도적으로 선택한 일에서 나온다. 주도적으로 일을 선택한 사람만이 일을 창의적으로 해결하려고 노력할 것이다. 무슨 일을 해야 하는지 선택할 수도 없는 직장에 간다면 우리는 주도성을 잃어갈 것이고 이는 선택하는 능력, 창의력을 잃어가는 것을 의미한다. 이미 우리는 학교 생활을 통해서 창의력을 잃었다고 말한다면 이렇게 말하고 싶다. 그러니까 더 이상 창의력을 잃어서는 안 된다. 주도성으로부터 나오는 창의력만이 새로운 시대에서 우리를 살아남게 할 것이기 때문이다.</p>\n<h3 id=\"업계-業界\"><a href=\"#업계-業界\" class=\"headerlink\" title=\"업계(業界)\"></a>업계(業界)</h3><p>같은 일을 하는 사람들의 세계, 업계. 직업을 선택한다는 것은 업계를 선택하는 것이다. 업계는 직장보다 더 넓은 세계다. 이곳은 더 자유롭다. 그리고 더 안전하다.<br>업계가 직장보다 더 넓은 세계라는 점은 굳이 설명할 필요가 없다. 직장은 특정 집단의 이윤을 추구하는 곳이지만 업계는 같은 유형의 일을 하는 사람들의 집합이다. 다양한 기업에 일하는 사람들의 총합에서 같은 유형의 일을 하는 사람을 모아둔 것이다. 훨씬 많은 사람이 있으며 다양한 국가의 사람이 존재할 수 있다. 또한 넓은 장소일수록 활동 반경이 넓어지고 자유로워지는 것처럼 이처럼 넓은 세계에서는 더욱 자유로울 수 있다. 일례로 이직에 관한 사례들을 들어봐도 그렇다. 듣자 하니 실리콘밸리에서는 능력이 된다면 더 자주 이직한다고 한다. 1년에 한 번씩 이직하더라도 그것을 능력이라고 생각한다고 한다. (이직과 함께 연봉도 오른다고 한다.) 심지어는 이처럼 능력 있는 이직꾼(?)들은 특정 회사에 소속되려 하지 않는다. 극단적인 자유를 누리면서 일한다. 바로 디지털 노마드다. 컴퓨터가 있고 인터넷이 된다면 어디서든 일한다. 이 같은 일이 가능한 것은 그들이 직업을 선택했기 때문이다.</p>\n<p>자유롭지만 또한 안전한 이유는 무엇일까. 직장이 아닌 직업을 선택하기에 가장 두려운 부분이 바로 불안정에 대한 두려움 때문일 것이다. 남들이 알아주는 안정적인 직장을 선택하면 때론 일이 고달프더라도 그리고 내가 무슨 일을 하는지 잘 모르더라도 안정적으로 월급을 받을 수 있으니 그걸로 족하다는 생각을 할 것이다. 사실은 그렇지 않다. 물론 모든 경우가 그렇지 않다고 단정 지을 수 없는 부분이 있다. 하지만 앞서 말한 것처럼 새로운 시대에 우리는 어느 누구도 안정적인 직장을 가질 수 없다. 우리는 그나마 안정적인 직업을 가질 수 있을 뿐이다. 업계에 들어오는 것이 보다 안정적이고 안전한 이유는 그 세계가 넓기 때문이다. 이건 또 무슨 도돌이표 같은 소리인가. 잘 생각해보자. 더 넓은 세계에서는 또 다른 장소로의 이동이 자유롭다. 자유롭다는 것은 제약이 적다는 것이다. 이동(이직)의 장벽이 낮다는 것이다. 바로 이 지점이다. 평생직장이 없기에 우리는 잦은 이직을 경험해야 하고 또한 선택해야 한다. 그렇기 때문에 우리는 넓은 세계, 이동이 용이한 세계에 들어가야 한다. 그것이 보다 안정적인 삶을 영위할 수 있는 방법이다.</p>\n<h3 id=\"고통의-길\"><a href=\"#고통의-길\" class=\"headerlink\" title=\"고통의 길\"></a>고통의 길</h3><p>사실 직업을 선택하는 것은 고통의 길이다. 앞서 말한 창의력으로 새로운 시대에서 살아남는 것과 이직의 자유로움을 얻기 위해선 고통이 따른다. 단순히 직장이 아닌 직업을 선택했다고 곧장 주어지는 선물이 아니다. 업계에서 쓰일만한 능력을 갖추기 위해 계속 공부하고 발전해야 한다. 그 모든 과정이 재미있고 보람찰 때도 있겠지만 때론 상당히 고통스러울 것이다. 그렇지만 우리가 직업을 선택하지 않는다면 이러한 고통도 없이 애써볼 시간도 없이 막다른 길에 이르게 될 것이다.</p>\n<h3 id=\"나와-같다면\"><a href=\"#나와-같다면\" class=\"headerlink\" title=\"나와 같다면\"></a>나와 같다면</h3><p>사회라는 새로운 세상으로 들어서는 길, 그 길은 갈림길이다.<br>남들이 부러워하는 안정적인 직장인의 길과 불안정하고 인정받지 못하는 것처럼 보이는 직업인의 길이다. 어떤 길을 선택할 것인가.</p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"‘나와-같다면’-시리즈-소개\"><a href=\"#‘나와-같다면’-시리즈-소개\" class=\"headerlink\" title=\"‘나와 같다면’ 시리즈 소개\"></a>‘나와 같다면’ 시리즈 소개</h5><p>  <em>‘그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼’</em> 김연우씨가 불러서 더 유명한 노래 ‘나와 같다면’에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.</p>\n<hr>\n<h2 id=\"직장이-아니라-직업\"><a href=\"#직장이-아니라-직업\" class=\"headerlink\" title=\"직장이 아니라 직업\"></a>직장이 아니라 직업</h2><h3 id=\"나의-선택\"><a href=\"#나의-선택\" class=\"headerlink\" title=\"나의 선택\"></a>나의 선택</h3><p>나는 직장이 아닌 직업을 선택했다. 개발자라는 직업을 선택했다. 그리고 특정 직장(기업)이 아닌 업계를 선택했다. IT업계와 스타트업계가 그것이다. 나는 개발자로서 IT 업계에 종사하는 사람이다. 스타트업에 일하는 사람으로서 스타트업계에 종사하는 사람이다. 대학 졸업은 앞둔 나는 개발이 하고 싶었다. 잘 하는 편은 아니었지만 그래도 뭔가 새로운 서비스를 만드는 일이 하고 싶었다. 내가 작성한 코드로 돌아가는 서비스를 만들었들 때 그 서비스를 이용하는 유저들의 반응이 궁금했다. 나는 개발자가 되고 싶었고, 개발자라는 직업을 선택했다. 사회생활의 시작을 준비하면서 이 길을 선택했다.</p>\n<h3 id=\"새로운-시대\"><a href=\"#새로운-시대\" class=\"headerlink\" title=\"새로운 시대\"></a>새로운 시대</h3><p>우리 세대는 이제 직장이 아니라 직업을 선택해야 한다. 더 이상 평생직장은 없다. 평생 나를 먹여 살려줄 회사는 없다. 이름만 들으면 다 아는 대기업이라면 안정적인 공기업이라면 다르지 않을까. 한동안 돈은 많이 벌 수 있을지 모르겠다. 하지만 오래 가진 않을 것이다. 새로운 시대가 오고 있다. 바로 4차 산업의 시대다.<br>정치권에서도 4차 산업 시대를 운운한다. 어떤 시대가 될지 정확히 알 수 없지만 한 가지 확실한 것은 지금과 일의 개념이 많이 달라질 것이라는 점이다. 기업은 더 이상 반복적으로 누구나 할 수 있는 일을 사람에게 맡기지 않을 것이다. 이윤을 추구하는 기업의 특성상 그러한 일을 사람에게 맡기는 건 비효율적이기 때문이다. 그렇다면 직장이 아니라 직업을 선택하면 안전하단 말인가? 사실 또 그렇다고 말하긴 좀 어렵지만 그래도 직장을 선택하는 것보다는 낫다. 직장을 선택하는 것과 직업을 선택하는 것의 차이는 주도성에 있기 때문이다.</p>\n<h3 id=\"주도성과-창의력\"><a href=\"#주도성과-창의력\" class=\"headerlink\" title=\"주도성과 창의력\"></a>주도성과 창의력</h3><p>직업을 선택하는 행위는 직장을 선택하는 행위보다 내가 어떤 일을 할 것인지 선택할 수 있는 주도성 혹은 주체성이라고 할 수 있는 어떤 자주적인 선택 능력이 더 필요하다. 직장은 다양한 일을 하는 사람, 팀 혹은 집단의 집합인데 직장을 선택한다는 것은 이러한 집합을 선택한다는 의미이다. 특정 직장에 들어가길 원한다는 것은 그들이 하는 일 중 어떤 것이 자신에게 맡겨지더라도 무관하다고 말하는 것과 같다. 결국 자신이 어떤 일을 할지에 대해서는 선택을 포기한 것이다. 반면 직업은 어떤 일 자체를 의미한다. 직업을 선택한다는 것은 그 일을 선택한다는 것을 의미한다. 전자의 선택보다 훨씬 주체적이고 구체적인 선택을 하는 것이다.<br>직장과 직업을 선택하는 차이가 주도성에 있는데, 그 주도성이 왜 중요하고 좋은 것이냐고 묻는다면 다시 4차 산업 시대를 이야기로 돌아가야 한다. 반복되는 작업은 기계와 소프트웨어가 대신하는 시대가 올 것이다. 그 시대에서 살아남는 방법은 이전과는 다른 선택을 하는 것이다. 기계가 따라 할 수 없는 선택을 하는 것이다. 기계가 아직 학습하지 못한 형태의 선택을 하는 것이다. 개인적으로는 이러한 형태의, 이전과는 다른 선택을 할 수 있는 능력이 창의력이라고 생각한다. 새로운 방식을 선택하는 능력, 새로운 방법을 선택하는 능력이 창의력이다. 창의력은 주도적으로 선택한 일에서 나온다. 주도적으로 일을 선택한 사람만이 일을 창의적으로 해결하려고 노력할 것이다. 무슨 일을 해야 하는지 선택할 수도 없는 직장에 간다면 우리는 주도성을 잃어갈 것이고 이는 선택하는 능력, 창의력을 잃어가는 것을 의미한다. 이미 우리는 학교 생활을 통해서 창의력을 잃었다고 말한다면 이렇게 말하고 싶다. 그러니까 더 이상 창의력을 잃어서는 안 된다. 주도성으로부터 나오는 창의력만이 새로운 시대에서 우리를 살아남게 할 것이기 때문이다.</p>\n<h3 id=\"업계-業界\"><a href=\"#업계-業界\" class=\"headerlink\" title=\"업계(業界)\"></a>업계(業界)</h3><p>같은 일을 하는 사람들의 세계, 업계. 직업을 선택한다는 것은 업계를 선택하는 것이다. 업계는 직장보다 더 넓은 세계다. 이곳은 더 자유롭다. 그리고 더 안전하다.<br>업계가 직장보다 더 넓은 세계라는 점은 굳이 설명할 필요가 없다. 직장은 특정 집단의 이윤을 추구하는 곳이지만 업계는 같은 유형의 일을 하는 사람들의 집합이다. 다양한 기업에 일하는 사람들의 총합에서 같은 유형의 일을 하는 사람을 모아둔 것이다. 훨씬 많은 사람이 있으며 다양한 국가의 사람이 존재할 수 있다. 또한 넓은 장소일수록 활동 반경이 넓어지고 자유로워지는 것처럼 이처럼 넓은 세계에서는 더욱 자유로울 수 있다. 일례로 이직에 관한 사례들을 들어봐도 그렇다. 듣자 하니 실리콘밸리에서는 능력이 된다면 더 자주 이직한다고 한다. 1년에 한 번씩 이직하더라도 그것을 능력이라고 생각한다고 한다. (이직과 함께 연봉도 오른다고 한다.) 심지어는 이처럼 능력 있는 이직꾼(?)들은 특정 회사에 소속되려 하지 않는다. 극단적인 자유를 누리면서 일한다. 바로 디지털 노마드다. 컴퓨터가 있고 인터넷이 된다면 어디서든 일한다. 이 같은 일이 가능한 것은 그들이 직업을 선택했기 때문이다.</p>\n<p>자유롭지만 또한 안전한 이유는 무엇일까. 직장이 아닌 직업을 선택하기에 가장 두려운 부분이 바로 불안정에 대한 두려움 때문일 것이다. 남들이 알아주는 안정적인 직장을 선택하면 때론 일이 고달프더라도 그리고 내가 무슨 일을 하는지 잘 모르더라도 안정적으로 월급을 받을 수 있으니 그걸로 족하다는 생각을 할 것이다. 사실은 그렇지 않다. 물론 모든 경우가 그렇지 않다고 단정 지을 수 없는 부분이 있다. 하지만 앞서 말한 것처럼 새로운 시대에 우리는 어느 누구도 안정적인 직장을 가질 수 없다. 우리는 그나마 안정적인 직업을 가질 수 있을 뿐이다. 업계에 들어오는 것이 보다 안정적이고 안전한 이유는 그 세계가 넓기 때문이다. 이건 또 무슨 도돌이표 같은 소리인가. 잘 생각해보자. 더 넓은 세계에서는 또 다른 장소로의 이동이 자유롭다. 자유롭다는 것은 제약이 적다는 것이다. 이동(이직)의 장벽이 낮다는 것이다. 바로 이 지점이다. 평생직장이 없기에 우리는 잦은 이직을 경험해야 하고 또한 선택해야 한다. 그렇기 때문에 우리는 넓은 세계, 이동이 용이한 세계에 들어가야 한다. 그것이 보다 안정적인 삶을 영위할 수 있는 방법이다.</p>\n<h3 id=\"고통의-길\"><a href=\"#고통의-길\" class=\"headerlink\" title=\"고통의 길\"></a>고통의 길</h3><p>사실 직업을 선택하는 것은 고통의 길이다. 앞서 말한 창의력으로 새로운 시대에서 살아남는 것과 이직의 자유로움을 얻기 위해선 고통이 따른다. 단순히 직장이 아닌 직업을 선택했다고 곧장 주어지는 선물이 아니다. 업계에서 쓰일만한 능력을 갖추기 위해 계속 공부하고 발전해야 한다. 그 모든 과정이 재미있고 보람찰 때도 있겠지만 때론 상당히 고통스러울 것이다. 그렇지만 우리가 직업을 선택하지 않는다면 이러한 고통도 없이 애써볼 시간도 없이 막다른 길에 이르게 될 것이다.</p>\n<h3 id=\"나와-같다면\"><a href=\"#나와-같다면\" class=\"headerlink\" title=\"나와 같다면\"></a>나와 같다면</h3><p>사회라는 새로운 세상으로 들어서는 길, 그 길은 갈림길이다.<br>남들이 부러워하는 안정적인 직장인의 길과 불안정하고 인정받지 못하는 것처럼 보이는 직업인의 길이다. 어떤 길을 선택할 것인가.</p>\n"},{"title":"미니게임 - BINGO(2)","date":"2017-07-16T04:55:31.000Z","_content":"_(의식의 흐름대로) 미니 게임을 만들어보자!_\n\n## BINGO[2] - View\n숫자 데이터(배열)를 만들어서 DOM에 그리기까지\n\n### 빙고판 데이터 만들기\n75개의 숫자(1~75) 중에서 25개의 숫자를 임의로 선택해서 5x5 크기의 판을 만들어보자.\n\n#### 1부터 75까지 담고 있는 배열을 만든다.\n\n```javascript\nvar base_arr = [], i = 0;\nwhile (++i < 76) base_arr.push(i);\n\n// Partial.js의 함수들을 사용하면 아래와 같이 할 수 있다.\n// var base_arr = _.go(76, _.range, _.rest);\n```\n\n#### 빙고판을 만들어줄 함수를 만든다.\n다섯개의 배열(B, I, N, G, O 에 해당하는 배열)을 값으로 갖는 배열을 만들어야 하는데, 이때 숫자들은 15개씩 각 배열에 속해야 함으로 적절한 위치를 찾아주는 함수가 필요하다. (물론 순서대로 넣어주면 되지만 랜덤한 숫자일 필요가 있기 때문에 위치를 찾아주는 수고가 필요하다.)\n\n```javascript\nfunction find_idx(n) {\n  var i = 4;\n  if (n <= 15) i = 0;\n  else if (n <= 30) i = 1;\n  else if (n <= 45) i = 2;\n  else if (n <= 60) i = 3;\n  return i;\n}\n```\n위의 함수를 이용해서 다섯개의 배열을 값으로 갖는 배열을 만드는 함수를 만든다.\n\n```javascript\nfunction make_bingo(arr) {\n  return arr.reduce(function(o, n) {\n    var i = find_idx(n);\n    return o[i].push(n), o;\n    }, [[],[],[],[],[]])\n}\n\n// Partial.js의 함수는 커링을 지원한다. \n// 첫번째 인자를 제외한 인자가 들어오면 동작할 준비가 된 함수를 반환한다.\n// var make_bingo2 = _.reduce(\n//  (o, n) => {\n//     var i = find_idx(n);\n//     return o[i] = o[i].concat(n), o;\n//     }, [[],[],[],[],[]]);\n```\n\n#### 상황판에 해당하는 배열과 빙고판에 해당하는 배열을 만드는 함수를 만든다.\n사실 위의 `make_bingo`는 5x5의 빙고판을 만들어주지 않는다. 길이가 15인 배열 5개를 가진 배열을 만들 뿐이다. 이렇게 만들어진 판은 게임에 참가하는 유저에게 주어지는 판이 아니라 게임 진행 상황을 확인할 수 있는 상황판이 된다. 이제 실제 유저가 사용할 수 있는 진짜 5x5 빙고판을 만들어보자.\n\n```javascript\nfunction make_user_data(arr) {\n  var rand_arr = _.shuffle(arr);\n  return make_bingo(rand_arr);\n}\n\nvar result = make_user_data(base_arr);\nconsole.log(result[0]); // 순서가 섞인 배열 (B의 범위에 속하는 배열)\nconsole.log(result[0].length); // 15\n```\n`_.shuffle` 함수 덕분에 순서가 섞인 배열을 얻게 되었지만 여전히 배열이 너무 길다. 줄여보자.\n\n```javascript\nfunction reduce_first_5(arr) {\n  return arr.reduce(function(l, v, i) {\n    return l[i] = _.first(v, 5), l;\n  }, [])\n} // var reduce_first_5 = _.reduce((l, v, i) => (l[i] = _.first(v, 5), l), []);\n\nfunction make_user_data(arr) {\n  var rand_arr = _.shuffle(arr);\n  return reduce_first_5(make_bingo(rand_arr));\n} // var make_user_data = _.pipe(_.shuffle, make_bingo, reduce_first_5);\n\nvar user_data = make_user_data(base_arr);\nconsole.log(user_data[0]); // 순서가 섞인 배열 (B의 범위에 속하는 배열)\nconsole.log(user_data[0].length); // 5\n```\n`result`는 5개의 배열을 갖는 배열이며 각 배열의 길이는 5이다. 그리고 각 배열은 임의의 순서가 섞여 있다. 이 상태를 5x5 빙고판의 데이터라고 보자. (`make_user_data``라는 함수를 이용하면 매번 새로운 빙고판 데이터를 만들 수 있다.)\n\n\n### 데이터를 이용해서 빙고판 그리기\n결국 게임을 진행하려면 DOM에 만든 배열을 그려야하는데, 어떻게 그려야할까. 우선 그려질 숫자를 적어 넣을 판을 먼저 만들어야 한다.\n\n#### html table 태그 문자열을 만든다.\nDOM에 그려질 html 태그를 괄호까지 직접 타이핑하는 것은 너무 번거로운 일이다. 그래서 대부분은 [pug](https://pugjs.org/api/getting-started.html), [ejs](http://www.embeddedjs.com/), [handlebars](http://handlebarsjs.com/) 같은 템플릿 엔진을 사용한다. 이와 같은 도구는 값에 따라 다른 태그를 유동적으로 작성해야할 때 매우 유용한데, Partial.js에서는 `_.template` 함수가 이와 같은 일을 한다. \n\n```javascript\nvar table_template = _.template('data', `\n        table \n          tr\n            th B\n            th I\n            th N\n            th G\n            th O {{ _.go(data, `, _.template.each('d1', `\n          tr {{ _.go(d1, `, _.template.each('d2',`\n            td {{d2}}\n          `),`)}}`),\n        `)}}\n      `);\n\ntable_template(user_board);\n/* 출력 결과\n\"<table ><tr ><th >B</th><th >I</th><th >N</th><th >G</th><th >O <tr ><td >10</td><td >7</td><td >5</td><td >4</td><td >8</td></tr><tr ><td >28</td><td >20</td><td >30</td><td >16</td><td >26</td></tr><tr ><td >33</td><td >41</td><td >45</td><td >42</td><td >32</td></tr><tr ><td >47</td><td >59</td><td >50</td><td >51</td><td >52</td></tr><tr ><td >65</td><td >67</td><td >68</td><td >69</td><td >63</td></tr></th></tr></table>\"\n*/\n```\n`_.template(data_name, template_structure)` 함수는 두개의 인자를 받아서 함수를 반환한다. 이 함수는 데이터를 받아 html 태그 문자열을 만든다. 처음에 `_.template` 함수가 받는 두개의 인자는 각각 태그를 그릴 때 사용할 '데이터의 이름'과 '템플릿의 구조'를 받는다. 데이터의 이름은 템플릿의 구조에서 <code>&#123;&#123;&#125;&#125;</code> 안에서 그려질 태그 문자열에 반영될 데이터의 이름이다. 템플릿 구조 안에서 이중 중괄호 안은 자바스크립트의 영역이다. 자세한 내용은 [Partial.js의 문서](https://marpple.github.io/partial.js/#함수-스타일의-템플릿-함수)를 참고하면 된다.\n\n참고: `_.template.each` 함수는 템플릿을 반복적으로 그려야할 때 사용한다. 템플릿의 구조를 정의하기 위해 사용된 역따옴표는 ES6부터 개행이 포함된 문자열을 담을때 사용한다. ES5에서는 개행 전에 역슬래시가 포함되어야 한다.\n\n#### 필요한 함수를 조립한다.\nDOM에 그려질 View를 만들기 위한 작업은 어느정도 되었다. 이제 함수를 조립해서 실제로 사용할 함수를 만들자.\n\n```javascript\nvar make_bingo_table = _.pipe(_.unzip, table_template, D.el);\n\nvar make_user_board = _.pipe(make_user_data, make_bingo_table, D.appendTo('.user_board'));\n\nvar make_admin_board = _.pipe(make_bingo, make_bingo_table, D.appendTo('.admin_board'));\n```\n세개의 함수가 준비되었다. `make_user_board(base_arr)`의 형태로 사용하면 user_board를 클래스로 갖는 DOM 엘리먼트에 기대했던 빙고판이 붙는다. 여기서 사용된 `D`를 네임스페이스로 갖는 함수는 [Don.js](https://rawgit.com/joeunha/bingo/master/docs/js/don.js)라는 라이브러리가 가진 함수들이다. 사용법은 jQuery와 같은데 메서드로 사용하지 않고 함수로 사용한다는 점만 다르다. 덕분에 더욱 우아한 함수형 코드가 작성 가능하다. \n\n\n### 맺음\n전체 코드는 아래와 같다. 다음 글에서 Control 부분을 완성할 예정이다.\n\n```javascript\nvar base_arr = [], i = 0;\n\nwhile (++i < 76) base_arr.push(i);\n\nfunction find_idx(n) {\n  var i = 4;\n  if (n <= 15) i = 0;\n  else if (n <= 30) i = 1;\n  else if (n <= 45) i = 2;\n  else if (n <= 60) i = 3;\n  return i;\n}\n\nfunction make_bingo(arr) {\n  return arr.reduce(function(o, n) {\n    var i = find_idx(n);\n    return o[i].push(n), o;\n  }, [[],[],[],[],[]])\n}\n\nfunction reduce_first_5(arr) {\n  return arr.reduce(function(l, v, i) {\n    return l[i] = _.first(v, 5), l;\n  }, [])\n} // var reduce_first_5 = _.reduce((l, v, i) => (l[i] = _.first(v, 5), l), []);\n\nfunction make_user_data(arr) {\n  var rand_arr = _.shuffle(arr);\n  return reduce_first_5(make_bingo(rand_arr));\n} // var make_user_board = _.pipe(_.shuffle, make_bingo, reduce_first_5);\n\nvar table_template = _.template('data', `\n    table\n      tr\n        th B\n        th I\n        th N\n        th G\n        th O {{ _.go(data, `, _.template.each('d1', `\n      tr {{ _.go(d1, `, _.template.each('d2',`\n        td {{d2}}\n      `),`)}}`),\n  `)}}\n  `);\n\nvar make_bingo_table = _.pipe(_.unzip, table_template, D.el);\n\nvar make_user_board = _.pipe(make_user_data, make_bingo_table, D.appendTo('.user_board'));\n\nvar make_admin_board = _.pipe(make_bingo, make_bingo_table, D.appendTo('.admin_board'));\n```","source":"_posts/make-bingo-game-1.md","raw":"---\ntitle: '미니게임 - BINGO(2)'\ndate: 2017-07-16 13:55:31\ncategories:\n  - programming\ntags:\n  - javascript\n  - 미니게임\n  - 만들기\n  - 빙고\n  - bingo\n---\n_(의식의 흐름대로) 미니 게임을 만들어보자!_\n\n## BINGO[2] - View\n숫자 데이터(배열)를 만들어서 DOM에 그리기까지\n\n### 빙고판 데이터 만들기\n75개의 숫자(1~75) 중에서 25개의 숫자를 임의로 선택해서 5x5 크기의 판을 만들어보자.\n\n#### 1부터 75까지 담고 있는 배열을 만든다.\n\n```javascript\nvar base_arr = [], i = 0;\nwhile (++i < 76) base_arr.push(i);\n\n// Partial.js의 함수들을 사용하면 아래와 같이 할 수 있다.\n// var base_arr = _.go(76, _.range, _.rest);\n```\n\n#### 빙고판을 만들어줄 함수를 만든다.\n다섯개의 배열(B, I, N, G, O 에 해당하는 배열)을 값으로 갖는 배열을 만들어야 하는데, 이때 숫자들은 15개씩 각 배열에 속해야 함으로 적절한 위치를 찾아주는 함수가 필요하다. (물론 순서대로 넣어주면 되지만 랜덤한 숫자일 필요가 있기 때문에 위치를 찾아주는 수고가 필요하다.)\n\n```javascript\nfunction find_idx(n) {\n  var i = 4;\n  if (n <= 15) i = 0;\n  else if (n <= 30) i = 1;\n  else if (n <= 45) i = 2;\n  else if (n <= 60) i = 3;\n  return i;\n}\n```\n위의 함수를 이용해서 다섯개의 배열을 값으로 갖는 배열을 만드는 함수를 만든다.\n\n```javascript\nfunction make_bingo(arr) {\n  return arr.reduce(function(o, n) {\n    var i = find_idx(n);\n    return o[i].push(n), o;\n    }, [[],[],[],[],[]])\n}\n\n// Partial.js의 함수는 커링을 지원한다. \n// 첫번째 인자를 제외한 인자가 들어오면 동작할 준비가 된 함수를 반환한다.\n// var make_bingo2 = _.reduce(\n//  (o, n) => {\n//     var i = find_idx(n);\n//     return o[i] = o[i].concat(n), o;\n//     }, [[],[],[],[],[]]);\n```\n\n#### 상황판에 해당하는 배열과 빙고판에 해당하는 배열을 만드는 함수를 만든다.\n사실 위의 `make_bingo`는 5x5의 빙고판을 만들어주지 않는다. 길이가 15인 배열 5개를 가진 배열을 만들 뿐이다. 이렇게 만들어진 판은 게임에 참가하는 유저에게 주어지는 판이 아니라 게임 진행 상황을 확인할 수 있는 상황판이 된다. 이제 실제 유저가 사용할 수 있는 진짜 5x5 빙고판을 만들어보자.\n\n```javascript\nfunction make_user_data(arr) {\n  var rand_arr = _.shuffle(arr);\n  return make_bingo(rand_arr);\n}\n\nvar result = make_user_data(base_arr);\nconsole.log(result[0]); // 순서가 섞인 배열 (B의 범위에 속하는 배열)\nconsole.log(result[0].length); // 15\n```\n`_.shuffle` 함수 덕분에 순서가 섞인 배열을 얻게 되었지만 여전히 배열이 너무 길다. 줄여보자.\n\n```javascript\nfunction reduce_first_5(arr) {\n  return arr.reduce(function(l, v, i) {\n    return l[i] = _.first(v, 5), l;\n  }, [])\n} // var reduce_first_5 = _.reduce((l, v, i) => (l[i] = _.first(v, 5), l), []);\n\nfunction make_user_data(arr) {\n  var rand_arr = _.shuffle(arr);\n  return reduce_first_5(make_bingo(rand_arr));\n} // var make_user_data = _.pipe(_.shuffle, make_bingo, reduce_first_5);\n\nvar user_data = make_user_data(base_arr);\nconsole.log(user_data[0]); // 순서가 섞인 배열 (B의 범위에 속하는 배열)\nconsole.log(user_data[0].length); // 5\n```\n`result`는 5개의 배열을 갖는 배열이며 각 배열의 길이는 5이다. 그리고 각 배열은 임의의 순서가 섞여 있다. 이 상태를 5x5 빙고판의 데이터라고 보자. (`make_user_data``라는 함수를 이용하면 매번 새로운 빙고판 데이터를 만들 수 있다.)\n\n\n### 데이터를 이용해서 빙고판 그리기\n결국 게임을 진행하려면 DOM에 만든 배열을 그려야하는데, 어떻게 그려야할까. 우선 그려질 숫자를 적어 넣을 판을 먼저 만들어야 한다.\n\n#### html table 태그 문자열을 만든다.\nDOM에 그려질 html 태그를 괄호까지 직접 타이핑하는 것은 너무 번거로운 일이다. 그래서 대부분은 [pug](https://pugjs.org/api/getting-started.html), [ejs](http://www.embeddedjs.com/), [handlebars](http://handlebarsjs.com/) 같은 템플릿 엔진을 사용한다. 이와 같은 도구는 값에 따라 다른 태그를 유동적으로 작성해야할 때 매우 유용한데, Partial.js에서는 `_.template` 함수가 이와 같은 일을 한다. \n\n```javascript\nvar table_template = _.template('data', `\n        table \n          tr\n            th B\n            th I\n            th N\n            th G\n            th O {{ _.go(data, `, _.template.each('d1', `\n          tr {{ _.go(d1, `, _.template.each('d2',`\n            td {{d2}}\n          `),`)}}`),\n        `)}}\n      `);\n\ntable_template(user_board);\n/* 출력 결과\n\"<table ><tr ><th >B</th><th >I</th><th >N</th><th >G</th><th >O <tr ><td >10</td><td >7</td><td >5</td><td >4</td><td >8</td></tr><tr ><td >28</td><td >20</td><td >30</td><td >16</td><td >26</td></tr><tr ><td >33</td><td >41</td><td >45</td><td >42</td><td >32</td></tr><tr ><td >47</td><td >59</td><td >50</td><td >51</td><td >52</td></tr><tr ><td >65</td><td >67</td><td >68</td><td >69</td><td >63</td></tr></th></tr></table>\"\n*/\n```\n`_.template(data_name, template_structure)` 함수는 두개의 인자를 받아서 함수를 반환한다. 이 함수는 데이터를 받아 html 태그 문자열을 만든다. 처음에 `_.template` 함수가 받는 두개의 인자는 각각 태그를 그릴 때 사용할 '데이터의 이름'과 '템플릿의 구조'를 받는다. 데이터의 이름은 템플릿의 구조에서 <code>&#123;&#123;&#125;&#125;</code> 안에서 그려질 태그 문자열에 반영될 데이터의 이름이다. 템플릿 구조 안에서 이중 중괄호 안은 자바스크립트의 영역이다. 자세한 내용은 [Partial.js의 문서](https://marpple.github.io/partial.js/#함수-스타일의-템플릿-함수)를 참고하면 된다.\n\n참고: `_.template.each` 함수는 템플릿을 반복적으로 그려야할 때 사용한다. 템플릿의 구조를 정의하기 위해 사용된 역따옴표는 ES6부터 개행이 포함된 문자열을 담을때 사용한다. ES5에서는 개행 전에 역슬래시가 포함되어야 한다.\n\n#### 필요한 함수를 조립한다.\nDOM에 그려질 View를 만들기 위한 작업은 어느정도 되었다. 이제 함수를 조립해서 실제로 사용할 함수를 만들자.\n\n```javascript\nvar make_bingo_table = _.pipe(_.unzip, table_template, D.el);\n\nvar make_user_board = _.pipe(make_user_data, make_bingo_table, D.appendTo('.user_board'));\n\nvar make_admin_board = _.pipe(make_bingo, make_bingo_table, D.appendTo('.admin_board'));\n```\n세개의 함수가 준비되었다. `make_user_board(base_arr)`의 형태로 사용하면 user_board를 클래스로 갖는 DOM 엘리먼트에 기대했던 빙고판이 붙는다. 여기서 사용된 `D`를 네임스페이스로 갖는 함수는 [Don.js](https://rawgit.com/joeunha/bingo/master/docs/js/don.js)라는 라이브러리가 가진 함수들이다. 사용법은 jQuery와 같은데 메서드로 사용하지 않고 함수로 사용한다는 점만 다르다. 덕분에 더욱 우아한 함수형 코드가 작성 가능하다. \n\n\n### 맺음\n전체 코드는 아래와 같다. 다음 글에서 Control 부분을 완성할 예정이다.\n\n```javascript\nvar base_arr = [], i = 0;\n\nwhile (++i < 76) base_arr.push(i);\n\nfunction find_idx(n) {\n  var i = 4;\n  if (n <= 15) i = 0;\n  else if (n <= 30) i = 1;\n  else if (n <= 45) i = 2;\n  else if (n <= 60) i = 3;\n  return i;\n}\n\nfunction make_bingo(arr) {\n  return arr.reduce(function(o, n) {\n    var i = find_idx(n);\n    return o[i].push(n), o;\n  }, [[],[],[],[],[]])\n}\n\nfunction reduce_first_5(arr) {\n  return arr.reduce(function(l, v, i) {\n    return l[i] = _.first(v, 5), l;\n  }, [])\n} // var reduce_first_5 = _.reduce((l, v, i) => (l[i] = _.first(v, 5), l), []);\n\nfunction make_user_data(arr) {\n  var rand_arr = _.shuffle(arr);\n  return reduce_first_5(make_bingo(rand_arr));\n} // var make_user_board = _.pipe(_.shuffle, make_bingo, reduce_first_5);\n\nvar table_template = _.template('data', `\n    table\n      tr\n        th B\n        th I\n        th N\n        th G\n        th O {{ _.go(data, `, _.template.each('d1', `\n      tr {{ _.go(d1, `, _.template.each('d2',`\n        td {{d2}}\n      `),`)}}`),\n  `)}}\n  `);\n\nvar make_bingo_table = _.pipe(_.unzip, table_template, D.el);\n\nvar make_user_board = _.pipe(make_user_data, make_bingo_table, D.appendTo('.user_board'));\n\nvar make_admin_board = _.pipe(make_bingo, make_bingo_table, D.appendTo('.admin_board'));\n```","slug":"make-bingo-game-1","published":1,"updated":"2019-12-05T15:05:29.491Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9iz009rdirv6lslivjh","content":"<p><em>(의식의 흐름대로) 미니 게임을 만들어보자!</em></p>\n<h2 id=\"BINGO-2-View\"><a href=\"#BINGO-2-View\" class=\"headerlink\" title=\"BINGO[2] - View\"></a>BINGO[2] - View</h2><p>숫자 데이터(배열)를 만들어서 DOM에 그리기까지</p>\n<h3 id=\"빙고판-데이터-만들기\"><a href=\"#빙고판-데이터-만들기\" class=\"headerlink\" title=\"빙고판 데이터 만들기\"></a>빙고판 데이터 만들기</h3><p>75개의 숫자(1~75) 중에서 25개의 숫자를 임의로 선택해서 5x5 크기의 판을 만들어보자.</p>\n<h4 id=\"1부터-75까지-담고-있는-배열을-만든다\"><a href=\"#1부터-75까지-담고-있는-배열을-만든다\" class=\"headerlink\" title=\"1부터 75까지 담고 있는 배열을 만든다.\"></a>1부터 75까지 담고 있는 배열을 만든다.</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> base_arr = [], i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (++i &lt; <span class=\"number\">76</span>) base_arr.push(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Partial.js의 함수들을 사용하면 아래와 같이 할 수 있다.</span></span><br><span class=\"line\"><span class=\"comment\">// var base_arr = _.go(76, _.range, _.rest);</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"빙고판을-만들어줄-함수를-만든다\"><a href=\"#빙고판을-만들어줄-함수를-만든다\" class=\"headerlink\" title=\"빙고판을 만들어줄 함수를 만든다.\"></a>빙고판을 만들어줄 함수를 만든다.</h4><p>다섯개의 배열(B, I, N, G, O 에 해당하는 배열)을 값으로 갖는 배열을 만들어야 하는데, 이때 숫자들은 15개씩 각 배열에 속해야 함으로 적절한 위치를 찾아주는 함수가 필요하다. (물론 순서대로 넣어주면 되지만 랜덤한 숫자일 필요가 있기 때문에 위치를 찾아주는 수고가 필요하다.)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find_idx</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">15</span>) i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">30</span>) i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">45</span>) i = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">60</span>) i = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위의 함수를 이용해서 다섯개의 배열을 값으로 갖는 배열을 만드는 함수를 만든다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make_bingo</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = find_idx(n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o[i].push(n), o;</span><br><span class=\"line\">    &#125;, [[],[],[],[],[]])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Partial.js의 함수는 커링을 지원한다. </span></span><br><span class=\"line\"><span class=\"comment\">// 첫번째 인자를 제외한 인자가 들어오면 동작할 준비가 된 함수를 반환한다.</span></span><br><span class=\"line\"><span class=\"comment\">// var make_bingo2 = _.reduce(</span></span><br><span class=\"line\"><span class=\"comment\">//  (o, n) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     var i = find_idx(n);</span></span><br><span class=\"line\"><span class=\"comment\">//     return o[i] = o[i].concat(n), o;</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;, [[],[],[],[],[]]);</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"상황판에-해당하는-배열과-빙고판에-해당하는-배열을-만드는-함수를-만든다\"><a href=\"#상황판에-해당하는-배열과-빙고판에-해당하는-배열을-만드는-함수를-만든다\" class=\"headerlink\" title=\"상황판에 해당하는 배열과 빙고판에 해당하는 배열을 만드는 함수를 만든다.\"></a>상황판에 해당하는 배열과 빙고판에 해당하는 배열을 만드는 함수를 만든다.</h4><p>사실 위의 <code>make_bingo</code>는 5x5의 빙고판을 만들어주지 않는다. 길이가 15인 배열 5개를 가진 배열을 만들 뿐이다. 이렇게 만들어진 판은 게임에 참가하는 유저에게 주어지는 판이 아니라 게임 진행 상황을 확인할 수 있는 상황판이 된다. 이제 실제 유저가 사용할 수 있는 진짜 5x5 빙고판을 만들어보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make_user_data</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> rand_arr = _.shuffle(arr);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> make_bingo(rand_arr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = make_user_data(base_arr);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result[<span class=\"number\">0</span>]); <span class=\"comment\">// 순서가 섞인 배열 (B의 범위에 속하는 배열)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result[<span class=\"number\">0</span>].length); <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n\n<p><code>_.shuffle</code> 함수 덕분에 순서가 섞인 배열을 얻게 되었지만 여전히 배열이 너무 길다. 줄여보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reduce_first_5</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">l, v, i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l[i] = _.first(v, <span class=\"number\">5</span>), l;</span><br><span class=\"line\">  &#125;, [])</span><br><span class=\"line\">&#125; <span class=\"comment\">// var reduce_first_5 = _.reduce((l, v, i) =&gt; (l[i] = _.first(v, 5), l), []);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make_user_data</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> rand_arr = _.shuffle(arr);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce_first_5(make_bingo(rand_arr));</span><br><span class=\"line\">&#125; <span class=\"comment\">// var make_user_data = _.pipe(_.shuffle, make_bingo, reduce_first_5);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> user_data = make_user_data(base_arr);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user_data[<span class=\"number\">0</span>]); <span class=\"comment\">// 순서가 섞인 배열 (B의 범위에 속하는 배열)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user_data[<span class=\"number\">0</span>].length); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p><code>result</code>는 5개의 배열을 갖는 배열이며 각 배열의 길이는 5이다. 그리고 각 배열은 임의의 순서가 섞여 있다. 이 상태를 5x5 빙고판의 데이터라고 보자. (`make_user_data``라는 함수를 이용하면 매번 새로운 빙고판 데이터를 만들 수 있다.)</p>\n<h3 id=\"데이터를-이용해서-빙고판-그리기\"><a href=\"#데이터를-이용해서-빙고판-그리기\" class=\"headerlink\" title=\"데이터를 이용해서 빙고판 그리기\"></a>데이터를 이용해서 빙고판 그리기</h3><p>결국 게임을 진행하려면 DOM에 만든 배열을 그려야하는데, 어떻게 그려야할까. 우선 그려질 숫자를 적어 넣을 판을 먼저 만들어야 한다.</p>\n<h4 id=\"html-table-태그-문자열을-만든다\"><a href=\"#html-table-태그-문자열을-만든다\" class=\"headerlink\" title=\"html table 태그 문자열을 만든다.\"></a>html table 태그 문자열을 만든다.</h4><p>DOM에 그려질 html 태그를 괄호까지 직접 타이핑하는 것은 너무 번거로운 일이다. 그래서 대부분은 <a href=\"https://pugjs.org/api/getting-started.html\" target=\"_blank\" rel=\"noopener\">pug</a>, <a href=\"http://www.embeddedjs.com/\" target=\"_blank\" rel=\"noopener\">ejs</a>, <a href=\"http://handlebarsjs.com/\" target=\"_blank\" rel=\"noopener\">handlebars</a> 같은 템플릿 엔진을 사용한다. 이와 같은 도구는 값에 따라 다른 태그를 유동적으로 작성해야할 때 매우 유용한데, Partial.js에서는 <code>_.template</code> 함수가 이와 같은 일을 한다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> table_template = _.template(<span class=\"string\">'data'</span>, <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        table </span></span><br><span class=\"line\"><span class=\"string\">          tr</span></span><br><span class=\"line\"><span class=\"string\">            th B</span></span><br><span class=\"line\"><span class=\"string\">            th I</span></span><br><span class=\"line\"><span class=\"string\">            th N</span></span><br><span class=\"line\"><span class=\"string\">            th G</span></span><br><span class=\"line\"><span class=\"string\">            th O &#123;&#123; _.go(data, `</span>, _.template.each(<span class=\"string\">'d1'</span>, <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">          tr &#123;&#123; _.go(d1, `</span>, _.template.each(<span class=\"string\">'d2'</span>,<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">            td &#123;&#123;d2&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">          `</span>),<span class=\"string\">`)&#125;&#125;`</span>),</span><br><span class=\"line\">        <span class=\"string\">`)&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      `</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">table_template(user_board);</span><br><span class=\"line\"><span class=\"comment\">/* 출력 결과</span></span><br><span class=\"line\"><span class=\"comment\">\"&lt;table &gt;&lt;tr &gt;&lt;th &gt;B&lt;/th&gt;&lt;th &gt;I&lt;/th&gt;&lt;th &gt;N&lt;/th&gt;&lt;th &gt;G&lt;/th&gt;&lt;th &gt;O &lt;tr &gt;&lt;td &gt;10&lt;/td&gt;&lt;td &gt;7&lt;/td&gt;&lt;td &gt;5&lt;/td&gt;&lt;td &gt;4&lt;/td&gt;&lt;td &gt;8&lt;/td&gt;&lt;/tr&gt;&lt;tr &gt;&lt;td &gt;28&lt;/td&gt;&lt;td &gt;20&lt;/td&gt;&lt;td &gt;30&lt;/td&gt;&lt;td &gt;16&lt;/td&gt;&lt;td &gt;26&lt;/td&gt;&lt;/tr&gt;&lt;tr &gt;&lt;td &gt;33&lt;/td&gt;&lt;td &gt;41&lt;/td&gt;&lt;td &gt;45&lt;/td&gt;&lt;td &gt;42&lt;/td&gt;&lt;td &gt;32&lt;/td&gt;&lt;/tr&gt;&lt;tr &gt;&lt;td &gt;47&lt;/td&gt;&lt;td &gt;59&lt;/td&gt;&lt;td &gt;50&lt;/td&gt;&lt;td &gt;51&lt;/td&gt;&lt;td &gt;52&lt;/td&gt;&lt;/tr&gt;&lt;tr &gt;&lt;td &gt;65&lt;/td&gt;&lt;td &gt;67&lt;/td&gt;&lt;td &gt;68&lt;/td&gt;&lt;td &gt;69&lt;/td&gt;&lt;td &gt;63&lt;/td&gt;&lt;/tr&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;\"</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p><code>_.template(data_name, template_structure)</code> 함수는 두개의 인자를 받아서 함수를 반환한다. 이 함수는 데이터를 받아 html 태그 문자열을 만든다. 처음에 <code>_.template</code> 함수가 받는 두개의 인자는 각각 태그를 그릴 때 사용할 ‘데이터의 이름’과 ‘템플릿의 구조’를 받는다. 데이터의 이름은 템플릿의 구조에서 <code>&#123;&#123;&#125;&#125;</code> 안에서 그려질 태그 문자열에 반영될 데이터의 이름이다. 템플릿 구조 안에서 이중 중괄호 안은 자바스크립트의 영역이다. 자세한 내용은 <a href=\"https://marpple.github.io/partial.js/#함수-스타일의-템플릿-함수\" target=\"_blank\" rel=\"noopener\">Partial.js의 문서</a>를 참고하면 된다.</p>\n<p>참고: <code>_.template.each</code> 함수는 템플릿을 반복적으로 그려야할 때 사용한다. 템플릿의 구조를 정의하기 위해 사용된 역따옴표는 ES6부터 개행이 포함된 문자열을 담을때 사용한다. ES5에서는 개행 전에 역슬래시가 포함되어야 한다.</p>\n<h4 id=\"필요한-함수를-조립한다\"><a href=\"#필요한-함수를-조립한다\" class=\"headerlink\" title=\"필요한 함수를 조립한다.\"></a>필요한 함수를 조립한다.</h4><p>DOM에 그려질 View를 만들기 위한 작업은 어느정도 되었다. 이제 함수를 조립해서 실제로 사용할 함수를 만들자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> make_bingo_table = _.pipe(_.unzip, table_template, D.el);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> make_user_board = _.pipe(make_user_data, make_bingo_table, D.appendTo(<span class=\"string\">'.user_board'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> make_admin_board = _.pipe(make_bingo, make_bingo_table, D.appendTo(<span class=\"string\">'.admin_board'</span>));</span><br></pre></td></tr></table></figure>\n\n<p>세개의 함수가 준비되었다. <code>make_user_board(base_arr)</code>의 형태로 사용하면 user_board를 클래스로 갖는 DOM 엘리먼트에 기대했던 빙고판이 붙는다. 여기서 사용된 <code>D</code>를 네임스페이스로 갖는 함수는 <a href=\"https://rawgit.com/joeunha/bingo/master/docs/js/don.js\" target=\"_blank\" rel=\"noopener\">Don.js</a>라는 라이브러리가 가진 함수들이다. 사용법은 jQuery와 같은데 메서드로 사용하지 않고 함수로 사용한다는 점만 다르다. 덕분에 더욱 우아한 함수형 코드가 작성 가능하다. </p>\n<h3 id=\"맺음\"><a href=\"#맺음\" class=\"headerlink\" title=\"맺음\"></a>맺음</h3><p>전체 코드는 아래와 같다. 다음 글에서 Control 부분을 완성할 예정이다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> base_arr = [], i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (++i &lt; <span class=\"number\">76</span>) base_arr.push(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find_idx</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">15</span>) i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">30</span>) i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">45</span>) i = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">60</span>) i = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make_bingo</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = find_idx(n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o[i].push(n), o;</span><br><span class=\"line\">  &#125;, [[],[],[],[],[]])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reduce_first_5</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">l, v, i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l[i] = _.first(v, <span class=\"number\">5</span>), l;</span><br><span class=\"line\">  &#125;, [])</span><br><span class=\"line\">&#125; <span class=\"comment\">// var reduce_first_5 = _.reduce((l, v, i) =&gt; (l[i] = _.first(v, 5), l), []);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make_user_data</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> rand_arr = _.shuffle(arr);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce_first_5(make_bingo(rand_arr));</span><br><span class=\"line\">&#125; <span class=\"comment\">// var make_user_board = _.pipe(_.shuffle, make_bingo, reduce_first_5);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> table_template = _.template(<span class=\"string\">'data'</span>, <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    table</span></span><br><span class=\"line\"><span class=\"string\">      tr</span></span><br><span class=\"line\"><span class=\"string\">        th B</span></span><br><span class=\"line\"><span class=\"string\">        th I</span></span><br><span class=\"line\"><span class=\"string\">        th N</span></span><br><span class=\"line\"><span class=\"string\">        th G</span></span><br><span class=\"line\"><span class=\"string\">        th O &#123;&#123; _.go(data, `</span>, _.template.each(<span class=\"string\">'d1'</span>, <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      tr &#123;&#123; _.go(d1, `</span>, _.template.each(<span class=\"string\">'d2'</span>,<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        td &#123;&#123;d2&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      `</span>),<span class=\"string\">`)&#125;&#125;`</span>),</span><br><span class=\"line\">  <span class=\"string\">`)&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">  `</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> make_bingo_table = _.pipe(_.unzip, table_template, D.el);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> make_user_board = _.pipe(make_user_data, make_bingo_table, D.appendTo(<span class=\"string\">'.user_board'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> make_admin_board = _.pipe(make_bingo, make_bingo_table, D.appendTo(<span class=\"string\">'.admin_board'</span>));</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><em>(의식의 흐름대로) 미니 게임을 만들어보자!</em></p>\n<h2 id=\"BINGO-2-View\"><a href=\"#BINGO-2-View\" class=\"headerlink\" title=\"BINGO[2] - View\"></a>BINGO[2] - View</h2><p>숫자 데이터(배열)를 만들어서 DOM에 그리기까지</p>\n<h3 id=\"빙고판-데이터-만들기\"><a href=\"#빙고판-데이터-만들기\" class=\"headerlink\" title=\"빙고판 데이터 만들기\"></a>빙고판 데이터 만들기</h3><p>75개의 숫자(1~75) 중에서 25개의 숫자를 임의로 선택해서 5x5 크기의 판을 만들어보자.</p>\n<h4 id=\"1부터-75까지-담고-있는-배열을-만든다\"><a href=\"#1부터-75까지-담고-있는-배열을-만든다\" class=\"headerlink\" title=\"1부터 75까지 담고 있는 배열을 만든다.\"></a>1부터 75까지 담고 있는 배열을 만든다.</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> base_arr = [], i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (++i &lt; <span class=\"number\">76</span>) base_arr.push(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Partial.js의 함수들을 사용하면 아래와 같이 할 수 있다.</span></span><br><span class=\"line\"><span class=\"comment\">// var base_arr = _.go(76, _.range, _.rest);</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"빙고판을-만들어줄-함수를-만든다\"><a href=\"#빙고판을-만들어줄-함수를-만든다\" class=\"headerlink\" title=\"빙고판을 만들어줄 함수를 만든다.\"></a>빙고판을 만들어줄 함수를 만든다.</h4><p>다섯개의 배열(B, I, N, G, O 에 해당하는 배열)을 값으로 갖는 배열을 만들어야 하는데, 이때 숫자들은 15개씩 각 배열에 속해야 함으로 적절한 위치를 찾아주는 함수가 필요하다. (물론 순서대로 넣어주면 되지만 랜덤한 숫자일 필요가 있기 때문에 위치를 찾아주는 수고가 필요하다.)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find_idx</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">15</span>) i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">30</span>) i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">45</span>) i = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">60</span>) i = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>위의 함수를 이용해서 다섯개의 배열을 값으로 갖는 배열을 만드는 함수를 만든다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make_bingo</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = find_idx(n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o[i].push(n), o;</span><br><span class=\"line\">    &#125;, [[],[],[],[],[]])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Partial.js의 함수는 커링을 지원한다. </span></span><br><span class=\"line\"><span class=\"comment\">// 첫번째 인자를 제외한 인자가 들어오면 동작할 준비가 된 함수를 반환한다.</span></span><br><span class=\"line\"><span class=\"comment\">// var make_bingo2 = _.reduce(</span></span><br><span class=\"line\"><span class=\"comment\">//  (o, n) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     var i = find_idx(n);</span></span><br><span class=\"line\"><span class=\"comment\">//     return o[i] = o[i].concat(n), o;</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;, [[],[],[],[],[]]);</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"상황판에-해당하는-배열과-빙고판에-해당하는-배열을-만드는-함수를-만든다\"><a href=\"#상황판에-해당하는-배열과-빙고판에-해당하는-배열을-만드는-함수를-만든다\" class=\"headerlink\" title=\"상황판에 해당하는 배열과 빙고판에 해당하는 배열을 만드는 함수를 만든다.\"></a>상황판에 해당하는 배열과 빙고판에 해당하는 배열을 만드는 함수를 만든다.</h4><p>사실 위의 <code>make_bingo</code>는 5x5의 빙고판을 만들어주지 않는다. 길이가 15인 배열 5개를 가진 배열을 만들 뿐이다. 이렇게 만들어진 판은 게임에 참가하는 유저에게 주어지는 판이 아니라 게임 진행 상황을 확인할 수 있는 상황판이 된다. 이제 실제 유저가 사용할 수 있는 진짜 5x5 빙고판을 만들어보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make_user_data</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> rand_arr = _.shuffle(arr);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> make_bingo(rand_arr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = make_user_data(base_arr);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result[<span class=\"number\">0</span>]); <span class=\"comment\">// 순서가 섞인 배열 (B의 범위에 속하는 배열)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result[<span class=\"number\">0</span>].length); <span class=\"comment\">// 15</span></span><br></pre></td></tr></table></figure>\n\n<p><code>_.shuffle</code> 함수 덕분에 순서가 섞인 배열을 얻게 되었지만 여전히 배열이 너무 길다. 줄여보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reduce_first_5</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">l, v, i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l[i] = _.first(v, <span class=\"number\">5</span>), l;</span><br><span class=\"line\">  &#125;, [])</span><br><span class=\"line\">&#125; <span class=\"comment\">// var reduce_first_5 = _.reduce((l, v, i) =&gt; (l[i] = _.first(v, 5), l), []);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make_user_data</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> rand_arr = _.shuffle(arr);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce_first_5(make_bingo(rand_arr));</span><br><span class=\"line\">&#125; <span class=\"comment\">// var make_user_data = _.pipe(_.shuffle, make_bingo, reduce_first_5);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> user_data = make_user_data(base_arr);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user_data[<span class=\"number\">0</span>]); <span class=\"comment\">// 순서가 섞인 배열 (B의 범위에 속하는 배열)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user_data[<span class=\"number\">0</span>].length); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p><code>result</code>는 5개의 배열을 갖는 배열이며 각 배열의 길이는 5이다. 그리고 각 배열은 임의의 순서가 섞여 있다. 이 상태를 5x5 빙고판의 데이터라고 보자. (`make_user_data``라는 함수를 이용하면 매번 새로운 빙고판 데이터를 만들 수 있다.)</p>\n<h3 id=\"데이터를-이용해서-빙고판-그리기\"><a href=\"#데이터를-이용해서-빙고판-그리기\" class=\"headerlink\" title=\"데이터를 이용해서 빙고판 그리기\"></a>데이터를 이용해서 빙고판 그리기</h3><p>결국 게임을 진행하려면 DOM에 만든 배열을 그려야하는데, 어떻게 그려야할까. 우선 그려질 숫자를 적어 넣을 판을 먼저 만들어야 한다.</p>\n<h4 id=\"html-table-태그-문자열을-만든다\"><a href=\"#html-table-태그-문자열을-만든다\" class=\"headerlink\" title=\"html table 태그 문자열을 만든다.\"></a>html table 태그 문자열을 만든다.</h4><p>DOM에 그려질 html 태그를 괄호까지 직접 타이핑하는 것은 너무 번거로운 일이다. 그래서 대부분은 <a href=\"https://pugjs.org/api/getting-started.html\" target=\"_blank\" rel=\"noopener\">pug</a>, <a href=\"http://www.embeddedjs.com/\" target=\"_blank\" rel=\"noopener\">ejs</a>, <a href=\"http://handlebarsjs.com/\" target=\"_blank\" rel=\"noopener\">handlebars</a> 같은 템플릿 엔진을 사용한다. 이와 같은 도구는 값에 따라 다른 태그를 유동적으로 작성해야할 때 매우 유용한데, Partial.js에서는 <code>_.template</code> 함수가 이와 같은 일을 한다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> table_template = _.template(<span class=\"string\">'data'</span>, <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        table </span></span><br><span class=\"line\"><span class=\"string\">          tr</span></span><br><span class=\"line\"><span class=\"string\">            th B</span></span><br><span class=\"line\"><span class=\"string\">            th I</span></span><br><span class=\"line\"><span class=\"string\">            th N</span></span><br><span class=\"line\"><span class=\"string\">            th G</span></span><br><span class=\"line\"><span class=\"string\">            th O &#123;&#123; _.go(data, `</span>, _.template.each(<span class=\"string\">'d1'</span>, <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">          tr &#123;&#123; _.go(d1, `</span>, _.template.each(<span class=\"string\">'d2'</span>,<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">            td &#123;&#123;d2&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">          `</span>),<span class=\"string\">`)&#125;&#125;`</span>),</span><br><span class=\"line\">        <span class=\"string\">`)&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      `</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">table_template(user_board);</span><br><span class=\"line\"><span class=\"comment\">/* 출력 결과</span></span><br><span class=\"line\"><span class=\"comment\">\"&lt;table &gt;&lt;tr &gt;&lt;th &gt;B&lt;/th&gt;&lt;th &gt;I&lt;/th&gt;&lt;th &gt;N&lt;/th&gt;&lt;th &gt;G&lt;/th&gt;&lt;th &gt;O &lt;tr &gt;&lt;td &gt;10&lt;/td&gt;&lt;td &gt;7&lt;/td&gt;&lt;td &gt;5&lt;/td&gt;&lt;td &gt;4&lt;/td&gt;&lt;td &gt;8&lt;/td&gt;&lt;/tr&gt;&lt;tr &gt;&lt;td &gt;28&lt;/td&gt;&lt;td &gt;20&lt;/td&gt;&lt;td &gt;30&lt;/td&gt;&lt;td &gt;16&lt;/td&gt;&lt;td &gt;26&lt;/td&gt;&lt;/tr&gt;&lt;tr &gt;&lt;td &gt;33&lt;/td&gt;&lt;td &gt;41&lt;/td&gt;&lt;td &gt;45&lt;/td&gt;&lt;td &gt;42&lt;/td&gt;&lt;td &gt;32&lt;/td&gt;&lt;/tr&gt;&lt;tr &gt;&lt;td &gt;47&lt;/td&gt;&lt;td &gt;59&lt;/td&gt;&lt;td &gt;50&lt;/td&gt;&lt;td &gt;51&lt;/td&gt;&lt;td &gt;52&lt;/td&gt;&lt;/tr&gt;&lt;tr &gt;&lt;td &gt;65&lt;/td&gt;&lt;td &gt;67&lt;/td&gt;&lt;td &gt;68&lt;/td&gt;&lt;td &gt;69&lt;/td&gt;&lt;td &gt;63&lt;/td&gt;&lt;/tr&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;\"</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p><code>_.template(data_name, template_structure)</code> 함수는 두개의 인자를 받아서 함수를 반환한다. 이 함수는 데이터를 받아 html 태그 문자열을 만든다. 처음에 <code>_.template</code> 함수가 받는 두개의 인자는 각각 태그를 그릴 때 사용할 ‘데이터의 이름’과 ‘템플릿의 구조’를 받는다. 데이터의 이름은 템플릿의 구조에서 <code>&#123;&#123;&#125;&#125;</code> 안에서 그려질 태그 문자열에 반영될 데이터의 이름이다. 템플릿 구조 안에서 이중 중괄호 안은 자바스크립트의 영역이다. 자세한 내용은 <a href=\"https://marpple.github.io/partial.js/#함수-스타일의-템플릿-함수\" target=\"_blank\" rel=\"noopener\">Partial.js의 문서</a>를 참고하면 된다.</p>\n<p>참고: <code>_.template.each</code> 함수는 템플릿을 반복적으로 그려야할 때 사용한다. 템플릿의 구조를 정의하기 위해 사용된 역따옴표는 ES6부터 개행이 포함된 문자열을 담을때 사용한다. ES5에서는 개행 전에 역슬래시가 포함되어야 한다.</p>\n<h4 id=\"필요한-함수를-조립한다\"><a href=\"#필요한-함수를-조립한다\" class=\"headerlink\" title=\"필요한 함수를 조립한다.\"></a>필요한 함수를 조립한다.</h4><p>DOM에 그려질 View를 만들기 위한 작업은 어느정도 되었다. 이제 함수를 조립해서 실제로 사용할 함수를 만들자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> make_bingo_table = _.pipe(_.unzip, table_template, D.el);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> make_user_board = _.pipe(make_user_data, make_bingo_table, D.appendTo(<span class=\"string\">'.user_board'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> make_admin_board = _.pipe(make_bingo, make_bingo_table, D.appendTo(<span class=\"string\">'.admin_board'</span>));</span><br></pre></td></tr></table></figure>\n\n<p>세개의 함수가 준비되었다. <code>make_user_board(base_arr)</code>의 형태로 사용하면 user_board를 클래스로 갖는 DOM 엘리먼트에 기대했던 빙고판이 붙는다. 여기서 사용된 <code>D</code>를 네임스페이스로 갖는 함수는 <a href=\"https://rawgit.com/joeunha/bingo/master/docs/js/don.js\" target=\"_blank\" rel=\"noopener\">Don.js</a>라는 라이브러리가 가진 함수들이다. 사용법은 jQuery와 같은데 메서드로 사용하지 않고 함수로 사용한다는 점만 다르다. 덕분에 더욱 우아한 함수형 코드가 작성 가능하다. </p>\n<h3 id=\"맺음\"><a href=\"#맺음\" class=\"headerlink\" title=\"맺음\"></a>맺음</h3><p>전체 코드는 아래와 같다. 다음 글에서 Control 부분을 완성할 예정이다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> base_arr = [], i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (++i &lt; <span class=\"number\">76</span>) base_arr.push(i);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find_idx</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">15</span>) i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">30</span>) i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">45</span>) i = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">60</span>) i = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make_bingo</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o, n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = find_idx(n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o[i].push(n), o;</span><br><span class=\"line\">  &#125;, [[],[],[],[],[]])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reduce_first_5</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">l, v, i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l[i] = _.first(v, <span class=\"number\">5</span>), l;</span><br><span class=\"line\">  &#125;, [])</span><br><span class=\"line\">&#125; <span class=\"comment\">// var reduce_first_5 = _.reduce((l, v, i) =&gt; (l[i] = _.first(v, 5), l), []);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make_user_data</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> rand_arr = _.shuffle(arr);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce_first_5(make_bingo(rand_arr));</span><br><span class=\"line\">&#125; <span class=\"comment\">// var make_user_board = _.pipe(_.shuffle, make_bingo, reduce_first_5);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> table_template = _.template(<span class=\"string\">'data'</span>, <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    table</span></span><br><span class=\"line\"><span class=\"string\">      tr</span></span><br><span class=\"line\"><span class=\"string\">        th B</span></span><br><span class=\"line\"><span class=\"string\">        th I</span></span><br><span class=\"line\"><span class=\"string\">        th N</span></span><br><span class=\"line\"><span class=\"string\">        th G</span></span><br><span class=\"line\"><span class=\"string\">        th O &#123;&#123; _.go(data, `</span>, _.template.each(<span class=\"string\">'d1'</span>, <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      tr &#123;&#123; _.go(d1, `</span>, _.template.each(<span class=\"string\">'d2'</span>,<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        td &#123;&#123;d2&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      `</span>),<span class=\"string\">`)&#125;&#125;`</span>),</span><br><span class=\"line\">  <span class=\"string\">`)&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">  `</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> make_bingo_table = _.pipe(_.unzip, table_template, D.el);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> make_user_board = _.pipe(make_user_data, make_bingo_table, D.appendTo(<span class=\"string\">'.user_board'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> make_admin_board = _.pipe(make_bingo, make_bingo_table, D.appendTo(<span class=\"string\">'.admin_board'</span>));</span><br></pre></td></tr></table></figure>"},{"title":"나와 같다면 - 어쩌다 개발자","date":"2017-04-14T13:45:08.000Z","_content":"\n##### '나와 같다면' 시리즈 소개\n  _'그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼'_ 김연우씨가 불러서 더 유명한 노래 '나와 같다면'에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.\n\n* * *\n\n## 어쩌다 개발자\n\n### 나는 문과생이었다\n나는 수학 시험이 싫었다. 문제를 푸는 것은 제법 재미 있었지만 응용 문제를 제한된 시간 안에 풀어야한다는 그 압박감이 너무 싫었다. 그래서 문과를 선택했다. 문학이 좋기도 했다. 물론 빨리 정답을 찾아야하는 것은 그리 문학스럽지 못했지만 그정도는 눈치로 풀 수 있었다. 수학은 눈치로 되는 게 아니었다. 수학은 시간이 더 필요한 과목이었다. 결국 내가 문과를 선택한 것은 시험에서 유리해지기 위함이었다. 이유야 어찌되었건 나는 문과를 선택했고 문과생으로 대학을 진학했다.\n\n대학 1년을 마치고 군대를 갔다 왔다. 다들 그러하듯 냉정하게 현실을 바라보게 된 나는 내가 다니는 학교에선 원했던 공부를 할 수 없다는 생각이 들었다. 편입할 자신은 없었다. 전과가 자유로운 학교의 특성을 활용해야겠다고 생각했다. 전공 탐색을 위해 교양으로 들을 수 있는 타 전공 과목을 듣기 시작했다. 그 중 하나였던 'C 프로그래밍'이라는 수업을 들으며 컴퓨터 공학으로의 전과를 생각할 수 있었다. 아마 그때부터였던거 같다. __프로그래밍은 문과스러운 점이 많다는 것__을 깨달았던 순간이.\n\n### 컴퓨터의 언어를 배우다\n사실 컴퓨터 언어를 배운다는 건 그리 쉽지만은 않은 일이다. 많은 이유가 있겠지만 우선 어딘가 공대스럽다는 느낌 때문이다. 수학은 공대생, 문학은 인문대생의 전유물로 생각되는 것처럼 컴퓨터 언어 역시 공대생들의 전유물로 여겨지기에 뭔가 본래의 난이도 이상으로 어렵게 와닿는다. 나와 같은 문과생들에게는 더욱이 그렇다. 나 역시 두려웠다. 그래서 학원을 다녔다. \n\n교양 수업을 듣기 전(여름 방학), 학원을 등록했다. 학원에서 이해할 수 있었던 것은 이틀째까지였다. 이후로는 무슨 소린지 전혀 알지 못했다. 따지고 보면 첫날은 설치만 했으니 하루정도만 이해한 것이다. 그 후로 이해는 없었다. 직전 학기에 이미 학교에서 수업을 듣고 재이수를 위해 학원을 찾은 동기들과 수준 차이도 엄청났다. 그때 나는 내가 바보인줄 알았다. 그냥 이런 저런 단어들만 머리를 스쳐지나갔다. \n\n개강은 여지없이 찾아왔고 C 프로그래밍 수업도 시작되었다. 놀라운 점은 방학 때 들었던(스쳐지나간 줄 알았던) 단어만으로 수업을 따라갈 수 있었다는 점이다. 예를 들면 '배열'이라는 단어가 이 수업에서 어떻게 쓰일 것인지 예상하고 있는 것만으로 수업은 아주 흥미로워졌고 다른 친구들보다 수업에 빠르게 적응할 수 있었다. 비록 교수님이 래퍼라 불릴 정도로 엄청난 속도로 단어들을 내뱉더라도 나는 그 단어를 이해할 수 있었다. 마치 가사를 보고 랩을 듣는 기분이었다. 수업을 이해하니 과제도 재미있었다. 그때 과제를 푼다고 10시간씩 코딩했다. 지금보면 정말 아무것도 아닌 버스 요금 계산하는 어플리케이션을 며칠을 고민해서 만들었다. 내 코드가 정상적으로 동작하는 그 순간의 짜릿함을 맛봤다. 그때 코딩에 빠져들게 되었다.\n\n이 과정에서 __새로운 학문을 배우는 일은 그 학문에서 사용하는 단어를 이해하고 알아가는 것__이며, 컴퓨터 언어를 배우는 것 역시 마찬가지라는 점을 깨닫게 되었다. 결국 컴퓨터 언어를 배워서 코드를 작성하는 프로그래밍이라는 것도 그에 필요한 언어들을 배우고 익혀가면 누구나 할 수 있다는 생각이 들었다.\n\n### 문과스러운 프로그래밍\n굳이 프로그래밍이 문과스럽다고 표현한 것은 프로그래밍이 글쓰기와 유사하고 생각했기 때문이다. 글쓰기를 먼저 살펴보자면 글쓰기는 글이라는 것을 작성(쓰기)하는 행위이다. 글이라는 것은 어떠한 목적을 가지며 소설과 같은 문학적인 글이 아닌 유형의 글(객관적 사실을 전달하는 글, 생각과 주장을 전달하는 글)의 경우는 글을 통해 전달하고자 하는 정보가 분명하다. 그러한 글을 쓰기 위해서는 논리라는 것이 필요하다. 이제 프로그래밍을 살펴보면 프로그래밍이라는 것은 프로그램을 만드는 행위, 보다 구체적으로 말하면 프로그램을 정의하는 코드를 작성하는 행위이다. 코드 역시 어떠한 목적을 달성하기 위해 작성되며 논리가 필요하다. 결국 글쓰기와 프로그래밍은 어떤 목적을 이루기 위해 __논리적으로__ 글 혹은 코드를 __작성하는 행위__라는 점에서 유사하다.\n\n예를 들어 조건문이라는 것을 보면 이해가 될 것 같다. 문자 그대로 조건을 정의하는 구문이다. 이렇게 생겼다. `if a > b: do_something()` 해석해보면 '만약에 a가 b보다 크면, 무엇인가 해라'는 뜻이다. 프로그래밍을 하는 중에는 이와 유사한 조건문이 수시로 등장한다. 그리고 이러한 조건에 비교를 위해 사용되는 값이 변경되거나 새로 만들어지면서 프로그램이라는 것이 완성된다. 반복문이라는 녀석도 있다. 어떠한 일을 반복적으로 처리하는 문장 구조인데 그 반복적인 일에도 논리가 존재한다. `while a > b: say_hello()` 조건문과 유사하지만 단어가 `if`에서 `while`로 바뀌었다. 의미도 그만큼 바뀐다. 'a가 b보다 큰 동안에, 인사를 해라'는 된다. 물론 `do_something`이 `say_hello`로 바뀌었지만 큰 맥락에서 바뀐 것은 '무엇을'이 아니라 '어떻게'가 바뀐 것이다. 어떤 행동을 논리적으로 어떻게 할 것인지 조건문, 반복문이 정의할 수 있다. 제법 글쓰기와 비슷하다. \n\n### 개발자라는 직업\n이렇게 프로그래밍의 문과스러운 면모를 확인하자 개발자라는 직업을 진지하게 고민하게 되었다. 미래는 [직장인이 아니라 직업인의 시대라는 생각](/view-of-value/like-me-1/)을 가지고 있었기에 더욱 개발자라는 업(業)은 매력적으로 느껴졌다. 유일한 걸림돌은 내가 개발자가 될 수 있는가 하는 것이었다. 개발자 자체는 근사하고 좋은데 과연 문과 출신에 수포자인 내가 개발자가 될 수 있을까? 이러한 나의 고민에 용기를 준 것은 [생활코딩](https://opentutorials.org/course/1)의 운영자인 이고잉님이었다. 국문과 출신의 이고잉님이 일반인들에게 프로그래밍을 알려주고 있는 모습을 보고 나도 할 수 있다는 막연한 믿음이 생긴 것이다. 그 뒤로 생활코딩을 비롯한 온라인 강의를 찾아보며 공부를 시작했다. 학교에선 배우지 못한 웹 개발에 관한 것이었다. 블로그도 그때부터 시작했다. 워드프레스를 기반으로 만든 블로그는 자바스크립트를 공부하는 내용을 담았다. \n\n운 좋게도 졸업한 선배의 특강을 들으러 갔다가 스타트업에 인턴으로 일할 수 있는 기회도 얻었다. 역삼에 있는 사무실에서 6개월동안 일하면서 Angular와 Ionic Framework를 이용해 웹 앱을 개발했다. 고시텔 생활이었지만 내가 개발자로서 일할 수 있다는 사실에 감사해서 불편한지도 모르고 살았다. 10시에 출근해서 10시에 퇴근했다. 주말도 반납했다. 개발이 나의 유일한 놀이였으며 즐거움이었다. 그렇게 만든 서비스가 앱으로 출시되어 그렇다할 성과를 내지 못하고 잊혀졌음에도 불구하고 스스로 뿌듯하고 감사한 시간이었다. 6개월의 일을 마치고 학교로 돌아왔을 때는 자신감이 붙어있었다. 개발자로 일할 수 있다는 확신이 생겼다. 블로그를 정비하고 로켓펀치에 나의 경험을 정리해두었다. \n\n그리 오래 지나지 않아서 취업 전선에 뛰어들었다. 친구들과 코딩 테스트를 준비하는 모임도 만들었고 나름대로 체계적으로 공부를 진행했다. 졸업을 앞둔 5월의 어느날 메일을 한통 받았다. 로켓펀치를 통해 연락을 준 것이다. 몇가지 이야기가 오갔고 당장 면접을 보기 위해 올라갔다. 지금의 회사가 바로 그 회사다. 이 회사는 내가 개발자로 제대로 시작할 환경을 만들어주었고 자바스크립트에 고수가 되도록 해주었다. 특히 함수형 프로그래밍이라는 패러다임에 눈 뜰 수 있게 해주었다. 한동안 연재하던 ['오늘의 함수' 시리즈](/tags/오늘의-함수/)도 이 회사에서 배운 것들 덕분에 가능한 글이었다. 1년이 지났을 때 성장한 자신을 느낄 수 있었고 [1주년 회고록](/view-of-value/1-year-anniversary/)도 적게 되었다. 이제는 스스로 개발자라고 부를 수 있다.\n\n### 나는 개발자다\n이 글은 애초에 문과 출신에게 용기를 주기 위해 시작한 글이다. 프로그래밍이 문과생에게 오히려 이점이 있는 부분이 있다는 것을 이야기하고 싶었다. 논리적으로 글을 읽고 쓸 수 있는 능력이 있다면 코드를 작성할 수 있다. 오히려 창의적인 코드가 인문학적 소양을 갖춘 이들에게서 나올 수 있다. 정말 작은 용기가 있다면 할 수 있다. 어느날 스스로를 개발자라고 부르게 될 날이 올 것이다. 오늘 포기하지 않는다면.","source":"_posts/like-me-2.md","raw":"---\ntitle: '나와 같다면 - 어쩌다 개발자'\ncategories:\n  - view of value\ntags:\n  - opinion\n  - 나와 같다면\ndate: 2017-04-14 22:45:08\n---\n\n##### '나와 같다면' 시리즈 소개\n  _'그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼'_ 김연우씨가 불러서 더 유명한 노래 '나와 같다면'에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.\n\n* * *\n\n## 어쩌다 개발자\n\n### 나는 문과생이었다\n나는 수학 시험이 싫었다. 문제를 푸는 것은 제법 재미 있었지만 응용 문제를 제한된 시간 안에 풀어야한다는 그 압박감이 너무 싫었다. 그래서 문과를 선택했다. 문학이 좋기도 했다. 물론 빨리 정답을 찾아야하는 것은 그리 문학스럽지 못했지만 그정도는 눈치로 풀 수 있었다. 수학은 눈치로 되는 게 아니었다. 수학은 시간이 더 필요한 과목이었다. 결국 내가 문과를 선택한 것은 시험에서 유리해지기 위함이었다. 이유야 어찌되었건 나는 문과를 선택했고 문과생으로 대학을 진학했다.\n\n대학 1년을 마치고 군대를 갔다 왔다. 다들 그러하듯 냉정하게 현실을 바라보게 된 나는 내가 다니는 학교에선 원했던 공부를 할 수 없다는 생각이 들었다. 편입할 자신은 없었다. 전과가 자유로운 학교의 특성을 활용해야겠다고 생각했다. 전공 탐색을 위해 교양으로 들을 수 있는 타 전공 과목을 듣기 시작했다. 그 중 하나였던 'C 프로그래밍'이라는 수업을 들으며 컴퓨터 공학으로의 전과를 생각할 수 있었다. 아마 그때부터였던거 같다. __프로그래밍은 문과스러운 점이 많다는 것__을 깨달았던 순간이.\n\n### 컴퓨터의 언어를 배우다\n사실 컴퓨터 언어를 배운다는 건 그리 쉽지만은 않은 일이다. 많은 이유가 있겠지만 우선 어딘가 공대스럽다는 느낌 때문이다. 수학은 공대생, 문학은 인문대생의 전유물로 생각되는 것처럼 컴퓨터 언어 역시 공대생들의 전유물로 여겨지기에 뭔가 본래의 난이도 이상으로 어렵게 와닿는다. 나와 같은 문과생들에게는 더욱이 그렇다. 나 역시 두려웠다. 그래서 학원을 다녔다. \n\n교양 수업을 듣기 전(여름 방학), 학원을 등록했다. 학원에서 이해할 수 있었던 것은 이틀째까지였다. 이후로는 무슨 소린지 전혀 알지 못했다. 따지고 보면 첫날은 설치만 했으니 하루정도만 이해한 것이다. 그 후로 이해는 없었다. 직전 학기에 이미 학교에서 수업을 듣고 재이수를 위해 학원을 찾은 동기들과 수준 차이도 엄청났다. 그때 나는 내가 바보인줄 알았다. 그냥 이런 저런 단어들만 머리를 스쳐지나갔다. \n\n개강은 여지없이 찾아왔고 C 프로그래밍 수업도 시작되었다. 놀라운 점은 방학 때 들었던(스쳐지나간 줄 알았던) 단어만으로 수업을 따라갈 수 있었다는 점이다. 예를 들면 '배열'이라는 단어가 이 수업에서 어떻게 쓰일 것인지 예상하고 있는 것만으로 수업은 아주 흥미로워졌고 다른 친구들보다 수업에 빠르게 적응할 수 있었다. 비록 교수님이 래퍼라 불릴 정도로 엄청난 속도로 단어들을 내뱉더라도 나는 그 단어를 이해할 수 있었다. 마치 가사를 보고 랩을 듣는 기분이었다. 수업을 이해하니 과제도 재미있었다. 그때 과제를 푼다고 10시간씩 코딩했다. 지금보면 정말 아무것도 아닌 버스 요금 계산하는 어플리케이션을 며칠을 고민해서 만들었다. 내 코드가 정상적으로 동작하는 그 순간의 짜릿함을 맛봤다. 그때 코딩에 빠져들게 되었다.\n\n이 과정에서 __새로운 학문을 배우는 일은 그 학문에서 사용하는 단어를 이해하고 알아가는 것__이며, 컴퓨터 언어를 배우는 것 역시 마찬가지라는 점을 깨닫게 되었다. 결국 컴퓨터 언어를 배워서 코드를 작성하는 프로그래밍이라는 것도 그에 필요한 언어들을 배우고 익혀가면 누구나 할 수 있다는 생각이 들었다.\n\n### 문과스러운 프로그래밍\n굳이 프로그래밍이 문과스럽다고 표현한 것은 프로그래밍이 글쓰기와 유사하고 생각했기 때문이다. 글쓰기를 먼저 살펴보자면 글쓰기는 글이라는 것을 작성(쓰기)하는 행위이다. 글이라는 것은 어떠한 목적을 가지며 소설과 같은 문학적인 글이 아닌 유형의 글(객관적 사실을 전달하는 글, 생각과 주장을 전달하는 글)의 경우는 글을 통해 전달하고자 하는 정보가 분명하다. 그러한 글을 쓰기 위해서는 논리라는 것이 필요하다. 이제 프로그래밍을 살펴보면 프로그래밍이라는 것은 프로그램을 만드는 행위, 보다 구체적으로 말하면 프로그램을 정의하는 코드를 작성하는 행위이다. 코드 역시 어떠한 목적을 달성하기 위해 작성되며 논리가 필요하다. 결국 글쓰기와 프로그래밍은 어떤 목적을 이루기 위해 __논리적으로__ 글 혹은 코드를 __작성하는 행위__라는 점에서 유사하다.\n\n예를 들어 조건문이라는 것을 보면 이해가 될 것 같다. 문자 그대로 조건을 정의하는 구문이다. 이렇게 생겼다. `if a > b: do_something()` 해석해보면 '만약에 a가 b보다 크면, 무엇인가 해라'는 뜻이다. 프로그래밍을 하는 중에는 이와 유사한 조건문이 수시로 등장한다. 그리고 이러한 조건에 비교를 위해 사용되는 값이 변경되거나 새로 만들어지면서 프로그램이라는 것이 완성된다. 반복문이라는 녀석도 있다. 어떠한 일을 반복적으로 처리하는 문장 구조인데 그 반복적인 일에도 논리가 존재한다. `while a > b: say_hello()` 조건문과 유사하지만 단어가 `if`에서 `while`로 바뀌었다. 의미도 그만큼 바뀐다. 'a가 b보다 큰 동안에, 인사를 해라'는 된다. 물론 `do_something`이 `say_hello`로 바뀌었지만 큰 맥락에서 바뀐 것은 '무엇을'이 아니라 '어떻게'가 바뀐 것이다. 어떤 행동을 논리적으로 어떻게 할 것인지 조건문, 반복문이 정의할 수 있다. 제법 글쓰기와 비슷하다. \n\n### 개발자라는 직업\n이렇게 프로그래밍의 문과스러운 면모를 확인하자 개발자라는 직업을 진지하게 고민하게 되었다. 미래는 [직장인이 아니라 직업인의 시대라는 생각](/view-of-value/like-me-1/)을 가지고 있었기에 더욱 개발자라는 업(業)은 매력적으로 느껴졌다. 유일한 걸림돌은 내가 개발자가 될 수 있는가 하는 것이었다. 개발자 자체는 근사하고 좋은데 과연 문과 출신에 수포자인 내가 개발자가 될 수 있을까? 이러한 나의 고민에 용기를 준 것은 [생활코딩](https://opentutorials.org/course/1)의 운영자인 이고잉님이었다. 국문과 출신의 이고잉님이 일반인들에게 프로그래밍을 알려주고 있는 모습을 보고 나도 할 수 있다는 막연한 믿음이 생긴 것이다. 그 뒤로 생활코딩을 비롯한 온라인 강의를 찾아보며 공부를 시작했다. 학교에선 배우지 못한 웹 개발에 관한 것이었다. 블로그도 그때부터 시작했다. 워드프레스를 기반으로 만든 블로그는 자바스크립트를 공부하는 내용을 담았다. \n\n운 좋게도 졸업한 선배의 특강을 들으러 갔다가 스타트업에 인턴으로 일할 수 있는 기회도 얻었다. 역삼에 있는 사무실에서 6개월동안 일하면서 Angular와 Ionic Framework를 이용해 웹 앱을 개발했다. 고시텔 생활이었지만 내가 개발자로서 일할 수 있다는 사실에 감사해서 불편한지도 모르고 살았다. 10시에 출근해서 10시에 퇴근했다. 주말도 반납했다. 개발이 나의 유일한 놀이였으며 즐거움이었다. 그렇게 만든 서비스가 앱으로 출시되어 그렇다할 성과를 내지 못하고 잊혀졌음에도 불구하고 스스로 뿌듯하고 감사한 시간이었다. 6개월의 일을 마치고 학교로 돌아왔을 때는 자신감이 붙어있었다. 개발자로 일할 수 있다는 확신이 생겼다. 블로그를 정비하고 로켓펀치에 나의 경험을 정리해두었다. \n\n그리 오래 지나지 않아서 취업 전선에 뛰어들었다. 친구들과 코딩 테스트를 준비하는 모임도 만들었고 나름대로 체계적으로 공부를 진행했다. 졸업을 앞둔 5월의 어느날 메일을 한통 받았다. 로켓펀치를 통해 연락을 준 것이다. 몇가지 이야기가 오갔고 당장 면접을 보기 위해 올라갔다. 지금의 회사가 바로 그 회사다. 이 회사는 내가 개발자로 제대로 시작할 환경을 만들어주었고 자바스크립트에 고수가 되도록 해주었다. 특히 함수형 프로그래밍이라는 패러다임에 눈 뜰 수 있게 해주었다. 한동안 연재하던 ['오늘의 함수' 시리즈](/tags/오늘의-함수/)도 이 회사에서 배운 것들 덕분에 가능한 글이었다. 1년이 지났을 때 성장한 자신을 느낄 수 있었고 [1주년 회고록](/view-of-value/1-year-anniversary/)도 적게 되었다. 이제는 스스로 개발자라고 부를 수 있다.\n\n### 나는 개발자다\n이 글은 애초에 문과 출신에게 용기를 주기 위해 시작한 글이다. 프로그래밍이 문과생에게 오히려 이점이 있는 부분이 있다는 것을 이야기하고 싶었다. 논리적으로 글을 읽고 쓸 수 있는 능력이 있다면 코드를 작성할 수 있다. 오히려 창의적인 코드가 인문학적 소양을 갖춘 이들에게서 나올 수 있다. 정말 작은 용기가 있다면 할 수 있다. 어느날 스스로를 개발자라고 부르게 될 날이 올 것이다. 오늘 포기하지 않는다면.","slug":"like-me-2","published":1,"updated":"2019-07-15T12:03:14.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9j2009vdirvo8dzjqy2","content":"<h5 id=\"‘나와-같다면’-시리즈-소개\"><a href=\"#‘나와-같다면’-시리즈-소개\" class=\"headerlink\" title=\"‘나와 같다면’ 시리즈 소개\"></a>‘나와 같다면’ 시리즈 소개</h5><p>  <em>‘그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼’</em> 김연우씨가 불러서 더 유명한 노래 ‘나와 같다면’에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.</p>\n<hr>\n<h2 id=\"어쩌다-개발자\"><a href=\"#어쩌다-개발자\" class=\"headerlink\" title=\"어쩌다 개발자\"></a>어쩌다 개발자</h2><h3 id=\"나는-문과생이었다\"><a href=\"#나는-문과생이었다\" class=\"headerlink\" title=\"나는 문과생이었다\"></a>나는 문과생이었다</h3><p>나는 수학 시험이 싫었다. 문제를 푸는 것은 제법 재미 있었지만 응용 문제를 제한된 시간 안에 풀어야한다는 그 압박감이 너무 싫었다. 그래서 문과를 선택했다. 문학이 좋기도 했다. 물론 빨리 정답을 찾아야하는 것은 그리 문학스럽지 못했지만 그정도는 눈치로 풀 수 있었다. 수학은 눈치로 되는 게 아니었다. 수학은 시간이 더 필요한 과목이었다. 결국 내가 문과를 선택한 것은 시험에서 유리해지기 위함이었다. 이유야 어찌되었건 나는 문과를 선택했고 문과생으로 대학을 진학했다.</p>\n<p>대학 1년을 마치고 군대를 갔다 왔다. 다들 그러하듯 냉정하게 현실을 바라보게 된 나는 내가 다니는 학교에선 원했던 공부를 할 수 없다는 생각이 들었다. 편입할 자신은 없었다. 전과가 자유로운 학교의 특성을 활용해야겠다고 생각했다. 전공 탐색을 위해 교양으로 들을 수 있는 타 전공 과목을 듣기 시작했다. 그 중 하나였던 ‘C 프로그래밍’이라는 수업을 들으며 컴퓨터 공학으로의 전과를 생각할 수 있었다. 아마 그때부터였던거 같다. <strong>프로그래밍은 문과스러운 점이 많다는 것</strong>을 깨달았던 순간이.</p>\n<h3 id=\"컴퓨터의-언어를-배우다\"><a href=\"#컴퓨터의-언어를-배우다\" class=\"headerlink\" title=\"컴퓨터의 언어를 배우다\"></a>컴퓨터의 언어를 배우다</h3><p>사실 컴퓨터 언어를 배운다는 건 그리 쉽지만은 않은 일이다. 많은 이유가 있겠지만 우선 어딘가 공대스럽다는 느낌 때문이다. 수학은 공대생, 문학은 인문대생의 전유물로 생각되는 것처럼 컴퓨터 언어 역시 공대생들의 전유물로 여겨지기에 뭔가 본래의 난이도 이상으로 어렵게 와닿는다. 나와 같은 문과생들에게는 더욱이 그렇다. 나 역시 두려웠다. 그래서 학원을 다녔다. </p>\n<p>교양 수업을 듣기 전(여름 방학), 학원을 등록했다. 학원에서 이해할 수 있었던 것은 이틀째까지였다. 이후로는 무슨 소린지 전혀 알지 못했다. 따지고 보면 첫날은 설치만 했으니 하루정도만 이해한 것이다. 그 후로 이해는 없었다. 직전 학기에 이미 학교에서 수업을 듣고 재이수를 위해 학원을 찾은 동기들과 수준 차이도 엄청났다. 그때 나는 내가 바보인줄 알았다. 그냥 이런 저런 단어들만 머리를 스쳐지나갔다. </p>\n<p>개강은 여지없이 찾아왔고 C 프로그래밍 수업도 시작되었다. 놀라운 점은 방학 때 들었던(스쳐지나간 줄 알았던) 단어만으로 수업을 따라갈 수 있었다는 점이다. 예를 들면 ‘배열’이라는 단어가 이 수업에서 어떻게 쓰일 것인지 예상하고 있는 것만으로 수업은 아주 흥미로워졌고 다른 친구들보다 수업에 빠르게 적응할 수 있었다. 비록 교수님이 래퍼라 불릴 정도로 엄청난 속도로 단어들을 내뱉더라도 나는 그 단어를 이해할 수 있었다. 마치 가사를 보고 랩을 듣는 기분이었다. 수업을 이해하니 과제도 재미있었다. 그때 과제를 푼다고 10시간씩 코딩했다. 지금보면 정말 아무것도 아닌 버스 요금 계산하는 어플리케이션을 며칠을 고민해서 만들었다. 내 코드가 정상적으로 동작하는 그 순간의 짜릿함을 맛봤다. 그때 코딩에 빠져들게 되었다.</p>\n<p>이 과정에서 <strong>새로운 학문을 배우는 일은 그 학문에서 사용하는 단어를 이해하고 알아가는 것</strong>이며, 컴퓨터 언어를 배우는 것 역시 마찬가지라는 점을 깨닫게 되었다. 결국 컴퓨터 언어를 배워서 코드를 작성하는 프로그래밍이라는 것도 그에 필요한 언어들을 배우고 익혀가면 누구나 할 수 있다는 생각이 들었다.</p>\n<h3 id=\"문과스러운-프로그래밍\"><a href=\"#문과스러운-프로그래밍\" class=\"headerlink\" title=\"문과스러운 프로그래밍\"></a>문과스러운 프로그래밍</h3><p>굳이 프로그래밍이 문과스럽다고 표현한 것은 프로그래밍이 글쓰기와 유사하고 생각했기 때문이다. 글쓰기를 먼저 살펴보자면 글쓰기는 글이라는 것을 작성(쓰기)하는 행위이다. 글이라는 것은 어떠한 목적을 가지며 소설과 같은 문학적인 글이 아닌 유형의 글(객관적 사실을 전달하는 글, 생각과 주장을 전달하는 글)의 경우는 글을 통해 전달하고자 하는 정보가 분명하다. 그러한 글을 쓰기 위해서는 논리라는 것이 필요하다. 이제 프로그래밍을 살펴보면 프로그래밍이라는 것은 프로그램을 만드는 행위, 보다 구체적으로 말하면 프로그램을 정의하는 코드를 작성하는 행위이다. 코드 역시 어떠한 목적을 달성하기 위해 작성되며 논리가 필요하다. 결국 글쓰기와 프로그래밍은 어떤 목적을 이루기 위해 <strong>논리적으로</strong> 글 혹은 코드를 <strong>작성하는 행위</strong>라는 점에서 유사하다.</p>\n<p>예를 들어 조건문이라는 것을 보면 이해가 될 것 같다. 문자 그대로 조건을 정의하는 구문이다. 이렇게 생겼다. <code>if a &gt; b: do_something()</code> 해석해보면 ‘만약에 a가 b보다 크면, 무엇인가 해라’는 뜻이다. 프로그래밍을 하는 중에는 이와 유사한 조건문이 수시로 등장한다. 그리고 이러한 조건에 비교를 위해 사용되는 값이 변경되거나 새로 만들어지면서 프로그램이라는 것이 완성된다. 반복문이라는 녀석도 있다. 어떠한 일을 반복적으로 처리하는 문장 구조인데 그 반복적인 일에도 논리가 존재한다. <code>while a &gt; b: say_hello()</code> 조건문과 유사하지만 단어가 <code>if</code>에서 <code>while</code>로 바뀌었다. 의미도 그만큼 바뀐다. ‘a가 b보다 큰 동안에, 인사를 해라’는 된다. 물론 <code>do_something</code>이 <code>say_hello</code>로 바뀌었지만 큰 맥락에서 바뀐 것은 ‘무엇을’이 아니라 ‘어떻게’가 바뀐 것이다. 어떤 행동을 논리적으로 어떻게 할 것인지 조건문, 반복문이 정의할 수 있다. 제법 글쓰기와 비슷하다. </p>\n<h3 id=\"개발자라는-직업\"><a href=\"#개발자라는-직업\" class=\"headerlink\" title=\"개발자라는 직업\"></a>개발자라는 직업</h3><p>이렇게 프로그래밍의 문과스러운 면모를 확인하자 개발자라는 직업을 진지하게 고민하게 되었다. 미래는 <a href=\"/view-of-value/like-me-1/\">직장인이 아니라 직업인의 시대라는 생각</a>을 가지고 있었기에 더욱 개발자라는 업(業)은 매력적으로 느껴졌다. 유일한 걸림돌은 내가 개발자가 될 수 있는가 하는 것이었다. 개발자 자체는 근사하고 좋은데 과연 문과 출신에 수포자인 내가 개발자가 될 수 있을까? 이러한 나의 고민에 용기를 준 것은 <a href=\"https://opentutorials.org/course/1\" target=\"_blank\" rel=\"noopener\">생활코딩</a>의 운영자인 이고잉님이었다. 국문과 출신의 이고잉님이 일반인들에게 프로그래밍을 알려주고 있는 모습을 보고 나도 할 수 있다는 막연한 믿음이 생긴 것이다. 그 뒤로 생활코딩을 비롯한 온라인 강의를 찾아보며 공부를 시작했다. 학교에선 배우지 못한 웹 개발에 관한 것이었다. 블로그도 그때부터 시작했다. 워드프레스를 기반으로 만든 블로그는 자바스크립트를 공부하는 내용을 담았다. </p>\n<p>운 좋게도 졸업한 선배의 특강을 들으러 갔다가 스타트업에 인턴으로 일할 수 있는 기회도 얻었다. 역삼에 있는 사무실에서 6개월동안 일하면서 Angular와 Ionic Framework를 이용해 웹 앱을 개발했다. 고시텔 생활이었지만 내가 개발자로서 일할 수 있다는 사실에 감사해서 불편한지도 모르고 살았다. 10시에 출근해서 10시에 퇴근했다. 주말도 반납했다. 개발이 나의 유일한 놀이였으며 즐거움이었다. 그렇게 만든 서비스가 앱으로 출시되어 그렇다할 성과를 내지 못하고 잊혀졌음에도 불구하고 스스로 뿌듯하고 감사한 시간이었다. 6개월의 일을 마치고 학교로 돌아왔을 때는 자신감이 붙어있었다. 개발자로 일할 수 있다는 확신이 생겼다. 블로그를 정비하고 로켓펀치에 나의 경험을 정리해두었다. </p>\n<p>그리 오래 지나지 않아서 취업 전선에 뛰어들었다. 친구들과 코딩 테스트를 준비하는 모임도 만들었고 나름대로 체계적으로 공부를 진행했다. 졸업을 앞둔 5월의 어느날 메일을 한통 받았다. 로켓펀치를 통해 연락을 준 것이다. 몇가지 이야기가 오갔고 당장 면접을 보기 위해 올라갔다. 지금의 회사가 바로 그 회사다. 이 회사는 내가 개발자로 제대로 시작할 환경을 만들어주었고 자바스크립트에 고수가 되도록 해주었다. 특히 함수형 프로그래밍이라는 패러다임에 눈 뜰 수 있게 해주었다. 한동안 연재하던 <a href=\"/tags/오늘의-함수/\">‘오늘의 함수’ 시리즈</a>도 이 회사에서 배운 것들 덕분에 가능한 글이었다. 1년이 지났을 때 성장한 자신을 느낄 수 있었고 <a href=\"/view-of-value/1-year-anniversary/\">1주년 회고록</a>도 적게 되었다. 이제는 스스로 개발자라고 부를 수 있다.</p>\n<h3 id=\"나는-개발자다\"><a href=\"#나는-개발자다\" class=\"headerlink\" title=\"나는 개발자다\"></a>나는 개발자다</h3><p>이 글은 애초에 문과 출신에게 용기를 주기 위해 시작한 글이다. 프로그래밍이 문과생에게 오히려 이점이 있는 부분이 있다는 것을 이야기하고 싶었다. 논리적으로 글을 읽고 쓸 수 있는 능력이 있다면 코드를 작성할 수 있다. 오히려 창의적인 코드가 인문학적 소양을 갖춘 이들에게서 나올 수 있다. 정말 작은 용기가 있다면 할 수 있다. 어느날 스스로를 개발자라고 부르게 될 날이 올 것이다. 오늘 포기하지 않는다면.</p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"‘나와-같다면’-시리즈-소개\"><a href=\"#‘나와-같다면’-시리즈-소개\" class=\"headerlink\" title=\"‘나와 같다면’ 시리즈 소개\"></a>‘나와 같다면’ 시리즈 소개</h5><p>  <em>‘그대여 나와 같다면 내 마음과 똑같다면 그냥 나에게 오면 돼’</em> 김연우씨가 불러서 더 유명한 노래 ‘나와 같다면’에 나오는 가사입니다. 저는 이 노래의 제목을 제 가치관을 나누는 시리즈의 제목으로 쓰려고 합니다. 이 노래의 가사처럼 저와 같은 가치관을 가진 분들과 함께 하고 싶은 마음을 담았습니다. 가치관이 담긴 글이다 보니 다른 글보다 조금 더 편하게 때론 더 단호하게 써내려갈 생각입니다.</p>\n<hr>\n<h2 id=\"어쩌다-개발자\"><a href=\"#어쩌다-개발자\" class=\"headerlink\" title=\"어쩌다 개발자\"></a>어쩌다 개발자</h2><h3 id=\"나는-문과생이었다\"><a href=\"#나는-문과생이었다\" class=\"headerlink\" title=\"나는 문과생이었다\"></a>나는 문과생이었다</h3><p>나는 수학 시험이 싫었다. 문제를 푸는 것은 제법 재미 있었지만 응용 문제를 제한된 시간 안에 풀어야한다는 그 압박감이 너무 싫었다. 그래서 문과를 선택했다. 문학이 좋기도 했다. 물론 빨리 정답을 찾아야하는 것은 그리 문학스럽지 못했지만 그정도는 눈치로 풀 수 있었다. 수학은 눈치로 되는 게 아니었다. 수학은 시간이 더 필요한 과목이었다. 결국 내가 문과를 선택한 것은 시험에서 유리해지기 위함이었다. 이유야 어찌되었건 나는 문과를 선택했고 문과생으로 대학을 진학했다.</p>\n<p>대학 1년을 마치고 군대를 갔다 왔다. 다들 그러하듯 냉정하게 현실을 바라보게 된 나는 내가 다니는 학교에선 원했던 공부를 할 수 없다는 생각이 들었다. 편입할 자신은 없었다. 전과가 자유로운 학교의 특성을 활용해야겠다고 생각했다. 전공 탐색을 위해 교양으로 들을 수 있는 타 전공 과목을 듣기 시작했다. 그 중 하나였던 ‘C 프로그래밍’이라는 수업을 들으며 컴퓨터 공학으로의 전과를 생각할 수 있었다. 아마 그때부터였던거 같다. <strong>프로그래밍은 문과스러운 점이 많다는 것</strong>을 깨달았던 순간이.</p>\n<h3 id=\"컴퓨터의-언어를-배우다\"><a href=\"#컴퓨터의-언어를-배우다\" class=\"headerlink\" title=\"컴퓨터의 언어를 배우다\"></a>컴퓨터의 언어를 배우다</h3><p>사실 컴퓨터 언어를 배운다는 건 그리 쉽지만은 않은 일이다. 많은 이유가 있겠지만 우선 어딘가 공대스럽다는 느낌 때문이다. 수학은 공대생, 문학은 인문대생의 전유물로 생각되는 것처럼 컴퓨터 언어 역시 공대생들의 전유물로 여겨지기에 뭔가 본래의 난이도 이상으로 어렵게 와닿는다. 나와 같은 문과생들에게는 더욱이 그렇다. 나 역시 두려웠다. 그래서 학원을 다녔다. </p>\n<p>교양 수업을 듣기 전(여름 방학), 학원을 등록했다. 학원에서 이해할 수 있었던 것은 이틀째까지였다. 이후로는 무슨 소린지 전혀 알지 못했다. 따지고 보면 첫날은 설치만 했으니 하루정도만 이해한 것이다. 그 후로 이해는 없었다. 직전 학기에 이미 학교에서 수업을 듣고 재이수를 위해 학원을 찾은 동기들과 수준 차이도 엄청났다. 그때 나는 내가 바보인줄 알았다. 그냥 이런 저런 단어들만 머리를 스쳐지나갔다. </p>\n<p>개강은 여지없이 찾아왔고 C 프로그래밍 수업도 시작되었다. 놀라운 점은 방학 때 들었던(스쳐지나간 줄 알았던) 단어만으로 수업을 따라갈 수 있었다는 점이다. 예를 들면 ‘배열’이라는 단어가 이 수업에서 어떻게 쓰일 것인지 예상하고 있는 것만으로 수업은 아주 흥미로워졌고 다른 친구들보다 수업에 빠르게 적응할 수 있었다. 비록 교수님이 래퍼라 불릴 정도로 엄청난 속도로 단어들을 내뱉더라도 나는 그 단어를 이해할 수 있었다. 마치 가사를 보고 랩을 듣는 기분이었다. 수업을 이해하니 과제도 재미있었다. 그때 과제를 푼다고 10시간씩 코딩했다. 지금보면 정말 아무것도 아닌 버스 요금 계산하는 어플리케이션을 며칠을 고민해서 만들었다. 내 코드가 정상적으로 동작하는 그 순간의 짜릿함을 맛봤다. 그때 코딩에 빠져들게 되었다.</p>\n<p>이 과정에서 <strong>새로운 학문을 배우는 일은 그 학문에서 사용하는 단어를 이해하고 알아가는 것</strong>이며, 컴퓨터 언어를 배우는 것 역시 마찬가지라는 점을 깨닫게 되었다. 결국 컴퓨터 언어를 배워서 코드를 작성하는 프로그래밍이라는 것도 그에 필요한 언어들을 배우고 익혀가면 누구나 할 수 있다는 생각이 들었다.</p>\n<h3 id=\"문과스러운-프로그래밍\"><a href=\"#문과스러운-프로그래밍\" class=\"headerlink\" title=\"문과스러운 프로그래밍\"></a>문과스러운 프로그래밍</h3><p>굳이 프로그래밍이 문과스럽다고 표현한 것은 프로그래밍이 글쓰기와 유사하고 생각했기 때문이다. 글쓰기를 먼저 살펴보자면 글쓰기는 글이라는 것을 작성(쓰기)하는 행위이다. 글이라는 것은 어떠한 목적을 가지며 소설과 같은 문학적인 글이 아닌 유형의 글(객관적 사실을 전달하는 글, 생각과 주장을 전달하는 글)의 경우는 글을 통해 전달하고자 하는 정보가 분명하다. 그러한 글을 쓰기 위해서는 논리라는 것이 필요하다. 이제 프로그래밍을 살펴보면 프로그래밍이라는 것은 프로그램을 만드는 행위, 보다 구체적으로 말하면 프로그램을 정의하는 코드를 작성하는 행위이다. 코드 역시 어떠한 목적을 달성하기 위해 작성되며 논리가 필요하다. 결국 글쓰기와 프로그래밍은 어떤 목적을 이루기 위해 <strong>논리적으로</strong> 글 혹은 코드를 <strong>작성하는 행위</strong>라는 점에서 유사하다.</p>\n<p>예를 들어 조건문이라는 것을 보면 이해가 될 것 같다. 문자 그대로 조건을 정의하는 구문이다. 이렇게 생겼다. <code>if a &gt; b: do_something()</code> 해석해보면 ‘만약에 a가 b보다 크면, 무엇인가 해라’는 뜻이다. 프로그래밍을 하는 중에는 이와 유사한 조건문이 수시로 등장한다. 그리고 이러한 조건에 비교를 위해 사용되는 값이 변경되거나 새로 만들어지면서 프로그램이라는 것이 완성된다. 반복문이라는 녀석도 있다. 어떠한 일을 반복적으로 처리하는 문장 구조인데 그 반복적인 일에도 논리가 존재한다. <code>while a &gt; b: say_hello()</code> 조건문과 유사하지만 단어가 <code>if</code>에서 <code>while</code>로 바뀌었다. 의미도 그만큼 바뀐다. ‘a가 b보다 큰 동안에, 인사를 해라’는 된다. 물론 <code>do_something</code>이 <code>say_hello</code>로 바뀌었지만 큰 맥락에서 바뀐 것은 ‘무엇을’이 아니라 ‘어떻게’가 바뀐 것이다. 어떤 행동을 논리적으로 어떻게 할 것인지 조건문, 반복문이 정의할 수 있다. 제법 글쓰기와 비슷하다. </p>\n<h3 id=\"개발자라는-직업\"><a href=\"#개발자라는-직업\" class=\"headerlink\" title=\"개발자라는 직업\"></a>개발자라는 직업</h3><p>이렇게 프로그래밍의 문과스러운 면모를 확인하자 개발자라는 직업을 진지하게 고민하게 되었다. 미래는 <a href=\"/view-of-value/like-me-1/\">직장인이 아니라 직업인의 시대라는 생각</a>을 가지고 있었기에 더욱 개발자라는 업(業)은 매력적으로 느껴졌다. 유일한 걸림돌은 내가 개발자가 될 수 있는가 하는 것이었다. 개발자 자체는 근사하고 좋은데 과연 문과 출신에 수포자인 내가 개발자가 될 수 있을까? 이러한 나의 고민에 용기를 준 것은 <a href=\"https://opentutorials.org/course/1\" target=\"_blank\" rel=\"noopener\">생활코딩</a>의 운영자인 이고잉님이었다. 국문과 출신의 이고잉님이 일반인들에게 프로그래밍을 알려주고 있는 모습을 보고 나도 할 수 있다는 막연한 믿음이 생긴 것이다. 그 뒤로 생활코딩을 비롯한 온라인 강의를 찾아보며 공부를 시작했다. 학교에선 배우지 못한 웹 개발에 관한 것이었다. 블로그도 그때부터 시작했다. 워드프레스를 기반으로 만든 블로그는 자바스크립트를 공부하는 내용을 담았다. </p>\n<p>운 좋게도 졸업한 선배의 특강을 들으러 갔다가 스타트업에 인턴으로 일할 수 있는 기회도 얻었다. 역삼에 있는 사무실에서 6개월동안 일하면서 Angular와 Ionic Framework를 이용해 웹 앱을 개발했다. 고시텔 생활이었지만 내가 개발자로서 일할 수 있다는 사실에 감사해서 불편한지도 모르고 살았다. 10시에 출근해서 10시에 퇴근했다. 주말도 반납했다. 개발이 나의 유일한 놀이였으며 즐거움이었다. 그렇게 만든 서비스가 앱으로 출시되어 그렇다할 성과를 내지 못하고 잊혀졌음에도 불구하고 스스로 뿌듯하고 감사한 시간이었다. 6개월의 일을 마치고 학교로 돌아왔을 때는 자신감이 붙어있었다. 개발자로 일할 수 있다는 확신이 생겼다. 블로그를 정비하고 로켓펀치에 나의 경험을 정리해두었다. </p>\n<p>그리 오래 지나지 않아서 취업 전선에 뛰어들었다. 친구들과 코딩 테스트를 준비하는 모임도 만들었고 나름대로 체계적으로 공부를 진행했다. 졸업을 앞둔 5월의 어느날 메일을 한통 받았다. 로켓펀치를 통해 연락을 준 것이다. 몇가지 이야기가 오갔고 당장 면접을 보기 위해 올라갔다. 지금의 회사가 바로 그 회사다. 이 회사는 내가 개발자로 제대로 시작할 환경을 만들어주었고 자바스크립트에 고수가 되도록 해주었다. 특히 함수형 프로그래밍이라는 패러다임에 눈 뜰 수 있게 해주었다. 한동안 연재하던 <a href=\"/tags/오늘의-함수/\">‘오늘의 함수’ 시리즈</a>도 이 회사에서 배운 것들 덕분에 가능한 글이었다. 1년이 지났을 때 성장한 자신을 느낄 수 있었고 <a href=\"/view-of-value/1-year-anniversary/\">1주년 회고록</a>도 적게 되었다. 이제는 스스로 개발자라고 부를 수 있다.</p>\n<h3 id=\"나는-개발자다\"><a href=\"#나는-개발자다\" class=\"headerlink\" title=\"나는 개발자다\"></a>나는 개발자다</h3><p>이 글은 애초에 문과 출신에게 용기를 주기 위해 시작한 글이다. 프로그래밍이 문과생에게 오히려 이점이 있는 부분이 있다는 것을 이야기하고 싶었다. 논리적으로 글을 읽고 쓸 수 있는 능력이 있다면 코드를 작성할 수 있다. 오히려 창의적인 코드가 인문학적 소양을 갖춘 이들에게서 나올 수 있다. 정말 작은 용기가 있다면 할 수 있다. 어느날 스스로를 개발자라고 부르게 될 날이 올 것이다. 오늘 포기하지 않는다면.</p>\n"},{"title":"함수형 자바스크립트 - 함수형 자바스크립트 라이브러리","date":"2017-10-19T09:41:14.000Z","_content":"## 함수형 자바스크립트 라이브러리\n함수형으로 프로그래밍하는데 도움을 주는 자바스크립트 라이브러리를 알아보고 배워보자. \n(모든 예제는 웹 브라우저의 '검사' 도구를 열어서 테스트할 수 있다.)\n\n### Partial.js\n##### 0. Underscore\n자바스크립트 생태계에서 `_`(underscore)라는 네임스페이스는 보통 [Underscore](http://underscorejs.org/)나 [Lodash](https://lodash.com/)의 차지다. underscore가 먼저 등장했고 이후에 조금 더 다양한 함수와 기능으로 무장한 채로 lodash가 등장했다. 그리고 이제 같은 네임스페이스를 사용하지만 보다 함수형 프로그래밍에 적합한 [Partial](https://marpple.github.io/partial.js/)을 소개할 차례다.\n\n\n##### 1. 부분 적용 함수 `_.partial`\n[지난 시간](/programming/functional-js-study-1/)에 다룬 `curryr` 함수는 해결되지 않은 문제를 가지고 있었다. \n\n```javascript\nvar add = curryr((a, b) => a + b);\n```\n\n`curryr`에 의해 커링이 가능하게 만들어진 함수는 받을 수 있는 인자의 개수가 2개로 제한되어 있다는 점이었다. `reduce`와 같이 3개 이상의 인자를 받는 함수가 커링이 가능하도록 만들기 위해서는 `curryr`을 새로 만들어야하는 상황이었다. \n\n```javascript\nfunction curryr3(fn) {\n  return function(a, b, c) {\n    if (arguments.length == 1) // <-- 인자의 수에 따라 다른 값을 리턴\n      return function(b) {\n        return fn(b, a);\n      };\n    if (arguments.length == 2) \n      return function(c) {\n        return fn(c, a, b);\n      };\n    return fn(a, b, c); \n  }\n}\n```\n\n`curryr3`은 세개의 인자를 받는 함수라도 커링이 가능하도록 만들어주는 함수다. 허나 인자의 수에 따라 새로운 함수를 여러개 만들어 두는 것은 그리 근사한 방법이 아니다. 이 부분도 추상화가 가능하다. 바로 `_.partial` 함수다. 이 함수는 커링을 보다 높은 레벨로 추상화한 함수다. `curry`와 마찬가지로 커링이 가능한 함수를 리턴하는 함수이지만 미리 값을 적용시켜둘 인자의 순서를 정할 수 있는 함수다. 사용법을 살펴보자.\n\n```javascript\nvar arr = [1,2,3,4,5,6,7,8,9,10];\n\nvar sum_init_0 = _.partial(reduce, _, (total, num) => total + num, 0);\nconsole.log(sum_init_0(arr)); // 55\n\nvar sum = _.partial(reduce, _, (total, num) => total + num);\nconsole.log(sum(arr, 100)); // 155\n\nvar reduce_arr = _.partial(reduce, arr);\nconsole.log(reduce_arr((total, num) => total + num)); // 55\n```\n\n`sum_init_0` 함수는 `0`을 초기값으로 가진 상태로 돌림직한 데이터가 가진 모든 수를 더하는 함수다. 선언되는 과정을 살펴보면 `_.partial` 함수에게 세개의 인자가 전달된다. 첫번째 인자인 `reduce`는 커링의 대상이 될 함수다. 이후의 인자들은 `reduce`에 전달될 인자를 의미한다. 두번째 인자는 `_`인데 이 부분은 나중에 받겠다는 의미가 된다. __'지금은 비워두고 나중에 값이 들어오면 여기에 넣어라'__는 의미가 되는 셈이다. 반면 `(total, num) => total + num`과 `0`은 각각 `iter`, `memo`를 의미하고([기본 함수 구현하고 사용하기](/programming/functional-js-study/) 편의 `reduce` 참고) __'지금 값을 넣어두겠다'__는 의미가 된다. 이렇게 일정 부분만 미리 값을 넣어두는 행위를 __부분 적용__이라고 한다. \n\n`sum` 함수는 돌림직한 데이터가 가진 모든 수를 더하는 함수다. `sum_init_0`와는 초기값의 유무에서 차이가 생긴다. `_.partial` 함수를 살펴보면 마지막 인자 `0`이 없는 것을 알 수 있다. 이처럼 `_.partial`로 부분 적용된 함수를 만들 때 마지막 인자가 들어오지 않으면 `_`과 같은 취급을 한다. 즉 '지금은 비워두고 나중에 값이 들어오면 넣는' 영역으로 본다. 결과적으로 `sum`은 `iter`만을 가진 함수가 되어 실행하는 시점에 데이터 `arr`와 초기값 `100`을 인자로 줄 수 있었다.\n\n반면 `reduce_arr`는 데이터를 가지고 있지만 어떻게 돌리며 접어나갈지 정의 되지 않았다. 때문에 실행되는 시점에 어떻게 돌릴지 정의하는 함수를 주고 결과를 얻어낼 수 있었다. (`reduce`는 초기값이 생략되면 데이터의 첫번째 값을 초기값으로 사용한다.)\n\n이렇게 `_.partial`을 사용하면 `_curry`, `_curryr`이 가지고 있던 단점을 모두 보완할 수 있다. 실제 사용의 사례를 보면 이렇다.\n\n```javascript\n_.go(arr,\n  _.partial(filter, _, n => n % 2),\n  _(reduce, _, (a, b) => a + b, 0), // <-- 네임스페이스 '_'는 _.partial 함수다.\n  console.log); // 25\n```\n\n위 코드에서 재미난 부분은 Partial.js에서는 네임스페이스인 `_`가 `_.partial` 함수라는 점이다. Partial이라는 라이브러리의 이름이 `_.partial` 함수와 같은 이유가 바로 이 때문이다. 사실 위의 코드는 `_.partial`의 사용 예를 보여주기만을 위한 코드라 그리 근사하지 않다. 지난 시간에 만든 `filter`와 `reduce` 대신 Partial.js의 함수들을 사용하면 보다 깔끔한 코드를 만들 수 있다. \n\n```javascript\n_.go(arr,\n  _.filter(n => n % 2),\n  _.reduce((a, b) => a + b),\n  console.log); // 25\n```\n\n`_.filter`와 `_.reduce`를 구현하는 코드에는 `_.partial` 함수가 사용되고 있기 때문에 위와 같은 부분 적용이 가능하다.\n\n\n##### 2. `_.go`, `_.pipe`의 사용\n우리는 이미 `go`와 `pipe`를 만들고 사용해보았다. 이번에 사용해볼 `_.go`와 `_.pipe`는 조금 특별한 비밀을 가지고 있다. 이전에 직접 만들었던 함수와 같은 일을 한다. 함수를 실행하거나 함수를 조합하여 리턴한다. 전달된 인자 중에 __비동기 함수가 있더라도 완벽하게 제어해준다는 점__을 제외하면 주요 역할은 동일한 함수다.\n\n```javascript\nfunction syncDate() {\n  return new Date();\n}\nfunction promiseDate() {\n  return new Promise(function(resolve) {\n    setTimeout(function() {\n      resolve(new Date());\n    }, 1000);\n  });\n}\n\n_.go([1, 2, 3],\n  _.map(syncDate),\n  _.map(d => d.toString()),\n  console.log);\n// 결과:\n//  [\"Sun Feb 05 2017 03:33:36 GMT+0900 (KST)\",\n//   \"Sun Feb 05 2017 03:33:36 GMT+0900 (KST)\",\n//   \"Sun Feb 05 2017 03:33:36 GMT+0900 (KST)\"]\n\n_.go([1, 2, 3],\n  _.map(promiseDate),\n  _.map(d => d.toString()),\n  console.log);\n// 결과:\n//  [\"Sun Feb 05 2017 03:33:37 GMT+0900 (KST)\",\n//   \"Sun Feb 05 2017 03:33:38 GMT+0900 (KST)\",\n//   \"Sun Feb 05 2017 03:33:39 GMT+0900 (KST)\"]\n```\n\n위의 예제는 Partial.js의 [소개 페이지](https://marpple.github.io/partial.js/#컬렉션을-다루는-비동기-제어-함수)에 나오는 코드를 가져왔다. 잠깐 코드를 살펴보면 동기적으로 날짜를 리턴하는 `snycData` 함수와 비동기적으로 날짜를 리턴하는 `promiseData` 함수가 있다. 두 함수를 `_.map`에 넣어 실행하면 날짜 데이터를 갖는 배열을 리턴한다. 다시 한번 `_.map`으로 날짜 데이터를 문자열로 치환하여 리턴하면 결과값과 같은 날짜와 시간을 표시한 문자열이 담긴 배열이 나온다. 비동기 상황임에도 불구하고 동기 상황과 같은 결과를 리턴한다. 물론 3초정도의 시간이 소요된다. [1주차](/programming/functional-js-study/)에 만들어본 일반 `go`를 사용하면 위와 같은 결과를 만들어내지 못한다. \n\n```javascript\ngo([1, 2, 3],\n  _.map(promiseDate),\n  _.map(d => d.toString()),\n  console.log); // []\n```\n\n비동기 상황을 무시하고 지나가면서 빈 배열만을 리턴한다. 살펴본 것처럼 Partial.js `_.go`를 사용하면 이와 같은 문제없이 비동기 상황을 생각한대로 제어할 수 있다.\n\n\n##### 3. 템플릿 함수 `_.template`\nHTML 코드를 보다 쉽게 작성하기 위해 [Pug](https://pugjs.org/api/getting-started.html), [Handlebars.js](http://handlebarsjs.com/), [ejs](http://www.embeddedjs.com/)와 같은 템플릿 엔진이 존재한다. Partial.js는 함수 스타일의 템플릿 엔진인 `_.template` 함수를 지원한다. Pug와 같은 문법을 사용하는 이 함수의 사용법에 대한 자세한 설명은 [소개 페이지](https://marpple.github.io/partial.js/#함수-스타일의-템플릿-함수)에서 확인할 수 있다.\n\n\n### 함수형 jQuery, don.js\n##### 1. jQuery vs don.js\ndon.js는 jQuery가 지원하는 함수들을 함수형 스타일로 지원한다. \n\n```javascript\n// jQuery\n$('body'); \n$('body').addClass('container');\n\n// don.js\nD('body'); \nD.addClass(D('body'), 'container');\n```\n\njQuery가 체인 방식으로 함수들을 이어나가는 것과 달리 __don.js는 함수의 리턴값을 사용함__으로 함수를 이어나간다. 때문에 Partial.js와 궁합이 잘 맞는다. \n\n\n##### 2. Don.js with Partial.js\n\n```javascript\n// jQuery (http://api.jquery.com/map/)\nconsole.log(\n  $( \":checkbox\" )\n    .map(function() {\n      return this.id;\n    })\n    .get() // <-- 이때 배열이 된다.\n    .join());\n\n\n// don.js\n_.go(\n  D('[type=\"checkbox\"]'),\n  _.map(function(el) {\n    return el.id;\n  }), // <-- 이미 배열인 상태다.\n  _.join(), // arr => arr.join(),\n  _.log);\n```\n\njQuery가 셀렉터를 통해 찾아 리턴하는 값이 jQuery 객체인데 반해 don.js의 리턴값은 기본형 데이터인 배열이거나 엘리먼트 자체임으로 어떤 순수 함수인 다른 함수들과 조합이 자유롭다. 위의 예제에서 jQuery의 경우, `map`을 실행한 뒤에 `get`을 실행하지 않으면 배열의 기본 메서드인 `join`을 실행할 수 없다. 하지만 don.js는 항상 기본형 데이터를 사용하기 때문에 자유롭게 함수들을 이어갈 수 있다. \n\n`_.template` 계열의 템플릿 함수들과 함께 사용하면 더 don.js를 재미있고 유용하게 사용할 수 있다. 우선 예제를 위해 아래와 같은 주문서 데이터(`projections`)가 있다고 가정하자. \n\n```javascript\nvar projections = [\n  { id: 1, user_id: 2, _: { user: { name: 'ID', age: 36 }, products: [ { name: '긴팔티' }, { name: '후드티' } ] } },\n  { id: 2, user_id: 7, _: { user: { name: 'BJ', age: 32 }, products: [ { name: '긴팔티' } ] } },\n  { id: 3, user_id: 8, _: { user: { name: 'JM', age: 34 }, products: [ { name: '에코백' }, { name: '청바지' }] } },\n  { id: 4, user_id: 9, _: { user: { name: 'PJ', age: 27 }, products: [ { name: '양말' }, { name: '후드티' }, { name: '긴팔티' }, { name: '에코백' } ] } },\n  { id: 5, user_id: 1, _: { user: { name: 'HA', age: 25 }, products: [ { name: '에코백' } ] } },\n  { id: 6, user_id: 11, _: { user: { name: 'JE', age: 26 }, products: [ { name: '머플러' } ] } },\n  { id: 7, user_id: 12, _: { user: { name: 'JI', age: 31 }, products: [ { name: '머그컵' } ] } },\n  { id: 8, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' } ] } },\n  { id: 9, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' }] } },\n  { id: 10, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' }] } },\n];\n```\n\n예제 데이터는 주문서의 아이디, 주문자의 정보와 제품 정보를 담고 있다. 이를 이용해서 주문 목록을 그린다고 가정해보자. 템플릿 함수 중 하나인 `_.t$`(`_.template$`의 약식) 함수를 사용하면 아래와 같은 코드로 원하는 목록을 그릴 수 있다.\n\n```javascript\n_.go(\n  projections,\n  _.sum(_.t$(`\n    li#{{$.id}}\n      .user_info#{{$.user_id}}\n        h4 {{$._.user.name}}\n      ul.products {{_.sum($._.products, `, _.t$(`\n        li {{$.name}}\n      `) ,`)}}\n      button 주문취소\n      `)),\n  // _.hi, // <-- 앞의 주석을 제거하면 어떤 문자열이 만들어지는지 확인할 수 있다.\n  D.appendTo('.user_list'));\n```\n\n`_.sum`은 `projections` 데이터를 바탕으로 `_.t$` 함수가 만들어낸 HTML 문자열을 하나의 문자열로 합쳐준다. 이렇게 합쳐진 긴 문자열은 `D.appendTo` 함수에게 전달되는데 이 함수는 `'.user_list'`라는 문자열을 인자로 받았다. 클래스 명이 'user\\_product'에 해당하는 엘리먼트에게 이후에 들어오는 HTML 문자열을 엘리먼트로 변환해서 붙여넣겠다는 의미다. 결과적으로 앞에서 `_.sum`에 의해 합쳐진 문자열이 `D.appendTo`에 의해 엘리먼트로 변환되고 'user\\_product'에 해당하는 클래스를 가진 곳에 붙여진다. \n\n이벤트를 달아서 주문을 취소하는 동작을 만들기 위해선 아래와 같은 `on` 함수를 사용하면 된다.\n\n```javascript\n_.go(\n  D('body'),\n  D.on('click', 'button', _.pipe(\n    _.v('$currentTarget'),\n    D.parent('li'),\n    D.hide)\n  ));\n```\n\n`_.pipe` 함수가 등장했다. `D.on` 함수의 세번째 인자로 받을 함수는 '클릭 이벤트가 발생하면 어떤 일을 할지 정의한 함수'가 들어와야 한다. 이 함수를 `_.pipe`가 여러개의 함수를 조합해서 만들었다. 내부를 보면 `_.v('$currentTarget')` 함수가 이벤트의 대상이 되는 엘리먼트를 꺼내고 `D.parent('li')`가 부모 중에 li 엘리먼트인 것을 찾아 리턴한다. 마지막에 `D.hide`가 리턴된 엘리먼트를 숨긴다. 이러한 순서에 의해 버튼을 클릭하면 대상을 담고 있는 li 엘리먼트가 가려지는 동작을 수행한다. \n\n---\n\n### 전체 스터디 일정\n  - 1주차 - [기본 함수 구현하고 사용하기](/programming/functional-js-study/)\n  - 2주차 - [고차 함수와 커링(currying)](/programming/functional-js-study-1/)\n  - 3주차 - 함수형 자바스크립트 라이브러리\n  - _4주차 - Movie Box 1: 필터링, 정렬_\n  - _5주차 - Movie Box 2: 필터링, 정렬 복습_\n  - _6주차 - Movie Box 3: 지연평가 L, memoize_\n  - _7주차 - Movie Box 4: 비동기 상황 다루기_\n\n[예제 코드](https://github.com/joeunha/functional-js-study/tree/master/03_week)\n\n<script async>\nvar arr = [1,2,3,4,5,6,7,8,9,10];\n\nfunction filter(list, iter) {\n  var res = [];\n  if (Array.isArray(list)) {\n    for (var i = 0, len = list.length; i < len; i++) \n      if (iter(list[i], i, list)) \n        res.push(list[i]);\n  } else {\n    var keys = Object.keys(list);\n    for (var i = 0, len = keys.length; i < len; i++) \n      if (iter(list[keys[i]], keys[i], list)) \n        res.push(list[keys[i]]);\n  }\n  return res;\n}\n\nfunction reduce(list, iter, memo) {\n  var i = 0;\n  if (Array.isArray(list)) {\n    var res = (memo != undefined ? memo : list[i++]);\n    for (var len = list.length; i < len; i++) \n      res = iter(res, list[i], i, list);\n  } else {\n    var keys = Object.keys(list), res = (memo != undefined ? memo : list[keys[i++]]);\n    for (var len = keys.length; i < len; i++) \n      res = iter(res, list[keys[i]], keys[i], list);\n  }\n  return res;\n}\n\nvar projections = [\n  { id: 1, user_id: 2, _: { user: { name: 'ID', age: 36 }, products: [ { name: '긴팔티' }, { name: '후드티' } ] } },\n  { id: 2, user_id: 7, _: { user: { name: 'BJ', age: 32 }, products: [ { name: '긴팔티' } ] } },\n  { id: 3, user_id: 8, _: { user: { name: 'JM', age: 34 }, products: [ { name: '에코백' }, { name: '청바지' }] } },\n  { id: 4, user_id: 9, _: { user: { name: 'PJ', age: 27 }, products: [ { name: '양말' }, { name: '후드티' }, { name: '긴팔티' }, { name: '에코백' } ] } },\n  { id: 5, user_id: 1, _: { user: { name: 'HA', age: 25 }, products: [ { name: '에코백' } ] } },\n  { id: 6, user_id: 11, _: { user: { name: 'JE', age: 26 }, products: [ { name: '머플러' } ] } },\n  { id: 7, user_id: 12, _: { user: { name: 'JI', age: 31 }, products: [ { name: '머그컵' } ] } },\n  { id: 8, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' } ] } },\n  { id: 9, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' }] } },\n  { id: 10, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' }] } },\n];\n</script>\n<script async src=\"https://rawgit.com/joeunha/cdn/master/don.js\"></script>\n<script async src=\"https://rawgit.com/marpple/partial.js/master/partial.min.js\"></script>","source":"_posts/functional-js-study-2.md","raw":"---\ntitle: '함수형 자바스크립트 - 함수형 자바스크립트 라이브러리'\ncategories:\n  - programming\ntags:\n  - javascript\n  - 자바스크립트\n  - 함수형 프로그래밍\n  - 함수형 자바스크립트\ndate: 2017-10-19 18:41:14\n---\n## 함수형 자바스크립트 라이브러리\n함수형으로 프로그래밍하는데 도움을 주는 자바스크립트 라이브러리를 알아보고 배워보자. \n(모든 예제는 웹 브라우저의 '검사' 도구를 열어서 테스트할 수 있다.)\n\n### Partial.js\n##### 0. Underscore\n자바스크립트 생태계에서 `_`(underscore)라는 네임스페이스는 보통 [Underscore](http://underscorejs.org/)나 [Lodash](https://lodash.com/)의 차지다. underscore가 먼저 등장했고 이후에 조금 더 다양한 함수와 기능으로 무장한 채로 lodash가 등장했다. 그리고 이제 같은 네임스페이스를 사용하지만 보다 함수형 프로그래밍에 적합한 [Partial](https://marpple.github.io/partial.js/)을 소개할 차례다.\n\n\n##### 1. 부분 적용 함수 `_.partial`\n[지난 시간](/programming/functional-js-study-1/)에 다룬 `curryr` 함수는 해결되지 않은 문제를 가지고 있었다. \n\n```javascript\nvar add = curryr((a, b) => a + b);\n```\n\n`curryr`에 의해 커링이 가능하게 만들어진 함수는 받을 수 있는 인자의 개수가 2개로 제한되어 있다는 점이었다. `reduce`와 같이 3개 이상의 인자를 받는 함수가 커링이 가능하도록 만들기 위해서는 `curryr`을 새로 만들어야하는 상황이었다. \n\n```javascript\nfunction curryr3(fn) {\n  return function(a, b, c) {\n    if (arguments.length == 1) // <-- 인자의 수에 따라 다른 값을 리턴\n      return function(b) {\n        return fn(b, a);\n      };\n    if (arguments.length == 2) \n      return function(c) {\n        return fn(c, a, b);\n      };\n    return fn(a, b, c); \n  }\n}\n```\n\n`curryr3`은 세개의 인자를 받는 함수라도 커링이 가능하도록 만들어주는 함수다. 허나 인자의 수에 따라 새로운 함수를 여러개 만들어 두는 것은 그리 근사한 방법이 아니다. 이 부분도 추상화가 가능하다. 바로 `_.partial` 함수다. 이 함수는 커링을 보다 높은 레벨로 추상화한 함수다. `curry`와 마찬가지로 커링이 가능한 함수를 리턴하는 함수이지만 미리 값을 적용시켜둘 인자의 순서를 정할 수 있는 함수다. 사용법을 살펴보자.\n\n```javascript\nvar arr = [1,2,3,4,5,6,7,8,9,10];\n\nvar sum_init_0 = _.partial(reduce, _, (total, num) => total + num, 0);\nconsole.log(sum_init_0(arr)); // 55\n\nvar sum = _.partial(reduce, _, (total, num) => total + num);\nconsole.log(sum(arr, 100)); // 155\n\nvar reduce_arr = _.partial(reduce, arr);\nconsole.log(reduce_arr((total, num) => total + num)); // 55\n```\n\n`sum_init_0` 함수는 `0`을 초기값으로 가진 상태로 돌림직한 데이터가 가진 모든 수를 더하는 함수다. 선언되는 과정을 살펴보면 `_.partial` 함수에게 세개의 인자가 전달된다. 첫번째 인자인 `reduce`는 커링의 대상이 될 함수다. 이후의 인자들은 `reduce`에 전달될 인자를 의미한다. 두번째 인자는 `_`인데 이 부분은 나중에 받겠다는 의미가 된다. __'지금은 비워두고 나중에 값이 들어오면 여기에 넣어라'__는 의미가 되는 셈이다. 반면 `(total, num) => total + num`과 `0`은 각각 `iter`, `memo`를 의미하고([기본 함수 구현하고 사용하기](/programming/functional-js-study/) 편의 `reduce` 참고) __'지금 값을 넣어두겠다'__는 의미가 된다. 이렇게 일정 부분만 미리 값을 넣어두는 행위를 __부분 적용__이라고 한다. \n\n`sum` 함수는 돌림직한 데이터가 가진 모든 수를 더하는 함수다. `sum_init_0`와는 초기값의 유무에서 차이가 생긴다. `_.partial` 함수를 살펴보면 마지막 인자 `0`이 없는 것을 알 수 있다. 이처럼 `_.partial`로 부분 적용된 함수를 만들 때 마지막 인자가 들어오지 않으면 `_`과 같은 취급을 한다. 즉 '지금은 비워두고 나중에 값이 들어오면 넣는' 영역으로 본다. 결과적으로 `sum`은 `iter`만을 가진 함수가 되어 실행하는 시점에 데이터 `arr`와 초기값 `100`을 인자로 줄 수 있었다.\n\n반면 `reduce_arr`는 데이터를 가지고 있지만 어떻게 돌리며 접어나갈지 정의 되지 않았다. 때문에 실행되는 시점에 어떻게 돌릴지 정의하는 함수를 주고 결과를 얻어낼 수 있었다. (`reduce`는 초기값이 생략되면 데이터의 첫번째 값을 초기값으로 사용한다.)\n\n이렇게 `_.partial`을 사용하면 `_curry`, `_curryr`이 가지고 있던 단점을 모두 보완할 수 있다. 실제 사용의 사례를 보면 이렇다.\n\n```javascript\n_.go(arr,\n  _.partial(filter, _, n => n % 2),\n  _(reduce, _, (a, b) => a + b, 0), // <-- 네임스페이스 '_'는 _.partial 함수다.\n  console.log); // 25\n```\n\n위 코드에서 재미난 부분은 Partial.js에서는 네임스페이스인 `_`가 `_.partial` 함수라는 점이다. Partial이라는 라이브러리의 이름이 `_.partial` 함수와 같은 이유가 바로 이 때문이다. 사실 위의 코드는 `_.partial`의 사용 예를 보여주기만을 위한 코드라 그리 근사하지 않다. 지난 시간에 만든 `filter`와 `reduce` 대신 Partial.js의 함수들을 사용하면 보다 깔끔한 코드를 만들 수 있다. \n\n```javascript\n_.go(arr,\n  _.filter(n => n % 2),\n  _.reduce((a, b) => a + b),\n  console.log); // 25\n```\n\n`_.filter`와 `_.reduce`를 구현하는 코드에는 `_.partial` 함수가 사용되고 있기 때문에 위와 같은 부분 적용이 가능하다.\n\n\n##### 2. `_.go`, `_.pipe`의 사용\n우리는 이미 `go`와 `pipe`를 만들고 사용해보았다. 이번에 사용해볼 `_.go`와 `_.pipe`는 조금 특별한 비밀을 가지고 있다. 이전에 직접 만들었던 함수와 같은 일을 한다. 함수를 실행하거나 함수를 조합하여 리턴한다. 전달된 인자 중에 __비동기 함수가 있더라도 완벽하게 제어해준다는 점__을 제외하면 주요 역할은 동일한 함수다.\n\n```javascript\nfunction syncDate() {\n  return new Date();\n}\nfunction promiseDate() {\n  return new Promise(function(resolve) {\n    setTimeout(function() {\n      resolve(new Date());\n    }, 1000);\n  });\n}\n\n_.go([1, 2, 3],\n  _.map(syncDate),\n  _.map(d => d.toString()),\n  console.log);\n// 결과:\n//  [\"Sun Feb 05 2017 03:33:36 GMT+0900 (KST)\",\n//   \"Sun Feb 05 2017 03:33:36 GMT+0900 (KST)\",\n//   \"Sun Feb 05 2017 03:33:36 GMT+0900 (KST)\"]\n\n_.go([1, 2, 3],\n  _.map(promiseDate),\n  _.map(d => d.toString()),\n  console.log);\n// 결과:\n//  [\"Sun Feb 05 2017 03:33:37 GMT+0900 (KST)\",\n//   \"Sun Feb 05 2017 03:33:38 GMT+0900 (KST)\",\n//   \"Sun Feb 05 2017 03:33:39 GMT+0900 (KST)\"]\n```\n\n위의 예제는 Partial.js의 [소개 페이지](https://marpple.github.io/partial.js/#컬렉션을-다루는-비동기-제어-함수)에 나오는 코드를 가져왔다. 잠깐 코드를 살펴보면 동기적으로 날짜를 리턴하는 `snycData` 함수와 비동기적으로 날짜를 리턴하는 `promiseData` 함수가 있다. 두 함수를 `_.map`에 넣어 실행하면 날짜 데이터를 갖는 배열을 리턴한다. 다시 한번 `_.map`으로 날짜 데이터를 문자열로 치환하여 리턴하면 결과값과 같은 날짜와 시간을 표시한 문자열이 담긴 배열이 나온다. 비동기 상황임에도 불구하고 동기 상황과 같은 결과를 리턴한다. 물론 3초정도의 시간이 소요된다. [1주차](/programming/functional-js-study/)에 만들어본 일반 `go`를 사용하면 위와 같은 결과를 만들어내지 못한다. \n\n```javascript\ngo([1, 2, 3],\n  _.map(promiseDate),\n  _.map(d => d.toString()),\n  console.log); // []\n```\n\n비동기 상황을 무시하고 지나가면서 빈 배열만을 리턴한다. 살펴본 것처럼 Partial.js `_.go`를 사용하면 이와 같은 문제없이 비동기 상황을 생각한대로 제어할 수 있다.\n\n\n##### 3. 템플릿 함수 `_.template`\nHTML 코드를 보다 쉽게 작성하기 위해 [Pug](https://pugjs.org/api/getting-started.html), [Handlebars.js](http://handlebarsjs.com/), [ejs](http://www.embeddedjs.com/)와 같은 템플릿 엔진이 존재한다. Partial.js는 함수 스타일의 템플릿 엔진인 `_.template` 함수를 지원한다. Pug와 같은 문법을 사용하는 이 함수의 사용법에 대한 자세한 설명은 [소개 페이지](https://marpple.github.io/partial.js/#함수-스타일의-템플릿-함수)에서 확인할 수 있다.\n\n\n### 함수형 jQuery, don.js\n##### 1. jQuery vs don.js\ndon.js는 jQuery가 지원하는 함수들을 함수형 스타일로 지원한다. \n\n```javascript\n// jQuery\n$('body'); \n$('body').addClass('container');\n\n// don.js\nD('body'); \nD.addClass(D('body'), 'container');\n```\n\njQuery가 체인 방식으로 함수들을 이어나가는 것과 달리 __don.js는 함수의 리턴값을 사용함__으로 함수를 이어나간다. 때문에 Partial.js와 궁합이 잘 맞는다. \n\n\n##### 2. Don.js with Partial.js\n\n```javascript\n// jQuery (http://api.jquery.com/map/)\nconsole.log(\n  $( \":checkbox\" )\n    .map(function() {\n      return this.id;\n    })\n    .get() // <-- 이때 배열이 된다.\n    .join());\n\n\n// don.js\n_.go(\n  D('[type=\"checkbox\"]'),\n  _.map(function(el) {\n    return el.id;\n  }), // <-- 이미 배열인 상태다.\n  _.join(), // arr => arr.join(),\n  _.log);\n```\n\njQuery가 셀렉터를 통해 찾아 리턴하는 값이 jQuery 객체인데 반해 don.js의 리턴값은 기본형 데이터인 배열이거나 엘리먼트 자체임으로 어떤 순수 함수인 다른 함수들과 조합이 자유롭다. 위의 예제에서 jQuery의 경우, `map`을 실행한 뒤에 `get`을 실행하지 않으면 배열의 기본 메서드인 `join`을 실행할 수 없다. 하지만 don.js는 항상 기본형 데이터를 사용하기 때문에 자유롭게 함수들을 이어갈 수 있다. \n\n`_.template` 계열의 템플릿 함수들과 함께 사용하면 더 don.js를 재미있고 유용하게 사용할 수 있다. 우선 예제를 위해 아래와 같은 주문서 데이터(`projections`)가 있다고 가정하자. \n\n```javascript\nvar projections = [\n  { id: 1, user_id: 2, _: { user: { name: 'ID', age: 36 }, products: [ { name: '긴팔티' }, { name: '후드티' } ] } },\n  { id: 2, user_id: 7, _: { user: { name: 'BJ', age: 32 }, products: [ { name: '긴팔티' } ] } },\n  { id: 3, user_id: 8, _: { user: { name: 'JM', age: 34 }, products: [ { name: '에코백' }, { name: '청바지' }] } },\n  { id: 4, user_id: 9, _: { user: { name: 'PJ', age: 27 }, products: [ { name: '양말' }, { name: '후드티' }, { name: '긴팔티' }, { name: '에코백' } ] } },\n  { id: 5, user_id: 1, _: { user: { name: 'HA', age: 25 }, products: [ { name: '에코백' } ] } },\n  { id: 6, user_id: 11, _: { user: { name: 'JE', age: 26 }, products: [ { name: '머플러' } ] } },\n  { id: 7, user_id: 12, _: { user: { name: 'JI', age: 31 }, products: [ { name: '머그컵' } ] } },\n  { id: 8, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' } ] } },\n  { id: 9, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' }] } },\n  { id: 10, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' }] } },\n];\n```\n\n예제 데이터는 주문서의 아이디, 주문자의 정보와 제품 정보를 담고 있다. 이를 이용해서 주문 목록을 그린다고 가정해보자. 템플릿 함수 중 하나인 `_.t$`(`_.template$`의 약식) 함수를 사용하면 아래와 같은 코드로 원하는 목록을 그릴 수 있다.\n\n```javascript\n_.go(\n  projections,\n  _.sum(_.t$(`\n    li#{{$.id}}\n      .user_info#{{$.user_id}}\n        h4 {{$._.user.name}}\n      ul.products {{_.sum($._.products, `, _.t$(`\n        li {{$.name}}\n      `) ,`)}}\n      button 주문취소\n      `)),\n  // _.hi, // <-- 앞의 주석을 제거하면 어떤 문자열이 만들어지는지 확인할 수 있다.\n  D.appendTo('.user_list'));\n```\n\n`_.sum`은 `projections` 데이터를 바탕으로 `_.t$` 함수가 만들어낸 HTML 문자열을 하나의 문자열로 합쳐준다. 이렇게 합쳐진 긴 문자열은 `D.appendTo` 함수에게 전달되는데 이 함수는 `'.user_list'`라는 문자열을 인자로 받았다. 클래스 명이 'user\\_product'에 해당하는 엘리먼트에게 이후에 들어오는 HTML 문자열을 엘리먼트로 변환해서 붙여넣겠다는 의미다. 결과적으로 앞에서 `_.sum`에 의해 합쳐진 문자열이 `D.appendTo`에 의해 엘리먼트로 변환되고 'user\\_product'에 해당하는 클래스를 가진 곳에 붙여진다. \n\n이벤트를 달아서 주문을 취소하는 동작을 만들기 위해선 아래와 같은 `on` 함수를 사용하면 된다.\n\n```javascript\n_.go(\n  D('body'),\n  D.on('click', 'button', _.pipe(\n    _.v('$currentTarget'),\n    D.parent('li'),\n    D.hide)\n  ));\n```\n\n`_.pipe` 함수가 등장했다. `D.on` 함수의 세번째 인자로 받을 함수는 '클릭 이벤트가 발생하면 어떤 일을 할지 정의한 함수'가 들어와야 한다. 이 함수를 `_.pipe`가 여러개의 함수를 조합해서 만들었다. 내부를 보면 `_.v('$currentTarget')` 함수가 이벤트의 대상이 되는 엘리먼트를 꺼내고 `D.parent('li')`가 부모 중에 li 엘리먼트인 것을 찾아 리턴한다. 마지막에 `D.hide`가 리턴된 엘리먼트를 숨긴다. 이러한 순서에 의해 버튼을 클릭하면 대상을 담고 있는 li 엘리먼트가 가려지는 동작을 수행한다. \n\n---\n\n### 전체 스터디 일정\n  - 1주차 - [기본 함수 구현하고 사용하기](/programming/functional-js-study/)\n  - 2주차 - [고차 함수와 커링(currying)](/programming/functional-js-study-1/)\n  - 3주차 - 함수형 자바스크립트 라이브러리\n  - _4주차 - Movie Box 1: 필터링, 정렬_\n  - _5주차 - Movie Box 2: 필터링, 정렬 복습_\n  - _6주차 - Movie Box 3: 지연평가 L, memoize_\n  - _7주차 - Movie Box 4: 비동기 상황 다루기_\n\n[예제 코드](https://github.com/joeunha/functional-js-study/tree/master/03_week)\n\n<script async>\nvar arr = [1,2,3,4,5,6,7,8,9,10];\n\nfunction filter(list, iter) {\n  var res = [];\n  if (Array.isArray(list)) {\n    for (var i = 0, len = list.length; i < len; i++) \n      if (iter(list[i], i, list)) \n        res.push(list[i]);\n  } else {\n    var keys = Object.keys(list);\n    for (var i = 0, len = keys.length; i < len; i++) \n      if (iter(list[keys[i]], keys[i], list)) \n        res.push(list[keys[i]]);\n  }\n  return res;\n}\n\nfunction reduce(list, iter, memo) {\n  var i = 0;\n  if (Array.isArray(list)) {\n    var res = (memo != undefined ? memo : list[i++]);\n    for (var len = list.length; i < len; i++) \n      res = iter(res, list[i], i, list);\n  } else {\n    var keys = Object.keys(list), res = (memo != undefined ? memo : list[keys[i++]]);\n    for (var len = keys.length; i < len; i++) \n      res = iter(res, list[keys[i]], keys[i], list);\n  }\n  return res;\n}\n\nvar projections = [\n  { id: 1, user_id: 2, _: { user: { name: 'ID', age: 36 }, products: [ { name: '긴팔티' }, { name: '후드티' } ] } },\n  { id: 2, user_id: 7, _: { user: { name: 'BJ', age: 32 }, products: [ { name: '긴팔티' } ] } },\n  { id: 3, user_id: 8, _: { user: { name: 'JM', age: 34 }, products: [ { name: '에코백' }, { name: '청바지' }] } },\n  { id: 4, user_id: 9, _: { user: { name: 'PJ', age: 27 }, products: [ { name: '양말' }, { name: '후드티' }, { name: '긴팔티' }, { name: '에코백' } ] } },\n  { id: 5, user_id: 1, _: { user: { name: 'HA', age: 25 }, products: [ { name: '에코백' } ] } },\n  { id: 6, user_id: 11, _: { user: { name: 'JE', age: 26 }, products: [ { name: '머플러' } ] } },\n  { id: 7, user_id: 12, _: { user: { name: 'JI', age: 31 }, products: [ { name: '머그컵' } ] } },\n  { id: 8, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' } ] } },\n  { id: 9, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' }] } },\n  { id: 10, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' }] } },\n];\n</script>\n<script async src=\"https://rawgit.com/joeunha/cdn/master/don.js\"></script>\n<script async src=\"https://rawgit.com/marpple/partial.js/master/partial.min.js\"></script>","slug":"functional-js-study-2","published":1,"updated":"2019-12-05T15:05:29.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6jcr9jd00audirvea96ipxa","content":"<h2 id=\"함수형-자바스크립트-라이브러리\"><a href=\"#함수형-자바스크립트-라이브러리\" class=\"headerlink\" title=\"함수형 자바스크립트 라이브러리\"></a>함수형 자바스크립트 라이브러리</h2><p>함수형으로 프로그래밍하는데 도움을 주는 자바스크립트 라이브러리를 알아보고 배워보자.<br>(모든 예제는 웹 브라우저의 ‘검사’ 도구를 열어서 테스트할 수 있다.)</p>\n<h3 id=\"Partial-js\"><a href=\"#Partial-js\" class=\"headerlink\" title=\"Partial.js\"></a>Partial.js</h3><h5 id=\"0-Underscore\"><a href=\"#0-Underscore\" class=\"headerlink\" title=\"0. Underscore\"></a>0. Underscore</h5><p>자바스크립트 생태계에서 <code>_</code>(underscore)라는 네임스페이스는 보통 <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore</a>나 <a href=\"https://lodash.com/\" target=\"_blank\" rel=\"noopener\">Lodash</a>의 차지다. underscore가 먼저 등장했고 이후에 조금 더 다양한 함수와 기능으로 무장한 채로 lodash가 등장했다. 그리고 이제 같은 네임스페이스를 사용하지만 보다 함수형 프로그래밍에 적합한 <a href=\"https://marpple.github.io/partial.js/\" target=\"_blank\" rel=\"noopener\">Partial</a>을 소개할 차례다.</p>\n<h5 id=\"1-부분-적용-함수-partial\"><a href=\"#1-부분-적용-함수-partial\" class=\"headerlink\" title=\"1. 부분 적용 함수 _.partial\"></a>1. 부분 적용 함수 <code>_.partial</code></h5><p><a href=\"/programming/functional-js-study-1/\">지난 시간</a>에 다룬 <code>curryr</code> 함수는 해결되지 않은 문제를 가지고 있었다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = curryr(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b);</span><br></pre></td></tr></table></figure>\n\n<p><code>curryr</code>에 의해 커링이 가능하게 만들어진 함수는 받을 수 있는 인자의 개수가 2개로 제한되어 있다는 점이었다. <code>reduce</code>와 같이 3개 이상의 인자를 받는 함수가 커링이 가능하도록 만들기 위해서는 <code>curryr</code>을 새로 만들어야하는 상황이었다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curryr3</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length == <span class=\"number\">1</span>) <span class=\"comment\">// &lt;-- 인자의 수에 따라 다른 값을 리턴</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn(b, a);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length == <span class=\"number\">2</span>) </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn(c, a, b);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn(a, b, c); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>curryr3</code>은 세개의 인자를 받는 함수라도 커링이 가능하도록 만들어주는 함수다. 허나 인자의 수에 따라 새로운 함수를 여러개 만들어 두는 것은 그리 근사한 방법이 아니다. 이 부분도 추상화가 가능하다. 바로 <code>_.partial</code> 함수다. 이 함수는 커링을 보다 높은 레벨로 추상화한 함수다. <code>curry</code>와 마찬가지로 커링이 가능한 함수를 리턴하는 함수이지만 미리 값을 적용시켜둘 인자의 순서를 정할 수 있는 함수다. 사용법을 살펴보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum_init_0 = _.partial(reduce, _, (total, num) =&gt; total + num, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum_init_0(arr)); <span class=\"comment\">// 55</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = _.partial(reduce, _, (total, num) =&gt; total + num);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr, <span class=\"number\">100</span>)); <span class=\"comment\">// 155</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> reduce_arr = _.partial(reduce, arr);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reduce_arr(<span class=\"function\">(<span class=\"params\">total, num</span>) =&gt;</span> total + num)); <span class=\"comment\">// 55</span></span><br></pre></td></tr></table></figure>\n\n<p><code>sum_init_0</code> 함수는 <code>0</code>을 초기값으로 가진 상태로 돌림직한 데이터가 가진 모든 수를 더하는 함수다. 선언되는 과정을 살펴보면 <code>_.partial</code> 함수에게 세개의 인자가 전달된다. 첫번째 인자인 <code>reduce</code>는 커링의 대상이 될 함수다. 이후의 인자들은 <code>reduce</code>에 전달될 인자를 의미한다. 두번째 인자는 <code>_</code>인데 이 부분은 나중에 받겠다는 의미가 된다. <strong>‘지금은 비워두고 나중에 값이 들어오면 여기에 넣어라’</strong>는 의미가 되는 셈이다. 반면 <code>(total, num) =&gt; total + num</code>과 <code>0</code>은 각각 <code>iter</code>, <code>memo</code>를 의미하고(<a href=\"/programming/functional-js-study/\">기본 함수 구현하고 사용하기</a> 편의 <code>reduce</code> 참고) <strong>‘지금 값을 넣어두겠다’</strong>는 의미가 된다. 이렇게 일정 부분만 미리 값을 넣어두는 행위를 <strong>부분 적용</strong>이라고 한다. </p>\n<p><code>sum</code> 함수는 돌림직한 데이터가 가진 모든 수를 더하는 함수다. <code>sum_init_0</code>와는 초기값의 유무에서 차이가 생긴다. <code>_.partial</code> 함수를 살펴보면 마지막 인자 <code>0</code>이 없는 것을 알 수 있다. 이처럼 <code>_.partial</code>로 부분 적용된 함수를 만들 때 마지막 인자가 들어오지 않으면 <code>_</code>과 같은 취급을 한다. 즉 ‘지금은 비워두고 나중에 값이 들어오면 넣는’ 영역으로 본다. 결과적으로 <code>sum</code>은 <code>iter</code>만을 가진 함수가 되어 실행하는 시점에 데이터 <code>arr</code>와 초기값 <code>100</code>을 인자로 줄 수 있었다.</p>\n<p>반면 <code>reduce_arr</code>는 데이터를 가지고 있지만 어떻게 돌리며 접어나갈지 정의 되지 않았다. 때문에 실행되는 시점에 어떻게 돌릴지 정의하는 함수를 주고 결과를 얻어낼 수 있었다. (<code>reduce</code>는 초기값이 생략되면 데이터의 첫번째 값을 초기값으로 사용한다.)</p>\n<p>이렇게 <code>_.partial</code>을 사용하면 <code>_curry</code>, <code>_curryr</code>이 가지고 있던 단점을 모두 보완할 수 있다. 실제 사용의 사례를 보면 이렇다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.go(arr,</span><br><span class=\"line\">  _.partial(filter, _, n =&gt; n % <span class=\"number\">2</span>),</span><br><span class=\"line\">  _(reduce, _, (a, b) =&gt; a + b, <span class=\"number\">0</span>), <span class=\"comment\">// &lt;-- 네임스페이스 '_'는 _.partial 함수다.</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// 25</span></span><br></pre></td></tr></table></figure>\n\n<p>위 코드에서 재미난 부분은 Partial.js에서는 네임스페이스인 <code>_</code>가 <code>_.partial</code> 함수라는 점이다. Partial이라는 라이브러리의 이름이 <code>_.partial</code> 함수와 같은 이유가 바로 이 때문이다. 사실 위의 코드는 <code>_.partial</code>의 사용 예를 보여주기만을 위한 코드라 그리 근사하지 않다. 지난 시간에 만든 <code>filter</code>와 <code>reduce</code> 대신 Partial.js의 함수들을 사용하면 보다 깔끔한 코드를 만들 수 있다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.go(arr,</span><br><span class=\"line\">  _.filter(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n % <span class=\"number\">2</span>),</span><br><span class=\"line\">  _.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b),</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// 25</span></span><br></pre></td></tr></table></figure>\n\n<p><code>_.filter</code>와 <code>_.reduce</code>를 구현하는 코드에는 <code>_.partial</code> 함수가 사용되고 있기 때문에 위와 같은 부분 적용이 가능하다.</p>\n<h5 id=\"2-go-pipe의-사용\"><a href=\"#2-go-pipe의-사용\" class=\"headerlink\" title=\"2. _.go, _.pipe의 사용\"></a>2. <code>_.go</code>, <code>_.pipe</code>의 사용</h5><p>우리는 이미 <code>go</code>와 <code>pipe</code>를 만들고 사용해보았다. 이번에 사용해볼 <code>_.go</code>와 <code>_.pipe</code>는 조금 특별한 비밀을 가지고 있다. 이전에 직접 만들었던 함수와 같은 일을 한다. 함수를 실행하거나 함수를 조합하여 리턴한다. 전달된 인자 중에 <strong>비동기 함수가 있더라도 완벽하게 제어해준다는 점</strong>을 제외하면 주요 역할은 동일한 함수다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">syncDate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">promiseDate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      resolve(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>());</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_.go([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  _.map(syncDate),</span><br><span class=\"line\">  _.map(<span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d.toString()),</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log);</span><br><span class=\"line\"><span class=\"comment\">// 결과:</span></span><br><span class=\"line\"><span class=\"comment\">//  [\"Sun Feb 05 2017 03:33:36 GMT+0900 (KST)\",</span></span><br><span class=\"line\"><span class=\"comment\">//   \"Sun Feb 05 2017 03:33:36 GMT+0900 (KST)\",</span></span><br><span class=\"line\"><span class=\"comment\">//   \"Sun Feb 05 2017 03:33:36 GMT+0900 (KST)\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\">_.go([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  _.map(promiseDate),</span><br><span class=\"line\">  _.map(<span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d.toString()),</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log);</span><br><span class=\"line\"><span class=\"comment\">// 결과:</span></span><br><span class=\"line\"><span class=\"comment\">//  [\"Sun Feb 05 2017 03:33:37 GMT+0900 (KST)\",</span></span><br><span class=\"line\"><span class=\"comment\">//   \"Sun Feb 05 2017 03:33:38 GMT+0900 (KST)\",</span></span><br><span class=\"line\"><span class=\"comment\">//   \"Sun Feb 05 2017 03:33:39 GMT+0900 (KST)\"]</span></span><br></pre></td></tr></table></figure>\n\n<p>위의 예제는 Partial.js의 <a href=\"https://marpple.github.io/partial.js/#컬렉션을-다루는-비동기-제어-함수\" target=\"_blank\" rel=\"noopener\">소개 페이지</a>에 나오는 코드를 가져왔다. 잠깐 코드를 살펴보면 동기적으로 날짜를 리턴하는 <code>snycData</code> 함수와 비동기적으로 날짜를 리턴하는 <code>promiseData</code> 함수가 있다. 두 함수를 <code>_.map</code>에 넣어 실행하면 날짜 데이터를 갖는 배열을 리턴한다. 다시 한번 <code>_.map</code>으로 날짜 데이터를 문자열로 치환하여 리턴하면 결과값과 같은 날짜와 시간을 표시한 문자열이 담긴 배열이 나온다. 비동기 상황임에도 불구하고 동기 상황과 같은 결과를 리턴한다. 물론 3초정도의 시간이 소요된다. <a href=\"/programming/functional-js-study/\">1주차</a>에 만들어본 일반 <code>go</code>를 사용하면 위와 같은 결과를 만들어내지 못한다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  _.map(promiseDate),</span><br><span class=\"line\">  _.map(<span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d.toString()),</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// []</span></span><br></pre></td></tr></table></figure>\n\n<p>비동기 상황을 무시하고 지나가면서 빈 배열만을 리턴한다. 살펴본 것처럼 Partial.js <code>_.go</code>를 사용하면 이와 같은 문제없이 비동기 상황을 생각한대로 제어할 수 있다.</p>\n<h5 id=\"3-템플릿-함수-template\"><a href=\"#3-템플릿-함수-template\" class=\"headerlink\" title=\"3. 템플릿 함수 _.template\"></a>3. 템플릿 함수 <code>_.template</code></h5><p>HTML 코드를 보다 쉽게 작성하기 위해 <a href=\"https://pugjs.org/api/getting-started.html\" target=\"_blank\" rel=\"noopener\">Pug</a>, <a href=\"http://handlebarsjs.com/\" target=\"_blank\" rel=\"noopener\">Handlebars.js</a>, <a href=\"http://www.embeddedjs.com/\" target=\"_blank\" rel=\"noopener\">ejs</a>와 같은 템플릿 엔진이 존재한다. Partial.js는 함수 스타일의 템플릿 엔진인 <code>_.template</code> 함수를 지원한다. Pug와 같은 문법을 사용하는 이 함수의 사용법에 대한 자세한 설명은 <a href=\"https://marpple.github.io/partial.js/#함수-스타일의-템플릿-함수\" target=\"_blank\" rel=\"noopener\">소개 페이지</a>에서 확인할 수 있다.</p>\n<h3 id=\"함수형-jQuery-don-js\"><a href=\"#함수형-jQuery-don-js\" class=\"headerlink\" title=\"함수형 jQuery, don.js\"></a>함수형 jQuery, don.js</h3><h5 id=\"1-jQuery-vs-don-js\"><a href=\"#1-jQuery-vs-don-js\" class=\"headerlink\" title=\"1. jQuery vs don.js\"></a>1. jQuery vs don.js</h5><p>don.js는 jQuery가 지원하는 함수들을 함수형 스타일로 지원한다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// jQuery</span></span><br><span class=\"line\">$(<span class=\"string\">'body'</span>); </span><br><span class=\"line\">$(<span class=\"string\">'body'</span>).addClass(<span class=\"string\">'container'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// don.js</span></span><br><span class=\"line\">D(<span class=\"string\">'body'</span>); </span><br><span class=\"line\">D.addClass(D(<span class=\"string\">'body'</span>), <span class=\"string\">'container'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>jQuery가 체인 방식으로 함수들을 이어나가는 것과 달리 <strong>don.js는 함수의 리턴값을 사용함</strong>으로 함수를 이어나간다. 때문에 Partial.js와 궁합이 잘 맞는다. </p>\n<h5 id=\"2-Don-js-with-Partial-js\"><a href=\"#2-Don-js-with-Partial-js\" class=\"headerlink\" title=\"2. Don.js with Partial.js\"></a>2. Don.js with Partial.js</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// jQuery (http://api.jquery.com/map/)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  $( <span class=\"string\">\":checkbox\"</span> )</span><br><span class=\"line\">    .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.id;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .get() <span class=\"comment\">// &lt;-- 이때 배열이 된다.</span></span><br><span class=\"line\">    .join());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// don.js</span></span><br><span class=\"line\">_.go(</span><br><span class=\"line\">  D(<span class=\"string\">'[type=\"checkbox\"]'</span>),</span><br><span class=\"line\">  _.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> el.id;</span><br><span class=\"line\">  &#125;), <span class=\"comment\">// &lt;-- 이미 배열인 상태다.</span></span><br><span class=\"line\">  _.join(), <span class=\"comment\">// arr =&gt; arr.join(),</span></span><br><span class=\"line\">  _.log);</span><br></pre></td></tr></table></figure>\n\n<p>jQuery가 셀렉터를 통해 찾아 리턴하는 값이 jQuery 객체인데 반해 don.js의 리턴값은 기본형 데이터인 배열이거나 엘리먼트 자체임으로 어떤 순수 함수인 다른 함수들과 조합이 자유롭다. 위의 예제에서 jQuery의 경우, <code>map</code>을 실행한 뒤에 <code>get</code>을 실행하지 않으면 배열의 기본 메서드인 <code>join</code>을 실행할 수 없다. 하지만 don.js는 항상 기본형 데이터를 사용하기 때문에 자유롭게 함수들을 이어갈 수 있다. </p>\n<p><code>_.template</code> 계열의 템플릿 함수들과 함께 사용하면 더 don.js를 재미있고 유용하게 사용할 수 있다. 우선 예제를 위해 아래와 같은 주문서 데이터(<code>projections</code>)가 있다고 가정하자. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> projections = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">2</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'ID'</span>, <span class=\"attr\">age</span>: <span class=\"number\">36</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'긴팔티'</span> &#125;, &#123; <span class=\"attr\">name</span>: <span class=\"string\">'후드티'</span> &#125; ] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">7</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'BJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">32</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'긴팔티'</span> &#125; ] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">3</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">8</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JM'</span>, <span class=\"attr\">age</span>: <span class=\"number\">34</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'에코백'</span> &#125;, &#123; <span class=\"attr\">name</span>: <span class=\"string\">'청바지'</span> &#125;] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">4</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">9</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'PJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'양말'</span> &#125;, &#123; <span class=\"attr\">name</span>: <span class=\"string\">'후드티'</span> &#125;, &#123; <span class=\"attr\">name</span>: <span class=\"string\">'긴팔티'</span> &#125;, &#123; <span class=\"attr\">name</span>: <span class=\"string\">'에코백'</span> &#125; ] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">5</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">1</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'HA'</span>, <span class=\"attr\">age</span>: <span class=\"number\">25</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'에코백'</span> &#125; ] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">6</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">11</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JE'</span>, <span class=\"attr\">age</span>: <span class=\"number\">26</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'머플러'</span> &#125; ] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">7</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">12</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JI'</span>, <span class=\"attr\">age</span>: <span class=\"number\">31</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'머그컵'</span> &#125; ] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">8</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">15</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'MP'</span>, <span class=\"attr\">age</span>: <span class=\"number\">23</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'에코백'</span> &#125; ] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">9</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">15</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'MP'</span>, <span class=\"attr\">age</span>: <span class=\"number\">23</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'에코백'</span> &#125;] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">10</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">15</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'MP'</span>, <span class=\"attr\">age</span>: <span class=\"number\">23</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'에코백'</span> &#125;] &#125; &#125;,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>예제 데이터는 주문서의 아이디, 주문자의 정보와 제품 정보를 담고 있다. 이를 이용해서 주문 목록을 그린다고 가정해보자. 템플릿 함수 중 하나인 <code>_.t$</code>(<code>_.template$</code>의 약식) 함수를 사용하면 아래와 같은 코드로 원하는 목록을 그릴 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.go(</span><br><span class=\"line\">  projections,</span><br><span class=\"line\">  _.sum(_.t$(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    li#&#123;&#123;$.id&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      .user_info#&#123;&#123;$.user_id&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">        h4 &#123;&#123;$._.user.name&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      ul.products &#123;&#123;_.sum($._.products, `</span>, _.t$(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        li &#123;&#123;$.name&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      `</span>) ,<span class=\"string\">`)&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      button 주문취소</span></span><br><span class=\"line\"><span class=\"string\">      `</span>)),</span><br><span class=\"line\">  <span class=\"comment\">// _.hi, // &lt;-- 앞의 주석을 제거하면 어떤 문자열이 만들어지는지 확인할 수 있다.</span></span><br><span class=\"line\">  D.appendTo(<span class=\"string\">'.user_list'</span>));</span><br></pre></td></tr></table></figure>\n\n<p><code>_.sum</code>은 <code>projections</code> 데이터를 바탕으로 <code>_.t$</code> 함수가 만들어낸 HTML 문자열을 하나의 문자열로 합쳐준다. 이렇게 합쳐진 긴 문자열은 <code>D.appendTo</code> 함수에게 전달되는데 이 함수는 <code>&#39;.user_list&#39;</code>라는 문자열을 인자로 받았다. 클래스 명이 ‘user_product’에 해당하는 엘리먼트에게 이후에 들어오는 HTML 문자열을 엘리먼트로 변환해서 붙여넣겠다는 의미다. 결과적으로 앞에서 <code>_.sum</code>에 의해 합쳐진 문자열이 <code>D.appendTo</code>에 의해 엘리먼트로 변환되고 ‘user_product’에 해당하는 클래스를 가진 곳에 붙여진다. </p>\n<p>이벤트를 달아서 주문을 취소하는 동작을 만들기 위해선 아래와 같은 <code>on</code> 함수를 사용하면 된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.go(</span><br><span class=\"line\">  D(<span class=\"string\">'body'</span>),</span><br><span class=\"line\">  D.on(<span class=\"string\">'click'</span>, <span class=\"string\">'button'</span>, _.pipe(</span><br><span class=\"line\">    _.v(<span class=\"string\">'$currentTarget'</span>),</span><br><span class=\"line\">    D.parent(<span class=\"string\">'li'</span>),</span><br><span class=\"line\">    D.hide)</span><br><span class=\"line\">  ));</span><br></pre></td></tr></table></figure>\n\n<p><code>_.pipe</code> 함수가 등장했다. <code>D.on</code> 함수의 세번째 인자로 받을 함수는 ‘클릭 이벤트가 발생하면 어떤 일을 할지 정의한 함수’가 들어와야 한다. 이 함수를 <code>_.pipe</code>가 여러개의 함수를 조합해서 만들었다. 내부를 보면 <code>_.v(&#39;$currentTarget&#39;)</code> 함수가 이벤트의 대상이 되는 엘리먼트를 꺼내고 <code>D.parent(&#39;li&#39;)</code>가 부모 중에 li 엘리먼트인 것을 찾아 리턴한다. 마지막에 <code>D.hide</code>가 리턴된 엘리먼트를 숨긴다. 이러한 순서에 의해 버튼을 클릭하면 대상을 담고 있는 li 엘리먼트가 가려지는 동작을 수행한다. </p>\n<hr>\n<h3 id=\"전체-스터디-일정\"><a href=\"#전체-스터디-일정\" class=\"headerlink\" title=\"전체 스터디 일정\"></a>전체 스터디 일정</h3><ul>\n<li>1주차 - <a href=\"/programming/functional-js-study/\">기본 함수 구현하고 사용하기</a></li>\n<li>2주차 - <a href=\"/programming/functional-js-study-1/\">고차 함수와 커링(currying)</a></li>\n<li>3주차 - 함수형 자바스크립트 라이브러리</li>\n<li><em>4주차 - Movie Box 1: 필터링, 정렬</em></li>\n<li><em>5주차 - Movie Box 2: 필터링, 정렬 복습</em></li>\n<li><em>6주차 - Movie Box 3: 지연평가 L, memoize</em></li>\n<li><em>7주차 - Movie Box 4: 비동기 상황 다루기</em></li>\n</ul>\n<p><a href=\"https://github.com/joeunha/functional-js-study/tree/master/03_week\" target=\"_blank\" rel=\"noopener\">예제 코드</a></p>\n<script async>\nvar arr = [1,2,3,4,5,6,7,8,9,10];\n\nfunction filter(list, iter) {\n  var res = [];\n  if (Array.isArray(list)) {\n    for (var i = 0, len = list.length; i < len; i++) \n      if (iter(list[i], i, list)) \n        res.push(list[i]);\n  } else {\n    var keys = Object.keys(list);\n    for (var i = 0, len = keys.length; i < len; i++) \n      if (iter(list[keys[i]], keys[i], list)) \n        res.push(list[keys[i]]);\n  }\n  return res;\n}\n\nfunction reduce(list, iter, memo) {\n  var i = 0;\n  if (Array.isArray(list)) {\n    var res = (memo != undefined ? memo : list[i++]);\n    for (var len = list.length; i < len; i++) \n      res = iter(res, list[i], i, list);\n  } else {\n    var keys = Object.keys(list), res = (memo != undefined ? memo : list[keys[i++]]);\n    for (var len = keys.length; i < len; i++) \n      res = iter(res, list[keys[i]], keys[i], list);\n  }\n  return res;\n}\n\nvar projections = [\n  { id: 1, user_id: 2, _: { user: { name: 'ID', age: 36 }, products: [ { name: '긴팔티' }, { name: '후드티' } ] } },\n  { id: 2, user_id: 7, _: { user: { name: 'BJ', age: 32 }, products: [ { name: '긴팔티' } ] } },\n  { id: 3, user_id: 8, _: { user: { name: 'JM', age: 34 }, products: [ { name: '에코백' }, { name: '청바지' }] } },\n  { id: 4, user_id: 9, _: { user: { name: 'PJ', age: 27 }, products: [ { name: '양말' }, { name: '후드티' }, { name: '긴팔티' }, { name: '에코백' } ] } },\n  { id: 5, user_id: 1, _: { user: { name: 'HA', age: 25 }, products: [ { name: '에코백' } ] } },\n  { id: 6, user_id: 11, _: { user: { name: 'JE', age: 26 }, products: [ { name: '머플러' } ] } },\n  { id: 7, user_id: 12, _: { user: { name: 'JI', age: 31 }, products: [ { name: '머그컵' } ] } },\n  { id: 8, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' } ] } },\n  { id: 9, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' }] } },\n  { id: 10, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' }] } },\n];\n</script>\n<script async src=\"https://rawgit.com/joeunha/cdn/master/don.js\"></script>\n<script async src=\"https://rawgit.com/marpple/partial.js/master/partial.min.js\"></script>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"함수형-자바스크립트-라이브러리\"><a href=\"#함수형-자바스크립트-라이브러리\" class=\"headerlink\" title=\"함수형 자바스크립트 라이브러리\"></a>함수형 자바스크립트 라이브러리</h2><p>함수형으로 프로그래밍하는데 도움을 주는 자바스크립트 라이브러리를 알아보고 배워보자.<br>(모든 예제는 웹 브라우저의 ‘검사’ 도구를 열어서 테스트할 수 있다.)</p>\n<h3 id=\"Partial-js\"><a href=\"#Partial-js\" class=\"headerlink\" title=\"Partial.js\"></a>Partial.js</h3><h5 id=\"0-Underscore\"><a href=\"#0-Underscore\" class=\"headerlink\" title=\"0. Underscore\"></a>0. Underscore</h5><p>자바스크립트 생태계에서 <code>_</code>(underscore)라는 네임스페이스는 보통 <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore</a>나 <a href=\"https://lodash.com/\" target=\"_blank\" rel=\"noopener\">Lodash</a>의 차지다. underscore가 먼저 등장했고 이후에 조금 더 다양한 함수와 기능으로 무장한 채로 lodash가 등장했다. 그리고 이제 같은 네임스페이스를 사용하지만 보다 함수형 프로그래밍에 적합한 <a href=\"https://marpple.github.io/partial.js/\" target=\"_blank\" rel=\"noopener\">Partial</a>을 소개할 차례다.</p>\n<h5 id=\"1-부분-적용-함수-partial\"><a href=\"#1-부분-적용-함수-partial\" class=\"headerlink\" title=\"1. 부분 적용 함수 _.partial\"></a>1. 부분 적용 함수 <code>_.partial</code></h5><p><a href=\"/programming/functional-js-study-1/\">지난 시간</a>에 다룬 <code>curryr</code> 함수는 해결되지 않은 문제를 가지고 있었다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = curryr(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b);</span><br></pre></td></tr></table></figure>\n\n<p><code>curryr</code>에 의해 커링이 가능하게 만들어진 함수는 받을 수 있는 인자의 개수가 2개로 제한되어 있다는 점이었다. <code>reduce</code>와 같이 3개 이상의 인자를 받는 함수가 커링이 가능하도록 만들기 위해서는 <code>curryr</code>을 새로 만들어야하는 상황이었다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curryr3</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length == <span class=\"number\">1</span>) <span class=\"comment\">// &lt;-- 인자의 수에 따라 다른 값을 리턴</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn(b, a);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length == <span class=\"number\">2</span>) </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn(c, a, b);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn(a, b, c); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>curryr3</code>은 세개의 인자를 받는 함수라도 커링이 가능하도록 만들어주는 함수다. 허나 인자의 수에 따라 새로운 함수를 여러개 만들어 두는 것은 그리 근사한 방법이 아니다. 이 부분도 추상화가 가능하다. 바로 <code>_.partial</code> 함수다. 이 함수는 커링을 보다 높은 레벨로 추상화한 함수다. <code>curry</code>와 마찬가지로 커링이 가능한 함수를 리턴하는 함수이지만 미리 값을 적용시켜둘 인자의 순서를 정할 수 있는 함수다. 사용법을 살펴보자.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum_init_0 = _.partial(reduce, _, (total, num) =&gt; total + num, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum_init_0(arr)); <span class=\"comment\">// 55</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = _.partial(reduce, _, (total, num) =&gt; total + num);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(arr, <span class=\"number\">100</span>)); <span class=\"comment\">// 155</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> reduce_arr = _.partial(reduce, arr);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reduce_arr(<span class=\"function\">(<span class=\"params\">total, num</span>) =&gt;</span> total + num)); <span class=\"comment\">// 55</span></span><br></pre></td></tr></table></figure>\n\n<p><code>sum_init_0</code> 함수는 <code>0</code>을 초기값으로 가진 상태로 돌림직한 데이터가 가진 모든 수를 더하는 함수다. 선언되는 과정을 살펴보면 <code>_.partial</code> 함수에게 세개의 인자가 전달된다. 첫번째 인자인 <code>reduce</code>는 커링의 대상이 될 함수다. 이후의 인자들은 <code>reduce</code>에 전달될 인자를 의미한다. 두번째 인자는 <code>_</code>인데 이 부분은 나중에 받겠다는 의미가 된다. <strong>‘지금은 비워두고 나중에 값이 들어오면 여기에 넣어라’</strong>는 의미가 되는 셈이다. 반면 <code>(total, num) =&gt; total + num</code>과 <code>0</code>은 각각 <code>iter</code>, <code>memo</code>를 의미하고(<a href=\"/programming/functional-js-study/\">기본 함수 구현하고 사용하기</a> 편의 <code>reduce</code> 참고) <strong>‘지금 값을 넣어두겠다’</strong>는 의미가 된다. 이렇게 일정 부분만 미리 값을 넣어두는 행위를 <strong>부분 적용</strong>이라고 한다. </p>\n<p><code>sum</code> 함수는 돌림직한 데이터가 가진 모든 수를 더하는 함수다. <code>sum_init_0</code>와는 초기값의 유무에서 차이가 생긴다. <code>_.partial</code> 함수를 살펴보면 마지막 인자 <code>0</code>이 없는 것을 알 수 있다. 이처럼 <code>_.partial</code>로 부분 적용된 함수를 만들 때 마지막 인자가 들어오지 않으면 <code>_</code>과 같은 취급을 한다. 즉 ‘지금은 비워두고 나중에 값이 들어오면 넣는’ 영역으로 본다. 결과적으로 <code>sum</code>은 <code>iter</code>만을 가진 함수가 되어 실행하는 시점에 데이터 <code>arr</code>와 초기값 <code>100</code>을 인자로 줄 수 있었다.</p>\n<p>반면 <code>reduce_arr</code>는 데이터를 가지고 있지만 어떻게 돌리며 접어나갈지 정의 되지 않았다. 때문에 실행되는 시점에 어떻게 돌릴지 정의하는 함수를 주고 결과를 얻어낼 수 있었다. (<code>reduce</code>는 초기값이 생략되면 데이터의 첫번째 값을 초기값으로 사용한다.)</p>\n<p>이렇게 <code>_.partial</code>을 사용하면 <code>_curry</code>, <code>_curryr</code>이 가지고 있던 단점을 모두 보완할 수 있다. 실제 사용의 사례를 보면 이렇다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.go(arr,</span><br><span class=\"line\">  _.partial(filter, _, n =&gt; n % <span class=\"number\">2</span>),</span><br><span class=\"line\">  _(reduce, _, (a, b) =&gt; a + b, <span class=\"number\">0</span>), <span class=\"comment\">// &lt;-- 네임스페이스 '_'는 _.partial 함수다.</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// 25</span></span><br></pre></td></tr></table></figure>\n\n<p>위 코드에서 재미난 부분은 Partial.js에서는 네임스페이스인 <code>_</code>가 <code>_.partial</code> 함수라는 점이다. Partial이라는 라이브러리의 이름이 <code>_.partial</code> 함수와 같은 이유가 바로 이 때문이다. 사실 위의 코드는 <code>_.partial</code>의 사용 예를 보여주기만을 위한 코드라 그리 근사하지 않다. 지난 시간에 만든 <code>filter</code>와 <code>reduce</code> 대신 Partial.js의 함수들을 사용하면 보다 깔끔한 코드를 만들 수 있다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.go(arr,</span><br><span class=\"line\">  _.filter(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n % <span class=\"number\">2</span>),</span><br><span class=\"line\">  _.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b),</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// 25</span></span><br></pre></td></tr></table></figure>\n\n<p><code>_.filter</code>와 <code>_.reduce</code>를 구현하는 코드에는 <code>_.partial</code> 함수가 사용되고 있기 때문에 위와 같은 부분 적용이 가능하다.</p>\n<h5 id=\"2-go-pipe의-사용\"><a href=\"#2-go-pipe의-사용\" class=\"headerlink\" title=\"2. _.go, _.pipe의 사용\"></a>2. <code>_.go</code>, <code>_.pipe</code>의 사용</h5><p>우리는 이미 <code>go</code>와 <code>pipe</code>를 만들고 사용해보았다. 이번에 사용해볼 <code>_.go</code>와 <code>_.pipe</code>는 조금 특별한 비밀을 가지고 있다. 이전에 직접 만들었던 함수와 같은 일을 한다. 함수를 실행하거나 함수를 조합하여 리턴한다. 전달된 인자 중에 <strong>비동기 함수가 있더라도 완벽하게 제어해준다는 점</strong>을 제외하면 주요 역할은 동일한 함수다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">syncDate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">promiseDate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      resolve(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>());</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">_.go([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  _.map(syncDate),</span><br><span class=\"line\">  _.map(<span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d.toString()),</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log);</span><br><span class=\"line\"><span class=\"comment\">// 결과:</span></span><br><span class=\"line\"><span class=\"comment\">//  [\"Sun Feb 05 2017 03:33:36 GMT+0900 (KST)\",</span></span><br><span class=\"line\"><span class=\"comment\">//   \"Sun Feb 05 2017 03:33:36 GMT+0900 (KST)\",</span></span><br><span class=\"line\"><span class=\"comment\">//   \"Sun Feb 05 2017 03:33:36 GMT+0900 (KST)\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\">_.go([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  _.map(promiseDate),</span><br><span class=\"line\">  _.map(<span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d.toString()),</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log);</span><br><span class=\"line\"><span class=\"comment\">// 결과:</span></span><br><span class=\"line\"><span class=\"comment\">//  [\"Sun Feb 05 2017 03:33:37 GMT+0900 (KST)\",</span></span><br><span class=\"line\"><span class=\"comment\">//   \"Sun Feb 05 2017 03:33:38 GMT+0900 (KST)\",</span></span><br><span class=\"line\"><span class=\"comment\">//   \"Sun Feb 05 2017 03:33:39 GMT+0900 (KST)\"]</span></span><br></pre></td></tr></table></figure>\n\n<p>위의 예제는 Partial.js의 <a href=\"https://marpple.github.io/partial.js/#컬렉션을-다루는-비동기-제어-함수\" target=\"_blank\" rel=\"noopener\">소개 페이지</a>에 나오는 코드를 가져왔다. 잠깐 코드를 살펴보면 동기적으로 날짜를 리턴하는 <code>snycData</code> 함수와 비동기적으로 날짜를 리턴하는 <code>promiseData</code> 함수가 있다. 두 함수를 <code>_.map</code>에 넣어 실행하면 날짜 데이터를 갖는 배열을 리턴한다. 다시 한번 <code>_.map</code>으로 날짜 데이터를 문자열로 치환하여 리턴하면 결과값과 같은 날짜와 시간을 표시한 문자열이 담긴 배열이 나온다. 비동기 상황임에도 불구하고 동기 상황과 같은 결과를 리턴한다. 물론 3초정도의 시간이 소요된다. <a href=\"/programming/functional-js-study/\">1주차</a>에 만들어본 일반 <code>go</code>를 사용하면 위와 같은 결과를 만들어내지 못한다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  _.map(promiseDate),</span><br><span class=\"line\">  _.map(<span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d.toString()),</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log); <span class=\"comment\">// []</span></span><br></pre></td></tr></table></figure>\n\n<p>비동기 상황을 무시하고 지나가면서 빈 배열만을 리턴한다. 살펴본 것처럼 Partial.js <code>_.go</code>를 사용하면 이와 같은 문제없이 비동기 상황을 생각한대로 제어할 수 있다.</p>\n<h5 id=\"3-템플릿-함수-template\"><a href=\"#3-템플릿-함수-template\" class=\"headerlink\" title=\"3. 템플릿 함수 _.template\"></a>3. 템플릿 함수 <code>_.template</code></h5><p>HTML 코드를 보다 쉽게 작성하기 위해 <a href=\"https://pugjs.org/api/getting-started.html\" target=\"_blank\" rel=\"noopener\">Pug</a>, <a href=\"http://handlebarsjs.com/\" target=\"_blank\" rel=\"noopener\">Handlebars.js</a>, <a href=\"http://www.embeddedjs.com/\" target=\"_blank\" rel=\"noopener\">ejs</a>와 같은 템플릿 엔진이 존재한다. Partial.js는 함수 스타일의 템플릿 엔진인 <code>_.template</code> 함수를 지원한다. Pug와 같은 문법을 사용하는 이 함수의 사용법에 대한 자세한 설명은 <a href=\"https://marpple.github.io/partial.js/#함수-스타일의-템플릿-함수\" target=\"_blank\" rel=\"noopener\">소개 페이지</a>에서 확인할 수 있다.</p>\n<h3 id=\"함수형-jQuery-don-js\"><a href=\"#함수형-jQuery-don-js\" class=\"headerlink\" title=\"함수형 jQuery, don.js\"></a>함수형 jQuery, don.js</h3><h5 id=\"1-jQuery-vs-don-js\"><a href=\"#1-jQuery-vs-don-js\" class=\"headerlink\" title=\"1. jQuery vs don.js\"></a>1. jQuery vs don.js</h5><p>don.js는 jQuery가 지원하는 함수들을 함수형 스타일로 지원한다. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// jQuery</span></span><br><span class=\"line\">$(<span class=\"string\">'body'</span>); </span><br><span class=\"line\">$(<span class=\"string\">'body'</span>).addClass(<span class=\"string\">'container'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// don.js</span></span><br><span class=\"line\">D(<span class=\"string\">'body'</span>); </span><br><span class=\"line\">D.addClass(D(<span class=\"string\">'body'</span>), <span class=\"string\">'container'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>jQuery가 체인 방식으로 함수들을 이어나가는 것과 달리 <strong>don.js는 함수의 리턴값을 사용함</strong>으로 함수를 이어나간다. 때문에 Partial.js와 궁합이 잘 맞는다. </p>\n<h5 id=\"2-Don-js-with-Partial-js\"><a href=\"#2-Don-js-with-Partial-js\" class=\"headerlink\" title=\"2. Don.js with Partial.js\"></a>2. Don.js with Partial.js</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// jQuery (http://api.jquery.com/map/)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">  $( <span class=\"string\">\":checkbox\"</span> )</span><br><span class=\"line\">    .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.id;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .get() <span class=\"comment\">// &lt;-- 이때 배열이 된다.</span></span><br><span class=\"line\">    .join());</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// don.js</span></span><br><span class=\"line\">_.go(</span><br><span class=\"line\">  D(<span class=\"string\">'[type=\"checkbox\"]'</span>),</span><br><span class=\"line\">  _.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> el.id;</span><br><span class=\"line\">  &#125;), <span class=\"comment\">// &lt;-- 이미 배열인 상태다.</span></span><br><span class=\"line\">  _.join(), <span class=\"comment\">// arr =&gt; arr.join(),</span></span><br><span class=\"line\">  _.log);</span><br></pre></td></tr></table></figure>\n\n<p>jQuery가 셀렉터를 통해 찾아 리턴하는 값이 jQuery 객체인데 반해 don.js의 리턴값은 기본형 데이터인 배열이거나 엘리먼트 자체임으로 어떤 순수 함수인 다른 함수들과 조합이 자유롭다. 위의 예제에서 jQuery의 경우, <code>map</code>을 실행한 뒤에 <code>get</code>을 실행하지 않으면 배열의 기본 메서드인 <code>join</code>을 실행할 수 없다. 하지만 don.js는 항상 기본형 데이터를 사용하기 때문에 자유롭게 함수들을 이어갈 수 있다. </p>\n<p><code>_.template</code> 계열의 템플릿 함수들과 함께 사용하면 더 don.js를 재미있고 유용하게 사용할 수 있다. 우선 예제를 위해 아래와 같은 주문서 데이터(<code>projections</code>)가 있다고 가정하자. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> projections = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">2</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'ID'</span>, <span class=\"attr\">age</span>: <span class=\"number\">36</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'긴팔티'</span> &#125;, &#123; <span class=\"attr\">name</span>: <span class=\"string\">'후드티'</span> &#125; ] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">7</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'BJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">32</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'긴팔티'</span> &#125; ] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">3</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">8</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JM'</span>, <span class=\"attr\">age</span>: <span class=\"number\">34</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'에코백'</span> &#125;, &#123; <span class=\"attr\">name</span>: <span class=\"string\">'청바지'</span> &#125;] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">4</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">9</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'PJ'</span>, <span class=\"attr\">age</span>: <span class=\"number\">27</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'양말'</span> &#125;, &#123; <span class=\"attr\">name</span>: <span class=\"string\">'후드티'</span> &#125;, &#123; <span class=\"attr\">name</span>: <span class=\"string\">'긴팔티'</span> &#125;, &#123; <span class=\"attr\">name</span>: <span class=\"string\">'에코백'</span> &#125; ] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">5</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">1</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'HA'</span>, <span class=\"attr\">age</span>: <span class=\"number\">25</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'에코백'</span> &#125; ] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">6</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">11</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JE'</span>, <span class=\"attr\">age</span>: <span class=\"number\">26</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'머플러'</span> &#125; ] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">7</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">12</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'JI'</span>, <span class=\"attr\">age</span>: <span class=\"number\">31</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'머그컵'</span> &#125; ] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">8</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">15</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'MP'</span>, <span class=\"attr\">age</span>: <span class=\"number\">23</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'에코백'</span> &#125; ] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">9</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">15</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'MP'</span>, <span class=\"attr\">age</span>: <span class=\"number\">23</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'에코백'</span> &#125;] &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">id</span>: <span class=\"number\">10</span>, <span class=\"attr\">user_id</span>: <span class=\"number\">15</span>, <span class=\"attr\">_</span>: &#123; <span class=\"attr\">user</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'MP'</span>, <span class=\"attr\">age</span>: <span class=\"number\">23</span> &#125;, <span class=\"attr\">products</span>: [ &#123; <span class=\"attr\">name</span>: <span class=\"string\">'에코백'</span> &#125;] &#125; &#125;,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>예제 데이터는 주문서의 아이디, 주문자의 정보와 제품 정보를 담고 있다. 이를 이용해서 주문 목록을 그린다고 가정해보자. 템플릿 함수 중 하나인 <code>_.t$</code>(<code>_.template$</code>의 약식) 함수를 사용하면 아래와 같은 코드로 원하는 목록을 그릴 수 있다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.go(</span><br><span class=\"line\">  projections,</span><br><span class=\"line\">  _.sum(_.t$(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    li#&#123;&#123;$.id&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      .user_info#&#123;&#123;$.user_id&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">        h4 &#123;&#123;$._.user.name&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      ul.products &#123;&#123;_.sum($._.products, `</span>, _.t$(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        li &#123;&#123;$.name&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      `</span>) ,<span class=\"string\">`)&#125;&#125;</span></span><br><span class=\"line\"><span class=\"string\">      button 주문취소</span></span><br><span class=\"line\"><span class=\"string\">      `</span>)),</span><br><span class=\"line\">  <span class=\"comment\">// _.hi, // &lt;-- 앞의 주석을 제거하면 어떤 문자열이 만들어지는지 확인할 수 있다.</span></span><br><span class=\"line\">  D.appendTo(<span class=\"string\">'.user_list'</span>));</span><br></pre></td></tr></table></figure>\n\n<p><code>_.sum</code>은 <code>projections</code> 데이터를 바탕으로 <code>_.t$</code> 함수가 만들어낸 HTML 문자열을 하나의 문자열로 합쳐준다. 이렇게 합쳐진 긴 문자열은 <code>D.appendTo</code> 함수에게 전달되는데 이 함수는 <code>&#39;.user_list&#39;</code>라는 문자열을 인자로 받았다. 클래스 명이 ‘user_product’에 해당하는 엘리먼트에게 이후에 들어오는 HTML 문자열을 엘리먼트로 변환해서 붙여넣겠다는 의미다. 결과적으로 앞에서 <code>_.sum</code>에 의해 합쳐진 문자열이 <code>D.appendTo</code>에 의해 엘리먼트로 변환되고 ‘user_product’에 해당하는 클래스를 가진 곳에 붙여진다. </p>\n<p>이벤트를 달아서 주문을 취소하는 동작을 만들기 위해선 아래와 같은 <code>on</code> 함수를 사용하면 된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.go(</span><br><span class=\"line\">  D(<span class=\"string\">'body'</span>),</span><br><span class=\"line\">  D.on(<span class=\"string\">'click'</span>, <span class=\"string\">'button'</span>, _.pipe(</span><br><span class=\"line\">    _.v(<span class=\"string\">'$currentTarget'</span>),</span><br><span class=\"line\">    D.parent(<span class=\"string\">'li'</span>),</span><br><span class=\"line\">    D.hide)</span><br><span class=\"line\">  ));</span><br></pre></td></tr></table></figure>\n\n<p><code>_.pipe</code> 함수가 등장했다. <code>D.on</code> 함수의 세번째 인자로 받을 함수는 ‘클릭 이벤트가 발생하면 어떤 일을 할지 정의한 함수’가 들어와야 한다. 이 함수를 <code>_.pipe</code>가 여러개의 함수를 조합해서 만들었다. 내부를 보면 <code>_.v(&#39;$currentTarget&#39;)</code> 함수가 이벤트의 대상이 되는 엘리먼트를 꺼내고 <code>D.parent(&#39;li&#39;)</code>가 부모 중에 li 엘리먼트인 것을 찾아 리턴한다. 마지막에 <code>D.hide</code>가 리턴된 엘리먼트를 숨긴다. 이러한 순서에 의해 버튼을 클릭하면 대상을 담고 있는 li 엘리먼트가 가려지는 동작을 수행한다. </p>\n<hr>\n<h3 id=\"전체-스터디-일정\"><a href=\"#전체-스터디-일정\" class=\"headerlink\" title=\"전체 스터디 일정\"></a>전체 스터디 일정</h3><ul>\n<li>1주차 - <a href=\"/programming/functional-js-study/\">기본 함수 구현하고 사용하기</a></li>\n<li>2주차 - <a href=\"/programming/functional-js-study-1/\">고차 함수와 커링(currying)</a></li>\n<li>3주차 - 함수형 자바스크립트 라이브러리</li>\n<li><em>4주차 - Movie Box 1: 필터링, 정렬</em></li>\n<li><em>5주차 - Movie Box 2: 필터링, 정렬 복습</em></li>\n<li><em>6주차 - Movie Box 3: 지연평가 L, memoize</em></li>\n<li><em>7주차 - Movie Box 4: 비동기 상황 다루기</em></li>\n</ul>\n<p><a href=\"https://github.com/joeunha/functional-js-study/tree/master/03_week\" target=\"_blank\" rel=\"noopener\">예제 코드</a></p>\n<script async>\nvar arr = [1,2,3,4,5,6,7,8,9,10];\n\nfunction filter(list, iter) {\n  var res = [];\n  if (Array.isArray(list)) {\n    for (var i = 0, len = list.length; i < len; i++) \n      if (iter(list[i], i, list)) \n        res.push(list[i]);\n  } else {\n    var keys = Object.keys(list);\n    for (var i = 0, len = keys.length; i < len; i++) \n      if (iter(list[keys[i]], keys[i], list)) \n        res.push(list[keys[i]]);\n  }\n  return res;\n}\n\nfunction reduce(list, iter, memo) {\n  var i = 0;\n  if (Array.isArray(list)) {\n    var res = (memo != undefined ? memo : list[i++]);\n    for (var len = list.length; i < len; i++) \n      res = iter(res, list[i], i, list);\n  } else {\n    var keys = Object.keys(list), res = (memo != undefined ? memo : list[keys[i++]]);\n    for (var len = keys.length; i < len; i++) \n      res = iter(res, list[keys[i]], keys[i], list);\n  }\n  return res;\n}\n\nvar projections = [\n  { id: 1, user_id: 2, _: { user: { name: 'ID', age: 36 }, products: [ { name: '긴팔티' }, { name: '후드티' } ] } },\n  { id: 2, user_id: 7, _: { user: { name: 'BJ', age: 32 }, products: [ { name: '긴팔티' } ] } },\n  { id: 3, user_id: 8, _: { user: { name: 'JM', age: 34 }, products: [ { name: '에코백' }, { name: '청바지' }] } },\n  { id: 4, user_id: 9, _: { user: { name: 'PJ', age: 27 }, products: [ { name: '양말' }, { name: '후드티' }, { name: '긴팔티' }, { name: '에코백' } ] } },\n  { id: 5, user_id: 1, _: { user: { name: 'HA', age: 25 }, products: [ { name: '에코백' } ] } },\n  { id: 6, user_id: 11, _: { user: { name: 'JE', age: 26 }, products: [ { name: '머플러' } ] } },\n  { id: 7, user_id: 12, _: { user: { name: 'JI', age: 31 }, products: [ { name: '머그컵' } ] } },\n  { id: 8, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' } ] } },\n  { id: 9, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' }] } },\n  { id: 10, user_id: 15, _: { user: { name: 'MP', age: 23 }, products: [ { name: '에코백' }] } },\n];\n</script>\n<script async src=\"https://rawgit.com/joeunha/cdn/master/don.js\"></script>\n<script async src=\"https://rawgit.com/marpple/partial.js/master/partial.min.js\"></script>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck6jcr9ef0001dirvvu91jkrq","category_id":"ck6jcr9en0004dirvnn0b0c32","_id":"ck6jcr9ew000ddirv8nl095nc"},{"post_id":"ck6jcr9et000adirvq9qs988p","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9f2000idirv4357l912"},{"post_id":"ck6jcr9ek0003dirvslfjuslh","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9f4000ldirvefnbub0p"},{"post_id":"ck6jcr9ev000cdirvsmaaegnq","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9f7000odirv7e2kpjzx"},{"post_id":"ck6jcr9ey000fdirv99jhkmpj","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9f8000sdirvz0bfodp3"},{"post_id":"ck6jcr9eo0005dirvsam3irzg","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9fa000wdirv97c6l09h"},{"post_id":"ck6jcr9f3000kdirvepeii5ne","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9fc0010dirv4t67kc6y"},{"post_id":"ck6jcr9eq0007dirvsn43i040","category_id":"ck6jcr9f2000jdirv2o8o5it7","_id":"ck6jcr9fd0013dirv73npold0"},{"post_id":"ck6jcr9f5000ndirvsl9fzuzv","category_id":"ck6jcr9en0004dirvnn0b0c32","_id":"ck6jcr9fe0015dirvkwnucflg"},{"post_id":"ck6jcr9f8000rdirve6nr21sc","category_id":"ck6jcr9en0004dirvnn0b0c32","_id":"ck6jcr9fg0017dirv7hzqxfso"},{"post_id":"ck6jcr9es0008dirv7k4y1zfp","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9fh001adirvt8fb1z4h"},{"post_id":"ck6jcr9f9000vdirvj1w8h2hy","category_id":"ck6jcr9en0004dirvnn0b0c32","_id":"ck6jcr9fi001cdirvrjuxlrsx"},{"post_id":"ck6jcr9fb000zdirv2ye64d2s","category_id":"ck6jcr9en0004dirvnn0b0c32","_id":"ck6jcr9fj001fdirvkbhsg8gu"},{"post_id":"ck6jcr9f1000hdirv61nn999k","category_id":"ck6jcr9fb000ydirv7nqou7ir","_id":"ck6jcr9fl001idirvw68k9m7z"},{"post_id":"ck6jcr9fc0012dirv1yvfxzjp","category_id":"ck6jcr9fb000ydirv7nqou7ir","_id":"ck6jcr9fm001mdirv9octrwt7"},{"post_id":"ck6jcr9fe0014dirvayib7dbw","category_id":"ck6jcr9fb000ydirv7nqou7ir","_id":"ck6jcr9fo001pdirvn0cd85n2"},{"post_id":"ck6jcr9ff0016dirvsronrnsa","category_id":"ck6jcr9fb000ydirv7nqou7ir","_id":"ck6jcr9fq001tdirvir2unvcj"},{"post_id":"ck6jcr9fg0019dirv9zouctiy","category_id":"ck6jcr9fb000ydirv7nqou7ir","_id":"ck6jcr9fr001wdirvvkcngzfm"},{"post_id":"ck6jcr9fh001bdirv4ez14ja4","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9fx0020dirvwpckvqs9"},{"post_id":"ck6jcr9fj001edirvpzka1mgf","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9fy0023dirvjijh4ym6"},{"post_id":"ck6jcr9fk001hdirvglb8s495","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9fz0026dirvdeixk2hs"},{"post_id":"ck6jcr9fm001ldirvybg39qzu","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9g1002adirv58p700m0"},{"post_id":"ck6jcr9fn001odirvmeo3q0qf","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9g3002ddirvhu02qs67"},{"post_id":"ck6jcr9fo001sdirvd9fesxa5","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9g6002hdirviuajqg9x"},{"post_id":"ck6jcr9fq001vdirv82fq0mh9","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9g7002kdirvjxi0iw3x"},{"post_id":"ck6jcr9fw001zdirv57kp94db","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9g9002odirv1ptsv6wu"},{"post_id":"ck6jcr9fx0022dirvhjf8bwle","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9ga002rdirv21hxdq8x"},{"post_id":"ck6jcr9fz0025dirvwatnfln0","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9gd002vdirvt2r6ewbw"},{"post_id":"ck6jcr9g00029dirvwhnv7tbj","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9gf002ydirv1tnriukn"},{"post_id":"ck6jcr9g2002cdirvr4xu8ro2","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9gh0032dirvsomm8d8e"},{"post_id":"ck6jcr9g5002gdirvob15wz14","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9gi0035dirvs16h0xkc"},{"post_id":"ck6jcr9g6002jdirv4pd1ylx9","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9gk0039dirvijg7geof"},{"post_id":"ck6jcr9g8002ndirv05zjitum","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9gl003cdirv6p2js6cn"},{"post_id":"ck6jcr9ga002qdirvr6jw0tqb","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9gn003gdirvma54sdjh"},{"post_id":"ck6jcr9gc002udirvo8c3qadi","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9gp003jdirvis88puez"},{"post_id":"ck6jcr9ge002xdirvi33icg5u","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9gr003ndirv5vvz9jem"},{"post_id":"ck6jcr9gg0031dirvwqacvjxj","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9gr003qdirvoo923k4x"},{"post_id":"ck6jcr9gi0034dirvrhjh54yo","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9gt003udirvomjzy75m"},{"post_id":"ck6jcr9gj0038dirvnu4dpdvb","category_id":"ck6jcr9fb000ydirv7nqou7ir","_id":"ck6jcr9gu003xdirven3kvvjn"},{"post_id":"ck6jcr9gl003bdirvvzryczu4","category_id":"ck6jcr9fb000ydirv7nqou7ir","_id":"ck6jcr9gv0041dirv8qv6vcb9"},{"post_id":"ck6jcr9gn003fdirv1f1ic7hk","category_id":"ck6jcr9fb000ydirv7nqou7ir","_id":"ck6jcr9gw0044dirv37ged7sq"},{"post_id":"ck6jcr9go003idirvfwzf9ka7","category_id":"ck6jcr9fb000ydirv7nqou7ir","_id":"ck6jcr9gx0048dirvnpk934iy"},{"post_id":"ck6jcr9gq003mdirv6o6kb53h","category_id":"ck6jcr9fb000ydirv7nqou7ir","_id":"ck6jcr9gy004bdirvzyq9cft8"},{"post_id":"ck6jcr9gr003pdirv6v8sqen2","category_id":"ck6jcr9fb000ydirv7nqou7ir","_id":"ck6jcr9gz004fdirvp6cx8001"},{"post_id":"ck6jcr9gs003tdirv1jykudsz","category_id":"ck6jcr9fb000ydirv7nqou7ir","_id":"ck6jcr9h0004idirvf0iuorxr"},{"post_id":"ck6jcr9gt003wdirvyy3h6f97","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9h1004mdirvcq9et6i7"},{"post_id":"ck6jcr9gu0040dirvo12x17qp","category_id":"ck6jcr9fb000ydirv7nqou7ir","_id":"ck6jcr9h2004pdirvc2gtkhtc"},{"post_id":"ck6jcr9gv0043dirvyc7zny3e","category_id":"ck6jcr9fb000ydirv7nqou7ir","_id":"ck6jcr9h3004udirvrbravxfh"},{"post_id":"ck6jcr9gx0047dirv8ayviu67","category_id":"ck6jcr9fb000ydirv7nqou7ir","_id":"ck6jcr9h7004xdirvgnyxrehl"},{"post_id":"ck6jcr9gy004adirvhh6gqcj1","category_id":"ck6jcr9fb000ydirv7nqou7ir","_id":"ck6jcr9h80050dirvfuomhkd7"},{"post_id":"ck6jcr9gz004edirv0zo16el3","category_id":"ck6jcr9fb000ydirv7nqou7ir","_id":"ck6jcr9h90052dirv41mriif8"},{"post_id":"ck6jcr9gz004hdirv6sgqjmlp","category_id":"ck6jcr9f2000jdirv2o8o5it7","_id":"ck6jcr9h90055dirvixb4afp6"},{"post_id":"ck6jcr9h2004odirvhqjph65q","category_id":"ck6jcr9en0004dirvnn0b0c32","_id":"ck6jcr9ha0057dirv8bsn4k0s"},{"post_id":"ck6jcr9h3004tdirv2oy3b7gv","category_id":"ck6jcr9en0004dirvnn0b0c32","_id":"ck6jcr9ha005adirv46t6le5x"},{"post_id":"ck6jcr9h6004wdirv9m6vd6fa","category_id":"ck6jcr9h2004qdirvvzfwz2t0","_id":"ck6jcr9ha005cdirv755ekjiz"},{"post_id":"ck6jcr9h1004ldirvsc2pc2sy","category_id":"ck6jcr9h2004qdirvvzfwz2t0","_id":"ck6jcr9hb005edirvbe06r7w1"},{"post_id":"ck6jcr9ii0097dirvb1t5lodn","category_id":"ck6jcr9f2000jdirv2o8o5it7","_id":"ck6jcr9ir009edirv4v8uaabz"},{"post_id":"ck6jcr9ik009adirvzfk5kacb","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9it009idirv75gre0dw"},{"post_id":"ck6jcr9im009bdirv6jfhshik","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9iv009ldirvc8i8ru82"},{"post_id":"ck6jcr9ig0096dirvujxq7nc0","category_id":"ck6jcr9ij0098dirvbscdih0s","_id":"ck6jcr9ix009pdirvk43yj9uf"},{"post_id":"ck6jcr9io009ddirvhqz3612g","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9j1009sdirvbrkvflui"},{"post_id":"ck6jcr9is009hdirvq9jbrkzs","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9j3009wdirvv9ep9dgi"},{"post_id":"ck6jcr9iu009kdirve2nt355g","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9j5009ydirvcc58p0s4"},{"post_id":"ck6jcr9iw009odirvt6lq8chg","category_id":"ck6jcr9f2000jdirv2o8o5it7","_id":"ck6jcr9j600a1dirvoyz6zbk4"},{"post_id":"ck6jcr9iz009rdirv6lslivjh","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9j700a3dirvl0bpg2s4"},{"post_id":"ck6jcr9j2009vdirvo8dzjqy2","category_id":"ck6jcr9f2000jdirv2o8o5it7","_id":"ck6jcr9j700a5dirva861kewz"},{"post_id":"ck6jcr9jd00audirvea96ipxa","category_id":"ck6jcr9et0009dirvrovggga1","_id":"ck6jcr9jg00axdirvf7jcborb"}],"PostTag":[{"post_id":"ck6jcr9ek0003dirvslfjuslh","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9f7000pdirv5zgt7493"},{"post_id":"ck6jcr9ek0003dirvslfjuslh","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9f9000tdirvpn8g9edc"},{"post_id":"ck6jcr9ek0003dirvslfjuslh","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9fa000xdirvp1y9fb1i"},{"post_id":"ck6jcr9fh001bdirv4ez14ja4","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9fk001gdirvtcfx01wa"},{"post_id":"ck6jcr9fh001bdirv4ez14ja4","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9fm001kdirvgc3pn03m"},{"post_id":"ck6jcr9fh001bdirv4ez14ja4","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9fn001ndirvzyagku8a"},{"post_id":"ck6jcr9fj001edirvpzka1mgf","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9fo001rdirvgy9eraj4"},{"post_id":"ck6jcr9fj001edirvpzka1mgf","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9fq001udirv0dhkl2f9"},{"post_id":"ck6jcr9fj001edirvpzka1mgf","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9fr001xdirv0ubv3uti"},{"post_id":"ck6jcr9fk001hdirvglb8s495","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9fx0021dirviobfy59q"},{"post_id":"ck6jcr9fk001hdirvglb8s495","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9fz0024dirvs9s1kaop"},{"post_id":"ck6jcr9fk001hdirvglb8s495","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9g00028dirvs7ijla3q"},{"post_id":"ck6jcr9eo0005dirvsam3irzg","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9g2002bdirvmvokihh6"},{"post_id":"ck6jcr9eo0005dirvsam3irzg","tag_id":"ck6jcr9f9000udirv9ao0kman","_id":"ck6jcr9g5002fdirvj944155g"},{"post_id":"ck6jcr9eo0005dirvsam3irzg","tag_id":"ck6jcr9fc0011dirvnws984ho","_id":"ck6jcr9g6002idirvibmtquw7"},{"post_id":"ck6jcr9eo0005dirvsam3irzg","tag_id":"ck6jcr9fg0018dirv8axv15q0","_id":"ck6jcr9g8002mdirvriygpqcn"},{"post_id":"ck6jcr9eo0005dirvsam3irzg","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9g9002pdirv1wdftmco"},{"post_id":"ck6jcr9eo0005dirvsam3irzg","tag_id":"ck6jcr9fl001jdirvxnrxxt30","_id":"ck6jcr9gc002tdirv4orw5xz9"},{"post_id":"ck6jcr9fo001sdirvd9fesxa5","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9ge002wdirv13pmon3j"},{"post_id":"ck6jcr9fo001sdirvd9fesxa5","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9gg0030dirvkjlw81br"},{"post_id":"ck6jcr9fo001sdirvd9fesxa5","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9gi0033dirvns5t4rfz"},{"post_id":"ck6jcr9fq001vdirv82fq0mh9","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9gj0037dirv3vphx0ac"},{"post_id":"ck6jcr9fq001vdirv82fq0mh9","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9gk003adirv0bfyv0dy"},{"post_id":"ck6jcr9fq001vdirv82fq0mh9","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9gm003edirv52g8eikt"},{"post_id":"ck6jcr9fw001zdirv57kp94db","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9go003hdirvz9ysa469"},{"post_id":"ck6jcr9fw001zdirv57kp94db","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9gp003ldirvqzd284pa"},{"post_id":"ck6jcr9fw001zdirv57kp94db","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9gr003odirv48q19epl"},{"post_id":"ck6jcr9fx0022dirvhjf8bwle","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9gs003sdirv29ecpu86"},{"post_id":"ck6jcr9fx0022dirvhjf8bwle","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9gt003vdirvfh559fct"},{"post_id":"ck6jcr9fx0022dirvhjf8bwle","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9gu003zdirviukioail"},{"post_id":"ck6jcr9eq0007dirvsn43i040","tag_id":"ck6jcr9fo001qdirvn0lj9ypk","_id":"ck6jcr9gv0042dirv636ozpqd"},{"post_id":"ck6jcr9eq0007dirvsn43i040","tag_id":"ck6jcr9fr001ydirvbdtpa118","_id":"ck6jcr9gw0046dirvif1gg5n2"},{"post_id":"ck6jcr9fz0025dirvwatnfln0","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9gx0049dirvlxnw8mrh"},{"post_id":"ck6jcr9fz0025dirvwatnfln0","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9gy004ddirv6q6zt7lr"},{"post_id":"ck6jcr9fz0025dirvwatnfln0","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9gz004gdirvmm4x68hn"},{"post_id":"ck6jcr9g00029dirvwhnv7tbj","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9h0004kdirv0pfa5zi0"},{"post_id":"ck6jcr9g00029dirvwhnv7tbj","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9h1004ndirvx6gva4aj"},{"post_id":"ck6jcr9g00029dirvwhnv7tbj","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9h3004rdirv2wy0ybcn"},{"post_id":"ck6jcr9g2002cdirvr4xu8ro2","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9h5004vdirvly3zf5nm"},{"post_id":"ck6jcr9g2002cdirvr4xu8ro2","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9h8004ydirvb4gytetj"},{"post_id":"ck6jcr9g2002cdirvr4xu8ro2","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9h90051dirvrmcwj07x"},{"post_id":"ck6jcr9g5002gdirvob15wz14","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9h90053dirvt1q6unvc"},{"post_id":"ck6jcr9g5002gdirvob15wz14","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9ha0056dirvzn6af240"},{"post_id":"ck6jcr9g5002gdirvob15wz14","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9ha0058dirvkex79iig"},{"post_id":"ck6jcr9g6002jdirv4pd1ylx9","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9ha005bdirvknqqs5pl"},{"post_id":"ck6jcr9g6002jdirv4pd1ylx9","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9hb005ddirvvq7f94q5"},{"post_id":"ck6jcr9g6002jdirv4pd1ylx9","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9hb005gdirv8dc92mqo"},{"post_id":"ck6jcr9g8002ndirv05zjitum","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9hb005hdirvy6vn9zlf"},{"post_id":"ck6jcr9g8002ndirv05zjitum","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9hc005jdirv9aryspk4"},{"post_id":"ck6jcr9g8002ndirv05zjitum","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9hc005kdirvvuvmkhv1"},{"post_id":"ck6jcr9es0008dirv7k4y1zfp","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9hc005mdirvwp22fg14"},{"post_id":"ck6jcr9es0008dirv7k4y1zfp","tag_id":"ck6jcr9f9000udirv9ao0kman","_id":"ck6jcr9hc005ndirvicvtk4sp"},{"post_id":"ck6jcr9es0008dirv7k4y1zfp","tag_id":"ck6jcr9g3002edirvwv204psp","_id":"ck6jcr9hd005pdirv7hjxjmwe"},{"post_id":"ck6jcr9es0008dirv7k4y1zfp","tag_id":"ck6jcr9g7002ldirv76ny0nkt","_id":"ck6jcr9he005qdirv5sbcxh4k"},{"post_id":"ck6jcr9ga002qdirvr6jw0tqb","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9he005sdirvff2h1qf8"},{"post_id":"ck6jcr9ga002qdirvr6jw0tqb","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9hf005tdirvbye7yp8z"},{"post_id":"ck6jcr9ga002qdirvr6jw0tqb","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9hf005vdirvmqcalp1p"},{"post_id":"ck6jcr9gc002udirvo8c3qadi","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9hf005wdirvig66qf8n"},{"post_id":"ck6jcr9gc002udirvo8c3qadi","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9hg005ydirvlnhco0f6"},{"post_id":"ck6jcr9gc002udirvo8c3qadi","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9hg005zdirvnzll3ldw"},{"post_id":"ck6jcr9ge002xdirvi33icg5u","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9hh0061dirvdevybs6e"},{"post_id":"ck6jcr9ge002xdirvi33icg5u","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9hh0062dirvhkjl6fqo"},{"post_id":"ck6jcr9ge002xdirvi33icg5u","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9hh0063dirvgpp9k70i"},{"post_id":"ck6jcr9gg0031dirvwqacvjxj","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9hi0065dirvvt8odvv7"},{"post_id":"ck6jcr9gg0031dirvwqacvjxj","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9hj0066dirvxi3dgonc"},{"post_id":"ck6jcr9gg0031dirvwqacvjxj","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9hj0068dirv745kz37h"},{"post_id":"ck6jcr9gi0034dirvrhjh54yo","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9hk0069dirv31zs42up"},{"post_id":"ck6jcr9gi0034dirvrhjh54yo","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9hl006bdirvah3l8u6x"},{"post_id":"ck6jcr9gi0034dirvrhjh54yo","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9hl006cdirvg9ktma5t"},{"post_id":"ck6jcr9et000adirvq9qs988p","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9hl006edirvyiu2mdr0"},{"post_id":"ck6jcr9et000adirvq9qs988p","tag_id":"ck6jcr9f9000udirv9ao0kman","_id":"ck6jcr9hl006fdirvphketrma"},{"post_id":"ck6jcr9et000adirvq9qs988p","tag_id":"ck6jcr9g3002edirvwv204psp","_id":"ck6jcr9hm006hdirv2ho046yz"},{"post_id":"ck6jcr9et000adirvq9qs988p","tag_id":"ck6jcr9g7002ldirv76ny0nkt","_id":"ck6jcr9hm006idirvy1wg688b"},{"post_id":"ck6jcr9gn003fdirv1f1ic7hk","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9hn006kdirvob7wgiyb"},{"post_id":"ck6jcr9go003idirvfwzf9ka7","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9hn006ldirvo8otdv3l"},{"post_id":"ck6jcr9gq003mdirv6o6kb53h","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9hn006mdirvln42beun"},{"post_id":"ck6jcr9gr003pdirv6v8sqen2","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9ho006odirv4jjnsibm"},{"post_id":"ck6jcr9gs003tdirv1jykudsz","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9ho006pdirv8bnlfinn"},{"post_id":"ck6jcr9ev000cdirvsmaaegnq","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9hp006rdirv9yk5btob"},{"post_id":"ck6jcr9ev000cdirvsmaaegnq","tag_id":"ck6jcr9f9000udirv9ao0kman","_id":"ck6jcr9hq006sdirveaqka5ui"},{"post_id":"ck6jcr9ev000cdirvsmaaegnq","tag_id":"ck6jcr9g3002edirvwv204psp","_id":"ck6jcr9hr006udirvnyfqtfkf"},{"post_id":"ck6jcr9ev000cdirvsmaaegnq","tag_id":"ck6jcr9g7002ldirv76ny0nkt","_id":"ck6jcr9hs006vdirvwq7kdj3b"},{"post_id":"ck6jcr9ey000fdirv99jhkmpj","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9ht006xdirv3wzjmza6"},{"post_id":"ck6jcr9ey000fdirv99jhkmpj","tag_id":"ck6jcr9f9000udirv9ao0kman","_id":"ck6jcr9ht006ydirvzkh1fpof"},{"post_id":"ck6jcr9ey000fdirv99jhkmpj","tag_id":"ck6jcr9g3002edirvwv204psp","_id":"ck6jcr9ht006zdirvn1lm7fi9"},{"post_id":"ck6jcr9ey000fdirv99jhkmpj","tag_id":"ck6jcr9g7002ldirv76ny0nkt","_id":"ck6jcr9hu0071dirvbxtypnfg"},{"post_id":"ck6jcr9f1000hdirv61nn999k","tag_id":"ck6jcr9h0004jdirvj8rsqnpi","_id":"ck6jcr9hu0072dirvl8iieinf"},{"post_id":"ck6jcr9f3000kdirvepeii5ne","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9hu0074dirvwto9yawu"},{"post_id":"ck6jcr9f3000kdirvepeii5ne","tag_id":"ck6jcr9f9000udirv9ao0kman","_id":"ck6jcr9hu0075dirv1c24keo1"},{"post_id":"ck6jcr9f3000kdirvepeii5ne","tag_id":"ck6jcr9g3002edirvwv204psp","_id":"ck6jcr9hv0077dirvwzh8eeq0"},{"post_id":"ck6jcr9f3000kdirvepeii5ne","tag_id":"ck6jcr9g7002ldirv76ny0nkt","_id":"ck6jcr9hv0078dirv9w7ibemj"},{"post_id":"ck6jcr9f5000ndirvsl9fzuzv","tag_id":"ck6jcr9ha0059dirvtza9nlrj","_id":"ck6jcr9hv007adirvjse0xsio"},{"post_id":"ck6jcr9f5000ndirvsl9fzuzv","tag_id":"ck6jcr9hb005fdirvpd381edw","_id":"ck6jcr9hv007bdirvxk9syxo3"},{"post_id":"ck6jcr9f8000rdirve6nr21sc","tag_id":"ck6jcr9ha0059dirvtza9nlrj","_id":"ck6jcr9hw007ddirvpflzthyh"},{"post_id":"ck6jcr9f8000rdirve6nr21sc","tag_id":"ck6jcr9hb005fdirvpd381edw","_id":"ck6jcr9hw007edirv5pg4tcjt"},{"post_id":"ck6jcr9f9000vdirvj1w8h2hy","tag_id":"ck6jcr9ha0059dirvtza9nlrj","_id":"ck6jcr9hx007gdirv3xctyf7m"},{"post_id":"ck6jcr9f9000vdirvj1w8h2hy","tag_id":"ck6jcr9he005rdirv7bxsxmsb","_id":"ck6jcr9hx007hdirviglhxnbv"},{"post_id":"ck6jcr9fb000zdirv2ye64d2s","tag_id":"ck6jcr9ha0059dirvtza9nlrj","_id":"ck6jcr9hx007jdirvffn3pn6k"},{"post_id":"ck6jcr9fb000zdirv2ye64d2s","tag_id":"ck6jcr9hb005fdirvpd381edw","_id":"ck6jcr9hy007kdirv6wo1100n"},{"post_id":"ck6jcr9fc0012dirv1yvfxzjp","tag_id":"ck6jcr9hg0060dirvxfeki0xc","_id":"ck6jcr9hy007ldirvjd6j9f9s"},{"post_id":"ck6jcr9fe0014dirvayib7dbw","tag_id":"ck6jcr9hg0060dirvxfeki0xc","_id":"ck6jcr9hy007ndirvvb97ooaa"},{"post_id":"ck6jcr9ff0016dirvsronrnsa","tag_id":"ck6jcr9hj0067dirv9xzqreef","_id":"ck6jcr9hy007odirv8ssh9lfk"},{"post_id":"ck6jcr9fg0019dirv9zouctiy","tag_id":"ck6jcr9hl006adirv18evdqfd","_id":"ck6jcr9hy007qdirvtxsblees"},{"post_id":"ck6jcr9fm001ldirvybg39qzu","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9hy007rdirv8fmte30j"},{"post_id":"ck6jcr9fm001ldirvybg39qzu","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9hy007tdirvyz4qjd0u"},{"post_id":"ck6jcr9fm001ldirvybg39qzu","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9hy007udirv7rbfn95l"},{"post_id":"ck6jcr9fm001ldirvybg39qzu","tag_id":"ck6jcr9hl006ddirvl8d6mj54","_id":"ck6jcr9hz007wdirvtic81cc2"},{"post_id":"ck6jcr9fn001odirvmeo3q0qf","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9hz007xdirv4ubkvrfq"},{"post_id":"ck6jcr9fn001odirvmeo3q0qf","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9hz007ydirvd1cunmwu"},{"post_id":"ck6jcr9fn001odirvmeo3q0qf","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9hz0080dirvt1le43vc"},{"post_id":"ck6jcr9fn001odirvmeo3q0qf","tag_id":"ck6jcr9hl006ddirvl8d6mj54","_id":"ck6jcr9hz0081dirvaxgl9h3q"},{"post_id":"ck6jcr9gj0038dirvnu4dpdvb","tag_id":"ck6jcr9hm006jdirvyrnrkk1a","_id":"ck6jcr9hz0083dirv9i1wc0dt"},{"post_id":"ck6jcr9gl003bdirvvzryczu4","tag_id":"ck6jcr9hn006ndirvgbn0ka1t","_id":"ck6jcr9hz0084dirv6xu9inpa"},{"post_id":"ck6jcr9gt003wdirvyy3h6f97","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9hz0086dirvle5k8gbv"},{"post_id":"ck6jcr9gt003wdirvyy3h6f97","tag_id":"ck6jcr9hp006qdirvjszlilob","_id":"ck6jcr9i00087dirv9zo2mxp5"},{"post_id":"ck6jcr9gt003wdirvyy3h6f97","tag_id":"ck6jcr9hr006tdirva8jtvdhy","_id":"ck6jcr9i00089dirv9udi7u9b"},{"post_id":"ck6jcr9gt003wdirvyy3h6f97","tag_id":"ck6jcr9ht006wdirvpjagrbrm","_id":"ck6jcr9i0008adirvtg0lpuqd"},{"post_id":"ck6jcr9gt003wdirvyy3h6f97","tag_id":"ck6jcr9ht0070dirv4hj2wtl1","_id":"ck6jcr9i0008bdirvp94wrorp"},{"post_id":"ck6jcr9gu0040dirvo12x17qp","tag_id":"ck6jcr9hu0073dirvwekrxbal","_id":"ck6jcr9i0008ddirvwehhjib5"},{"post_id":"ck6jcr9gv0043dirvyc7zny3e","tag_id":"ck6jcr9hu0073dirvwekrxbal","_id":"ck6jcr9i0008edirvgvlss5mf"},{"post_id":"ck6jcr9gx0047dirv8ayviu67","tag_id":"ck6jcr9hv0079dirvn9zagv74","_id":"ck6jcr9i0008gdirvgcy2acfm"},{"post_id":"ck6jcr9gy004adirvhh6gqcj1","tag_id":"ck6jcr9hv0079dirvn9zagv74","_id":"ck6jcr9i0008hdirv318xbwno"},{"post_id":"ck6jcr9gz004edirv0zo16el3","tag_id":"ck6jcr9h0004jdirvj8rsqnpi","_id":"ck6jcr9i1008jdirvh8w7j20y"},{"post_id":"ck6jcr9gz004hdirv6sgqjmlp","tag_id":"ck6jcr9hx007idirvq0q554gn","_id":"ck6jcr9i1008kdirv71111d24"},{"post_id":"ck6jcr9gz004hdirv6sgqjmlp","tag_id":"ck6jcr9hy007mdirvdovnphok","_id":"ck6jcr9i1008mdirvx85irlm1"},{"post_id":"ck6jcr9h1004ldirvsc2pc2sy","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9i1008ndirvfzxcu39a"},{"post_id":"ck6jcr9h1004ldirvsc2pc2sy","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9i2008pdirvzo84399g"},{"post_id":"ck6jcr9h1004ldirvsc2pc2sy","tag_id":"ck6jcr9hy007pdirvfw7hnzhp","_id":"ck6jcr9i2008qdirvtxdjh1km"},{"post_id":"ck6jcr9h1004ldirvsc2pc2sy","tag_id":"ck6jcr9hy007sdirv402x2uvb","_id":"ck6jcr9i2008sdirvzz56y46w"},{"post_id":"ck6jcr9h1004ldirvsc2pc2sy","tag_id":"ck6jcr9hz007vdirvqfc311mg","_id":"ck6jcr9i2008tdirvpg9b6szk"},{"post_id":"ck6jcr9h2004odirvhqjph65q","tag_id":"ck6jcr9hz007zdirvpzy5lvqc","_id":"ck6jcr9i2008udirvb9t67k1x"},{"post_id":"ck6jcr9h2004odirvhqjph65q","tag_id":"ck6jcr9hz0082dirvszhrwxbl","_id":"ck6jcr9i3008vdirvz0o2brca"},{"post_id":"ck6jcr9h2004odirvhqjph65q","tag_id":"ck6jcr9hz0085dirv6763n72m","_id":"ck6jcr9i3008wdirvtn4k4fb8"},{"post_id":"ck6jcr9h2004odirvhqjph65q","tag_id":"ck6jcr9i00088dirvn11sicb6","_id":"ck6jcr9i3008xdirvn1g4893f"},{"post_id":"ck6jcr9h2004odirvhqjph65q","tag_id":"ck6jcr9i0008cdirvh0u9gvsf","_id":"ck6jcr9i3008ydirv2rmhgc4o"},{"post_id":"ck6jcr9h2004odirvhqjph65q","tag_id":"ck6jcr9i0008fdirvjcbbodae","_id":"ck6jcr9i3008zdirv43ggszv4"},{"post_id":"ck6jcr9h3004tdirv2oy3b7gv","tag_id":"ck6jcr9hz007zdirvpzy5lvqc","_id":"ck6jcr9i30090dirvf10szh4p"},{"post_id":"ck6jcr9h3004tdirv2oy3b7gv","tag_id":"ck6jcr9hz0082dirvszhrwxbl","_id":"ck6jcr9i30091dirvmfgu1f6d"},{"post_id":"ck6jcr9h6004wdirv9m6vd6fa","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9i30092dirv0pk1q5ud"},{"post_id":"ck6jcr9h6004wdirv9m6vd6fa","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9i30093dirv7ya10nz3"},{"post_id":"ck6jcr9h6004wdirv9m6vd6fa","tag_id":"ck6jcr9hy007pdirvfw7hnzhp","_id":"ck6jcr9i30094dirvoc20z0ka"},{"post_id":"ck6jcr9h6004wdirv9m6vd6fa","tag_id":"ck6jcr9hy007sdirv402x2uvb","_id":"ck6jcr9i30095dirvnuwgol36"},{"post_id":"ck6jcr9ik009adirvzfk5kacb","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9io009cdirvjxha0uk6"},{"post_id":"ck6jcr9ik009adirvzfk5kacb","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9is009gdirv08kwlhpp"},{"post_id":"ck6jcr9ik009adirvzfk5kacb","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9iu009jdirvnzsm2f5a"},{"post_id":"ck6jcr9im009bdirv6jfhshik","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9iw009ndirv4gae9q2b"},{"post_id":"ck6jcr9im009bdirv6jfhshik","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9iz009qdirvpkxsh78i"},{"post_id":"ck6jcr9im009bdirv6jfhshik","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9j2009udirvecn4doa3"},{"post_id":"ck6jcr9io009ddirvhqz3612g","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9j4009xdirvokr5avte"},{"post_id":"ck6jcr9io009ddirvhqz3612g","tag_id":"ck6jcr9eu000bdirv0mkf5wtp","_id":"ck6jcr9j5009zdirvdnez71gx"},{"post_id":"ck6jcr9io009ddirvhqz3612g","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9j600a2dirvv0p9tgxq"},{"post_id":"ck6jcr9io009ddirvhqz3612g","tag_id":"ck6jcr9hl006ddirvl8d6mj54","_id":"ck6jcr9j700a4dirv87ikpvqh"},{"post_id":"ck6jcr9is009hdirvq9jbrkzs","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9j800a6dirvla387ttn"},{"post_id":"ck6jcr9is009hdirvq9jbrkzs","tag_id":"ck6jcr9f9000udirv9ao0kman","_id":"ck6jcr9j800a7dirvtkat028k"},{"post_id":"ck6jcr9is009hdirvq9jbrkzs","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9j800a8dirvosv6psgl"},{"post_id":"ck6jcr9is009hdirvq9jbrkzs","tag_id":"ck6jcr9fl001jdirvxnrxxt30","_id":"ck6jcr9j800a9dirvar743x06"},{"post_id":"ck6jcr9iu009kdirve2nt355g","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9j800aadirverzoy25a"},{"post_id":"ck6jcr9iu009kdirve2nt355g","tag_id":"ck6jcr9f9000udirv9ao0kman","_id":"ck6jcr9j900abdirv8onbuhrj"},{"post_id":"ck6jcr9iu009kdirve2nt355g","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9j900acdirvyq44p2kv"},{"post_id":"ck6jcr9iu009kdirve2nt355g","tag_id":"ck6jcr9fl001jdirvxnrxxt30","_id":"ck6jcr9j900addirv5rqtlbiu"},{"post_id":"ck6jcr9iw009odirvt6lq8chg","tag_id":"ck6jcr9fo001qdirvn0lj9ypk","_id":"ck6jcr9j900aedirvivpegvsm"},{"post_id":"ck6jcr9iw009odirvt6lq8chg","tag_id":"ck6jcr9fr001ydirvbdtpa118","_id":"ck6jcr9j900afdirv2ig4i02h"},{"post_id":"ck6jcr9iz009rdirv6lslivjh","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9j900agdirv9ma24h9e"},{"post_id":"ck6jcr9iz009rdirv6lslivjh","tag_id":"ck6jcr9hp006qdirvjszlilob","_id":"ck6jcr9j900ahdirvx9mch7ov"},{"post_id":"ck6jcr9iz009rdirv6lslivjh","tag_id":"ck6jcr9hr006tdirva8jtvdhy","_id":"ck6jcr9j900aidirvrsztb148"},{"post_id":"ck6jcr9iz009rdirv6lslivjh","tag_id":"ck6jcr9ht006wdirvpjagrbrm","_id":"ck6jcr9j900ajdirvultcny9s"},{"post_id":"ck6jcr9iz009rdirv6lslivjh","tag_id":"ck6jcr9ht0070dirv4hj2wtl1","_id":"ck6jcr9j900akdirv9ri78w4i"},{"post_id":"ck6jcr9j2009vdirvo8dzjqy2","tag_id":"ck6jcr9fo001qdirvn0lj9ypk","_id":"ck6jcr9j900aldirvtnae2ntf"},{"post_id":"ck6jcr9j2009vdirvo8dzjqy2","tag_id":"ck6jcr9fr001ydirvbdtpa118","_id":"ck6jcr9j900amdirvh2dff561"},{"post_id":"ck6jcr9ig0096dirvujxq7nc0","tag_id":"ck6jcr9ij0099dirvjypoq014","_id":"ck6jcr9j900andirvoonjjaud"},{"post_id":"ck6jcr9ig0096dirvujxq7nc0","tag_id":"ck6jcr9ir009fdirvbsztdxxl","_id":"ck6jcr9j900aodirvyq8nk0fj"},{"post_id":"ck6jcr9ig0096dirvujxq7nc0","tag_id":"ck6jcr9iv009mdirv0xzqdgqq","_id":"ck6jcr9ja00apdirvbhc2czp0"},{"post_id":"ck6jcr9ig0096dirvujxq7nc0","tag_id":"ck6jcr9j2009tdirvusxogdqn","_id":"ck6jcr9ja00aqdirvwbcby438"},{"post_id":"ck6jcr9ii0097dirvb1t5lodn","tag_id":"ck6jcr9hx007idirvq0q554gn","_id":"ck6jcr9ja00ardirvwzwjtnxk"},{"post_id":"ck6jcr9ii0097dirvb1t5lodn","tag_id":"ck6jcr9j500a0dirvrxy8ehnb","_id":"ck6jcr9ja00asdirvvhqwyz9d"},{"post_id":"ck6jcr9ii0097dirvb1t5lodn","tag_id":"ck6jcr9hy007mdirvdovnphok","_id":"ck6jcr9ja00atdirvp27yhf0n"},{"post_id":"ck6jcr9jd00audirvea96ipxa","tag_id":"ck6jcr9ep0006dirvqaplevn6","_id":"ck6jcr9jf00avdirv83jklbau"},{"post_id":"ck6jcr9jd00audirvea96ipxa","tag_id":"ck6jcr9f9000udirv9ao0kman","_id":"ck6jcr9jg00awdirva29de0hw"},{"post_id":"ck6jcr9jd00audirvea96ipxa","tag_id":"ck6jcr9f0000gdirv97lwt6si","_id":"ck6jcr9jg00aydirvrzu5iy03"},{"post_id":"ck6jcr9jd00audirvea96ipxa","tag_id":"ck6jcr9fl001jdirvxnrxxt30","_id":"ck6jcr9jg00azdirvsd8x4u9z"}],"Tag":[{"name":"javascript","_id":"ck6jcr9ep0006dirvqaplevn6"},{"name":"오늘의 함수","_id":"ck6jcr9eu000bdirv0mkf5wtp"},{"name":"함수형 프로그래밍","_id":"ck6jcr9f0000gdirv97lwt6si"},{"name":"자바스크립트","_id":"ck6jcr9f9000udirv9ao0kman"},{"name":"don.js","_id":"ck6jcr9fc0011dirvnws984ho"},{"name":"partial.js","_id":"ck6jcr9fg0018dirv8axv15q0"},{"name":"함수형 자바스크립트","_id":"ck6jcr9fl001jdirvxnrxxt30"},{"name":"opinion","_id":"ck6jcr9fo001qdirvn0lj9ypk"},{"name":"나와 같다면","_id":"ck6jcr9fr001ydirvbdtpa118"},{"name":"blockchain","_id":"ck6jcr9g3002edirvwv204psp"},{"name":"블록체인","_id":"ck6jcr9g7002ldirv76ny0nkt"},{"name":"freecodecamp","_id":"ck6jcr9h0004jdirvj8rsqnpi"},{"name":"clean code","_id":"ck6jcr9ha0059dirvtza9nlrj"},{"name":"클린 코드","_id":"ck6jcr9hb005fdirvpd381edw"},{"name":"클린코드","_id":"ck6jcr9he005rdirv7bxsxmsb"},{"name":"css","_id":"ck6jcr9hg0060dirvxfeki0xc"},{"name":"coin","_id":"ck6jcr9hj0067dirv9xzqreef"},{"name":"daily-commit","_id":"ck6jcr9hl006adirv18evdqfd"},{"name":"조건문 함수","_id":"ck6jcr9hl006ddirvl8d6mj54"},{"name":"cs-basic","_id":"ck6jcr9hm006jdirvyrnrkk1a"},{"name":"introduction","_id":"ck6jcr9hn006ndirvgbn0ka1t"},{"name":"미니게임","_id":"ck6jcr9hp006qdirvjszlilob"},{"name":"만들기","_id":"ck6jcr9hr006tdirva8jtvdhy"},{"name":"빙고","_id":"ck6jcr9ht006wdirvpjagrbrm"},{"name":"bingo","_id":"ck6jcr9ht0070dirv4hj2wtl1"},{"name":"practice","_id":"ck6jcr9hu0073dirvwekrxbal"},{"name":"toy-project","_id":"ck6jcr9hv0079dirvn9zagv74"},{"name":"retrospection","_id":"ck6jcr9hx007idirvq0q554gn"},{"name":"회고록","_id":"ck6jcr9hy007mdirvdovnphok"},{"name":"든든한 우리 형","_id":"ck6jcr9hy007pdirvfw7hnzhp"},{"name":"forEach","_id":"ck6jcr9hy007sdirv402x2uvb"},{"name":"map","_id":"ck6jcr9hz007vdirvqfc311mg"},{"name":"Go","_id":"ck6jcr9hz007zdirvpzy5lvqc"},{"name":"Golang","_id":"ck6jcr9hz0082dirvszhrwxbl"},{"name":"for","_id":"ck6jcr9hz0085dirv6763n72m"},{"name":"range","_id":"ck6jcr9i00088dirvn11sicb6"},{"name":"array","_id":"ck6jcr9i0008cdirvh0u9gvsf"},{"name":"variadic function","_id":"ck6jcr9i0008fdirvjcbbodae"},{"name":"랜드서핑","_id":"ck6jcr9ij0099dirvjypoq014"},{"name":"youtube","_id":"ck6jcr9ir009fdirvbsztdxxl"},{"name":"instagram","_id":"ck6jcr9iv009mdirv0xzqdgqq"},{"name":"gopro","_id":"ck6jcr9j2009tdirvusxogdqn"},{"name":"anniversary","_id":"ck6jcr9j500a0dirvrxy8ehnb"}]}}